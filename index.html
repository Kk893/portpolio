(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const c of document.querySelectorAll('link[rel="modulepreload"]'))
        o(c);
    new MutationObserver(c => {
        for (const d of c)
            if (d.type === "childList")
                for (const g of d.addedNodes)
                    g.tagName === "LINK" && g.rel === "modulepreload" && o(g)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function a(c) {
        const d = {};
        return c.integrity && (d.integrity = c.integrity),
        c.referrerPolicy && (d.referrerPolicy = c.referrerPolicy),
        c.crossOrigin === "use-credentials" ? d.credentials = "include" : c.crossOrigin === "anonymous" ? d.credentials = "omit" : d.credentials = "same-origin",
        d
    }
    function o(c) {
        if (c.ep)
            return;
        c.ep = !0;
        const d = a(c);
        fetch(c.href, d)
    }
}
)();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {}
  , react$1 = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element")
  , n$1 = Symbol.for("react.portal")
  , p$3 = Symbol.for("react.fragment")
  , q$1 = Symbol.for("react.strict_mode")
  , r = Symbol.for("react.profiler")
  , t = Symbol.for("react.provider")
  , u = Symbol.for("react.context")
  , v$3 = Symbol.for("react.forward_ref")
  , w$2 = Symbol.for("react.suspense")
  , x = Symbol.for("react.memo")
  , y = Symbol.for("react.lazy")
  , z$1 = Symbol.iterator;
function A$1(s) {
    return s === null || typeof s != "object" ? null : (s = z$1 && s[z$1] || s["@@iterator"],
    typeof s == "function" ? s : null)
}
var B$1 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$1 = Object.assign
  , D$1 = {};
function E$1(s, e, a) {
    this.props = s,
    this.context = e,
    this.refs = D$1,
    this.updater = a || B$1
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(s, e) {
    if (typeof s != "object" && typeof s != "function" && s != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, s, e, "setState")
}
;
E$1.prototype.forceUpdate = function(s) {
    this.updater.enqueueForceUpdate(this, s, "forceUpdate")
}
;
function F() {}
F.prototype = E$1.prototype;
function G$1(s, e, a) {
    this.props = s,
    this.context = e,
    this.refs = D$1,
    this.updater = a || B$1
}
var H$1 = G$1.prototype = new F;
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = !0;
var I$1 = Array.isArray
  , J = Object.prototype.hasOwnProperty
  , K$1 = {
    current: null
}
  , L$1 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$1(s, e, a) {
    var o, c = {}, d = null, g = null;
    if (e != null)
        for (o in e.ref !== void 0 && (g = e.ref),
        e.key !== void 0 && (d = "" + e.key),
        e)
            J.call(e, o) && !L$1.hasOwnProperty(o) && (c[o] = e[o]);
    var _ = arguments.length - 2;
    if (_ === 1)
        c.children = a;
    else if (1 < _) {
        for (var b = Array(_), j = 0; j < _; j++)
            b[j] = arguments[j + 2];
        c.children = b
    }
    if (s && s.defaultProps)
        for (o in _ = s.defaultProps,
        _)
            c[o] === void 0 && (c[o] = _[o]);
    return {
        $$typeof: l$1,
        type: s,
        key: d,
        ref: g,
        props: c,
        _owner: K$1.current
    }
}
function N$1(s, e) {
    return {
        $$typeof: l$1,
        type: s.type,
        key: e,
        ref: s.ref,
        props: s.props,
        _owner: s._owner
    }
}
function O$1(s) {
    return typeof s == "object" && s !== null && s.$$typeof === l$1
}
function escape$1(s) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + s.replace(/[=:]/g, function(a) {
        return e[a]
    })
}
var P$1 = /\/+/g;
function Q$1(s, e) {
    return typeof s == "object" && s !== null && s.key != null ? escape$1("" + s.key) : e.toString(36)
}
function R$1(s, e, a, o, c) {
    var d = typeof s;
    (d === "undefined" || d === "boolean") && (s = null);
    var g = !1;
    if (s === null)
        g = !0;
    else
        switch (d) {
        case "string":
        case "number":
            g = !0;
            break;
        case "object":
            switch (s.$$typeof) {
            case l$1:
            case n$1:
                g = !0
            }
        }
    if (g)
        return g = s,
        c = c(g),
        s = o === "" ? "." + Q$1(g, 0) : o,
        I$1(c) ? (a = "",
        s != null && (a = s.replace(P$1, "$&/") + "/"),
        R$1(c, e, a, "", function(j) {
            return j
        })) : c != null && (O$1(c) && (c = N$1(c, a + (!c.key || g && g.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + s)),
        e.push(c)),
        1;
    if (g = 0,
    o = o === "" ? "." : o + ":",
    I$1(s))
        for (var _ = 0; _ < s.length; _++) {
            d = s[_];
            var b = o + Q$1(d, _);
            g += R$1(d, e, a, b, c)
        }
    else if (b = A$1(s),
    typeof b == "function")
        for (s = b.call(s),
        _ = 0; !(d = s.next()).done; )
            d = d.value,
            b = o + Q$1(d, _++),
            g += R$1(d, e, a, b, c);
    else if (d === "object")
        throw e = String(s),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return g
}
function S$1(s, e, a) {
    if (s == null)
        return s;
    var o = []
      , c = 0;
    return R$1(s, o, "", "", function(d) {
        return e.call(a, d, c++)
    }),
    o
}
function T$1(s) {
    if (s._status === -1) {
        var e = s._result;
        e = e(),
        e.then(function(a) {
            (s._status === 0 || s._status === -1) && (s._status = 1,
            s._result = a)
        }, function(a) {
            (s._status === 0 || s._status === -1) && (s._status = 2,
            s._result = a)
        }),
        s._status === -1 && (s._status = 0,
        s._result = e)
    }
    if (s._status === 1)
        return s._result.default;
    throw s._result
}
var U$1 = {
    current: null
}
  , V$1 = {
    transition: null
}
  , W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1
};
function X$1() {
    throw Error("act(...) is not supported in production builds of React.")
}
react_production_min.Children = {
    map: S$1,
    forEach: function(s, e, a) {
        S$1(s, function() {
            e.apply(this, arguments)
        }, a)
    },
    count: function(s) {
        var e = 0;
        return S$1(s, function() {
            e++
        }),
        e
    },
    toArray: function(s) {
        return S$1(s, function(e) {
            return e
        }) || []
    },
    only: function(s) {
        if (!O$1(s))
            throw Error("React.Children.only expected to receive a single React element child.");
        return s
    }
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(s, e, a) {
    if (s == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + s + ".");
    var o = C$1({}, s.props)
      , c = s.key
      , d = s.ref
      , g = s._owner;
    if (e != null) {
        if (e.ref !== void 0 && (d = e.ref,
        g = K$1.current),
        e.key !== void 0 && (c = "" + e.key),
        s.type && s.type.defaultProps)
            var _ = s.type.defaultProps;
        for (b in e)
            J.call(e, b) && !L$1.hasOwnProperty(b) && (o[b] = e[b] === void 0 && _ !== void 0 ? _[b] : e[b])
    }
    var b = arguments.length - 2;
    if (b === 1)
        o.children = a;
    else if (1 < b) {
        _ = Array(b);
        for (var j = 0; j < b; j++)
            _[j] = arguments[j + 2];
        o.children = _
    }
    return {
        $$typeof: l$1,
        type: s.type,
        key: c,
        ref: d,
        props: o,
        _owner: g
    }
}
;
react_production_min.createContext = function(s) {
    return s = {
        $$typeof: u,
        _currentValue: s,
        _currentValue2: s,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    s.Provider = {
        $$typeof: t,
        _context: s
    },
    s.Consumer = s
}
;
react_production_min.createElement = M$1;
react_production_min.createFactory = function(s) {
    var e = M$1.bind(null, s);
    return e.type = s,
    e
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(s) {
    return {
        $$typeof: v$3,
        render: s
    }
}
;
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(s) {
    return {
        $$typeof: y,
        _payload: {
            _status: -1,
            _result: s
        },
        _init: T$1
    }
}
;
react_production_min.memo = function(s, e) {
    return {
        $$typeof: x,
        type: s,
        compare: e === void 0 ? null : e
    }
}
;
react_production_min.startTransition = function(s) {
    var e = V$1.transition;
    V$1.transition = {};
    try {
        s()
    } finally {
        V$1.transition = e
    }
}
;
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(s, e) {
    return U$1.current.useCallback(s, e)
}
;
react_production_min.useContext = function(s) {
    return U$1.current.useContext(s)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(s) {
    return U$1.current.useDeferredValue(s)
}
;
react_production_min.useEffect = function(s, e) {
    return U$1.current.useEffect(s, e)
}
;
react_production_min.useId = function() {
    return U$1.current.useId()
}
;
react_production_min.useImperativeHandle = function(s, e, a) {
    return U$1.current.useImperativeHandle(s, e, a)
}
;
react_production_min.useInsertionEffect = function(s, e) {
    return U$1.current.useInsertionEffect(s, e)
}
;
react_production_min.useLayoutEffect = function(s, e) {
    return U$1.current.useLayoutEffect(s, e)
}
;
react_production_min.useMemo = function(s, e) {
    return U$1.current.useMemo(s, e)
}
;
react_production_min.useReducer = function(s, e, a) {
    return U$1.current.useReducer(s, e, a)
}
;
react_production_min.useRef = function(s) {
    return U$1.current.useRef(s)
}
;
react_production_min.useState = function(s) {
    return U$1.current.useState(s)
}
;
react_production_min.useSyncExternalStore = function(s, e, a) {
    return U$1.current.useSyncExternalStore(s, e, a)
}
;
react_production_min.useTransition = function() {
    return U$1.current.useTransition()
}
;
react_production_min.version = "18.3.1";
react$1.exports = react_production_min;
var reactExports = react$1.exports;
const React = getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = reactExports
  , k = Symbol.for("react.element")
  , l = Symbol.for("react.fragment")
  , m$1 = Object.prototype.hasOwnProperty
  , n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$2 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q(s, e, a) {
    var o, c = {}, d = null, g = null;
    a !== void 0 && (d = "" + a),
    e.key !== void 0 && (d = "" + e.key),
    e.ref !== void 0 && (g = e.ref);
    for (o in e)
        m$1.call(e, o) && !p$2.hasOwnProperty(o) && (c[o] = e[o]);
    if (s && s.defaultProps)
        for (o in e = s.defaultProps,
        e)
            c[o] === void 0 && (c[o] = e[o]);
    return {
        $$typeof: k,
        type: s,
        key: d,
        ref: g,
        props: c,
        _owner: n.current
    }
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports
  , client = {}
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler$1 = {
    exports: {}
}
  , scheduler_production_min$1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(s) {
    function e(mt, St) {
        var wt = mt.length;
        mt.push(St);
        e: for (; 0 < wt; ) {
            var Ct = wt - 1 >>> 1
              , Ht = mt[Ct];
            if (0 < c(Ht, St))
                mt[Ct] = St,
                mt[wt] = Ht,
                wt = Ct;
            else
                break e
        }
    }
    function a(mt) {
        return mt.length === 0 ? null : mt[0]
    }
    function o(mt) {
        if (mt.length === 0)
            return null;
        var St = mt[0]
          , wt = mt.pop();
        if (wt !== St) {
            mt[0] = wt;
            e: for (var Ct = 0, Ht = mt.length, en = Ht >>> 1; Ct < en; ) {
                var Ot = 2 * (Ct + 1) - 1
                  , Yt = mt[Ot]
                  , rn = Ot + 1
                  , Xt = mt[rn];
                if (0 > c(Yt, wt))
                    rn < Ht && 0 > c(Xt, Yt) ? (mt[Ct] = Xt,
                    mt[rn] = wt,
                    Ct = rn) : (mt[Ct] = Yt,
                    mt[Ot] = wt,
                    Ct = Ot);
                else if (rn < Ht && 0 > c(Xt, wt))
                    mt[Ct] = Xt,
                    mt[rn] = wt,
                    Ct = rn;
                else
                    break e
            }
        }
        return St
    }
    function c(mt, St) {
        var wt = mt.sortIndex - St.sortIndex;
        return wt !== 0 ? wt : mt.id - St.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var d = performance;
        s.unstable_now = function() {
            return d.now()
        }
    } else {
        var g = Date
          , _ = g.now();
        s.unstable_now = function() {
            return g.now() - _
        }
    }
    var b = []
      , j = []
      , $ = 1
      , nt = null
      , tt = 3
      , rt = !1
      , st = !1
      , lt = !1
      , ct = typeof setTimeout == "function" ? setTimeout : null
      , it = typeof clearTimeout == "function" ? clearTimeout : null
      , ot = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function at(mt) {
        for (var St = a(j); St !== null; ) {
            if (St.callback === null)
                o(j);
            else if (St.startTime <= mt)
                o(j),
                St.sortIndex = St.expirationTime,
                e(b, St);
            else
                break;
            St = a(j)
        }
    }
    function ht(mt) {
        if (lt = !1,
        at(mt),
        !st)
            if (a(b) !== null)
                st = !0,
                Mt(pt);
            else {
                var St = a(j);
                St !== null && Tt(ht, St.startTime - mt)
            }
    }
    function pt(mt, St) {
        st = !1,
        lt && (lt = !1,
        it(vt),
        vt = -1),
        rt = !0;
        var wt = tt;
        try {
            for (at(St),
            nt = a(b); nt !== null && (!(nt.expirationTime > St) || mt && !bt()); ) {
                var Ct = nt.callback;
                if (typeof Ct == "function") {
                    nt.callback = null,
                    tt = nt.priorityLevel;
                    var Ht = Ct(nt.expirationTime <= St);
                    St = s.unstable_now(),
                    typeof Ht == "function" ? nt.callback = Ht : nt === a(b) && o(b),
                    at(St)
                } else
                    o(b);
                nt = a(b)
            }
            if (nt !== null)
                var en = !0;
            else {
                var Ot = a(j);
                Ot !== null && Tt(ht, Ot.startTime - St),
                en = !1
            }
            return en
        } finally {
            nt = null,
            tt = wt,
            rt = !1
        }
    }
    var dt = !1
      , yt = null
      , vt = -1
      , xt = 5
      , _t = -1;
    function bt() {
        return !(s.unstable_now() - _t < xt)
    }
    function Rt() {
        if (yt !== null) {
            var mt = s.unstable_now();
            _t = mt;
            var St = !0;
            try {
                St = yt(!0, mt)
            } finally {
                St ? Ft() : (dt = !1,
                yt = null)
            }
        } else
            dt = !1
    }
    var Ft;
    if (typeof ot == "function")
        Ft = function() {
            ot(Rt)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Bt = new MessageChannel
          , Dt = Bt.port2;
        Bt.port1.onmessage = Rt,
        Ft = function() {
            Dt.postMessage(null)
        }
    } else
        Ft = function() {
            ct(Rt, 0)
        }
        ;
    function Mt(mt) {
        yt = mt,
        dt || (dt = !0,
        Ft())
    }
    function Tt(mt, St) {
        vt = ct(function() {
            mt(s.unstable_now())
        }, St)
    }
    s.unstable_IdlePriority = 5,
    s.unstable_ImmediatePriority = 1,
    s.unstable_LowPriority = 4,
    s.unstable_NormalPriority = 3,
    s.unstable_Profiling = null,
    s.unstable_UserBlockingPriority = 2,
    s.unstable_cancelCallback = function(mt) {
        mt.callback = null
    }
    ,
    s.unstable_continueExecution = function() {
        st || rt || (st = !0,
        Mt(pt))
    }
    ,
    s.unstable_forceFrameRate = function(mt) {
        0 > mt || 125 < mt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : xt = 0 < mt ? Math.floor(1e3 / mt) : 5
    }
    ,
    s.unstable_getCurrentPriorityLevel = function() {
        return tt
    }
    ,
    s.unstable_getFirstCallbackNode = function() {
        return a(b)
    }
    ,
    s.unstable_next = function(mt) {
        switch (tt) {
        case 1:
        case 2:
        case 3:
            var St = 3;
            break;
        default:
            St = tt
        }
        var wt = tt;
        tt = St;
        try {
            return mt()
        } finally {
            tt = wt
        }
    }
    ,
    s.unstable_pauseExecution = function() {}
    ,
    s.unstable_requestPaint = function() {}
    ,
    s.unstable_runWithPriority = function(mt, St) {
        switch (mt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            mt = 3
        }
        var wt = tt;
        tt = mt;
        try {
            return St()
        } finally {
            tt = wt
        }
    }
    ,
    s.unstable_scheduleCallback = function(mt, St, wt) {
        var Ct = s.unstable_now();
        switch (typeof wt == "object" && wt !== null ? (wt = wt.delay,
        wt = typeof wt == "number" && 0 < wt ? Ct + wt : Ct) : wt = Ct,
        mt) {
        case 1:
            var Ht = -1;
            break;
        case 2:
            Ht = 250;
            break;
        case 5:
            Ht = 1073741823;
            break;
        case 4:
            Ht = 1e4;
            break;
        default:
            Ht = 5e3
        }
        return Ht = wt + Ht,
        mt = {
            id: $++,
            callback: St,
            priorityLevel: mt,
            startTime: wt,
            expirationTime: Ht,
            sortIndex: -1
        },
        wt > Ct ? (mt.sortIndex = wt,
        e(j, mt),
        a(b) === null && mt === a(j) && (lt ? (it(vt),
        vt = -1) : lt = !0,
        Tt(ht, wt - Ct))) : (mt.sortIndex = Ht,
        e(b, mt),
        st || rt || (st = !0,
        Mt(pt))),
        mt
    }
    ,
    s.unstable_shouldYield = bt,
    s.unstable_wrapCallback = function(mt) {
        var St = tt;
        return function() {
            var wt = tt;
            tt = St;
            try {
                return mt.apply(this, arguments)
            } finally {
                tt = wt
            }
        }
    }
}
)(scheduler_production_min$1);
scheduler$1.exports = scheduler_production_min$1;
var schedulerExports$1 = scheduler$1.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports
  , ca = schedulerExports$1;
function p$1(s) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, a = 1; a < arguments.length; a++)
        e += "&args[]=" + encodeURIComponent(arguments[a]);
    return "Minified React error #" + s + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa(s, e) {
    ha(s, e),
    ha(s + "Capture", e)
}
function ha(s, e) {
    for (ea[s] = e,
    s = 0; s < e.length; s++)
        da.add(e[s])
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ja = Object.prototype.hasOwnProperty
  , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function oa(s) {
    return ja.call(ma, s) ? !0 : ja.call(la, s) ? !1 : ka.test(s) ? ma[s] = !0 : (la[s] = !0,
    !1)
}
function pa(s, e, a, o) {
    if (a !== null && a.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return o ? !1 : a !== null ? !a.acceptsBooleans : (s = s.toLowerCase().slice(0, 5),
        s !== "data-" && s !== "aria-");
    default:
        return !1
    }
}
function qa(s, e, a, o) {
    if (e === null || typeof e > "u" || pa(s, e, a, o))
        return !0;
    if (o)
        return !1;
    if (a !== null)
        switch (a.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function v$2(s, e, a, o, c, d, g) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = o,
    this.attributeNamespace = c,
    this.mustUseProperty = a,
    this.propertyName = s,
    this.type = e,
    this.sanitizeURL = d,
    this.removeEmptyString = g
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s) {
    z[s] = new v$2(s,0,!1,s,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
    var e = s[0];
    z[e] = new v$2(e,1,!1,s[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
    z[s] = new v$2(s,2,!1,s.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
    z[s] = new v$2(s,2,!1,s,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s) {
    z[s] = new v$2(s,3,!1,s.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(s) {
    z[s] = new v$2(s,3,!0,s,null,!1,!1)
});
["capture", "download"].forEach(function(s) {
    z[s] = new v$2(s,4,!1,s,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(s) {
    z[s] = new v$2(s,6,!1,s,null,!1,!1)
});
["rowSpan", "start"].forEach(function(s) {
    z[s] = new v$2(s,5,!1,s.toLowerCase(),null,!1,!1)
});
var ra = /[\-:]([a-z])/g;
function sa(s) {
    return s[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s) {
    var e = s.replace(ra, sa);
    z[e] = new v$2(e,1,!1,s,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s) {
    var e = s.replace(ra, sa);
    z[e] = new v$2(e,1,!1,s,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(s) {
    var e = s.replace(ra, sa);
    z[e] = new v$2(e,1,!1,s,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(s) {
    z[s] = new v$2(s,1,!1,s.toLowerCase(),null,!1,!1)
});
z.xlinkHref = new v$2("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(s) {
    z[s] = new v$2(s,1,!1,s.toLowerCase(),null,!0,!0)
});
function ta(s, e, a, o) {
    var c = z.hasOwnProperty(e) ? z[e] : null;
    (c !== null ? c.type !== 0 : o || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (qa(e, a, c, o) && (a = null),
    o || c === null ? oa(e) && (a === null ? s.removeAttribute(e) : s.setAttribute(e, "" + a)) : c.mustUseProperty ? s[c.propertyName] = a === null ? c.type === 3 ? !1 : "" : a : (e = c.attributeName,
    o = c.attributeNamespace,
    a === null ? s.removeAttribute(e) : (c = c.type,
    a = c === 3 || c === 4 && a === !0 ? "" : "" + a,
    o ? s.setAttributeNS(o, e, a) : s.setAttribute(e, a))))
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , va = Symbol.for("react.element")
  , wa = Symbol.for("react.portal")
  , ya = Symbol.for("react.fragment")
  , za = Symbol.for("react.strict_mode")
  , Aa = Symbol.for("react.profiler")
  , Ba = Symbol.for("react.provider")
  , Ca = Symbol.for("react.context")
  , Da = Symbol.for("react.forward_ref")
  , Ea = Symbol.for("react.suspense")
  , Fa = Symbol.for("react.suspense_list")
  , Ga = Symbol.for("react.memo")
  , Ha = Symbol.for("react.lazy")
  , Ia = Symbol.for("react.offscreen")
  , Ja = Symbol.iterator;
function Ka(s) {
    return s === null || typeof s != "object" ? null : (s = Ja && s[Ja] || s["@@iterator"],
    typeof s == "function" ? s : null)
}
var A = Object.assign, La;
function Ma(s) {
    if (La === void 0)
        try {
            throw Error()
        } catch (a) {
            var e = a.stack.trim().match(/\n( *(at )?)/);
            La = e && e[1] || ""
        }
    return `
` + La + s
}
var Na = !1;
function Oa(s, e) {
    if (!s || Na)
        return "";
    Na = !0;
    var a = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (j) {
                    var o = j
                }
                Reflect.construct(s, [], e)
            } else {
                try {
                    e.call()
                } catch (j) {
                    o = j
                }
                s.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (j) {
                o = j
            }
            s()
        }
    } catch (j) {
        if (j && o && typeof j.stack == "string") {
            for (var c = j.stack.split(`
`), d = o.stack.split(`
`), g = c.length - 1, _ = d.length - 1; 1 <= g && 0 <= _ && c[g] !== d[_]; )
                _--;
            for (; 1 <= g && 0 <= _; g--,
            _--)
                if (c[g] !== d[_]) {
                    if (g !== 1 || _ !== 1)
                        do
                            if (g--,
                            _--,
                            0 > _ || c[g] !== d[_]) {
                                var b = `
` + c[g].replace(" at new ", " at ");
                                return s.displayName && b.includes("<anonymous>") && (b = b.replace("<anonymous>", s.displayName)),
                                b
                            }
                        while (1 <= g && 0 <= _);
                    break
                }
        }
    } finally {
        Na = !1,
        Error.prepareStackTrace = a
    }
    return (s = s ? s.displayName || s.name : "") ? Ma(s) : ""
}
function Pa(s) {
    switch (s.tag) {
    case 5:
        return Ma(s.type);
    case 16:
        return Ma("Lazy");
    case 13:
        return Ma("Suspense");
    case 19:
        return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
        return s = Oa(s.type, !1),
        s;
    case 11:
        return s = Oa(s.type.render, !1),
        s;
    case 1:
        return s = Oa(s.type, !0),
        s;
    default:
        return ""
    }
}
function Qa(s) {
    if (s == null)
        return null;
    if (typeof s == "function")
        return s.displayName || s.name || null;
    if (typeof s == "string")
        return s;
    switch (s) {
    case ya:
        return "Fragment";
    case wa:
        return "Portal";
    case Aa:
        return "Profiler";
    case za:
        return "StrictMode";
    case Ea:
        return "Suspense";
    case Fa:
        return "SuspenseList"
    }
    if (typeof s == "object")
        switch (s.$$typeof) {
        case Ca:
            return (s.displayName || "Context") + ".Consumer";
        case Ba:
            return (s._context.displayName || "Context") + ".Provider";
        case Da:
            var e = s.render;
            return s = s.displayName,
            s || (s = e.displayName || e.name || "",
            s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"),
            s;
        case Ga:
            return e = s.displayName || null,
            e !== null ? e : Qa(s.type) || "Memo";
        case Ha:
            e = s._payload,
            s = s._init;
            try {
                return Qa(s(e))
            } catch {}
        }
    return null
}
function Ra(s) {
    var e = s.type;
    switch (s.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return s = e.render,
        s = s.displayName || s.name || "",
        e.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qa(e);
    case 8:
        return e === za ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function Sa(s) {
    switch (typeof s) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return s;
    case "object":
        return s;
    default:
        return ""
    }
}
function Ta(s) {
    var e = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function Ua(s) {
    var e = Ta(s) ? "checked" : "value"
      , a = Object.getOwnPropertyDescriptor(s.constructor.prototype, e)
      , o = "" + s[e];
    if (!s.hasOwnProperty(e) && typeof a < "u" && typeof a.get == "function" && typeof a.set == "function") {
        var c = a.get
          , d = a.set;
        return Object.defineProperty(s, e, {
            configurable: !0,
            get: function() {
                return c.call(this)
            },
            set: function(g) {
                o = "" + g,
                d.call(this, g)
            }
        }),
        Object.defineProperty(s, e, {
            enumerable: a.enumerable
        }),
        {
            getValue: function() {
                return o
            },
            setValue: function(g) {
                o = "" + g
            },
            stopTracking: function() {
                s._valueTracker = null,
                delete s[e]
            }
        }
    }
}
function Va(s) {
    s._valueTracker || (s._valueTracker = Ua(s))
}
function Wa(s) {
    if (!s)
        return !1;
    var e = s._valueTracker;
    if (!e)
        return !0;
    var a = e.getValue()
      , o = "";
    return s && (o = Ta(s) ? s.checked ? "true" : "false" : s.value),
    s = o,
    s !== a ? (e.setValue(s),
    !0) : !1
}
function Xa(s) {
    if (s = s || (typeof document < "u" ? document : void 0),
    typeof s > "u")
        return null;
    try {
        return s.activeElement || s.body
    } catch {
        return s.body
    }
}
function Ya(s, e) {
    var a = e.checked;
    return A({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: a ?? s._wrapperState.initialChecked
    })
}
function Za(s, e) {
    var a = e.defaultValue == null ? "" : e.defaultValue
      , o = e.checked != null ? e.checked : e.defaultChecked;
    a = Sa(e.value != null ? e.value : a),
    s._wrapperState = {
        initialChecked: o,
        initialValue: a,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function ab(s, e) {
    e = e.checked,
    e != null && ta(s, "checked", e, !1)
}
function bb(s, e) {
    ab(s, e);
    var a = Sa(e.value)
      , o = e.type;
    if (a != null)
        o === "number" ? (a === 0 && s.value === "" || s.value != a) && (s.value = "" + a) : s.value !== "" + a && (s.value = "" + a);
    else if (o === "submit" || o === "reset") {
        s.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? cb(s, e.type, a) : e.hasOwnProperty("defaultValue") && cb(s, e.type, Sa(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (s.defaultChecked = !!e.defaultChecked)
}
function db(s, e, a) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var o = e.type;
        if (!(o !== "submit" && o !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + s._wrapperState.initialValue,
        a || e === s.value || (s.value = e),
        s.defaultValue = e
    }
    a = s.name,
    a !== "" && (s.name = ""),
    s.defaultChecked = !!s._wrapperState.initialChecked,
    a !== "" && (s.name = a)
}
function cb(s, e, a) {
    (e !== "number" || Xa(s.ownerDocument) !== s) && (a == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + a && (s.defaultValue = "" + a))
}
var eb = Array.isArray;
function fb(s, e, a, o) {
    if (s = s.options,
    e) {
        e = {};
        for (var c = 0; c < a.length; c++)
            e["$" + a[c]] = !0;
        for (a = 0; a < s.length; a++)
            c = e.hasOwnProperty("$" + s[a].value),
            s[a].selected !== c && (s[a].selected = c),
            c && o && (s[a].defaultSelected = !0)
    } else {
        for (a = "" + Sa(a),
        e = null,
        c = 0; c < s.length; c++) {
            if (s[c].value === a) {
                s[c].selected = !0,
                o && (s[c].defaultSelected = !0);
                return
            }
            e !== null || s[c].disabled || (e = s[c])
        }
        e !== null && (e.selected = !0)
    }
}
function gb(s, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(p$1(91));
    return A({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + s._wrapperState.initialValue
    })
}
function hb(s, e) {
    var a = e.value;
    if (a == null) {
        if (a = e.children,
        e = e.defaultValue,
        a != null) {
            if (e != null)
                throw Error(p$1(92));
            if (eb(a)) {
                if (1 < a.length)
                    throw Error(p$1(93));
                a = a[0]
            }
            e = a
        }
        e == null && (e = ""),
        a = e
    }
    s._wrapperState = {
        initialValue: Sa(a)
    }
}
function ib(s, e) {
    var a = Sa(e.value)
      , o = Sa(e.defaultValue);
    a != null && (a = "" + a,
    a !== s.value && (s.value = a),
    e.defaultValue == null && s.defaultValue !== a && (s.defaultValue = a)),
    o != null && (s.defaultValue = "" + o)
}
function jb(s) {
    var e = s.textContent;
    e === s._wrapperState.initialValue && e !== "" && e !== null && (s.value = e)
}
function kb(s) {
    switch (s) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function lb(s, e) {
    return s == null || s === "http://www.w3.org/1999/xhtml" ? kb(e) : s === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s
}
var mb, nb = function(s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, a, o, c) {
        MSApp.execUnsafeLocalFunction(function() {
            return s(e, a, o, c)
        })
    }
    : s
}(function(s, e) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in s)
        s.innerHTML = e;
    else {
        for (mb = mb || document.createElement("div"),
        mb.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = mb.firstChild; s.firstChild; )
            s.removeChild(s.firstChild);
        for (; e.firstChild; )
            s.appendChild(e.firstChild)
    }
});
function ob(s, e) {
    if (e) {
        var a = s.firstChild;
        if (a && a === s.lastChild && a.nodeType === 3) {
            a.nodeValue = e;
            return
        }
    }
    s.textContent = e
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(s) {
    qb.forEach(function(e) {
        e = e + s.charAt(0).toUpperCase() + s.substring(1),
        pb[e] = pb[s]
    })
});
function rb(s, e, a) {
    return e == null || typeof e == "boolean" || e === "" ? "" : a || typeof e != "number" || e === 0 || pb.hasOwnProperty(s) && pb[s] ? ("" + e).trim() : e + "px"
}
function sb(s, e) {
    s = s.style;
    for (var a in e)
        if (e.hasOwnProperty(a)) {
            var o = a.indexOf("--") === 0
              , c = rb(a, e[a], o);
            a === "float" && (a = "cssFloat"),
            o ? s.setProperty(a, c) : s[a] = c
        }
}
var tb = A({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ub(s, e) {
    if (e) {
        if (tb[s] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(p$1(137, s));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(p$1(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(p$1(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(p$1(62))
    }
}
function vb(s, e) {
    if (s.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (s) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var wb = null;
function xb(s) {
    return s = s.target || s.srcElement || window,
    s.correspondingUseElement && (s = s.correspondingUseElement),
    s.nodeType === 3 ? s.parentNode : s
}
var yb = null
  , zb = null
  , Ab = null;
function Bb(s) {
    if (s = Cb(s)) {
        if (typeof yb != "function")
            throw Error(p$1(280));
        var e = s.stateNode;
        e && (e = Db(e),
        yb(s.stateNode, s.type, e))
    }
}
function Eb(s) {
    zb ? Ab ? Ab.push(s) : Ab = [s] : zb = s
}
function Fb() {
    if (zb) {
        var s = zb
          , e = Ab;
        if (Ab = zb = null,
        Bb(s),
        e)
            for (s = 0; s < e.length; s++)
                Bb(e[s])
    }
}
function Gb(s, e) {
    return s(e)
}
function Hb() {}
var Ib = !1;
function Jb(s, e, a) {
    if (Ib)
        return s(e, a);
    Ib = !0;
    try {
        return Gb(s, e, a)
    } finally {
        Ib = !1,
        (zb !== null || Ab !== null) && (Hb(),
        Fb())
    }
}
function Kb(s, e) {
    var a = s.stateNode;
    if (a === null)
        return null;
    var o = Db(a);
    if (o === null)
        return null;
    a = o[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (o = !o.disabled) || (s = s.type,
        o = !(s === "button" || s === "input" || s === "select" || s === "textarea")),
        s = !o;
        break e;
    default:
        s = !1
    }
    if (s)
        return null;
    if (a && typeof a != "function")
        throw Error(p$1(231, e, typeof a));
    return a
}
var Lb = !1;
if (ia)
    try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }),
        window.addEventListener("test", Mb, Mb),
        window.removeEventListener("test", Mb, Mb)
    } catch {
        Lb = !1
    }
function Nb(s, e, a, o, c, d, g, _, b) {
    var j = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(a, j)
    } catch ($) {
        this.onError($)
    }
}
var Ob = !1
  , Pb = null
  , Qb = !1
  , Rb = null
  , Sb = {
    onError: function(s) {
        Ob = !0,
        Pb = s
    }
};
function Tb(s, e, a, o, c, d, g, _, b) {
    Ob = !1,
    Pb = null,
    Nb.apply(Sb, arguments)
}
function Ub(s, e, a, o, c, d, g, _, b) {
    if (Tb.apply(this, arguments),
    Ob) {
        if (Ob) {
            var j = Pb;
            Ob = !1,
            Pb = null
        } else
            throw Error(p$1(198));
        Qb || (Qb = !0,
        Rb = j)
    }
}
function Vb(s) {
    var e = s
      , a = s;
    if (s.alternate)
        for (; e.return; )
            e = e.return;
    else {
        s = e;
        do
            e = s,
            e.flags & 4098 && (a = e.return),
            s = e.return;
        while (s)
    }
    return e.tag === 3 ? a : null
}
function Wb(s) {
    if (s.tag === 13) {
        var e = s.memoizedState;
        if (e === null && (s = s.alternate,
        s !== null && (e = s.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function Xb(s) {
    if (Vb(s) !== s)
        throw Error(p$1(188))
}
function Yb(s) {
    var e = s.alternate;
    if (!e) {
        if (e = Vb(s),
        e === null)
            throw Error(p$1(188));
        return e !== s ? null : s
    }
    for (var a = s, o = e; ; ) {
        var c = a.return;
        if (c === null)
            break;
        var d = c.alternate;
        if (d === null) {
            if (o = c.return,
            o !== null) {
                a = o;
                continue
            }
            break
        }
        if (c.child === d.child) {
            for (d = c.child; d; ) {
                if (d === a)
                    return Xb(c),
                    s;
                if (d === o)
                    return Xb(c),
                    e;
                d = d.sibling
            }
            throw Error(p$1(188))
        }
        if (a.return !== o.return)
            a = c,
            o = d;
        else {
            for (var g = !1, _ = c.child; _; ) {
                if (_ === a) {
                    g = !0,
                    a = c,
                    o = d;
                    break
                }
                if (_ === o) {
                    g = !0,
                    o = c,
                    a = d;
                    break
                }
                _ = _.sibling
            }
            if (!g) {
                for (_ = d.child; _; ) {
                    if (_ === a) {
                        g = !0,
                        a = d,
                        o = c;
                        break
                    }
                    if (_ === o) {
                        g = !0,
                        o = d,
                        a = c;
                        break
                    }
                    _ = _.sibling
                }
                if (!g)
                    throw Error(p$1(189))
            }
        }
        if (a.alternate !== o)
            throw Error(p$1(190))
    }
    if (a.tag !== 3)
        throw Error(p$1(188));
    return a.stateNode.current === a ? s : e
}
function Zb(s) {
    return s = Yb(s),
    s !== null ? $b(s) : null
}
function $b(s) {
    if (s.tag === 5 || s.tag === 6)
        return s;
    for (s = s.child; s !== null; ) {
        var e = $b(s);
        if (e !== null)
            return e;
        s = s.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback
  , bc = ca.unstable_cancelCallback
  , cc = ca.unstable_shouldYield
  , dc = ca.unstable_requestPaint
  , B = ca.unstable_now
  , ec = ca.unstable_getCurrentPriorityLevel
  , fc = ca.unstable_ImmediatePriority
  , gc = ca.unstable_UserBlockingPriority
  , hc = ca.unstable_NormalPriority
  , ic = ca.unstable_LowPriority
  , jc = ca.unstable_IdlePriority
  , kc = null
  , lc = null;
function mc(s) {
    if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
            lc.onCommitFiberRoot(kc, s, void 0, (s.current.flags & 128) === 128)
        } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc
  , pc = Math.log
  , qc = Math.LN2;
function nc(s) {
    return s >>>= 0,
    s === 0 ? 32 : 31 - (pc(s) / qc | 0) | 0
}
var rc = 64
  , sc = 4194304;
function tc(s) {
    switch (s & -s) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return s & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return s & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return s
    }
}
function uc(s, e) {
    var a = s.pendingLanes;
    if (a === 0)
        return 0;
    var o = 0
      , c = s.suspendedLanes
      , d = s.pingedLanes
      , g = a & 268435455;
    if (g !== 0) {
        var _ = g & ~c;
        _ !== 0 ? o = tc(_) : (d &= g,
        d !== 0 && (o = tc(d)))
    } else
        g = a & ~c,
        g !== 0 ? o = tc(g) : d !== 0 && (o = tc(d));
    if (o === 0)
        return 0;
    if (e !== 0 && e !== o && !(e & c) && (c = o & -o,
    d = e & -e,
    c >= d || c === 16 && (d & 4194240) !== 0))
        return e;
    if (o & 4 && (o |= a & 16),
    e = s.entangledLanes,
    e !== 0)
        for (s = s.entanglements,
        e &= o; 0 < e; )
            a = 31 - oc(e),
            c = 1 << a,
            o |= s[a],
            e &= ~c;
    return o
}
function vc(s, e) {
    switch (s) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wc(s, e) {
    for (var a = s.suspendedLanes, o = s.pingedLanes, c = s.expirationTimes, d = s.pendingLanes; 0 < d; ) {
        var g = 31 - oc(d)
          , _ = 1 << g
          , b = c[g];
        b === -1 ? (!(_ & a) || _ & o) && (c[g] = vc(_, e)) : b <= e && (s.expiredLanes |= _),
        d &= ~_
    }
}
function xc(s) {
    return s = s.pendingLanes & -1073741825,
    s !== 0 ? s : s & 1073741824 ? 1073741824 : 0
}
function yc() {
    var s = rc;
    return rc <<= 1,
    !(rc & 4194240) && (rc = 64),
    s
}
function zc(s) {
    for (var e = [], a = 0; 31 > a; a++)
        e.push(s);
    return e
}
function Ac(s, e, a) {
    s.pendingLanes |= e,
    e !== 536870912 && (s.suspendedLanes = 0,
    s.pingedLanes = 0),
    s = s.eventTimes,
    e = 31 - oc(e),
    s[e] = a
}
function Bc(s, e) {
    var a = s.pendingLanes & ~e;
    s.pendingLanes = e,
    s.suspendedLanes = 0,
    s.pingedLanes = 0,
    s.expiredLanes &= e,
    s.mutableReadLanes &= e,
    s.entangledLanes &= e,
    e = s.entanglements;
    var o = s.eventTimes;
    for (s = s.expirationTimes; 0 < a; ) {
        var c = 31 - oc(a)
          , d = 1 << c;
        e[c] = 0,
        o[c] = -1,
        s[c] = -1,
        a &= ~d
    }
}
function Cc(s, e) {
    var a = s.entangledLanes |= e;
    for (s = s.entanglements; a; ) {
        var o = 31 - oc(a)
          , c = 1 << o;
        c & e | s[o] & e && (s[o] |= e),
        a &= ~c
    }
}
var C = 0;
function Dc(s) {
    return s &= -s,
    1 < s ? 4 < s ? s & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(s, e) {
    switch (s) {
    case "focusin":
    case "focusout":
        Lc = null;
        break;
    case "dragenter":
    case "dragleave":
        Mc = null;
        break;
    case "mouseover":
    case "mouseout":
        Nc = null;
        break;
    case "pointerover":
    case "pointerout":
        Oc.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pc.delete(e.pointerId)
    }
}
function Tc(s, e, a, o, c, d) {
    return s === null || s.nativeEvent !== d ? (s = {
        blockedOn: e,
        domEventName: a,
        eventSystemFlags: o,
        nativeEvent: d,
        targetContainers: [c]
    },
    e !== null && (e = Cb(e),
    e !== null && Fc(e)),
    s) : (s.eventSystemFlags |= o,
    e = s.targetContainers,
    c !== null && e.indexOf(c) === -1 && e.push(c),
    s)
}
function Uc(s, e, a, o, c) {
    switch (e) {
    case "focusin":
        return Lc = Tc(Lc, s, e, a, o, c),
        !0;
    case "dragenter":
        return Mc = Tc(Mc, s, e, a, o, c),
        !0;
    case "mouseover":
        return Nc = Tc(Nc, s, e, a, o, c),
        !0;
    case "pointerover":
        var d = c.pointerId;
        return Oc.set(d, Tc(Oc.get(d) || null, s, e, a, o, c)),
        !0;
    case "gotpointercapture":
        return d = c.pointerId,
        Pc.set(d, Tc(Pc.get(d) || null, s, e, a, o, c)),
        !0
    }
    return !1
}
function Vc(s) {
    var e = Wc(s.target);
    if (e !== null) {
        var a = Vb(e);
        if (a !== null) {
            if (e = a.tag,
            e === 13) {
                if (e = Wb(a),
                e !== null) {
                    s.blockedOn = e,
                    Ic(s.priority, function() {
                        Gc(a)
                    });
                    return
                }
            } else if (e === 3 && a.stateNode.current.memoizedState.isDehydrated) {
                s.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
                return
            }
        }
    }
    s.blockedOn = null
}
function Xc(s) {
    if (s.blockedOn !== null)
        return !1;
    for (var e = s.targetContainers; 0 < e.length; ) {
        var a = Yc(s.domEventName, s.eventSystemFlags, e[0], s.nativeEvent);
        if (a === null) {
            a = s.nativeEvent;
            var o = new a.constructor(a.type,a);
            wb = o,
            a.target.dispatchEvent(o),
            wb = null
        } else
            return e = Cb(a),
            e !== null && Fc(e),
            s.blockedOn = a,
            !1;
        e.shift()
    }
    return !0
}
function Zc(s, e, a) {
    Xc(s) && a.delete(e)
}
function $c() {
    Jc = !1,
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(s, e) {
    s.blockedOn === e && (s.blockedOn = null,
    Jc || (Jc = !0,
    ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(s) {
    function e(c) {
        return ad(c, s)
    }
    if (0 < Kc.length) {
        ad(Kc[0], s);
        for (var a = 1; a < Kc.length; a++) {
            var o = Kc[a];
            o.blockedOn === s && (o.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, s),
    Mc !== null && ad(Mc, s),
    Nc !== null && ad(Nc, s),
    Oc.forEach(e),
    Pc.forEach(e),
    a = 0; a < Qc.length; a++)
        o = Qc[a],
        o.blockedOn === s && (o.blockedOn = null);
    for (; 0 < Qc.length && (a = Qc[0],
    a.blockedOn === null); )
        Vc(a),
        a.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig
  , dd = !0;
function ed(s, e, a, o) {
    var c = C
      , d = cd.transition;
    cd.transition = null;
    try {
        C = 1,
        fd(s, e, a, o)
    } finally {
        C = c,
        cd.transition = d
    }
}
function gd(s, e, a, o) {
    var c = C
      , d = cd.transition;
    cd.transition = null;
    try {
        C = 4,
        fd(s, e, a, o)
    } finally {
        C = c,
        cd.transition = d
    }
}
function fd(s, e, a, o) {
    if (dd) {
        var c = Yc(s, e, a, o);
        if (c === null)
            hd(s, e, o, id$2, a),
            Sc(s, o);
        else if (Uc(c, s, e, a, o))
            o.stopPropagation();
        else if (Sc(s, o),
        e & 4 && -1 < Rc.indexOf(s)) {
            for (; c !== null; ) {
                var d = Cb(c);
                if (d !== null && Ec(d),
                d = Yc(s, e, a, o),
                d === null && hd(s, e, o, id$2, a),
                d === c)
                    break;
                c = d
            }
            c !== null && o.stopPropagation()
        } else
            hd(s, e, o, null, a)
    }
}
var id$2 = null;
function Yc(s, e, a, o) {
    if (id$2 = null,
    s = xb(o),
    s = Wc(s),
    s !== null)
        if (e = Vb(s),
        e === null)
            s = null;
        else if (a = e.tag,
        a === 13) {
            if (s = Wb(e),
            s !== null)
                return s;
            s = null
        } else if (a === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            s = null
        } else
            e !== s && (s = null);
    return id$2 = s,
    null
}
function jd(s) {
    switch (s) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ec()) {
        case fc:
            return 1;
        case gc:
            return 4;
        case hc:
        case ic:
            return 16;
        case jc:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var kd = null
  , ld = null
  , md = null;
function nd() {
    if (md)
        return md;
    var s, e = ld, a = e.length, o, c = "value"in kd ? kd.value : kd.textContent, d = c.length;
    for (s = 0; s < a && e[s] === c[s]; s++)
        ;
    var g = a - s;
    for (o = 1; o <= g && e[a - o] === c[d - o]; o++)
        ;
    return md = c.slice(s, 1 < o ? 1 - o : void 0)
}
function od(s) {
    var e = s.keyCode;
    return "charCode"in s ? (s = s.charCode,
    s === 0 && e === 13 && (s = 13)) : s = e,
    s === 10 && (s = 13),
    32 <= s || s === 13 ? s : 0
}
function pd() {
    return !0
}
function qd() {
    return !1
}
function rd(s) {
    function e(a, o, c, d, g) {
        this._reactName = a,
        this._targetInst = c,
        this.type = o,
        this.nativeEvent = d,
        this.target = g,
        this.currentTarget = null;
        for (var _ in s)
            s.hasOwnProperty(_) && (a = s[_],
            this[_] = a ? a(d) : d[_]);
        return this.isDefaultPrevented = (d.defaultPrevented != null ? d.defaultPrevented : d.returnValue === !1) ? pd : qd,
        this.isPropagationStopped = qd,
        this
    }
    return A(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var a = this.nativeEvent;
            a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1),
            this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var a = this.nativeEvent;
            a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0),
            this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }),
    e
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(s) {
        return s.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, td = rd(sd), ud = A({}, sd, {
    view: 0,
    detail: 0
}), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(s) {
        return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget
    },
    movementX: function(s) {
        return "movementX"in s ? s.movementX : (s !== yd && (yd && s.type === "mousemove" ? (wd = s.screenX - yd.screenX,
        xd = s.screenY - yd.screenY) : xd = wd = 0,
        yd = s),
        wd)
    },
    movementY: function(s) {
        return "movementY"in s ? s.movementY : xd
    }
}), Bd = rd(Ad), Cd = A({}, Ad, {
    dataTransfer: 0
}), Dd = rd(Cd), Ed = A({}, ud, {
    relatedTarget: 0
}), Fd = rd(Ed), Gd = A({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hd = rd(Gd), Id = A({}, sd, {
    clipboardData: function(s) {
        return "clipboardData"in s ? s.clipboardData : window.clipboardData
    }
}), Jd = rd(Id), Kd = A({}, sd, {
    data: 0
}), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Pd(s) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(s) : (s = Od[s]) ? !!e[s] : !1
}
function zd() {
    return Pd
}
var Qd = A({}, ud, {
    key: function(s) {
        if (s.key) {
            var e = Md[s.key] || s.key;
            if (e !== "Unidentified")
                return e
        }
        return s.type === "keypress" ? (s = od(s),
        s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Nd[s.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(s) {
        return s.type === "keypress" ? od(s) : 0
    },
    keyCode: function(s) {
        return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
    },
    which: function(s) {
        return s.type === "keypress" ? od(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
    }
})
  , Rd = rd(Qd)
  , Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Td = rd(Sd)
  , Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
})
  , Vd = rd(Ud)
  , Wd = A({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Xd = rd(Wd)
  , Yd = A({}, Ad, {
    deltaX: function(s) {
        return "deltaX"in s ? s.deltaX : "wheelDeltaX"in s ? -s.wheelDeltaX : 0
    },
    deltaY: function(s) {
        return "deltaY"in s ? s.deltaY : "wheelDeltaY"in s ? -s.wheelDeltaY : "wheelDelta"in s ? -s.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Zd = rd(Yd)
  , $d = [9, 13, 27, 32]
  , ae = ia && "CompositionEvent"in window
  , be = null;
ia && "documentMode"in document && (be = document.documentMode);
var ce = ia && "TextEvent"in window && !be
  , de = ia && (!ae || be && 8 < be && 11 >= be)
  , ee = " "
  , fe = !1;
function ge(s, e) {
    switch (s) {
    case "keyup":
        return $d.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function he(s) {
    return s = s.detail,
    typeof s == "object" && "data"in s ? s.data : null
}
var ie = !1;
function je(s, e) {
    switch (s) {
    case "compositionend":
        return he(e);
    case "keypress":
        return e.which !== 32 ? null : (fe = !0,
        ee);
    case "textInput":
        return s = e.data,
        s === ee && fe ? null : s;
    default:
        return null
    }
}
function ke(s, e) {
    if (ie)
        return s === "compositionend" || !ae && ge(s, e) ? (s = nd(),
        md = ld = kd = null,
        ie = !1,
        s) : null;
    switch (s) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return de && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function me(s) {
    var e = s && s.nodeName && s.nodeName.toLowerCase();
    return e === "input" ? !!le[s.type] : e === "textarea"
}
function ne(s, e, a, o) {
    Eb(o),
    e = oe(e, "onChange"),
    0 < e.length && (a = new td("onChange","change",null,a,o),
    s.push({
        event: a,
        listeners: e
    }))
}
var pe = null
  , qe = null;
function re(s) {
    se(s, 0)
}
function te(s) {
    var e = ue(s);
    if (Wa(e))
        return s
}
function ve(s, e) {
    if (s === "change")
        return e
}
var we = !1;
if (ia) {
    var xe;
    if (ia) {
        var ye = "oninput"in document;
        if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;"),
            ye = typeof ze.oninput == "function"
        }
        xe = ye
    } else
        xe = !1;
    we = xe && (!document.documentMode || 9 < document.documentMode)
}
function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be),
    qe = pe = null)
}
function Be(s) {
    if (s.propertyName === "value" && te(qe)) {
        var e = [];
        ne(e, qe, s, xb(s)),
        Jb(re, e)
    }
}
function Ce(s, e, a) {
    s === "focusin" ? (Ae(),
    pe = e,
    qe = a,
    pe.attachEvent("onpropertychange", Be)) : s === "focusout" && Ae()
}
function De(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown")
        return te(qe)
}
function Ee(s, e) {
    if (s === "click")
        return te(e)
}
function Fe(s, e) {
    if (s === "input" || s === "change")
        return te(e)
}
function Ge(s, e) {
    return s === e && (s !== 0 || 1 / s === 1 / e) || s !== s && e !== e
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(s, e) {
    if (He(s, e))
        return !0;
    if (typeof s != "object" || s === null || typeof e != "object" || e === null)
        return !1;
    var a = Object.keys(s)
      , o = Object.keys(e);
    if (a.length !== o.length)
        return !1;
    for (o = 0; o < a.length; o++) {
        var c = a[o];
        if (!ja.call(e, c) || !He(s[c], e[c]))
            return !1
    }
    return !0
}
function Je(s) {
    for (; s && s.firstChild; )
        s = s.firstChild;
    return s
}
function Ke(s, e) {
    var a = Je(s);
    s = 0;
    for (var o; a; ) {
        if (a.nodeType === 3) {
            if (o = s + a.textContent.length,
            s <= e && o >= e)
                return {
                    node: a,
                    offset: e - s
                };
            s = o
        }
        e: {
            for (; a; ) {
                if (a.nextSibling) {
                    a = a.nextSibling;
                    break e
                }
                a = a.parentNode
            }
            a = void 0
        }
        a = Je(a)
    }
}
function Le(s, e) {
    return s && e ? s === e ? !0 : s && s.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Le(s, e.parentNode) : "contains"in s ? s.contains(e) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(e) & 16) : !1 : !1
}
function Me() {
    for (var s = window, e = Xa(); e instanceof s.HTMLIFrameElement; ) {
        try {
            var a = typeof e.contentWindow.location.href == "string"
        } catch {
            a = !1
        }
        if (a)
            s = e.contentWindow;
        else
            break;
        e = Xa(s.document)
    }
    return e
}
function Ne(s) {
    var e = s && s.nodeName && s.nodeName.toLowerCase();
    return e && (e === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || e === "textarea" || s.contentEditable === "true")
}
function Oe(s) {
    var e = Me()
      , a = s.focusedElem
      , o = s.selectionRange;
    if (e !== a && a && a.ownerDocument && Le(a.ownerDocument.documentElement, a)) {
        if (o !== null && Ne(a)) {
            if (e = o.start,
            s = o.end,
            s === void 0 && (s = e),
            "selectionStart"in a)
                a.selectionStart = e,
                a.selectionEnd = Math.min(s, a.value.length);
            else if (s = (e = a.ownerDocument || document) && e.defaultView || window,
            s.getSelection) {
                s = s.getSelection();
                var c = a.textContent.length
                  , d = Math.min(o.start, c);
                o = o.end === void 0 ? d : Math.min(o.end, c),
                !s.extend && d > o && (c = o,
                o = d,
                d = c),
                c = Ke(a, d);
                var g = Ke(a, o);
                c && g && (s.rangeCount !== 1 || s.anchorNode !== c.node || s.anchorOffset !== c.offset || s.focusNode !== g.node || s.focusOffset !== g.offset) && (e = e.createRange(),
                e.setStart(c.node, c.offset),
                s.removeAllRanges(),
                d > o ? (s.addRange(e),
                s.extend(g.node, g.offset)) : (e.setEnd(g.node, g.offset),
                s.addRange(e)))
            }
        }
        for (e = [],
        s = a; s = s.parentNode; )
            s.nodeType === 1 && e.push({
                element: s,
                left: s.scrollLeft,
                top: s.scrollTop
            });
        for (typeof a.focus == "function" && a.focus(),
        a = 0; a < e.length; a++)
            s = e[a],
            s.element.scrollLeft = s.left,
            s.element.scrollTop = s.top
    }
}
var Pe = ia && "documentMode"in document && 11 >= document.documentMode
  , Qe = null
  , Re = null
  , Se = null
  , Te = !1;
function Ue(s, e, a) {
    var o = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
    Te || Qe == null || Qe !== Xa(o) || (o = Qe,
    "selectionStart"in o && Ne(o) ? o = {
        start: o.selectionStart,
        end: o.selectionEnd
    } : (o = (o.ownerDocument && o.ownerDocument.defaultView || window).getSelection(),
    o = {
        anchorNode: o.anchorNode,
        anchorOffset: o.anchorOffset,
        focusNode: o.focusNode,
        focusOffset: o.focusOffset
    }),
    Se && Ie(Se, o) || (Se = o,
    o = oe(Re, "onSelect"),
    0 < o.length && (e = new td("onSelect","select",null,e,a),
    s.push({
        event: e,
        listeners: o
    }),
    e.target = Qe)))
}
function Ve(s, e) {
    var a = {};
    return a[s.toLowerCase()] = e.toLowerCase(),
    a["Webkit" + s] = "webkit" + e,
    a["Moz" + s] = "moz" + e,
    a
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
}
  , Xe = {}
  , Ye = {};
ia && (Ye = document.createElement("div").style,
"AnimationEvent"in window || (delete We.animationend.animation,
delete We.animationiteration.animation,
delete We.animationstart.animation),
"TransitionEvent"in window || delete We.transitionend.transition);
function Ze(s) {
    if (Xe[s])
        return Xe[s];
    if (!We[s])
        return s;
    var e = We[s], a;
    for (a in e)
        if (e.hasOwnProperty(a) && a in Ye)
            return Xe[s] = e[a];
    return s
}
var $e = Ze("animationend")
  , af = Ze("animationiteration")
  , bf = Ze("animationstart")
  , cf = Ze("transitionend")
  , df = new Map
  , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(s, e) {
    df.set(s, e),
    fa(e, [s])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf]
      , jf = hf.toLowerCase()
      , kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(s, e, a) {
    var o = s.type || "unknown-event";
    s.currentTarget = a,
    Ub(o, e, void 0, s),
    s.currentTarget = null
}
function se(s, e) {
    e = (e & 4) !== 0;
    for (var a = 0; a < s.length; a++) {
        var o = s[a]
          , c = o.event;
        o = o.listeners;
        e: {
            var d = void 0;
            if (e)
                for (var g = o.length - 1; 0 <= g; g--) {
                    var _ = o[g]
                      , b = _.instance
                      , j = _.currentTarget;
                    if (_ = _.listener,
                    b !== d && c.isPropagationStopped())
                        break e;
                    nf(c, _, j),
                    d = b
                }
            else
                for (g = 0; g < o.length; g++) {
                    if (_ = o[g],
                    b = _.instance,
                    j = _.currentTarget,
                    _ = _.listener,
                    b !== d && c.isPropagationStopped())
                        break e;
                    nf(c, _, j),
                    d = b
                }
        }
    }
    if (Qb)
        throw s = Rb,
        Qb = !1,
        Rb = null,
        s
}
function D(s, e) {
    var a = e[of];
    a === void 0 && (a = e[of] = new Set);
    var o = s + "__bubble";
    a.has(o) || (pf(e, s, 2, !1),
    a.add(o))
}
function qf(s, e, a) {
    var o = 0;
    e && (o |= 4),
    pf(a, s, o, e)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(s) {
    if (!s[rf]) {
        s[rf] = !0,
        da.forEach(function(a) {
            a !== "selectionchange" && (mf.has(a) || qf(a, !1, s),
            qf(a, !0, s))
        });
        var e = s.nodeType === 9 ? s : s.ownerDocument;
        e === null || e[rf] || (e[rf] = !0,
        qf("selectionchange", !1, e))
    }
}
function pf(s, e, a, o) {
    switch (jd(e)) {
    case 1:
        var c = ed;
        break;
    case 4:
        c = gd;
        break;
    default:
        c = fd
    }
    a = c.bind(null, e, a, s),
    c = void 0,
    !Lb || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (c = !0),
    o ? c !== void 0 ? s.addEventListener(e, a, {
        capture: !0,
        passive: c
    }) : s.addEventListener(e, a, !0) : c !== void 0 ? s.addEventListener(e, a, {
        passive: c
    }) : s.addEventListener(e, a, !1)
}
function hd(s, e, a, o, c) {
    var d = o;
    if (!(e & 1) && !(e & 2) && o !== null)
        e: for (; ; ) {
            if (o === null)
                return;
            var g = o.tag;
            if (g === 3 || g === 4) {
                var _ = o.stateNode.containerInfo;
                if (_ === c || _.nodeType === 8 && _.parentNode === c)
                    break;
                if (g === 4)
                    for (g = o.return; g !== null; ) {
                        var b = g.tag;
                        if ((b === 3 || b === 4) && (b = g.stateNode.containerInfo,
                        b === c || b.nodeType === 8 && b.parentNode === c))
                            return;
                        g = g.return
                    }
                for (; _ !== null; ) {
                    if (g = Wc(_),
                    g === null)
                        return;
                    if (b = g.tag,
                    b === 5 || b === 6) {
                        o = d = g;
                        continue e
                    }
                    _ = _.parentNode
                }
            }
            o = o.return
        }
    Jb(function() {
        var j = d
          , $ = xb(a)
          , nt = [];
        e: {
            var tt = df.get(s);
            if (tt !== void 0) {
                var rt = td
                  , st = s;
                switch (s) {
                case "keypress":
                    if (od(a) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    rt = Rd;
                    break;
                case "focusin":
                    st = "focus",
                    rt = Fd;
                    break;
                case "focusout":
                    st = "blur",
                    rt = Fd;
                    break;
                case "beforeblur":
                case "afterblur":
                    rt = Fd;
                    break;
                case "click":
                    if (a.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    rt = Bd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    rt = Dd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    rt = Vd;
                    break;
                case $e:
                case af:
                case bf:
                    rt = Hd;
                    break;
                case cf:
                    rt = Xd;
                    break;
                case "scroll":
                    rt = vd;
                    break;
                case "wheel":
                    rt = Zd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    rt = Jd;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    rt = Td
                }
                var lt = (e & 4) !== 0
                  , ct = !lt && s === "scroll"
                  , it = lt ? tt !== null ? tt + "Capture" : null : tt;
                lt = [];
                for (var ot = j, at; ot !== null; ) {
                    at = ot;
                    var ht = at.stateNode;
                    if (at.tag === 5 && ht !== null && (at = ht,
                    it !== null && (ht = Kb(ot, it),
                    ht != null && lt.push(tf(ot, ht, at)))),
                    ct)
                        break;
                    ot = ot.return
                }
                0 < lt.length && (tt = new rt(tt,st,null,a,$),
                nt.push({
                    event: tt,
                    listeners: lt
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (tt = s === "mouseover" || s === "pointerover",
                rt = s === "mouseout" || s === "pointerout",
                tt && a !== wb && (st = a.relatedTarget || a.fromElement) && (Wc(st) || st[uf]))
                    break e;
                if ((rt || tt) && (tt = $.window === $ ? $ : (tt = $.ownerDocument) ? tt.defaultView || tt.parentWindow : window,
                rt ? (st = a.relatedTarget || a.toElement,
                rt = j,
                st = st ? Wc(st) : null,
                st !== null && (ct = Vb(st),
                st !== ct || st.tag !== 5 && st.tag !== 6) && (st = null)) : (rt = null,
                st = j),
                rt !== st)) {
                    if (lt = Bd,
                    ht = "onMouseLeave",
                    it = "onMouseEnter",
                    ot = "mouse",
                    (s === "pointerout" || s === "pointerover") && (lt = Td,
                    ht = "onPointerLeave",
                    it = "onPointerEnter",
                    ot = "pointer"),
                    ct = rt == null ? tt : ue(rt),
                    at = st == null ? tt : ue(st),
                    tt = new lt(ht,ot + "leave",rt,a,$),
                    tt.target = ct,
                    tt.relatedTarget = at,
                    ht = null,
                    Wc($) === j && (lt = new lt(it,ot + "enter",st,a,$),
                    lt.target = at,
                    lt.relatedTarget = ct,
                    ht = lt),
                    ct = ht,
                    rt && st)
                        t: {
                            for (lt = rt,
                            it = st,
                            ot = 0,
                            at = lt; at; at = vf(at))
                                ot++;
                            for (at = 0,
                            ht = it; ht; ht = vf(ht))
                                at++;
                            for (; 0 < ot - at; )
                                lt = vf(lt),
                                ot--;
                            for (; 0 < at - ot; )
                                it = vf(it),
                                at--;
                            for (; ot--; ) {
                                if (lt === it || it !== null && lt === it.alternate)
                                    break t;
                                lt = vf(lt),
                                it = vf(it)
                            }
                            lt = null
                        }
                    else
                        lt = null;
                    rt !== null && wf(nt, tt, rt, lt, !1),
                    st !== null && ct !== null && wf(nt, ct, st, lt, !0)
                }
            }
            e: {
                if (tt = j ? ue(j) : window,
                rt = tt.nodeName && tt.nodeName.toLowerCase(),
                rt === "select" || rt === "input" && tt.type === "file")
                    var pt = ve;
                else if (me(tt))
                    if (we)
                        pt = Fe;
                    else {
                        pt = De;
                        var dt = Ce
                    }
                else
                    (rt = tt.nodeName) && rt.toLowerCase() === "input" && (tt.type === "checkbox" || tt.type === "radio") && (pt = Ee);
                if (pt && (pt = pt(s, j))) {
                    ne(nt, pt, a, $);
                    break e
                }
                dt && dt(s, tt, j),
                s === "focusout" && (dt = tt._wrapperState) && dt.controlled && tt.type === "number" && cb(tt, "number", tt.value)
            }
            switch (dt = j ? ue(j) : window,
            s) {
            case "focusin":
                (me(dt) || dt.contentEditable === "true") && (Qe = dt,
                Re = j,
                Se = null);
                break;
            case "focusout":
                Se = Re = Qe = null;
                break;
            case "mousedown":
                Te = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Te = !1,
                Ue(nt, a, $);
                break;
            case "selectionchange":
                if (Pe)
                    break;
            case "keydown":
            case "keyup":
                Ue(nt, a, $)
            }
            var yt;
            if (ae)
                e: {
                    switch (s) {
                    case "compositionstart":
                        var vt = "onCompositionStart";
                        break e;
                    case "compositionend":
                        vt = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        vt = "onCompositionUpdate";
                        break e
                    }
                    vt = void 0
                }
            else
                ie ? ge(s, a) && (vt = "onCompositionEnd") : s === "keydown" && a.keyCode === 229 && (vt = "onCompositionStart");
            vt && (de && a.locale !== "ko" && (ie || vt !== "onCompositionStart" ? vt === "onCompositionEnd" && ie && (yt = nd()) : (kd = $,
            ld = "value"in kd ? kd.value : kd.textContent,
            ie = !0)),
            dt = oe(j, vt),
            0 < dt.length && (vt = new Ld(vt,s,null,a,$),
            nt.push({
                event: vt,
                listeners: dt
            }),
            yt ? vt.data = yt : (yt = he(a),
            yt !== null && (vt.data = yt)))),
            (yt = ce ? je(s, a) : ke(s, a)) && (j = oe(j, "onBeforeInput"),
            0 < j.length && ($ = new Ld("onBeforeInput","beforeinput",null,a,$),
            nt.push({
                event: $,
                listeners: j
            }),
            $.data = yt))
        }
        se(nt, e)
    })
}
function tf(s, e, a) {
    return {
        instance: s,
        listener: e,
        currentTarget: a
    }
}
function oe(s, e) {
    for (var a = e + "Capture", o = []; s !== null; ) {
        var c = s
          , d = c.stateNode;
        c.tag === 5 && d !== null && (c = d,
        d = Kb(s, a),
        d != null && o.unshift(tf(s, d, c)),
        d = Kb(s, e),
        d != null && o.push(tf(s, d, c))),
        s = s.return
    }
    return o
}
function vf(s) {
    if (s === null)
        return null;
    do
        s = s.return;
    while (s && s.tag !== 5);
    return s || null
}
function wf(s, e, a, o, c) {
    for (var d = e._reactName, g = []; a !== null && a !== o; ) {
        var _ = a
          , b = _.alternate
          , j = _.stateNode;
        if (b !== null && b === o)
            break;
        _.tag === 5 && j !== null && (_ = j,
        c ? (b = Kb(a, d),
        b != null && g.unshift(tf(a, b, _))) : c || (b = Kb(a, d),
        b != null && g.push(tf(a, b, _)))),
        a = a.return
    }
    g.length !== 0 && s.push({
        event: e,
        listeners: g
    })
}
var xf = /\r\n?/g
  , yf = /\u0000|\uFFFD/g;
function zf(s) {
    return (typeof s == "string" ? s : "" + s).replace(xf, `
`).replace(yf, "")
}
function Af(s, e, a) {
    if (e = zf(e),
    zf(s) !== e && a)
        throw Error(p$1(425))
}
function Bf() {}
var Cf = null
  , Df = null;
function Ef(s, e) {
    return s === "textarea" || s === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0
  , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Hf = typeof Promise == "function" ? Promise : void 0
  , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(s) {
    return Hf.resolve(null).then(s).catch(If)
}
: Ff;
function If(s) {
    setTimeout(function() {
        throw s
    })
}
function Kf(s, e) {
    var a = e
      , o = 0;
    do {
        var c = a.nextSibling;
        if (s.removeChild(a),
        c && c.nodeType === 8)
            if (a = c.data,
            a === "/$") {
                if (o === 0) {
                    s.removeChild(c),
                    bd(e);
                    return
                }
                o--
            } else
                a !== "$" && a !== "$?" && a !== "$!" || o++;
        a = c
    } while (a);
    bd(e)
}
function Lf(s) {
    for (; s != null; s = s.nextSibling) {
        var e = s.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = s.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return s
}
function Mf(s) {
    s = s.previousSibling;
    for (var e = 0; s; ) {
        if (s.nodeType === 8) {
            var a = s.data;
            if (a === "$" || a === "$!" || a === "$?") {
                if (e === 0)
                    return s;
                e--
            } else
                a === "/$" && e++
        }
        s = s.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2)
  , Of = "__reactFiber$" + Nf
  , Pf = "__reactProps$" + Nf
  , uf = "__reactContainer$" + Nf
  , of = "__reactEvents$" + Nf
  , Qf = "__reactListeners$" + Nf
  , Rf = "__reactHandles$" + Nf;
function Wc(s) {
    var e = s[Of];
    if (e)
        return e;
    for (var a = s.parentNode; a; ) {
        if (e = a[uf] || a[Of]) {
            if (a = e.alternate,
            e.child !== null || a !== null && a.child !== null)
                for (s = Mf(s); s !== null; ) {
                    if (a = s[Of])
                        return a;
                    s = Mf(s)
                }
            return e
        }
        s = a,
        a = s.parentNode
    }
    return null
}
function Cb(s) {
    return s = s[Of] || s[uf],
    !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s
}
function ue(s) {
    if (s.tag === 5 || s.tag === 6)
        return s.stateNode;
    throw Error(p$1(33))
}
function Db(s) {
    return s[Pf] || null
}
var Sf = []
  , Tf = -1;
function Uf(s) {
    return {
        current: s
    }
}
function E(s) {
    0 > Tf || (s.current = Sf[Tf],
    Sf[Tf] = null,
    Tf--)
}
function G(s, e) {
    Tf++,
    Sf[Tf] = s.current,
    s.current = e
}
var Vf = {}
  , H = Uf(Vf)
  , Wf = Uf(!1)
  , Xf = Vf;
function Yf(s, e) {
    var a = s.type.contextTypes;
    if (!a)
        return Vf;
    var o = s.stateNode;
    if (o && o.__reactInternalMemoizedUnmaskedChildContext === e)
        return o.__reactInternalMemoizedMaskedChildContext;
    var c = {}, d;
    for (d in a)
        c[d] = e[d];
    return o && (s = s.stateNode,
    s.__reactInternalMemoizedUnmaskedChildContext = e,
    s.__reactInternalMemoizedMaskedChildContext = c),
    c
}
function Zf(s) {
    return s = s.childContextTypes,
    s != null
}
function $f() {
    E(Wf),
    E(H)
}
function ag(s, e, a) {
    if (H.current !== Vf)
        throw Error(p$1(168));
    G(H, e),
    G(Wf, a)
}
function bg(s, e, a) {
    var o = s.stateNode;
    if (e = e.childContextTypes,
    typeof o.getChildContext != "function")
        return a;
    o = o.getChildContext();
    for (var c in o)
        if (!(c in e))
            throw Error(p$1(108, Ra(s) || "Unknown", c));
    return A({}, a, o)
}
function cg(s) {
    return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || Vf,
    Xf = H.current,
    G(H, s),
    G(Wf, Wf.current),
    !0
}
function dg(s, e, a) {
    var o = s.stateNode;
    if (!o)
        throw Error(p$1(169));
    a ? (s = bg(s, e, Xf),
    o.__reactInternalMemoizedMergedChildContext = s,
    E(Wf),
    E(H),
    G(H, s)) : E(Wf),
    G(Wf, a)
}
var eg = null
  , fg = !1
  , gg = !1;
function hg(s) {
    eg === null ? eg = [s] : eg.push(s)
}
function ig(s) {
    fg = !0,
    hg(s)
}
function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var s = 0
          , e = C;
        try {
            var a = eg;
            for (C = 1; s < a.length; s++) {
                var o = a[s];
                do
                    o = o(!0);
                while (o !== null)
            }
            eg = null,
            fg = !1
        } catch (c) {
            throw eg !== null && (eg = eg.slice(s + 1)),
            ac(fc, jg),
            c
        } finally {
            C = e,
            gg = !1
        }
    }
    return null
}
var kg = []
  , lg = 0
  , mg = null
  , ng = 0
  , og = []
  , pg = 0
  , qg = null
  , rg = 1
  , sg = "";
function tg(s, e) {
    kg[lg++] = ng,
    kg[lg++] = mg,
    mg = s,
    ng = e
}
function ug(s, e, a) {
    og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    qg = s;
    var o = rg;
    s = sg;
    var c = 32 - oc(o) - 1;
    o &= ~(1 << c),
    a += 1;
    var d = 32 - oc(e) + c;
    if (30 < d) {
        var g = c - c % 5;
        d = (o & (1 << g) - 1).toString(32),
        o >>= g,
        c -= g,
        rg = 1 << 32 - oc(e) + c | a << c | o,
        sg = d + s
    } else
        rg = 1 << d | a << c | o,
        sg = s
}
function vg(s) {
    s.return !== null && (tg(s, 1),
    ug(s, 1, 0))
}
function wg(s) {
    for (; s === mg; )
        mg = kg[--lg],
        kg[lg] = null,
        ng = kg[--lg],
        kg[lg] = null;
    for (; s === qg; )
        qg = og[--pg],
        og[pg] = null,
        sg = og[--pg],
        og[pg] = null,
        rg = og[--pg],
        og[pg] = null
}
var xg = null
  , yg = null
  , I = !1
  , zg = null;
function Ag(s, e) {
    var a = Bg(5, null, null, 0);
    a.elementType = "DELETED",
    a.stateNode = e,
    a.return = s,
    e = s.deletions,
    e === null ? (s.deletions = [a],
    s.flags |= 16) : e.push(a)
}
function Cg(s, e) {
    switch (s.tag) {
    case 5:
        var a = s.type;
        return e = e.nodeType !== 1 || a.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (s.stateNode = e,
        xg = s,
        yg = Lf(e.firstChild),
        !0) : !1;
    case 6:
        return e = s.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (s.stateNode = e,
        xg = s,
        yg = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (a = qg !== null ? {
            id: rg,
            overflow: sg
        } : null,
        s.memoizedState = {
            dehydrated: e,
            treeContext: a,
            retryLane: 1073741824
        },
        a = Bg(18, null, null, 0),
        a.stateNode = e,
        a.return = s,
        s.child = a,
        xg = s,
        yg = null,
        !0) : !1;
    default:
        return !1
    }
}
function Dg(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0
}
function Eg(s) {
    if (I) {
        var e = yg;
        if (e) {
            var a = e;
            if (!Cg(s, e)) {
                if (Dg(s))
                    throw Error(p$1(418));
                e = Lf(a.nextSibling);
                var o = xg;
                e && Cg(s, e) ? Ag(o, a) : (s.flags = s.flags & -4097 | 2,
                I = !1,
                xg = s)
            }
        } else {
            if (Dg(s))
                throw Error(p$1(418));
            s.flags = s.flags & -4097 | 2,
            I = !1,
            xg = s
        }
    }
}
function Fg(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; )
        s = s.return;
    xg = s
}
function Gg(s) {
    if (s !== xg)
        return !1;
    if (!I)
        return Fg(s),
        I = !0,
        !1;
    var e;
    if ((e = s.tag !== 3) && !(e = s.tag !== 5) && (e = s.type,
    e = e !== "head" && e !== "body" && !Ef(s.type, s.memoizedProps)),
    e && (e = yg)) {
        if (Dg(s))
            throw Hg(),
            Error(p$1(418));
        for (; e; )
            Ag(s, e),
            e = Lf(e.nextSibling)
    }
    if (Fg(s),
    s.tag === 13) {
        if (s = s.memoizedState,
        s = s !== null ? s.dehydrated : null,
        !s)
            throw Error(p$1(317));
        e: {
            for (s = s.nextSibling,
            e = 0; s; ) {
                if (s.nodeType === 8) {
                    var a = s.data;
                    if (a === "/$") {
                        if (e === 0) {
                            yg = Lf(s.nextSibling);
                            break e
                        }
                        e--
                    } else
                        a !== "$" && a !== "$!" && a !== "$?" || e++
                }
                s = s.nextSibling
            }
            yg = null
        }
    } else
        yg = xg ? Lf(s.stateNode.nextSibling) : null;
    return !0
}
function Hg() {
    for (var s = yg; s; )
        s = Lf(s.nextSibling)
}
function Ig() {
    yg = xg = null,
    I = !1
}
function Jg(s) {
    zg === null ? zg = [s] : zg.push(s)
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(s, e, a) {
    if (s = a.ref,
    s !== null && typeof s != "function" && typeof s != "object") {
        if (a._owner) {
            if (a = a._owner,
            a) {
                if (a.tag !== 1)
                    throw Error(p$1(309));
                var o = a.stateNode
            }
            if (!o)
                throw Error(p$1(147, s));
            var c = o
              , d = "" + s;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === d ? e.ref : (e = function(g) {
                var _ = c.refs;
                g === null ? delete _[d] : _[d] = g
            }
            ,
            e._stringRef = d,
            e)
        }
        if (typeof s != "string")
            throw Error(p$1(284));
        if (!a._owner)
            throw Error(p$1(290, s))
    }
    return s
}
function Mg(s, e) {
    throw s = Object.prototype.toString.call(e),
    Error(p$1(31, s === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : s))
}
function Ng(s) {
    var e = s._init;
    return e(s._payload)
}
function Og(s) {
    function e(it, ot) {
        if (s) {
            var at = it.deletions;
            at === null ? (it.deletions = [ot],
            it.flags |= 16) : at.push(ot)
        }
    }
    function a(it, ot) {
        if (!s)
            return null;
        for (; ot !== null; )
            e(it, ot),
            ot = ot.sibling;
        return null
    }
    function o(it, ot) {
        for (it = new Map; ot !== null; )
            ot.key !== null ? it.set(ot.key, ot) : it.set(ot.index, ot),
            ot = ot.sibling;
        return it
    }
    function c(it, ot) {
        return it = Pg(it, ot),
        it.index = 0,
        it.sibling = null,
        it
    }
    function d(it, ot, at) {
        return it.index = at,
        s ? (at = it.alternate,
        at !== null ? (at = at.index,
        at < ot ? (it.flags |= 2,
        ot) : at) : (it.flags |= 2,
        ot)) : (it.flags |= 1048576,
        ot)
    }
    function g(it) {
        return s && it.alternate === null && (it.flags |= 2),
        it
    }
    function _(it, ot, at, ht) {
        return ot === null || ot.tag !== 6 ? (ot = Qg(at, it.mode, ht),
        ot.return = it,
        ot) : (ot = c(ot, at),
        ot.return = it,
        ot)
    }
    function b(it, ot, at, ht) {
        var pt = at.type;
        return pt === ya ? $(it, ot, at.props.children, ht, at.key) : ot !== null && (ot.elementType === pt || typeof pt == "object" && pt !== null && pt.$$typeof === Ha && Ng(pt) === ot.type) ? (ht = c(ot, at.props),
        ht.ref = Lg(it, ot, at),
        ht.return = it,
        ht) : (ht = Rg(at.type, at.key, at.props, null, it.mode, ht),
        ht.ref = Lg(it, ot, at),
        ht.return = it,
        ht)
    }
    function j(it, ot, at, ht) {
        return ot === null || ot.tag !== 4 || ot.stateNode.containerInfo !== at.containerInfo || ot.stateNode.implementation !== at.implementation ? (ot = Sg(at, it.mode, ht),
        ot.return = it,
        ot) : (ot = c(ot, at.children || []),
        ot.return = it,
        ot)
    }
    function $(it, ot, at, ht, pt) {
        return ot === null || ot.tag !== 7 ? (ot = Tg(at, it.mode, ht, pt),
        ot.return = it,
        ot) : (ot = c(ot, at),
        ot.return = it,
        ot)
    }
    function nt(it, ot, at) {
        if (typeof ot == "string" && ot !== "" || typeof ot == "number")
            return ot = Qg("" + ot, it.mode, at),
            ot.return = it,
            ot;
        if (typeof ot == "object" && ot !== null) {
            switch (ot.$$typeof) {
            case va:
                return at = Rg(ot.type, ot.key, ot.props, null, it.mode, at),
                at.ref = Lg(it, null, ot),
                at.return = it,
                at;
            case wa:
                return ot = Sg(ot, it.mode, at),
                ot.return = it,
                ot;
            case Ha:
                var ht = ot._init;
                return nt(it, ht(ot._payload), at)
            }
            if (eb(ot) || Ka(ot))
                return ot = Tg(ot, it.mode, at, null),
                ot.return = it,
                ot;
            Mg(it, ot)
        }
        return null
    }
    function tt(it, ot, at, ht) {
        var pt = ot !== null ? ot.key : null;
        if (typeof at == "string" && at !== "" || typeof at == "number")
            return pt !== null ? null : _(it, ot, "" + at, ht);
        if (typeof at == "object" && at !== null) {
            switch (at.$$typeof) {
            case va:
                return at.key === pt ? b(it, ot, at, ht) : null;
            case wa:
                return at.key === pt ? j(it, ot, at, ht) : null;
            case Ha:
                return pt = at._init,
                tt(it, ot, pt(at._payload), ht)
            }
            if (eb(at) || Ka(at))
                return pt !== null ? null : $(it, ot, at, ht, null);
            Mg(it, at)
        }
        return null
    }
    function rt(it, ot, at, ht, pt) {
        if (typeof ht == "string" && ht !== "" || typeof ht == "number")
            return it = it.get(at) || null,
            _(ot, it, "" + ht, pt);
        if (typeof ht == "object" && ht !== null) {
            switch (ht.$$typeof) {
            case va:
                return it = it.get(ht.key === null ? at : ht.key) || null,
                b(ot, it, ht, pt);
            case wa:
                return it = it.get(ht.key === null ? at : ht.key) || null,
                j(ot, it, ht, pt);
            case Ha:
                var dt = ht._init;
                return rt(it, ot, at, dt(ht._payload), pt)
            }
            if (eb(ht) || Ka(ht))
                return it = it.get(at) || null,
                $(ot, it, ht, pt, null);
            Mg(ot, ht)
        }
        return null
    }
    function st(it, ot, at, ht) {
        for (var pt = null, dt = null, yt = ot, vt = ot = 0, xt = null; yt !== null && vt < at.length; vt++) {
            yt.index > vt ? (xt = yt,
            yt = null) : xt = yt.sibling;
            var _t = tt(it, yt, at[vt], ht);
            if (_t === null) {
                yt === null && (yt = xt);
                break
            }
            s && yt && _t.alternate === null && e(it, yt),
            ot = d(_t, ot, vt),
            dt === null ? pt = _t : dt.sibling = _t,
            dt = _t,
            yt = xt
        }
        if (vt === at.length)
            return a(it, yt),
            I && tg(it, vt),
            pt;
        if (yt === null) {
            for (; vt < at.length; vt++)
                yt = nt(it, at[vt], ht),
                yt !== null && (ot = d(yt, ot, vt),
                dt === null ? pt = yt : dt.sibling = yt,
                dt = yt);
            return I && tg(it, vt),
            pt
        }
        for (yt = o(it, yt); vt < at.length; vt++)
            xt = rt(yt, it, vt, at[vt], ht),
            xt !== null && (s && xt.alternate !== null && yt.delete(xt.key === null ? vt : xt.key),
            ot = d(xt, ot, vt),
            dt === null ? pt = xt : dt.sibling = xt,
            dt = xt);
        return s && yt.forEach(function(bt) {
            return e(it, bt)
        }),
        I && tg(it, vt),
        pt
    }
    function lt(it, ot, at, ht) {
        var pt = Ka(at);
        if (typeof pt != "function")
            throw Error(p$1(150));
        if (at = pt.call(at),
        at == null)
            throw Error(p$1(151));
        for (var dt = pt = null, yt = ot, vt = ot = 0, xt = null, _t = at.next(); yt !== null && !_t.done; vt++,
        _t = at.next()) {
            yt.index > vt ? (xt = yt,
            yt = null) : xt = yt.sibling;
            var bt = tt(it, yt, _t.value, ht);
            if (bt === null) {
                yt === null && (yt = xt);
                break
            }
            s && yt && bt.alternate === null && e(it, yt),
            ot = d(bt, ot, vt),
            dt === null ? pt = bt : dt.sibling = bt,
            dt = bt,
            yt = xt
        }
        if (_t.done)
            return a(it, yt),
            I && tg(it, vt),
            pt;
        if (yt === null) {
            for (; !_t.done; vt++,
            _t = at.next())
                _t = nt(it, _t.value, ht),
                _t !== null && (ot = d(_t, ot, vt),
                dt === null ? pt = _t : dt.sibling = _t,
                dt = _t);
            return I && tg(it, vt),
            pt
        }
        for (yt = o(it, yt); !_t.done; vt++,
        _t = at.next())
            _t = rt(yt, it, vt, _t.value, ht),
            _t !== null && (s && _t.alternate !== null && yt.delete(_t.key === null ? vt : _t.key),
            ot = d(_t, ot, vt),
            dt === null ? pt = _t : dt.sibling = _t,
            dt = _t);
        return s && yt.forEach(function(Rt) {
            return e(it, Rt)
        }),
        I && tg(it, vt),
        pt
    }
    function ct(it, ot, at, ht) {
        if (typeof at == "object" && at !== null && at.type === ya && at.key === null && (at = at.props.children),
        typeof at == "object" && at !== null) {
            switch (at.$$typeof) {
            case va:
                e: {
                    for (var pt = at.key, dt = ot; dt !== null; ) {
                        if (dt.key === pt) {
                            if (pt = at.type,
                            pt === ya) {
                                if (dt.tag === 7) {
                                    a(it, dt.sibling),
                                    ot = c(dt, at.props.children),
                                    ot.return = it,
                                    it = ot;
                                    break e
                                }
                            } else if (dt.elementType === pt || typeof pt == "object" && pt !== null && pt.$$typeof === Ha && Ng(pt) === dt.type) {
                                a(it, dt.sibling),
                                ot = c(dt, at.props),
                                ot.ref = Lg(it, dt, at),
                                ot.return = it,
                                it = ot;
                                break e
                            }
                            a(it, dt);
                            break
                        } else
                            e(it, dt);
                        dt = dt.sibling
                    }
                    at.type === ya ? (ot = Tg(at.props.children, it.mode, ht, at.key),
                    ot.return = it,
                    it = ot) : (ht = Rg(at.type, at.key, at.props, null, it.mode, ht),
                    ht.ref = Lg(it, ot, at),
                    ht.return = it,
                    it = ht)
                }
                return g(it);
            case wa:
                e: {
                    for (dt = at.key; ot !== null; ) {
                        if (ot.key === dt)
                            if (ot.tag === 4 && ot.stateNode.containerInfo === at.containerInfo && ot.stateNode.implementation === at.implementation) {
                                a(it, ot.sibling),
                                ot = c(ot, at.children || []),
                                ot.return = it,
                                it = ot;
                                break e
                            } else {
                                a(it, ot);
                                break
                            }
                        else
                            e(it, ot);
                        ot = ot.sibling
                    }
                    ot = Sg(at, it.mode, ht),
                    ot.return = it,
                    it = ot
                }
                return g(it);
            case Ha:
                return dt = at._init,
                ct(it, ot, dt(at._payload), ht)
            }
            if (eb(at))
                return st(it, ot, at, ht);
            if (Ka(at))
                return lt(it, ot, at, ht);
            Mg(it, at)
        }
        return typeof at == "string" && at !== "" || typeof at == "number" ? (at = "" + at,
        ot !== null && ot.tag === 6 ? (a(it, ot.sibling),
        ot = c(ot, at),
        ot.return = it,
        it = ot) : (a(it, ot),
        ot = Qg(at, it.mode, ht),
        ot.return = it,
        it = ot),
        g(it)) : a(it, ot)
    }
    return ct
}
var Ug = Og(!0)
  , Vg = Og(!1)
  , Wg = Uf(null)
  , Xg = null
  , Yg = null
  , Zg = null;
function $g() {
    Zg = Yg = Xg = null
}
function ah(s) {
    var e = Wg.current;
    E(Wg),
    s._currentValue = e
}
function bh(s, e, a) {
    for (; s !== null; ) {
        var o = s.alternate;
        if ((s.childLanes & e) !== e ? (s.childLanes |= e,
        o !== null && (o.childLanes |= e)) : o !== null && (o.childLanes & e) !== e && (o.childLanes |= e),
        s === a)
            break;
        s = s.return
    }
}
function ch(s, e) {
    Xg = s,
    Zg = Yg = null,
    s = s.dependencies,
    s !== null && s.firstContext !== null && (s.lanes & e && (dh = !0),
    s.firstContext = null)
}
function eh(s) {
    var e = s._currentValue;
    if (Zg !== s)
        if (s = {
            context: s,
            memoizedValue: e,
            next: null
        },
        Yg === null) {
            if (Xg === null)
                throw Error(p$1(308));
            Yg = s,
            Xg.dependencies = {
                lanes: 0,
                firstContext: s
            }
        } else
            Yg = Yg.next = s;
    return e
}
var fh = null;
function gh(s) {
    fh === null ? fh = [s] : fh.push(s)
}
function hh(s, e, a, o) {
    var c = e.interleaved;
    return c === null ? (a.next = a,
    gh(e)) : (a.next = c.next,
    c.next = a),
    e.interleaved = a,
    ih(s, o)
}
function ih(s, e) {
    s.lanes |= e;
    var a = s.alternate;
    for (a !== null && (a.lanes |= e),
    a = s,
    s = s.return; s !== null; )
        s.childLanes |= e,
        a = s.alternate,
        a !== null && (a.childLanes |= e),
        a = s,
        s = s.return;
    return a.tag === 3 ? a.stateNode : null
}
var jh = !1;
function kh(s) {
    s.updateQueue = {
        baseState: s.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function lh(s, e) {
    s = s.updateQueue,
    e.updateQueue === s && (e.updateQueue = {
        baseState: s.baseState,
        firstBaseUpdate: s.firstBaseUpdate,
        lastBaseUpdate: s.lastBaseUpdate,
        shared: s.shared,
        effects: s.effects
    })
}
function mh(s, e) {
    return {
        eventTime: s,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function nh(s, e, a) {
    var o = s.updateQueue;
    if (o === null)
        return null;
    if (o = o.shared,
    K & 2) {
        var c = o.pending;
        return c === null ? e.next = e : (e.next = c.next,
        c.next = e),
        o.pending = e,
        ih(s, a)
    }
    return c = o.interleaved,
    c === null ? (e.next = e,
    gh(o)) : (e.next = c.next,
    c.next = e),
    o.interleaved = e,
    ih(s, a)
}
function oh(s, e, a) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (a & 4194240) !== 0)) {
        var o = e.lanes;
        o &= s.pendingLanes,
        a |= o,
        e.lanes = a,
        Cc(s, a)
    }
}
function ph(s, e) {
    var a = s.updateQueue
      , o = s.alternate;
    if (o !== null && (o = o.updateQueue,
    a === o)) {
        var c = null
          , d = null;
        if (a = a.firstBaseUpdate,
        a !== null) {
            do {
                var g = {
                    eventTime: a.eventTime,
                    lane: a.lane,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                };
                d === null ? c = d = g : d = d.next = g,
                a = a.next
            } while (a !== null);
            d === null ? c = d = e : d = d.next = e
        } else
            c = d = e;
        a = {
            baseState: o.baseState,
            firstBaseUpdate: c,
            lastBaseUpdate: d,
            shared: o.shared,
            effects: o.effects
        },
        s.updateQueue = a;
        return
    }
    s = a.lastBaseUpdate,
    s === null ? a.firstBaseUpdate = e : s.next = e,
    a.lastBaseUpdate = e
}
function qh(s, e, a, o) {
    var c = s.updateQueue;
    jh = !1;
    var d = c.firstBaseUpdate
      , g = c.lastBaseUpdate
      , _ = c.shared.pending;
    if (_ !== null) {
        c.shared.pending = null;
        var b = _
          , j = b.next;
        b.next = null,
        g === null ? d = j : g.next = j,
        g = b;
        var $ = s.alternate;
        $ !== null && ($ = $.updateQueue,
        _ = $.lastBaseUpdate,
        _ !== g && (_ === null ? $.firstBaseUpdate = j : _.next = j,
        $.lastBaseUpdate = b))
    }
    if (d !== null) {
        var nt = c.baseState;
        g = 0,
        $ = j = b = null,
        _ = d;
        do {
            var tt = _.lane
              , rt = _.eventTime;
            if ((o & tt) === tt) {
                $ !== null && ($ = $.next = {
                    eventTime: rt,
                    lane: 0,
                    tag: _.tag,
                    payload: _.payload,
                    callback: _.callback,
                    next: null
                });
                e: {
                    var st = s
                      , lt = _;
                    switch (tt = e,
                    rt = a,
                    lt.tag) {
                    case 1:
                        if (st = lt.payload,
                        typeof st == "function") {
                            nt = st.call(rt, nt, tt);
                            break e
                        }
                        nt = st;
                        break e;
                    case 3:
                        st.flags = st.flags & -65537 | 128;
                    case 0:
                        if (st = lt.payload,
                        tt = typeof st == "function" ? st.call(rt, nt, tt) : st,
                        tt == null)
                            break e;
                        nt = A({}, nt, tt);
                        break e;
                    case 2:
                        jh = !0
                    }
                }
                _.callback !== null && _.lane !== 0 && (s.flags |= 64,
                tt = c.effects,
                tt === null ? c.effects = [_] : tt.push(_))
            } else
                rt = {
                    eventTime: rt,
                    lane: tt,
                    tag: _.tag,
                    payload: _.payload,
                    callback: _.callback,
                    next: null
                },
                $ === null ? (j = $ = rt,
                b = nt) : $ = $.next = rt,
                g |= tt;
            if (_ = _.next,
            _ === null) {
                if (_ = c.shared.pending,
                _ === null)
                    break;
                tt = _,
                _ = tt.next,
                tt.next = null,
                c.lastBaseUpdate = tt,
                c.shared.pending = null
            }
        } while (!0);
        if ($ === null && (b = nt),
        c.baseState = b,
        c.firstBaseUpdate = j,
        c.lastBaseUpdate = $,
        e = c.shared.interleaved,
        e !== null) {
            c = e;
            do
                g |= c.lane,
                c = c.next;
            while (c !== e)
        } else
            d === null && (c.shared.lanes = 0);
        rh |= g,
        s.lanes = g,
        s.memoizedState = nt
    }
}
function sh(s, e, a) {
    if (s = e.effects,
    e.effects = null,
    s !== null)
        for (e = 0; e < s.length; e++) {
            var o = s[e]
              , c = o.callback;
            if (c !== null) {
                if (o.callback = null,
                o = a,
                typeof c != "function")
                    throw Error(p$1(191, c));
                c.call(o)
            }
        }
}
var th = {}
  , uh = Uf(th)
  , vh$1 = Uf(th)
  , wh = Uf(th);
function xh(s) {
    if (s === th)
        throw Error(p$1(174));
    return s
}
function yh(s, e) {
    switch (G(wh, e),
    G(vh$1, s),
    G(uh, th),
    s = e.nodeType,
    s) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : lb(null, "");
        break;
    default:
        s = s === 8 ? e.parentNode : e,
        e = s.namespaceURI || null,
        s = s.tagName,
        e = lb(e, s)
    }
    E(uh),
    G(uh, e)
}
function zh() {
    E(uh),
    E(vh$1),
    E(wh)
}
function Ah(s) {
    xh(wh.current);
    var e = xh(uh.current)
      , a = lb(e, s.type);
    e !== a && (G(vh$1, s),
    G(uh, a))
}
function Bh(s) {
    vh$1.current === s && (E(uh),
    E(vh$1))
}
var L = Uf(0);
function Ch(s) {
    for (var e = s; e !== null; ) {
        if (e.tag === 13) {
            var a = e.memoizedState;
            if (a !== null && (a = a.dehydrated,
            a === null || a.data === "$?" || a.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === s)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === s)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var Dh = [];
function Eh() {
    for (var s = 0; s < Dh.length; s++)
        Dh[s]._workInProgressVersionPrimary = null;
    Dh.length = 0
}
var Fh = ua.ReactCurrentDispatcher
  , Gh = ua.ReactCurrentBatchConfig
  , Hh = 0
  , M = null
  , N = null
  , O = null
  , Ih = !1
  , Jh = !1
  , Kh = 0
  , Lh = 0;
function P() {
    throw Error(p$1(321))
}
function Mh(s, e) {
    if (e === null)
        return !1;
    for (var a = 0; a < e.length && a < s.length; a++)
        if (!He(s[a], e[a]))
            return !1;
    return !0
}
function Nh(s, e, a, o, c, d) {
    if (Hh = d,
    M = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    Fh.current = s === null || s.memoizedState === null ? Oh : Ph,
    s = a(o, c),
    Jh) {
        d = 0;
        do {
            if (Jh = !1,
            Kh = 0,
            25 <= d)
                throw Error(p$1(301));
            d += 1,
            O = N = null,
            e.updateQueue = null,
            Fh.current = Qh,
            s = a(o, c)
        } while (Jh)
    }
    if (Fh.current = Rh,
    e = N !== null && N.next !== null,
    Hh = 0,
    O = N = M = null,
    Ih = !1,
    e)
        throw Error(p$1(300));
    return s
}
function Sh() {
    var s = Kh !== 0;
    return Kh = 0,
    s
}
function Th() {
    var s = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return O === null ? M.memoizedState = O = s : O = O.next = s,
    O
}
function Uh() {
    if (N === null) {
        var s = M.alternate;
        s = s !== null ? s.memoizedState : null
    } else
        s = N.next;
    var e = O === null ? M.memoizedState : O.next;
    if (e !== null)
        O = e,
        N = s;
    else {
        if (s === null)
            throw Error(p$1(310));
        N = s,
        s = {
            memoizedState: N.memoizedState,
            baseState: N.baseState,
            baseQueue: N.baseQueue,
            queue: N.queue,
            next: null
        },
        O === null ? M.memoizedState = O = s : O = O.next = s
    }
    return O
}
function Vh(s, e) {
    return typeof e == "function" ? e(s) : e
}
function Wh(s) {
    var e = Uh()
      , a = e.queue;
    if (a === null)
        throw Error(p$1(311));
    a.lastRenderedReducer = s;
    var o = N
      , c = o.baseQueue
      , d = a.pending;
    if (d !== null) {
        if (c !== null) {
            var g = c.next;
            c.next = d.next,
            d.next = g
        }
        o.baseQueue = c = d,
        a.pending = null
    }
    if (c !== null) {
        d = c.next,
        o = o.baseState;
        var _ = g = null
          , b = null
          , j = d;
        do {
            var $ = j.lane;
            if ((Hh & $) === $)
                b !== null && (b = b.next = {
                    lane: 0,
                    action: j.action,
                    hasEagerState: j.hasEagerState,
                    eagerState: j.eagerState,
                    next: null
                }),
                o = j.hasEagerState ? j.eagerState : s(o, j.action);
            else {
                var nt = {
                    lane: $,
                    action: j.action,
                    hasEagerState: j.hasEagerState,
                    eagerState: j.eagerState,
                    next: null
                };
                b === null ? (_ = b = nt,
                g = o) : b = b.next = nt,
                M.lanes |= $,
                rh |= $
            }
            j = j.next
        } while (j !== null && j !== d);
        b === null ? g = o : b.next = _,
        He(o, e.memoizedState) || (dh = !0),
        e.memoizedState = o,
        e.baseState = g,
        e.baseQueue = b,
        a.lastRenderedState = o
    }
    if (s = a.interleaved,
    s !== null) {
        c = s;
        do
            d = c.lane,
            M.lanes |= d,
            rh |= d,
            c = c.next;
        while (c !== s)
    } else
        c === null && (a.lanes = 0);
    return [e.memoizedState, a.dispatch]
}
function Xh(s) {
    var e = Uh()
      , a = e.queue;
    if (a === null)
        throw Error(p$1(311));
    a.lastRenderedReducer = s;
    var o = a.dispatch
      , c = a.pending
      , d = e.memoizedState;
    if (c !== null) {
        a.pending = null;
        var g = c = c.next;
        do
            d = s(d, g.action),
            g = g.next;
        while (g !== c);
        He(d, e.memoizedState) || (dh = !0),
        e.memoizedState = d,
        e.baseQueue === null && (e.baseState = d),
        a.lastRenderedState = d
    }
    return [d, o]
}
function Yh() {}
function Zh(s, e) {
    var a = M
      , o = Uh()
      , c = e()
      , d = !He(o.memoizedState, c);
    if (d && (o.memoizedState = c,
    dh = !0),
    o = o.queue,
    $h(ai.bind(null, a, o, s), [s]),
    o.getSnapshot !== e || d || O !== null && O.memoizedState.tag & 1) {
        if (a.flags |= 2048,
        bi(9, ci.bind(null, a, o, c, e), void 0, null),
        Q === null)
            throw Error(p$1(349));
        Hh & 30 || di(a, e, c)
    }
    return c
}
function di(s, e, a) {
    s.flags |= 16384,
    s = {
        getSnapshot: e,
        value: a
    },
    e = M.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    M.updateQueue = e,
    e.stores = [s]) : (a = e.stores,
    a === null ? e.stores = [s] : a.push(s))
}
function ci(s, e, a, o) {
    e.value = a,
    e.getSnapshot = o,
    ei(e) && fi(s)
}
function ai(s, e, a) {
    return a(function() {
        ei(e) && fi(s)
    })
}
function ei(s) {
    var e = s.getSnapshot;
    s = s.value;
    try {
        var a = e();
        return !He(s, a)
    } catch {
        return !0
    }
}
function fi(s) {
    var e = ih(s, 1);
    e !== null && gi(e, s, 1, -1)
}
function hi(s) {
    var e = Th();
    return typeof s == "function" && (s = s()),
    e.memoizedState = e.baseState = s,
    s = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Vh,
        lastRenderedState: s
    },
    e.queue = s,
    s = s.dispatch = ii.bind(null, M, s),
    [e.memoizedState, s]
}
function bi(s, e, a, o) {
    return s = {
        tag: s,
        create: e,
        destroy: a,
        deps: o,
        next: null
    },
    e = M.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    M.updateQueue = e,
    e.lastEffect = s.next = s) : (a = e.lastEffect,
    a === null ? e.lastEffect = s.next = s : (o = a.next,
    a.next = s,
    s.next = o,
    e.lastEffect = s)),
    s
}
function ji() {
    return Uh().memoizedState
}
function ki(s, e, a, o) {
    var c = Th();
    M.flags |= s,
    c.memoizedState = bi(1 | e, a, void 0, o === void 0 ? null : o)
}
function li(s, e, a, o) {
    var c = Uh();
    o = o === void 0 ? null : o;
    var d = void 0;
    if (N !== null) {
        var g = N.memoizedState;
        if (d = g.destroy,
        o !== null && Mh(o, g.deps)) {
            c.memoizedState = bi(e, a, d, o);
            return
        }
    }
    M.flags |= s,
    c.memoizedState = bi(1 | e, a, d, o)
}
function mi(s, e) {
    return ki(8390656, 8, s, e)
}
function $h(s, e) {
    return li(2048, 8, s, e)
}
function ni(s, e) {
    return li(4, 2, s, e)
}
function oi(s, e) {
    return li(4, 4, s, e)
}
function pi(s, e) {
    if (typeof e == "function")
        return s = s(),
        e(s),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return s = s(),
        e.current = s,
        function() {
            e.current = null
        }
}
function qi(s, e, a) {
    return a = a != null ? a.concat([s]) : null,
    li(4, 4, pi.bind(null, e, s), a)
}
function ri() {}
function si(s, e) {
    var a = Uh();
    e = e === void 0 ? null : e;
    var o = a.memoizedState;
    return o !== null && e !== null && Mh(e, o[1]) ? o[0] : (a.memoizedState = [s, e],
    s)
}
function ti(s, e) {
    var a = Uh();
    e = e === void 0 ? null : e;
    var o = a.memoizedState;
    return o !== null && e !== null && Mh(e, o[1]) ? o[0] : (s = s(),
    a.memoizedState = [s, e],
    s)
}
function ui(s, e, a) {
    return Hh & 21 ? (He(a, e) || (a = yc(),
    M.lanes |= a,
    rh |= a,
    s.baseState = !0),
    e) : (s.baseState && (s.baseState = !1,
    dh = !0),
    s.memoizedState = a)
}
function vi(s, e) {
    var a = C;
    C = a !== 0 && 4 > a ? a : 4,
    s(!0);
    var o = Gh.transition;
    Gh.transition = {};
    try {
        s(!1),
        e()
    } finally {
        C = a,
        Gh.transition = o
    }
}
function wi() {
    return Uh().memoizedState
}
function xi(s, e, a) {
    var o = yi(s);
    if (a = {
        lane: o,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    zi(s))
        Ai(e, a);
    else if (a = hh(s, e, a, o),
    a !== null) {
        var c = R();
        gi(a, s, o, c),
        Bi(a, e, o)
    }
}
function ii(s, e, a) {
    var o = yi(s)
      , c = {
        lane: o,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (zi(s))
        Ai(e, c);
    else {
        var d = s.alternate;
        if (s.lanes === 0 && (d === null || d.lanes === 0) && (d = e.lastRenderedReducer,
        d !== null))
            try {
                var g = e.lastRenderedState
                  , _ = d(g, a);
                if (c.hasEagerState = !0,
                c.eagerState = _,
                He(_, g)) {
                    var b = e.interleaved;
                    b === null ? (c.next = c,
                    gh(e)) : (c.next = b.next,
                    b.next = c),
                    e.interleaved = c;
                    return
                }
            } catch {} finally {}
        a = hh(s, e, c, o),
        a !== null && (c = R(),
        gi(a, s, o, c),
        Bi(a, e, o))
    }
}
function zi(s) {
    var e = s.alternate;
    return s === M || e !== null && e === M
}
function Ai(s, e) {
    Jh = Ih = !0;
    var a = s.pending;
    a === null ? e.next = e : (e.next = a.next,
    a.next = e),
    s.pending = e
}
function Bi(s, e, a) {
    if (a & 4194240) {
        var o = e.lanes;
        o &= s.pendingLanes,
        a |= o,
        e.lanes = a,
        Cc(s, a)
    }
}
var Rh = {
    readContext: eh,
    useCallback: P,
    useContext: P,
    useEffect: P,
    useImperativeHandle: P,
    useInsertionEffect: P,
    useLayoutEffect: P,
    useMemo: P,
    useReducer: P,
    useRef: P,
    useState: P,
    useDebugValue: P,
    useDeferredValue: P,
    useTransition: P,
    useMutableSource: P,
    useSyncExternalStore: P,
    useId: P,
    unstable_isNewReconciler: !1
}
  , Oh = {
    readContext: eh,
    useCallback: function(s, e) {
        return Th().memoizedState = [s, e === void 0 ? null : e],
        s
    },
    useContext: eh,
    useEffect: mi,
    useImperativeHandle: function(s, e, a) {
        return a = a != null ? a.concat([s]) : null,
        ki(4194308, 4, pi.bind(null, e, s), a)
    },
    useLayoutEffect: function(s, e) {
        return ki(4194308, 4, s, e)
    },
    useInsertionEffect: function(s, e) {
        return ki(4, 2, s, e)
    },
    useMemo: function(s, e) {
        var a = Th();
        return e = e === void 0 ? null : e,
        s = s(),
        a.memoizedState = [s, e],
        s
    },
    useReducer: function(s, e, a) {
        var o = Th();
        return e = a !== void 0 ? a(e) : e,
        o.memoizedState = o.baseState = e,
        s = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: s,
            lastRenderedState: e
        },
        o.queue = s,
        s = s.dispatch = xi.bind(null, M, s),
        [o.memoizedState, s]
    },
    useRef: function(s) {
        var e = Th();
        return s = {
            current: s
        },
        e.memoizedState = s
    },
    useState: hi,
    useDebugValue: ri,
    useDeferredValue: function(s) {
        return Th().memoizedState = s
    },
    useTransition: function() {
        var s = hi(!1)
          , e = s[0];
        return s = vi.bind(null, s[1]),
        Th().memoizedState = s,
        [e, s]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(s, e, a) {
        var o = M
          , c = Th();
        if (I) {
            if (a === void 0)
                throw Error(p$1(407));
            a = a()
        } else {
            if (a = e(),
            Q === null)
                throw Error(p$1(349));
            Hh & 30 || di(o, e, a)
        }
        c.memoizedState = a;
        var d = {
            value: a,
            getSnapshot: e
        };
        return c.queue = d,
        mi(ai.bind(null, o, d, s), [s]),
        o.flags |= 2048,
        bi(9, ci.bind(null, o, d, a, e), void 0, null),
        a
    },
    useId: function() {
        var s = Th()
          , e = Q.identifierPrefix;
        if (I) {
            var a = sg
              , o = rg;
            a = (o & ~(1 << 32 - oc(o) - 1)).toString(32) + a,
            e = ":" + e + "R" + a,
            a = Kh++,
            0 < a && (e += "H" + a.toString(32)),
            e += ":"
        } else
            a = Lh++,
            e = ":" + e + "r" + a.toString(32) + ":";
        return s.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
        return Wh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(s) {
        var e = Uh();
        return ui(e, N.memoizedState, s)
    },
    useTransition: function() {
        var s = Wh(Vh)[0]
          , e = Uh().memoizedState;
        return [s, e]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
}
  , Qh = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Xh,
    useRef: ji,
    useState: function() {
        return Xh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(s) {
        var e = Uh();
        return N === null ? e.memoizedState = s : ui(e, N.memoizedState, s)
    },
    useTransition: function() {
        var s = Xh(Vh)[0]
          , e = Uh().memoizedState;
        return [s, e]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
};
function Ci(s, e) {
    if (s && s.defaultProps) {
        e = A({}, e),
        s = s.defaultProps;
        for (var a in s)
            e[a] === void 0 && (e[a] = s[a]);
        return e
    }
    return e
}
function Di(s, e, a, o) {
    e = s.memoizedState,
    a = a(o, e),
    a = a == null ? e : A({}, e, a),
    s.memoizedState = a,
    s.lanes === 0 && (s.updateQueue.baseState = a)
}
var Ei = {
    isMounted: function(s) {
        return (s = s._reactInternals) ? Vb(s) === s : !1
    },
    enqueueSetState: function(s, e, a) {
        s = s._reactInternals;
        var o = R()
          , c = yi(s)
          , d = mh(o, c);
        d.payload = e,
        a != null && (d.callback = a),
        e = nh(s, d, c),
        e !== null && (gi(e, s, c, o),
        oh(e, s, c))
    },
    enqueueReplaceState: function(s, e, a) {
        s = s._reactInternals;
        var o = R()
          , c = yi(s)
          , d = mh(o, c);
        d.tag = 1,
        d.payload = e,
        a != null && (d.callback = a),
        e = nh(s, d, c),
        e !== null && (gi(e, s, c, o),
        oh(e, s, c))
    },
    enqueueForceUpdate: function(s, e) {
        s = s._reactInternals;
        var a = R()
          , o = yi(s)
          , c = mh(a, o);
        c.tag = 2,
        e != null && (c.callback = e),
        e = nh(s, c, o),
        e !== null && (gi(e, s, o, a),
        oh(e, s, o))
    }
};
function Fi(s, e, a, o, c, d, g) {
    return s = s.stateNode,
    typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(o, d, g) : e.prototype && e.prototype.isPureReactComponent ? !Ie(a, o) || !Ie(c, d) : !0
}
function Gi(s, e, a) {
    var o = !1
      , c = Vf
      , d = e.contextType;
    return typeof d == "object" && d !== null ? d = eh(d) : (c = Zf(e) ? Xf : H.current,
    o = e.contextTypes,
    d = (o = o != null) ? Yf(s, c) : Vf),
    e = new e(a,d),
    s.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Ei,
    s.stateNode = e,
    e._reactInternals = s,
    o && (s = s.stateNode,
    s.__reactInternalMemoizedUnmaskedChildContext = c,
    s.__reactInternalMemoizedMaskedChildContext = d),
    e
}
function Hi(s, e, a, o) {
    s = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(a, o),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(a, o),
    e.state !== s && Ei.enqueueReplaceState(e, e.state, null)
}
function Ii(s, e, a, o) {
    var c = s.stateNode;
    c.props = a,
    c.state = s.memoizedState,
    c.refs = {},
    kh(s);
    var d = e.contextType;
    typeof d == "object" && d !== null ? c.context = eh(d) : (d = Zf(e) ? Xf : H.current,
    c.context = Yf(s, d)),
    c.state = s.memoizedState,
    d = e.getDerivedStateFromProps,
    typeof d == "function" && (Di(s, e, d, a),
    c.state = s.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof c.getSnapshotBeforeUpdate == "function" || typeof c.UNSAFE_componentWillMount != "function" && typeof c.componentWillMount != "function" || (e = c.state,
    typeof c.componentWillMount == "function" && c.componentWillMount(),
    typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(),
    e !== c.state && Ei.enqueueReplaceState(c, c.state, null),
    qh(s, a, c, o),
    c.state = s.memoizedState),
    typeof c.componentDidMount == "function" && (s.flags |= 4194308)
}
function Ji(s, e) {
    try {
        var a = ""
          , o = e;
        do
            a += Pa(o),
            o = o.return;
        while (o);
        var c = a
    } catch (d) {
        c = `
Error generating stack: ` + d.message + `
` + d.stack
    }
    return {
        value: s,
        source: e,
        stack: c,
        digest: null
    }
}
function Ki(s, e, a) {
    return {
        value: s,
        source: null,
        stack: a ?? null,
        digest: e ?? null
    }
}
function Li(s, e) {
    try {
        console.error(e.value)
    } catch (a) {
        setTimeout(function() {
            throw a
        })
    }
}
var Mi = typeof WeakMap == "function" ? WeakMap : Map;
function Ni(s, e, a) {
    a = mh(-1, a),
    a.tag = 3,
    a.payload = {
        element: null
    };
    var o = e.value;
    return a.callback = function() {
        Oi || (Oi = !0,
        Pi = o),
        Li(s, e)
    }
    ,
    a
}
function Qi(s, e, a) {
    a = mh(-1, a),
    a.tag = 3;
    var o = s.type.getDerivedStateFromError;
    if (typeof o == "function") {
        var c = e.value;
        a.payload = function() {
            return o(c)
        }
        ,
        a.callback = function() {
            Li(s, e)
        }
    }
    var d = s.stateNode;
    return d !== null && typeof d.componentDidCatch == "function" && (a.callback = function() {
        Li(s, e),
        typeof o != "function" && (Ri === null ? Ri = new Set([this]) : Ri.add(this));
        var g = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: g !== null ? g : ""
        })
    }
    ),
    a
}
function Si(s, e, a) {
    var o = s.pingCache;
    if (o === null) {
        o = s.pingCache = new Mi;
        var c = new Set;
        o.set(e, c)
    } else
        c = o.get(e),
        c === void 0 && (c = new Set,
        o.set(e, c));
    c.has(a) || (c.add(a),
    s = Ti.bind(null, s, e, a),
    e.then(s, s))
}
function Ui(s) {
    do {
        var e;
        if ((e = s.tag === 13) && (e = s.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return s;
        s = s.return
    } while (s !== null);
    return null
}
function Vi(s, e, a, o, c) {
    return s.mode & 1 ? (s.flags |= 65536,
    s.lanes = c,
    s) : (s === e ? s.flags |= 65536 : (s.flags |= 128,
    a.flags |= 131072,
    a.flags &= -52805,
    a.tag === 1 && (a.alternate === null ? a.tag = 17 : (e = mh(-1, 1),
    e.tag = 2,
    nh(a, e, 1))),
    a.lanes |= 1),
    s)
}
var Wi = ua.ReactCurrentOwner
  , dh = !1;
function Xi(s, e, a, o) {
    e.child = s === null ? Vg(e, null, a, o) : Ug(e, s.child, a, o)
}
function Yi(s, e, a, o, c) {
    a = a.render;
    var d = e.ref;
    return ch(e, c),
    o = Nh(s, e, a, o, d, c),
    a = Sh(),
    s !== null && !dh ? (e.updateQueue = s.updateQueue,
    e.flags &= -2053,
    s.lanes &= ~c,
    Zi(s, e, c)) : (I && a && vg(e),
    e.flags |= 1,
    Xi(s, e, o, c),
    e.child)
}
function $i(s, e, a, o, c) {
    if (s === null) {
        var d = a.type;
        return typeof d == "function" && !aj(d) && d.defaultProps === void 0 && a.compare === null && a.defaultProps === void 0 ? (e.tag = 15,
        e.type = d,
        bj(s, e, d, o, c)) : (s = Rg(a.type, null, o, e, e.mode, c),
        s.ref = e.ref,
        s.return = e,
        e.child = s)
    }
    if (d = s.child,
    !(s.lanes & c)) {
        var g = d.memoizedProps;
        if (a = a.compare,
        a = a !== null ? a : Ie,
        a(g, o) && s.ref === e.ref)
            return Zi(s, e, c)
    }
    return e.flags |= 1,
    s = Pg(d, o),
    s.ref = e.ref,
    s.return = e,
    e.child = s
}
function bj(s, e, a, o, c) {
    if (s !== null) {
        var d = s.memoizedProps;
        if (Ie(d, o) && s.ref === e.ref)
            if (dh = !1,
            e.pendingProps = o = d,
            (s.lanes & c) !== 0)
                s.flags & 131072 && (dh = !0);
            else
                return e.lanes = s.lanes,
                Zi(s, e, c)
    }
    return cj(s, e, a, o, c)
}
function dj(s, e, a) {
    var o = e.pendingProps
      , c = o.children
      , d = s !== null ? s.memoizedState : null;
    if (o.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G(ej, fj),
            fj |= a;
        else {
            if (!(a & 1073741824))
                return s = d !== null ? d.baseLanes | a : a,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: s,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                G(ej, fj),
                fj |= s,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            o = d !== null ? d.baseLanes : a,
            G(ej, fj),
            fj |= o
        }
    else
        d !== null ? (o = d.baseLanes | a,
        e.memoizedState = null) : o = a,
        G(ej, fj),
        fj |= o;
    return Xi(s, e, c, a),
    e.child
}
function gj(s, e) {
    var a = e.ref;
    (s === null && a !== null || s !== null && s.ref !== a) && (e.flags |= 512,
    e.flags |= 2097152)
}
function cj(s, e, a, o, c) {
    var d = Zf(a) ? Xf : H.current;
    return d = Yf(e, d),
    ch(e, c),
    a = Nh(s, e, a, o, d, c),
    o = Sh(),
    s !== null && !dh ? (e.updateQueue = s.updateQueue,
    e.flags &= -2053,
    s.lanes &= ~c,
    Zi(s, e, c)) : (I && o && vg(e),
    e.flags |= 1,
    Xi(s, e, a, c),
    e.child)
}
function hj(s, e, a, o, c) {
    if (Zf(a)) {
        var d = !0;
        cg(e)
    } else
        d = !1;
    if (ch(e, c),
    e.stateNode === null)
        ij(s, e),
        Gi(e, a, o),
        Ii(e, a, o, c),
        o = !0;
    else if (s === null) {
        var g = e.stateNode
          , _ = e.memoizedProps;
        g.props = _;
        var b = g.context
          , j = a.contextType;
        typeof j == "object" && j !== null ? j = eh(j) : (j = Zf(a) ? Xf : H.current,
        j = Yf(e, j));
        var $ = a.getDerivedStateFromProps
          , nt = typeof $ == "function" || typeof g.getSnapshotBeforeUpdate == "function";
        nt || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (_ !== o || b !== j) && Hi(e, g, o, j),
        jh = !1;
        var tt = e.memoizedState;
        g.state = tt,
        qh(e, o, g, c),
        b = e.memoizedState,
        _ !== o || tt !== b || Wf.current || jh ? (typeof $ == "function" && (Di(e, a, $, o),
        b = e.memoizedState),
        (_ = jh || Fi(e, a, _, o, tt, b, j)) ? (nt || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(),
        typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()),
        typeof g.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = o,
        e.memoizedState = b),
        g.props = o,
        g.state = b,
        g.context = j,
        o = _) : (typeof g.componentDidMount == "function" && (e.flags |= 4194308),
        o = !1)
    } else {
        g = e.stateNode,
        lh(s, e),
        _ = e.memoizedProps,
        j = e.type === e.elementType ? _ : Ci(e.type, _),
        g.props = j,
        nt = e.pendingProps,
        tt = g.context,
        b = a.contextType,
        typeof b == "object" && b !== null ? b = eh(b) : (b = Zf(a) ? Xf : H.current,
        b = Yf(e, b));
        var rt = a.getDerivedStateFromProps;
        ($ = typeof rt == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (_ !== nt || tt !== b) && Hi(e, g, o, b),
        jh = !1,
        tt = e.memoizedState,
        g.state = tt,
        qh(e, o, g, c);
        var st = e.memoizedState;
        _ !== nt || tt !== st || Wf.current || jh ? (typeof rt == "function" && (Di(e, a, rt, o),
        st = e.memoizedState),
        (j = jh || Fi(e, a, j, o, tt, st, b) || !1) ? ($ || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(o, st, b),
        typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(o, st, b)),
        typeof g.componentDidUpdate == "function" && (e.flags |= 4),
        typeof g.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || _ === s.memoizedProps && tt === s.memoizedState || (e.flags |= 4),
        typeof g.getSnapshotBeforeUpdate != "function" || _ === s.memoizedProps && tt === s.memoizedState || (e.flags |= 1024),
        e.memoizedProps = o,
        e.memoizedState = st),
        g.props = o,
        g.state = st,
        g.context = b,
        o = j) : (typeof g.componentDidUpdate != "function" || _ === s.memoizedProps && tt === s.memoizedState || (e.flags |= 4),
        typeof g.getSnapshotBeforeUpdate != "function" || _ === s.memoizedProps && tt === s.memoizedState || (e.flags |= 1024),
        o = !1)
    }
    return jj(s, e, a, o, d, c)
}
function jj(s, e, a, o, c, d) {
    gj(s, e);
    var g = (e.flags & 128) !== 0;
    if (!o && !g)
        return c && dg(e, a, !1),
        Zi(s, e, d);
    o = e.stateNode,
    Wi.current = e;
    var _ = g && typeof a.getDerivedStateFromError != "function" ? null : o.render();
    return e.flags |= 1,
    s !== null && g ? (e.child = Ug(e, s.child, null, d),
    e.child = Ug(e, null, _, d)) : Xi(s, e, _, d),
    e.memoizedState = o.state,
    c && dg(e, a, !0),
    e.child
}
function kj(s) {
    var e = s.stateNode;
    e.pendingContext ? ag(s, e.pendingContext, e.pendingContext !== e.context) : e.context && ag(s, e.context, !1),
    yh(s, e.containerInfo)
}
function lj(s, e, a, o, c) {
    return Ig(),
    Jg(c),
    e.flags |= 256,
    Xi(s, e, a, o),
    e.child
}
var mj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function nj(s) {
    return {
        baseLanes: s,
        cachePool: null,
        transitions: null
    }
}
function oj(s, e, a) {
    var o = e.pendingProps, c = L.current, d = !1, g = (e.flags & 128) !== 0, _;
    if ((_ = g) || (_ = s !== null && s.memoizedState === null ? !1 : (c & 2) !== 0),
    _ ? (d = !0,
    e.flags &= -129) : (s === null || s.memoizedState !== null) && (c |= 1),
    G(L, c & 1),
    s === null)
        return Eg(e),
        s = e.memoizedState,
        s !== null && (s = s.dehydrated,
        s !== null) ? (e.mode & 1 ? s.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (g = o.children,
        s = o.fallback,
        d ? (o = e.mode,
        d = e.child,
        g = {
            mode: "hidden",
            children: g
        },
        !(o & 1) && d !== null ? (d.childLanes = 0,
        d.pendingProps = g) : d = pj(g, o, 0, null),
        s = Tg(s, o, a, null),
        d.return = e,
        s.return = e,
        d.sibling = s,
        e.child = d,
        e.child.memoizedState = nj(a),
        e.memoizedState = mj,
        s) : qj(e, g));
    if (c = s.memoizedState,
    c !== null && (_ = c.dehydrated,
    _ !== null))
        return rj(s, e, g, o, _, c, a);
    if (d) {
        d = o.fallback,
        g = e.mode,
        c = s.child,
        _ = c.sibling;
        var b = {
            mode: "hidden",
            children: o.children
        };
        return !(g & 1) && e.child !== c ? (o = e.child,
        o.childLanes = 0,
        o.pendingProps = b,
        e.deletions = null) : (o = Pg(c, b),
        o.subtreeFlags = c.subtreeFlags & 14680064),
        _ !== null ? d = Pg(_, d) : (d = Tg(d, g, a, null),
        d.flags |= 2),
        d.return = e,
        o.return = e,
        o.sibling = d,
        e.child = o,
        o = d,
        d = e.child,
        g = s.child.memoizedState,
        g = g === null ? nj(a) : {
            baseLanes: g.baseLanes | a,
            cachePool: null,
            transitions: g.transitions
        },
        d.memoizedState = g,
        d.childLanes = s.childLanes & ~a,
        e.memoizedState = mj,
        o
    }
    return d = s.child,
    s = d.sibling,
    o = Pg(d, {
        mode: "visible",
        children: o.children
    }),
    !(e.mode & 1) && (o.lanes = a),
    o.return = e,
    o.sibling = null,
    s !== null && (a = e.deletions,
    a === null ? (e.deletions = [s],
    e.flags |= 16) : a.push(s)),
    e.child = o,
    e.memoizedState = null,
    o
}
function qj(s, e) {
    return e = pj({
        mode: "visible",
        children: e
    }, s.mode, 0, null),
    e.return = s,
    s.child = e
}
function sj(s, e, a, o) {
    return o !== null && Jg(o),
    Ug(e, s.child, null, a),
    s = qj(e, e.pendingProps.children),
    s.flags |= 2,
    e.memoizedState = null,
    s
}
function rj(s, e, a, o, c, d, g) {
    if (a)
        return e.flags & 256 ? (e.flags &= -257,
        o = Ki(Error(p$1(422))),
        sj(s, e, g, o)) : e.memoizedState !== null ? (e.child = s.child,
        e.flags |= 128,
        null) : (d = o.fallback,
        c = e.mode,
        o = pj({
            mode: "visible",
            children: o.children
        }, c, 0, null),
        d = Tg(d, c, g, null),
        d.flags |= 2,
        o.return = e,
        d.return = e,
        o.sibling = d,
        e.child = o,
        e.mode & 1 && Ug(e, s.child, null, g),
        e.child.memoizedState = nj(g),
        e.memoizedState = mj,
        d);
    if (!(e.mode & 1))
        return sj(s, e, g, null);
    if (c.data === "$!") {
        if (o = c.nextSibling && c.nextSibling.dataset,
        o)
            var _ = o.dgst;
        return o = _,
        d = Error(p$1(419)),
        o = Ki(d, o, void 0),
        sj(s, e, g, o)
    }
    if (_ = (g & s.childLanes) !== 0,
    dh || _) {
        if (o = Q,
        o !== null) {
            switch (g & -g) {
            case 4:
                c = 2;
                break;
            case 16:
                c = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                c = 32;
                break;
            case 536870912:
                c = 268435456;
                break;
            default:
                c = 0
            }
            c = c & (o.suspendedLanes | g) ? 0 : c,
            c !== 0 && c !== d.retryLane && (d.retryLane = c,
            ih(s, c),
            gi(o, s, c, -1))
        }
        return tj(),
        o = Ki(Error(p$1(421))),
        sj(s, e, g, o)
    }
    return c.data === "$?" ? (e.flags |= 128,
    e.child = s.child,
    e = uj.bind(null, s),
    c._reactRetry = e,
    null) : (s = d.treeContext,
    yg = Lf(c.nextSibling),
    xg = e,
    I = !0,
    zg = null,
    s !== null && (og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    rg = s.id,
    sg = s.overflow,
    qg = e),
    e = qj(e, o.children),
    e.flags |= 4096,
    e)
}
function vj(s, e, a) {
    s.lanes |= e;
    var o = s.alternate;
    o !== null && (o.lanes |= e),
    bh(s.return, e, a)
}
function wj(s, e, a, o, c) {
    var d = s.memoizedState;
    d === null ? s.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: o,
        tail: a,
        tailMode: c
    } : (d.isBackwards = e,
    d.rendering = null,
    d.renderingStartTime = 0,
    d.last = o,
    d.tail = a,
    d.tailMode = c)
}
function xj(s, e, a) {
    var o = e.pendingProps
      , c = o.revealOrder
      , d = o.tail;
    if (Xi(s, e, o.children, a),
    o = L.current,
    o & 2)
        o = o & 1 | 2,
        e.flags |= 128;
    else {
        if (s !== null && s.flags & 128)
            e: for (s = e.child; s !== null; ) {
                if (s.tag === 13)
                    s.memoizedState !== null && vj(s, a, e);
                else if (s.tag === 19)
                    vj(s, a, e);
                else if (s.child !== null) {
                    s.child.return = s,
                    s = s.child;
                    continue
                }
                if (s === e)
                    break e;
                for (; s.sibling === null; ) {
                    if (s.return === null || s.return === e)
                        break e;
                    s = s.return
                }
                s.sibling.return = s.return,
                s = s.sibling
            }
        o &= 1
    }
    if (G(L, o),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (c) {
        case "forwards":
            for (a = e.child,
            c = null; a !== null; )
                s = a.alternate,
                s !== null && Ch(s) === null && (c = a),
                a = a.sibling;
            a = c,
            a === null ? (c = e.child,
            e.child = null) : (c = a.sibling,
            a.sibling = null),
            wj(e, !1, c, a, d);
            break;
        case "backwards":
            for (a = null,
            c = e.child,
            e.child = null; c !== null; ) {
                if (s = c.alternate,
                s !== null && Ch(s) === null) {
                    e.child = c;
                    break
                }
                s = c.sibling,
                c.sibling = a,
                a = c,
                c = s
            }
            wj(e, !0, a, null, d);
            break;
        case "together":
            wj(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function ij(s, e) {
    !(e.mode & 1) && s !== null && (s.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function Zi(s, e, a) {
    if (s !== null && (e.dependencies = s.dependencies),
    rh |= e.lanes,
    !(a & e.childLanes))
        return null;
    if (s !== null && e.child !== s.child)
        throw Error(p$1(153));
    if (e.child !== null) {
        for (s = e.child,
        a = Pg(s, s.pendingProps),
        e.child = a,
        a.return = e; s.sibling !== null; )
            s = s.sibling,
            a = a.sibling = Pg(s, s.pendingProps),
            a.return = e;
        a.sibling = null
    }
    return e.child
}
function yj(s, e, a) {
    switch (e.tag) {
    case 3:
        kj(e),
        Ig();
        break;
    case 5:
        Ah(e);
        break;
    case 1:
        Zf(e.type) && cg(e);
        break;
    case 4:
        yh(e, e.stateNode.containerInfo);
        break;
    case 10:
        var o = e.type._context
          , c = e.memoizedProps.value;
        G(Wg, o._currentValue),
        o._currentValue = c;
        break;
    case 13:
        if (o = e.memoizedState,
        o !== null)
            return o.dehydrated !== null ? (G(L, L.current & 1),
            e.flags |= 128,
            null) : a & e.child.childLanes ? oj(s, e, a) : (G(L, L.current & 1),
            s = Zi(s, e, a),
            s !== null ? s.sibling : null);
        G(L, L.current & 1);
        break;
    case 19:
        if (o = (a & e.childLanes) !== 0,
        s.flags & 128) {
            if (o)
                return xj(s, e, a);
            e.flags |= 128
        }
        if (c = e.memoizedState,
        c !== null && (c.rendering = null,
        c.tail = null,
        c.lastEffect = null),
        G(L, L.current),
        o)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        dj(s, e, a)
    }
    return Zi(s, e, a)
}
var zj, Aj, Bj, Cj;
zj = function(s, e) {
    for (var a = e.child; a !== null; ) {
        if (a.tag === 5 || a.tag === 6)
            s.appendChild(a.stateNode);
        else if (a.tag !== 4 && a.child !== null) {
            a.child.return = a,
            a = a.child;
            continue
        }
        if (a === e)
            break;
        for (; a.sibling === null; ) {
            if (a.return === null || a.return === e)
                return;
            a = a.return
        }
        a.sibling.return = a.return,
        a = a.sibling
    }
}
;
Aj = function() {}
;
Bj = function(s, e, a, o) {
    var c = s.memoizedProps;
    if (c !== o) {
        s = e.stateNode,
        xh(uh.current);
        var d = null;
        switch (a) {
        case "input":
            c = Ya(s, c),
            o = Ya(s, o),
            d = [];
            break;
        case "select":
            c = A({}, c, {
                value: void 0
            }),
            o = A({}, o, {
                value: void 0
            }),
            d = [];
            break;
        case "textarea":
            c = gb(s, c),
            o = gb(s, o),
            d = [];
            break;
        default:
            typeof c.onClick != "function" && typeof o.onClick == "function" && (s.onclick = Bf)
        }
        ub(a, o);
        var g;
        a = null;
        for (j in c)
            if (!o.hasOwnProperty(j) && c.hasOwnProperty(j) && c[j] != null)
                if (j === "style") {
                    var _ = c[j];
                    for (g in _)
                        _.hasOwnProperty(g) && (a || (a = {}),
                        a[g] = "")
                } else
                    j !== "dangerouslySetInnerHTML" && j !== "children" && j !== "suppressContentEditableWarning" && j !== "suppressHydrationWarning" && j !== "autoFocus" && (ea.hasOwnProperty(j) ? d || (d = []) : (d = d || []).push(j, null));
        for (j in o) {
            var b = o[j];
            if (_ = c != null ? c[j] : void 0,
            o.hasOwnProperty(j) && b !== _ && (b != null || _ != null))
                if (j === "style")
                    if (_) {
                        for (g in _)
                            !_.hasOwnProperty(g) || b && b.hasOwnProperty(g) || (a || (a = {}),
                            a[g] = "");
                        for (g in b)
                            b.hasOwnProperty(g) && _[g] !== b[g] && (a || (a = {}),
                            a[g] = b[g])
                    } else
                        a || (d || (d = []),
                        d.push(j, a)),
                        a = b;
                else
                    j === "dangerouslySetInnerHTML" ? (b = b ? b.__html : void 0,
                    _ = _ ? _.__html : void 0,
                    b != null && _ !== b && (d = d || []).push(j, b)) : j === "children" ? typeof b != "string" && typeof b != "number" || (d = d || []).push(j, "" + b) : j !== "suppressContentEditableWarning" && j !== "suppressHydrationWarning" && (ea.hasOwnProperty(j) ? (b != null && j === "onScroll" && D("scroll", s),
                    d || _ === b || (d = [])) : (d = d || []).push(j, b))
        }
        a && (d = d || []).push("style", a);
        var j = d;
        (e.updateQueue = j) && (e.flags |= 4)
    }
}
;
Cj = function(s, e, a, o) {
    a !== o && (e.flags |= 4)
}
;
function Dj(s, e) {
    if (!I)
        switch (s.tailMode) {
        case "hidden":
            e = s.tail;
            for (var a = null; e !== null; )
                e.alternate !== null && (a = e),
                e = e.sibling;
            a === null ? s.tail = null : a.sibling = null;
            break;
        case "collapsed":
            a = s.tail;
            for (var o = null; a !== null; )
                a.alternate !== null && (o = a),
                a = a.sibling;
            o === null ? e || s.tail === null ? s.tail = null : s.tail.sibling = null : o.sibling = null
        }
}
function S(s) {
    var e = s.alternate !== null && s.alternate.child === s.child
      , a = 0
      , o = 0;
    if (e)
        for (var c = s.child; c !== null; )
            a |= c.lanes | c.childLanes,
            o |= c.subtreeFlags & 14680064,
            o |= c.flags & 14680064,
            c.return = s,
            c = c.sibling;
    else
        for (c = s.child; c !== null; )
            a |= c.lanes | c.childLanes,
            o |= c.subtreeFlags,
            o |= c.flags,
            c.return = s,
            c = c.sibling;
    return s.subtreeFlags |= o,
    s.childLanes = a,
    e
}
function Ej(s, e, a) {
    var o = e.pendingProps;
    switch (wg(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return S(e),
        null;
    case 1:
        return Zf(e.type) && $f(),
        S(e),
        null;
    case 3:
        return o = e.stateNode,
        zh(),
        E(Wf),
        E(H),
        Eh(),
        o.pendingContext && (o.context = o.pendingContext,
        o.pendingContext = null),
        (s === null || s.child === null) && (Gg(e) ? e.flags |= 4 : s === null || s.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        zg !== null && (Fj(zg),
        zg = null))),
        Aj(s, e),
        S(e),
        null;
    case 5:
        Bh(e);
        var c = xh(wh.current);
        if (a = e.type,
        s !== null && e.stateNode != null)
            Bj(s, e, a, o, c),
            s.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!o) {
                if (e.stateNode === null)
                    throw Error(p$1(166));
                return S(e),
                null
            }
            if (s = xh(uh.current),
            Gg(e)) {
                o = e.stateNode,
                a = e.type;
                var d = e.memoizedProps;
                switch (o[Of] = e,
                o[Pf] = d,
                s = (e.mode & 1) !== 0,
                a) {
                case "dialog":
                    D("cancel", o),
                    D("close", o);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D("load", o);
                    break;
                case "video":
                case "audio":
                    for (c = 0; c < lf.length; c++)
                        D(lf[c], o);
                    break;
                case "source":
                    D("error", o);
                    break;
                case "img":
                case "image":
                case "link":
                    D("error", o),
                    D("load", o);
                    break;
                case "details":
                    D("toggle", o);
                    break;
                case "input":
                    Za(o, d),
                    D("invalid", o);
                    break;
                case "select":
                    o._wrapperState = {
                        wasMultiple: !!d.multiple
                    },
                    D("invalid", o);
                    break;
                case "textarea":
                    hb(o, d),
                    D("invalid", o)
                }
                ub(a, d),
                c = null;
                for (var g in d)
                    if (d.hasOwnProperty(g)) {
                        var _ = d[g];
                        g === "children" ? typeof _ == "string" ? o.textContent !== _ && (d.suppressHydrationWarning !== !0 && Af(o.textContent, _, s),
                        c = ["children", _]) : typeof _ == "number" && o.textContent !== "" + _ && (d.suppressHydrationWarning !== !0 && Af(o.textContent, _, s),
                        c = ["children", "" + _]) : ea.hasOwnProperty(g) && _ != null && g === "onScroll" && D("scroll", o)
                    }
                switch (a) {
                case "input":
                    Va(o),
                    db(o, d, !0);
                    break;
                case "textarea":
                    Va(o),
                    jb(o);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof d.onClick == "function" && (o.onclick = Bf)
                }
                o = c,
                e.updateQueue = o,
                o !== null && (e.flags |= 4)
            } else {
                g = c.nodeType === 9 ? c : c.ownerDocument,
                s === "http://www.w3.org/1999/xhtml" && (s = kb(a)),
                s === "http://www.w3.org/1999/xhtml" ? a === "script" ? (s = g.createElement("div"),
                s.innerHTML = "<script><\/script>",
                s = s.removeChild(s.firstChild)) : typeof o.is == "string" ? s = g.createElement(a, {
                    is: o.is
                }) : (s = g.createElement(a),
                a === "select" && (g = s,
                o.multiple ? g.multiple = !0 : o.size && (g.size = o.size))) : s = g.createElementNS(s, a),
                s[Of] = e,
                s[Pf] = o,
                zj(s, e, !1, !1),
                e.stateNode = s;
                e: {
                    switch (g = vb(a, o),
                    a) {
                    case "dialog":
                        D("cancel", s),
                        D("close", s),
                        c = o;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D("load", s),
                        c = o;
                        break;
                    case "video":
                    case "audio":
                        for (c = 0; c < lf.length; c++)
                            D(lf[c], s);
                        c = o;
                        break;
                    case "source":
                        D("error", s),
                        c = o;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D("error", s),
                        D("load", s),
                        c = o;
                        break;
                    case "details":
                        D("toggle", s),
                        c = o;
                        break;
                    case "input":
                        Za(s, o),
                        c = Ya(s, o),
                        D("invalid", s);
                        break;
                    case "option":
                        c = o;
                        break;
                    case "select":
                        s._wrapperState = {
                            wasMultiple: !!o.multiple
                        },
                        c = A({}, o, {
                            value: void 0
                        }),
                        D("invalid", s);
                        break;
                    case "textarea":
                        hb(s, o),
                        c = gb(s, o),
                        D("invalid", s);
                        break;
                    default:
                        c = o
                    }
                    ub(a, c),
                    _ = c;
                    for (d in _)
                        if (_.hasOwnProperty(d)) {
                            var b = _[d];
                            d === "style" ? sb(s, b) : d === "dangerouslySetInnerHTML" ? (b = b ? b.__html : void 0,
                            b != null && nb(s, b)) : d === "children" ? typeof b == "string" ? (a !== "textarea" || b !== "") && ob(s, b) : typeof b == "number" && ob(s, "" + b) : d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && d !== "autoFocus" && (ea.hasOwnProperty(d) ? b != null && d === "onScroll" && D("scroll", s) : b != null && ta(s, d, b, g))
                        }
                    switch (a) {
                    case "input":
                        Va(s),
                        db(s, o, !1);
                        break;
                    case "textarea":
                        Va(s),
                        jb(s);
                        break;
                    case "option":
                        o.value != null && s.setAttribute("value", "" + Sa(o.value));
                        break;
                    case "select":
                        s.multiple = !!o.multiple,
                        d = o.value,
                        d != null ? fb(s, !!o.multiple, d, !1) : o.defaultValue != null && fb(s, !!o.multiple, o.defaultValue, !0);
                        break;
                    default:
                        typeof c.onClick == "function" && (s.onclick = Bf)
                    }
                    switch (a) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        o = !!o.autoFocus;
                        break e;
                    case "img":
                        o = !0;
                        break e;
                    default:
                        o = !1
                    }
                }
                o && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return S(e),
        null;
    case 6:
        if (s && e.stateNode != null)
            Cj(s, e, s.memoizedProps, o);
        else {
            if (typeof o != "string" && e.stateNode === null)
                throw Error(p$1(166));
            if (a = xh(wh.current),
            xh(uh.current),
            Gg(e)) {
                if (o = e.stateNode,
                a = e.memoizedProps,
                o[Of] = e,
                (d = o.nodeValue !== a) && (s = xg,
                s !== null))
                    switch (s.tag) {
                    case 3:
                        Af(o.nodeValue, a, (s.mode & 1) !== 0);
                        break;
                    case 5:
                        s.memoizedProps.suppressHydrationWarning !== !0 && Af(o.nodeValue, a, (s.mode & 1) !== 0)
                    }
                d && (e.flags |= 4)
            } else
                o = (a.nodeType === 9 ? a : a.ownerDocument).createTextNode(o),
                o[Of] = e,
                e.stateNode = o
        }
        return S(e),
        null;
    case 13:
        if (E(L),
        o = e.memoizedState,
        s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
            if (I && yg !== null && e.mode & 1 && !(e.flags & 128))
                Hg(),
                Ig(),
                e.flags |= 98560,
                d = !1;
            else if (d = Gg(e),
            o !== null && o.dehydrated !== null) {
                if (s === null) {
                    if (!d)
                        throw Error(p$1(318));
                    if (d = e.memoizedState,
                    d = d !== null ? d.dehydrated : null,
                    !d)
                        throw Error(p$1(317));
                    d[Of] = e
                } else
                    Ig(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                S(e),
                d = !1
            } else
                zg !== null && (Fj(zg),
                zg = null),
                d = !0;
            if (!d)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = a,
        e) : (o = o !== null,
        o !== (s !== null && s.memoizedState !== null) && o && (e.child.flags |= 8192,
        e.mode & 1 && (s === null || L.current & 1 ? T === 0 && (T = 3) : tj())),
        e.updateQueue !== null && (e.flags |= 4),
        S(e),
        null);
    case 4:
        return zh(),
        Aj(s, e),
        s === null && sf(e.stateNode.containerInfo),
        S(e),
        null;
    case 10:
        return ah(e.type._context),
        S(e),
        null;
    case 17:
        return Zf(e.type) && $f(),
        S(e),
        null;
    case 19:
        if (E(L),
        d = e.memoizedState,
        d === null)
            return S(e),
            null;
        if (o = (e.flags & 128) !== 0,
        g = d.rendering,
        g === null)
            if (o)
                Dj(d, !1);
            else {
                if (T !== 0 || s !== null && s.flags & 128)
                    for (s = e.child; s !== null; ) {
                        if (g = Ch(s),
                        g !== null) {
                            for (e.flags |= 128,
                            Dj(d, !1),
                            o = g.updateQueue,
                            o !== null && (e.updateQueue = o,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            o = a,
                            a = e.child; a !== null; )
                                d = a,
                                s = o,
                                d.flags &= 14680066,
                                g = d.alternate,
                                g === null ? (d.childLanes = 0,
                                d.lanes = s,
                                d.child = null,
                                d.subtreeFlags = 0,
                                d.memoizedProps = null,
                                d.memoizedState = null,
                                d.updateQueue = null,
                                d.dependencies = null,
                                d.stateNode = null) : (d.childLanes = g.childLanes,
                                d.lanes = g.lanes,
                                d.child = g.child,
                                d.subtreeFlags = 0,
                                d.deletions = null,
                                d.memoizedProps = g.memoizedProps,
                                d.memoizedState = g.memoizedState,
                                d.updateQueue = g.updateQueue,
                                d.type = g.type,
                                s = g.dependencies,
                                d.dependencies = s === null ? null : {
                                    lanes: s.lanes,
                                    firstContext: s.firstContext
                                }),
                                a = a.sibling;
                            return G(L, L.current & 1 | 2),
                            e.child
                        }
                        s = s.sibling
                    }
                d.tail !== null && B() > Gj && (e.flags |= 128,
                o = !0,
                Dj(d, !1),
                e.lanes = 4194304)
            }
        else {
            if (!o)
                if (s = Ch(g),
                s !== null) {
                    if (e.flags |= 128,
                    o = !0,
                    a = s.updateQueue,
                    a !== null && (e.updateQueue = a,
                    e.flags |= 4),
                    Dj(d, !0),
                    d.tail === null && d.tailMode === "hidden" && !g.alternate && !I)
                        return S(e),
                        null
                } else
                    2 * B() - d.renderingStartTime > Gj && a !== 1073741824 && (e.flags |= 128,
                    o = !0,
                    Dj(d, !1),
                    e.lanes = 4194304);
            d.isBackwards ? (g.sibling = e.child,
            e.child = g) : (a = d.last,
            a !== null ? a.sibling = g : e.child = g,
            d.last = g)
        }
        return d.tail !== null ? (e = d.tail,
        d.rendering = e,
        d.tail = e.sibling,
        d.renderingStartTime = B(),
        e.sibling = null,
        a = L.current,
        G(L, o ? a & 1 | 2 : a & 1),
        e) : (S(e),
        null);
    case 22:
    case 23:
        return Hj(),
        o = e.memoizedState !== null,
        s !== null && s.memoizedState !== null !== o && (e.flags |= 8192),
        o && e.mode & 1 ? fj & 1073741824 && (S(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : S(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p$1(156, e.tag))
}
function Ij(s, e) {
    switch (wg(e),
    e.tag) {
    case 1:
        return Zf(e.type) && $f(),
        s = e.flags,
        s & 65536 ? (e.flags = s & -65537 | 128,
        e) : null;
    case 3:
        return zh(),
        E(Wf),
        E(H),
        Eh(),
        s = e.flags,
        s & 65536 && !(s & 128) ? (e.flags = s & -65537 | 128,
        e) : null;
    case 5:
        return Bh(e),
        null;
    case 13:
        if (E(L),
        s = e.memoizedState,
        s !== null && s.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(p$1(340));
            Ig()
        }
        return s = e.flags,
        s & 65536 ? (e.flags = s & -65537 | 128,
        e) : null;
    case 19:
        return E(L),
        null;
    case 4:
        return zh(),
        null;
    case 10:
        return ah(e.type._context),
        null;
    case 22:
    case 23:
        return Hj(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Jj = !1
  , U = !1
  , Kj = typeof WeakSet == "function" ? WeakSet : Set
  , V = null;
function Lj(s, e) {
    var a = s.ref;
    if (a !== null)
        if (typeof a == "function")
            try {
                a(null)
            } catch (o) {
                W(s, e, o)
            }
        else
            a.current = null
}
function Mj(s, e, a) {
    try {
        a()
    } catch (o) {
        W(s, e, o)
    }
}
var Nj = !1;
function Oj(s, e) {
    if (Cf = dd,
    s = Me(),
    Ne(s)) {
        if ("selectionStart"in s)
            var a = {
                start: s.selectionStart,
                end: s.selectionEnd
            };
        else
            e: {
                a = (a = s.ownerDocument) && a.defaultView || window;
                var o = a.getSelection && a.getSelection();
                if (o && o.rangeCount !== 0) {
                    a = o.anchorNode;
                    var c = o.anchorOffset
                      , d = o.focusNode;
                    o = o.focusOffset;
                    try {
                        a.nodeType,
                        d.nodeType
                    } catch {
                        a = null;
                        break e
                    }
                    var g = 0
                      , _ = -1
                      , b = -1
                      , j = 0
                      , $ = 0
                      , nt = s
                      , tt = null;
                    t: for (; ; ) {
                        for (var rt; nt !== a || c !== 0 && nt.nodeType !== 3 || (_ = g + c),
                        nt !== d || o !== 0 && nt.nodeType !== 3 || (b = g + o),
                        nt.nodeType === 3 && (g += nt.nodeValue.length),
                        (rt = nt.firstChild) !== null; )
                            tt = nt,
                            nt = rt;
                        for (; ; ) {
                            if (nt === s)
                                break t;
                            if (tt === a && ++j === c && (_ = g),
                            tt === d && ++$ === o && (b = g),
                            (rt = nt.nextSibling) !== null)
                                break;
                            nt = tt,
                            tt = nt.parentNode
                        }
                        nt = rt
                    }
                    a = _ === -1 || b === -1 ? null : {
                        start: _,
                        end: b
                    }
                } else
                    a = null
            }
        a = a || {
            start: 0,
            end: 0
        }
    } else
        a = null;
    for (Df = {
        focusedElem: s,
        selectionRange: a
    },
    dd = !1,
    V = e; V !== null; )
        if (e = V,
        s = e.child,
        (e.subtreeFlags & 1028) !== 0 && s !== null)
            s.return = e,
            V = s;
        else
            for (; V !== null; ) {
                e = V;
                try {
                    var st = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (st !== null) {
                                var lt = st.memoizedProps
                                  , ct = st.memoizedState
                                  , it = e.stateNode
                                  , ot = it.getSnapshotBeforeUpdate(e.elementType === e.type ? lt : Ci(e.type, lt), ct);
                                it.__reactInternalSnapshotBeforeUpdate = ot
                            }
                            break;
                        case 3:
                            var at = e.stateNode.containerInfo;
                            at.nodeType === 1 ? at.textContent = "" : at.nodeType === 9 && at.documentElement && at.removeChild(at.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$1(163))
                        }
                } catch (ht) {
                    W(e, e.return, ht)
                }
                if (s = e.sibling,
                s !== null) {
                    s.return = e.return,
                    V = s;
                    break
                }
                V = e.return
            }
    return st = Nj,
    Nj = !1,
    st
}
function Pj(s, e, a) {
    var o = e.updateQueue;
    if (o = o !== null ? o.lastEffect : null,
    o !== null) {
        var c = o = o.next;
        do {
            if ((c.tag & s) === s) {
                var d = c.destroy;
                c.destroy = void 0,
                d !== void 0 && Mj(e, a, d)
            }
            c = c.next
        } while (c !== o)
    }
}
function Qj(s, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var a = e = e.next;
        do {
            if ((a.tag & s) === s) {
                var o = a.create;
                a.destroy = o()
            }
            a = a.next
        } while (a !== e)
    }
}
function Rj(s) {
    var e = s.ref;
    if (e !== null) {
        var a = s.stateNode;
        switch (s.tag) {
        case 5:
            s = a;
            break;
        default:
            s = a
        }
        typeof e == "function" ? e(s) : e.current = s
    }
}
function Sj(s) {
    var e = s.alternate;
    e !== null && (s.alternate = null,
    Sj(e)),
    s.child = null,
    s.deletions = null,
    s.sibling = null,
    s.tag === 5 && (e = s.stateNode,
    e !== null && (delete e[Of],
    delete e[Pf],
    delete e[of],
    delete e[Qf],
    delete e[Rf])),
    s.stateNode = null,
    s.return = null,
    s.dependencies = null,
    s.memoizedProps = null,
    s.memoizedState = null,
    s.pendingProps = null,
    s.stateNode = null,
    s.updateQueue = null
}
function Tj(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4
}
function Uj(s) {
    e: for (; ; ) {
        for (; s.sibling === null; ) {
            if (s.return === null || Tj(s.return))
                return null;
            s = s.return
        }
        for (s.sibling.return = s.return,
        s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
            if (s.flags & 2 || s.child === null || s.tag === 4)
                continue e;
            s.child.return = s,
            s = s.child
        }
        if (!(s.flags & 2))
            return s.stateNode
    }
}
function Vj(s, e, a) {
    var o = s.tag;
    if (o === 5 || o === 6)
        s = s.stateNode,
        e ? a.nodeType === 8 ? a.parentNode.insertBefore(s, e) : a.insertBefore(s, e) : (a.nodeType === 8 ? (e = a.parentNode,
        e.insertBefore(s, a)) : (e = a,
        e.appendChild(s)),
        a = a._reactRootContainer,
        a != null || e.onclick !== null || (e.onclick = Bf));
    else if (o !== 4 && (s = s.child,
    s !== null))
        for (Vj(s, e, a),
        s = s.sibling; s !== null; )
            Vj(s, e, a),
            s = s.sibling
}
function Wj(s, e, a) {
    var o = s.tag;
    if (o === 5 || o === 6)
        s = s.stateNode,
        e ? a.insertBefore(s, e) : a.appendChild(s);
    else if (o !== 4 && (s = s.child,
    s !== null))
        for (Wj(s, e, a),
        s = s.sibling; s !== null; )
            Wj(s, e, a),
            s = s.sibling
}
var X = null
  , Xj = !1;
function Yj(s, e, a) {
    for (a = a.child; a !== null; )
        Zj(s, e, a),
        a = a.sibling
}
function Zj(s, e, a) {
    if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
            lc.onCommitFiberUnmount(kc, a)
        } catch {}
    switch (a.tag) {
    case 5:
        U || Lj(a, e);
    case 6:
        var o = X
          , c = Xj;
        X = null,
        Yj(s, e, a),
        X = o,
        Xj = c,
        X !== null && (Xj ? (s = X,
        a = a.stateNode,
        s.nodeType === 8 ? s.parentNode.removeChild(a) : s.removeChild(a)) : X.removeChild(a.stateNode));
        break;
    case 18:
        X !== null && (Xj ? (s = X,
        a = a.stateNode,
        s.nodeType === 8 ? Kf(s.parentNode, a) : s.nodeType === 1 && Kf(s, a),
        bd(s)) : Kf(X, a.stateNode));
        break;
    case 4:
        o = X,
        c = Xj,
        X = a.stateNode.containerInfo,
        Xj = !0,
        Yj(s, e, a),
        X = o,
        Xj = c;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!U && (o = a.updateQueue,
        o !== null && (o = o.lastEffect,
        o !== null))) {
            c = o = o.next;
            do {
                var d = c
                  , g = d.destroy;
                d = d.tag,
                g !== void 0 && (d & 2 || d & 4) && Mj(a, e, g),
                c = c.next
            } while (c !== o)
        }
        Yj(s, e, a);
        break;
    case 1:
        if (!U && (Lj(a, e),
        o = a.stateNode,
        typeof o.componentWillUnmount == "function"))
            try {
                o.props = a.memoizedProps,
                o.state = a.memoizedState,
                o.componentWillUnmount()
            } catch (_) {
                W(a, e, _)
            }
        Yj(s, e, a);
        break;
    case 21:
        Yj(s, e, a);
        break;
    case 22:
        a.mode & 1 ? (U = (o = U) || a.memoizedState !== null,
        Yj(s, e, a),
        U = o) : Yj(s, e, a);
        break;
    default:
        Yj(s, e, a)
    }
}
function ak(s) {
    var e = s.updateQueue;
    if (e !== null) {
        s.updateQueue = null;
        var a = s.stateNode;
        a === null && (a = s.stateNode = new Kj),
        e.forEach(function(o) {
            var c = bk.bind(null, s, o);
            a.has(o) || (a.add(o),
            o.then(c, c))
        })
    }
}
function ck(s, e) {
    var a = e.deletions;
    if (a !== null)
        for (var o = 0; o < a.length; o++) {
            var c = a[o];
            try {
                var d = s
                  , g = e
                  , _ = g;
                e: for (; _ !== null; ) {
                    switch (_.tag) {
                    case 5:
                        X = _.stateNode,
                        Xj = !1;
                        break e;
                    case 3:
                        X = _.stateNode.containerInfo,
                        Xj = !0;
                        break e;
                    case 4:
                        X = _.stateNode.containerInfo,
                        Xj = !0;
                        break e
                    }
                    _ = _.return
                }
                if (X === null)
                    throw Error(p$1(160));
                Zj(d, g, c),
                X = null,
                Xj = !1;
                var b = c.alternate;
                b !== null && (b.return = null),
                c.return = null
            } catch (j) {
                W(c, e, j)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            dk(e, s),
            e = e.sibling
}
function dk(s, e) {
    var a = s.alternate
      , o = s.flags;
    switch (s.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (ck(e, s),
        ek(s),
        o & 4) {
            try {
                Pj(3, s, s.return),
                Qj(3, s)
            } catch (lt) {
                W(s, s.return, lt)
            }
            try {
                Pj(5, s, s.return)
            } catch (lt) {
                W(s, s.return, lt)
            }
        }
        break;
    case 1:
        ck(e, s),
        ek(s),
        o & 512 && a !== null && Lj(a, a.return);
        break;
    case 5:
        if (ck(e, s),
        ek(s),
        o & 512 && a !== null && Lj(a, a.return),
        s.flags & 32) {
            var c = s.stateNode;
            try {
                ob(c, "")
            } catch (lt) {
                W(s, s.return, lt)
            }
        }
        if (o & 4 && (c = s.stateNode,
        c != null)) {
            var d = s.memoizedProps
              , g = a !== null ? a.memoizedProps : d
              , _ = s.type
              , b = s.updateQueue;
            if (s.updateQueue = null,
            b !== null)
                try {
                    _ === "input" && d.type === "radio" && d.name != null && ab(c, d),
                    vb(_, g);
                    var j = vb(_, d);
                    for (g = 0; g < b.length; g += 2) {
                        var $ = b[g]
                          , nt = b[g + 1];
                        $ === "style" ? sb(c, nt) : $ === "dangerouslySetInnerHTML" ? nb(c, nt) : $ === "children" ? ob(c, nt) : ta(c, $, nt, j)
                    }
                    switch (_) {
                    case "input":
                        bb(c, d);
                        break;
                    case "textarea":
                        ib(c, d);
                        break;
                    case "select":
                        var tt = c._wrapperState.wasMultiple;
                        c._wrapperState.wasMultiple = !!d.multiple;
                        var rt = d.value;
                        rt != null ? fb(c, !!d.multiple, rt, !1) : tt !== !!d.multiple && (d.defaultValue != null ? fb(c, !!d.multiple, d.defaultValue, !0) : fb(c, !!d.multiple, d.multiple ? [] : "", !1))
                    }
                    c[Pf] = d
                } catch (lt) {
                    W(s, s.return, lt)
                }
        }
        break;
    case 6:
        if (ck(e, s),
        ek(s),
        o & 4) {
            if (s.stateNode === null)
                throw Error(p$1(162));
            c = s.stateNode,
            d = s.memoizedProps;
            try {
                c.nodeValue = d
            } catch (lt) {
                W(s, s.return, lt)
            }
        }
        break;
    case 3:
        if (ck(e, s),
        ek(s),
        o & 4 && a !== null && a.memoizedState.isDehydrated)
            try {
                bd(e.containerInfo)
            } catch (lt) {
                W(s, s.return, lt)
            }
        break;
    case 4:
        ck(e, s),
        ek(s);
        break;
    case 13:
        ck(e, s),
        ek(s),
        c = s.child,
        c.flags & 8192 && (d = c.memoizedState !== null,
        c.stateNode.isHidden = d,
        !d || c.alternate !== null && c.alternate.memoizedState !== null || (fk = B())),
        o & 4 && ak(s);
        break;
    case 22:
        if ($ = a !== null && a.memoizedState !== null,
        s.mode & 1 ? (U = (j = U) || $,
        ck(e, s),
        U = j) : ck(e, s),
        ek(s),
        o & 8192) {
            if (j = s.memoizedState !== null,
            (s.stateNode.isHidden = j) && !$ && s.mode & 1)
                for (V = s,
                $ = s.child; $ !== null; ) {
                    for (nt = V = $; V !== null; ) {
                        switch (tt = V,
                        rt = tt.child,
                        tt.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Pj(4, tt, tt.return);
                            break;
                        case 1:
                            Lj(tt, tt.return);
                            var st = tt.stateNode;
                            if (typeof st.componentWillUnmount == "function") {
                                o = tt,
                                a = tt.return;
                                try {
                                    e = o,
                                    st.props = e.memoizedProps,
                                    st.state = e.memoizedState,
                                    st.componentWillUnmount()
                                } catch (lt) {
                                    W(o, a, lt)
                                }
                            }
                            break;
                        case 5:
                            Lj(tt, tt.return);
                            break;
                        case 22:
                            if (tt.memoizedState !== null) {
                                gk(nt);
                                continue
                            }
                        }
                        rt !== null ? (rt.return = tt,
                        V = rt) : gk(nt)
                    }
                    $ = $.sibling
                }
            e: for ($ = null,
            nt = s; ; ) {
                if (nt.tag === 5) {
                    if ($ === null) {
                        $ = nt;
                        try {
                            c = nt.stateNode,
                            j ? (d = c.style,
                            typeof d.setProperty == "function" ? d.setProperty("display", "none", "important") : d.display = "none") : (_ = nt.stateNode,
                            b = nt.memoizedProps.style,
                            g = b != null && b.hasOwnProperty("display") ? b.display : null,
                            _.style.display = rb("display", g))
                        } catch (lt) {
                            W(s, s.return, lt)
                        }
                    }
                } else if (nt.tag === 6) {
                    if ($ === null)
                        try {
                            nt.stateNode.nodeValue = j ? "" : nt.memoizedProps
                        } catch (lt) {
                            W(s, s.return, lt)
                        }
                } else if ((nt.tag !== 22 && nt.tag !== 23 || nt.memoizedState === null || nt === s) && nt.child !== null) {
                    nt.child.return = nt,
                    nt = nt.child;
                    continue
                }
                if (nt === s)
                    break e;
                for (; nt.sibling === null; ) {
                    if (nt.return === null || nt.return === s)
                        break e;
                    $ === nt && ($ = null),
                    nt = nt.return
                }
                $ === nt && ($ = null),
                nt.sibling.return = nt.return,
                nt = nt.sibling
            }
        }
        break;
    case 19:
        ck(e, s),
        ek(s),
        o & 4 && ak(s);
        break;
    case 21:
        break;
    default:
        ck(e, s),
        ek(s)
    }
}
function ek(s) {
    var e = s.flags;
    if (e & 2) {
        try {
            e: {
                for (var a = s.return; a !== null; ) {
                    if (Tj(a)) {
                        var o = a;
                        break e
                    }
                    a = a.return
                }
                throw Error(p$1(160))
            }
            switch (o.tag) {
            case 5:
                var c = o.stateNode;
                o.flags & 32 && (ob(c, ""),
                o.flags &= -33);
                var d = Uj(s);
                Wj(s, d, c);
                break;
            case 3:
            case 4:
                var g = o.stateNode.containerInfo
                  , _ = Uj(s);
                Vj(s, _, g);
                break;
            default:
                throw Error(p$1(161))
            }
        } catch (b) {
            W(s, s.return, b)
        }
        s.flags &= -3
    }
    e & 4096 && (s.flags &= -4097)
}
function hk(s, e, a) {
    V = s,
    ik(s)
}
function ik(s, e, a) {
    for (var o = (s.mode & 1) !== 0; V !== null; ) {
        var c = V
          , d = c.child;
        if (c.tag === 22 && o) {
            var g = c.memoizedState !== null || Jj;
            if (!g) {
                var _ = c.alternate
                  , b = _ !== null && _.memoizedState !== null || U;
                _ = Jj;
                var j = U;
                if (Jj = g,
                (U = b) && !j)
                    for (V = c; V !== null; )
                        g = V,
                        b = g.child,
                        g.tag === 22 && g.memoizedState !== null ? jk(c) : b !== null ? (b.return = g,
                        V = b) : jk(c);
                for (; d !== null; )
                    V = d,
                    ik(d),
                    d = d.sibling;
                V = c,
                Jj = _,
                U = j
            }
            kk(s)
        } else
            c.subtreeFlags & 8772 && d !== null ? (d.return = c,
            V = d) : kk(s)
    }
}
function kk(s) {
    for (; V !== null; ) {
        var e = V;
        if (e.flags & 8772) {
            var a = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U || Qj(5, e);
                        break;
                    case 1:
                        var o = e.stateNode;
                        if (e.flags & 4 && !U)
                            if (a === null)
                                o.componentDidMount();
                            else {
                                var c = e.elementType === e.type ? a.memoizedProps : Ci(e.type, a.memoizedProps);
                                o.componentDidUpdate(c, a.memoizedState, o.__reactInternalSnapshotBeforeUpdate)
                            }
                        var d = e.updateQueue;
                        d !== null && sh(e, d, o);
                        break;
                    case 3:
                        var g = e.updateQueue;
                        if (g !== null) {
                            if (a = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    a = e.child.stateNode;
                                    break;
                                case 1:
                                    a = e.child.stateNode
                                }
                            sh(e, g, a)
                        }
                        break;
                    case 5:
                        var _ = e.stateNode;
                        if (a === null && e.flags & 4) {
                            a = _;
                            var b = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                b.autoFocus && a.focus();
                                break;
                            case "img":
                                b.src && (a.src = b.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var j = e.alternate;
                            if (j !== null) {
                                var $ = j.memoizedState;
                                if ($ !== null) {
                                    var nt = $.dehydrated;
                                    nt !== null && bd(nt)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p$1(163))
                    }
                U || e.flags & 512 && Rj(e)
            } catch (tt) {
                W(e, e.return, tt)
            }
        }
        if (e === s) {
            V = null;
            break
        }
        if (a = e.sibling,
        a !== null) {
            a.return = e.return,
            V = a;
            break
        }
        V = e.return
    }
}
function gk(s) {
    for (; V !== null; ) {
        var e = V;
        if (e === s) {
            V = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            V = a;
            break
        }
        V = e.return
    }
}
function jk(s) {
    for (; V !== null; ) {
        var e = V;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var a = e.return;
                try {
                    Qj(4, e)
                } catch (b) {
                    W(e, a, b)
                }
                break;
            case 1:
                var o = e.stateNode;
                if (typeof o.componentDidMount == "function") {
                    var c = e.return;
                    try {
                        o.componentDidMount()
                    } catch (b) {
                        W(e, c, b)
                    }
                }
                var d = e.return;
                try {
                    Rj(e)
                } catch (b) {
                    W(e, d, b)
                }
                break;
            case 5:
                var g = e.return;
                try {
                    Rj(e)
                } catch (b) {
                    W(e, g, b)
                }
            }
        } catch (b) {
            W(e, e.return, b)
        }
        if (e === s) {
            V = null;
            break
        }
        var _ = e.sibling;
        if (_ !== null) {
            _.return = e.return,
            V = _;
            break
        }
        V = e.return
    }
}
var lk = Math.ceil
  , mk = ua.ReactCurrentDispatcher
  , nk = ua.ReactCurrentOwner
  , ok = ua.ReactCurrentBatchConfig
  , K = 0
  , Q = null
  , Y = null
  , Z = 0
  , fj = 0
  , ej = Uf(0)
  , T = 0
  , pk = null
  , rh = 0
  , qk = 0
  , rk = 0
  , sk = null
  , tk = null
  , fk = 0
  , Gj = 1 / 0
  , uk = null
  , Oi = !1
  , Pi = null
  , Ri = null
  , vk = !1
  , wk = null
  , xk = 0
  , yk = 0
  , zk = null
  , Ak = -1
  , Bk = 0;
function R() {
    return K & 6 ? B() : Ak !== -1 ? Ak : Ak = B()
}
function yi(s) {
    return s.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Bk === 0 && (Bk = yc()),
    Bk) : (s = C,
    s !== 0 || (s = window.event,
    s = s === void 0 ? 16 : jd(s.type)),
    s) : 1
}
function gi(s, e, a, o) {
    if (50 < yk)
        throw yk = 0,
        zk = null,
        Error(p$1(185));
    Ac(s, a, o),
    (!(K & 2) || s !== Q) && (s === Q && (!(K & 2) && (qk |= a),
    T === 4 && Ck(s, Z)),
    Dk(s, o),
    a === 1 && K === 0 && !(e.mode & 1) && (Gj = B() + 500,
    fg && jg()))
}
function Dk(s, e) {
    var a = s.callbackNode;
    wc(s, e);
    var o = uc(s, s === Q ? Z : 0);
    if (o === 0)
        a !== null && bc(a),
        s.callbackNode = null,
        s.callbackPriority = 0;
    else if (e = o & -o,
    s.callbackPriority !== e) {
        if (a != null && bc(a),
        e === 1)
            s.tag === 0 ? ig(Ek.bind(null, s)) : hg(Ek.bind(null, s)),
            Jf(function() {
                !(K & 6) && jg()
            }),
            a = null;
        else {
            switch (Dc(o)) {
            case 1:
                a = fc;
                break;
            case 4:
                a = gc;
                break;
            case 16:
                a = hc;
                break;
            case 536870912:
                a = jc;
                break;
            default:
                a = hc
            }
            a = Fk(a, Gk.bind(null, s))
        }
        s.callbackPriority = e,
        s.callbackNode = a
    }
}
function Gk(s, e) {
    if (Ak = -1,
    Bk = 0,
    K & 6)
        throw Error(p$1(327));
    var a = s.callbackNode;
    if (Hk() && s.callbackNode !== a)
        return null;
    var o = uc(s, s === Q ? Z : 0);
    if (o === 0)
        return null;
    if (o & 30 || o & s.expiredLanes || e)
        e = Ik(s, o);
    else {
        e = o;
        var c = K;
        K |= 2;
        var d = Jk();
        (Q !== s || Z !== e) && (uk = null,
        Gj = B() + 500,
        Kk(s, e));
        do
            try {
                Lk();
                break
            } catch (_) {
                Mk(s, _)
            }
        while (!0);
        $g(),
        mk.current = d,
        K = c,
        Y !== null ? e = 0 : (Q = null,
        Z = 0,
        e = T)
    }
    if (e !== 0) {
        if (e === 2 && (c = xc(s),
        c !== 0 && (o = c,
        e = Nk(s, c))),
        e === 1)
            throw a = pk,
            Kk(s, 0),
            Ck(s, o),
            Dk(s, B()),
            a;
        if (e === 6)
            Ck(s, o);
        else {
            if (c = s.current.alternate,
            !(o & 30) && !Ok(c) && (e = Ik(s, o),
            e === 2 && (d = xc(s),
            d !== 0 && (o = d,
            e = Nk(s, d))),
            e === 1))
                throw a = pk,
                Kk(s, 0),
                Ck(s, o),
                Dk(s, B()),
                a;
            switch (s.finishedWork = c,
            s.finishedLanes = o,
            e) {
            case 0:
            case 1:
                throw Error(p$1(345));
            case 2:
                Pk(s, tk, uk);
                break;
            case 3:
                if (Ck(s, o),
                (o & 130023424) === o && (e = fk + 500 - B(),
                10 < e)) {
                    if (uc(s, 0) !== 0)
                        break;
                    if (c = s.suspendedLanes,
                    (c & o) !== o) {
                        R(),
                        s.pingedLanes |= s.suspendedLanes & c;
                        break
                    }
                    s.timeoutHandle = Ff(Pk.bind(null, s, tk, uk), e);
                    break
                }
                Pk(s, tk, uk);
                break;
            case 4:
                if (Ck(s, o),
                (o & 4194240) === o)
                    break;
                for (e = s.eventTimes,
                c = -1; 0 < o; ) {
                    var g = 31 - oc(o);
                    d = 1 << g,
                    g = e[g],
                    g > c && (c = g),
                    o &= ~d
                }
                if (o = c,
                o = B() - o,
                o = (120 > o ? 120 : 480 > o ? 480 : 1080 > o ? 1080 : 1920 > o ? 1920 : 3e3 > o ? 3e3 : 4320 > o ? 4320 : 1960 * lk(o / 1960)) - o,
                10 < o) {
                    s.timeoutHandle = Ff(Pk.bind(null, s, tk, uk), o);
                    break
                }
                Pk(s, tk, uk);
                break;
            case 5:
                Pk(s, tk, uk);
                break;
            default:
                throw Error(p$1(329))
            }
        }
    }
    return Dk(s, B()),
    s.callbackNode === a ? Gk.bind(null, s) : null
}
function Nk(s, e) {
    var a = sk;
    return s.current.memoizedState.isDehydrated && (Kk(s, e).flags |= 256),
    s = Ik(s, e),
    s !== 2 && (e = tk,
    tk = a,
    e !== null && Fj(e)),
    s
}
function Fj(s) {
    tk === null ? tk = s : tk.push.apply(tk, s)
}
function Ok(s) {
    for (var e = s; ; ) {
        if (e.flags & 16384) {
            var a = e.updateQueue;
            if (a !== null && (a = a.stores,
            a !== null))
                for (var o = 0; o < a.length; o++) {
                    var c = a[o]
                      , d = c.getSnapshot;
                    c = c.value;
                    try {
                        if (!He(d(), c))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (a = e.child,
        e.subtreeFlags & 16384 && a !== null)
            a.return = e,
            e = a;
        else {
            if (e === s)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === s)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function Ck(s, e) {
    for (e &= ~rk,
    e &= ~qk,
    s.suspendedLanes |= e,
    s.pingedLanes &= ~e,
    s = s.expirationTimes; 0 < e; ) {
        var a = 31 - oc(e)
          , o = 1 << a;
        s[a] = -1,
        e &= ~o
    }
}
function Ek(s) {
    if (K & 6)
        throw Error(p$1(327));
    Hk();
    var e = uc(s, 0);
    if (!(e & 1))
        return Dk(s, B()),
        null;
    var a = Ik(s, e);
    if (s.tag !== 0 && a === 2) {
        var o = xc(s);
        o !== 0 && (e = o,
        a = Nk(s, o))
    }
    if (a === 1)
        throw a = pk,
        Kk(s, 0),
        Ck(s, e),
        Dk(s, B()),
        a;
    if (a === 6)
        throw Error(p$1(345));
    return s.finishedWork = s.current.alternate,
    s.finishedLanes = e,
    Pk(s, tk, uk),
    Dk(s, B()),
    null
}
function Qk(s, e) {
    var a = K;
    K |= 1;
    try {
        return s(e)
    } finally {
        K = a,
        K === 0 && (Gj = B() + 500,
        fg && jg())
    }
}
function Rk(s) {
    wk !== null && wk.tag === 0 && !(K & 6) && Hk();
    var e = K;
    K |= 1;
    var a = ok.transition
      , o = C;
    try {
        if (ok.transition = null,
        C = 1,
        s)
            return s()
    } finally {
        C = o,
        ok.transition = a,
        K = e,
        !(K & 6) && jg()
    }
}
function Hj() {
    fj = ej.current,
    E(ej)
}
function Kk(s, e) {
    s.finishedWork = null,
    s.finishedLanes = 0;
    var a = s.timeoutHandle;
    if (a !== -1 && (s.timeoutHandle = -1,
    Gf(a)),
    Y !== null)
        for (a = Y.return; a !== null; ) {
            var o = a;
            switch (wg(o),
            o.tag) {
            case 1:
                o = o.type.childContextTypes,
                o != null && $f();
                break;
            case 3:
                zh(),
                E(Wf),
                E(H),
                Eh();
                break;
            case 5:
                Bh(o);
                break;
            case 4:
                zh();
                break;
            case 13:
                E(L);
                break;
            case 19:
                E(L);
                break;
            case 10:
                ah(o.type._context);
                break;
            case 22:
            case 23:
                Hj()
            }
            a = a.return
        }
    if (Q = s,
    Y = s = Pg(s.current, null),
    Z = fj = e,
    T = 0,
    pk = null,
    rk = qk = rh = 0,
    tk = sk = null,
    fh !== null) {
        for (e = 0; e < fh.length; e++)
            if (a = fh[e],
            o = a.interleaved,
            o !== null) {
                a.interleaved = null;
                var c = o.next
                  , d = a.pending;
                if (d !== null) {
                    var g = d.next;
                    d.next = c,
                    o.next = g
                }
                a.pending = o
            }
        fh = null
    }
    return s
}
function Mk(s, e) {
    do {
        var a = Y;
        try {
            if ($g(),
            Fh.current = Rh,
            Ih) {
                for (var o = M.memoizedState; o !== null; ) {
                    var c = o.queue;
                    c !== null && (c.pending = null),
                    o = o.next
                }
                Ih = !1
            }
            if (Hh = 0,
            O = N = M = null,
            Jh = !1,
            Kh = 0,
            nk.current = null,
            a === null || a.return === null) {
                T = 1,
                pk = e,
                Y = null;
                break
            }
            e: {
                var d = s
                  , g = a.return
                  , _ = a
                  , b = e;
                if (e = Z,
                _.flags |= 32768,
                b !== null && typeof b == "object" && typeof b.then == "function") {
                    var j = b
                      , $ = _
                      , nt = $.tag;
                    if (!($.mode & 1) && (nt === 0 || nt === 11 || nt === 15)) {
                        var tt = $.alternate;
                        tt ? ($.updateQueue = tt.updateQueue,
                        $.memoizedState = tt.memoizedState,
                        $.lanes = tt.lanes) : ($.updateQueue = null,
                        $.memoizedState = null)
                    }
                    var rt = Ui(g);
                    if (rt !== null) {
                        rt.flags &= -257,
                        Vi(rt, g, _, d, e),
                        rt.mode & 1 && Si(d, j, e),
                        e = rt,
                        b = j;
                        var st = e.updateQueue;
                        if (st === null) {
                            var lt = new Set;
                            lt.add(b),
                            e.updateQueue = lt
                        } else
                            st.add(b);
                        break e
                    } else {
                        if (!(e & 1)) {
                            Si(d, j, e),
                            tj();
                            break e
                        }
                        b = Error(p$1(426))
                    }
                } else if (I && _.mode & 1) {
                    var ct = Ui(g);
                    if (ct !== null) {
                        !(ct.flags & 65536) && (ct.flags |= 256),
                        Vi(ct, g, _, d, e),
                        Jg(Ji(b, _));
                        break e
                    }
                }
                d = b = Ji(b, _),
                T !== 4 && (T = 2),
                sk === null ? sk = [d] : sk.push(d),
                d = g;
                do {
                    switch (d.tag) {
                    case 3:
                        d.flags |= 65536,
                        e &= -e,
                        d.lanes |= e;
                        var it = Ni(d, b, e);
                        ph(d, it);
                        break e;
                    case 1:
                        _ = b;
                        var ot = d.type
                          , at = d.stateNode;
                        if (!(d.flags & 128) && (typeof ot.getDerivedStateFromError == "function" || at !== null && typeof at.componentDidCatch == "function" && (Ri === null || !Ri.has(at)))) {
                            d.flags |= 65536,
                            e &= -e,
                            d.lanes |= e;
                            var ht = Qi(d, _, e);
                            ph(d, ht);
                            break e
                        }
                    }
                    d = d.return
                } while (d !== null)
            }
            Sk(a)
        } catch (pt) {
            e = pt,
            Y === a && a !== null && (Y = a = a.return);
            continue
        }
        break
    } while (!0)
}
function Jk() {
    var s = mk.current;
    return mk.current = Rh,
    s === null ? Rh : s
}
function tj() {
    (T === 0 || T === 3 || T === 2) && (T = 4),
    Q === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q, Z)
}
function Ik(s, e) {
    var a = K;
    K |= 2;
    var o = Jk();
    (Q !== s || Z !== e) && (uk = null,
    Kk(s, e));
    do
        try {
            Tk();
            break
        } catch (c) {
            Mk(s, c)
        }
    while (!0);
    if ($g(),
    K = a,
    mk.current = o,
    Y !== null)
        throw Error(p$1(261));
    return Q = null,
    Z = 0,
    T
}
function Tk() {
    for (; Y !== null; )
        Uk(Y)
}
function Lk() {
    for (; Y !== null && !cc(); )
        Uk(Y)
}
function Uk(s) {
    var e = Vk(s.alternate, s, fj);
    s.memoizedProps = s.pendingProps,
    e === null ? Sk(s) : Y = e,
    nk.current = null
}
function Sk(s) {
    var e = s;
    do {
        var a = e.alternate;
        if (s = e.return,
        e.flags & 32768) {
            if (a = Ij(a, e),
            a !== null) {
                a.flags &= 32767,
                Y = a;
                return
            }
            if (s !== null)
                s.flags |= 32768,
                s.subtreeFlags = 0,
                s.deletions = null;
            else {
                T = 6,
                Y = null;
                return
            }
        } else if (a = Ej(a, e, fj),
        a !== null) {
            Y = a;
            return
        }
        if (e = e.sibling,
        e !== null) {
            Y = e;
            return
        }
        Y = e = s
    } while (e !== null);
    T === 0 && (T = 5)
}
function Pk(s, e, a) {
    var o = C
      , c = ok.transition;
    try {
        ok.transition = null,
        C = 1,
        Wk(s, e, a, o)
    } finally {
        ok.transition = c,
        C = o
    }
    return null
}
function Wk(s, e, a, o) {
    do
        Hk();
    while (wk !== null);
    if (K & 6)
        throw Error(p$1(327));
    a = s.finishedWork;
    var c = s.finishedLanes;
    if (a === null)
        return null;
    if (s.finishedWork = null,
    s.finishedLanes = 0,
    a === s.current)
        throw Error(p$1(177));
    s.callbackNode = null,
    s.callbackPriority = 0;
    var d = a.lanes | a.childLanes;
    if (Bc(s, d),
    s === Q && (Y = Q = null,
    Z = 0),
    !(a.subtreeFlags & 2064) && !(a.flags & 2064) || vk || (vk = !0,
    Fk(hc, function() {
        return Hk(),
        null
    })),
    d = (a.flags & 15990) !== 0,
    a.subtreeFlags & 15990 || d) {
        d = ok.transition,
        ok.transition = null;
        var g = C;
        C = 1;
        var _ = K;
        K |= 4,
        nk.current = null,
        Oj(s, a),
        dk(a, s),
        Oe(Df),
        dd = !!Cf,
        Df = Cf = null,
        s.current = a,
        hk(a),
        dc(),
        K = _,
        C = g,
        ok.transition = d
    } else
        s.current = a;
    if (vk && (vk = !1,
    wk = s,
    xk = c),
    d = s.pendingLanes,
    d === 0 && (Ri = null),
    mc(a.stateNode),
    Dk(s, B()),
    e !== null)
        for (o = s.onRecoverableError,
        a = 0; a < e.length; a++)
            c = e[a],
            o(c.value, {
                componentStack: c.stack,
                digest: c.digest
            });
    if (Oi)
        throw Oi = !1,
        s = Pi,
        Pi = null,
        s;
    return xk & 1 && s.tag !== 0 && Hk(),
    d = s.pendingLanes,
    d & 1 ? s === zk ? yk++ : (yk = 0,
    zk = s) : yk = 0,
    jg(),
    null
}
function Hk() {
    if (wk !== null) {
        var s = Dc(xk)
          , e = ok.transition
          , a = C;
        try {
            if (ok.transition = null,
            C = 16 > s ? 16 : s,
            wk === null)
                var o = !1;
            else {
                if (s = wk,
                wk = null,
                xk = 0,
                K & 6)
                    throw Error(p$1(331));
                var c = K;
                for (K |= 4,
                V = s.current; V !== null; ) {
                    var d = V
                      , g = d.child;
                    if (V.flags & 16) {
                        var _ = d.deletions;
                        if (_ !== null) {
                            for (var b = 0; b < _.length; b++) {
                                var j = _[b];
                                for (V = j; V !== null; ) {
                                    var $ = V;
                                    switch ($.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Pj(8, $, d)
                                    }
                                    var nt = $.child;
                                    if (nt !== null)
                                        nt.return = $,
                                        V = nt;
                                    else
                                        for (; V !== null; ) {
                                            $ = V;
                                            var tt = $.sibling
                                              , rt = $.return;
                                            if (Sj($),
                                            $ === j) {
                                                V = null;
                                                break
                                            }
                                            if (tt !== null) {
                                                tt.return = rt,
                                                V = tt;
                                                break
                                            }
                                            V = rt
                                        }
                                }
                            }
                            var st = d.alternate;
                            if (st !== null) {
                                var lt = st.child;
                                if (lt !== null) {
                                    st.child = null;
                                    do {
                                        var ct = lt.sibling;
                                        lt.sibling = null,
                                        lt = ct
                                    } while (lt !== null)
                                }
                            }
                            V = d
                        }
                    }
                    if (d.subtreeFlags & 2064 && g !== null)
                        g.return = d,
                        V = g;
                    else
                        e: for (; V !== null; ) {
                            if (d = V,
                            d.flags & 2048)
                                switch (d.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Pj(9, d, d.return)
                                }
                            var it = d.sibling;
                            if (it !== null) {
                                it.return = d.return,
                                V = it;
                                break e
                            }
                            V = d.return
                        }
                }
                var ot = s.current;
                for (V = ot; V !== null; ) {
                    g = V;
                    var at = g.child;
                    if (g.subtreeFlags & 2064 && at !== null)
                        at.return = g,
                        V = at;
                    else
                        e: for (g = ot; V !== null; ) {
                            if (_ = V,
                            _.flags & 2048)
                                try {
                                    switch (_.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(9, _)
                                    }
                                } catch (pt) {
                                    W(_, _.return, pt)
                                }
                            if (_ === g) {
                                V = null;
                                break e
                            }
                            var ht = _.sibling;
                            if (ht !== null) {
                                ht.return = _.return,
                                V = ht;
                                break e
                            }
                            V = _.return
                        }
                }
                if (K = c,
                jg(),
                lc && typeof lc.onPostCommitFiberRoot == "function")
                    try {
                        lc.onPostCommitFiberRoot(kc, s)
                    } catch {}
                o = !0
            }
            return o
        } finally {
            C = a,
            ok.transition = e
        }
    }
    return !1
}
function Xk(s, e, a) {
    e = Ji(a, e),
    e = Ni(s, e, 1),
    s = nh(s, e, 1),
    e = R(),
    s !== null && (Ac(s, 1, e),
    Dk(s, e))
}
function W(s, e, a) {
    if (s.tag === 3)
        Xk(s, s, a);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                Xk(e, s, a);
                break
            } else if (e.tag === 1) {
                var o = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof o.componentDidCatch == "function" && (Ri === null || !Ri.has(o))) {
                    s = Ji(a, s),
                    s = Qi(e, s, 1),
                    e = nh(e, s, 1),
                    s = R(),
                    e !== null && (Ac(e, 1, s),
                    Dk(e, s));
                    break
                }
            }
            e = e.return
        }
}
function Ti(s, e, a) {
    var o = s.pingCache;
    o !== null && o.delete(e),
    e = R(),
    s.pingedLanes |= s.suspendedLanes & a,
    Q === s && (Z & a) === a && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(s, 0) : rk |= a),
    Dk(s, e)
}
function Yk(s, e) {
    e === 0 && (s.mode & 1 ? (e = sc,
    sc <<= 1,
    !(sc & 130023424) && (sc = 4194304)) : e = 1);
    var a = R();
    s = ih(s, e),
    s !== null && (Ac(s, e, a),
    Dk(s, a))
}
function uj(s) {
    var e = s.memoizedState
      , a = 0;
    e !== null && (a = e.retryLane),
    Yk(s, a)
}
function bk(s, e) {
    var a = 0;
    switch (s.tag) {
    case 13:
        var o = s.stateNode
          , c = s.memoizedState;
        c !== null && (a = c.retryLane);
        break;
    case 19:
        o = s.stateNode;
        break;
    default:
        throw Error(p$1(314))
    }
    o !== null && o.delete(e),
    Yk(s, a)
}
var Vk;
Vk = function(s, e, a) {
    if (s !== null)
        if (s.memoizedProps !== e.pendingProps || Wf.current)
            dh = !0;
        else {
            if (!(s.lanes & a) && !(e.flags & 128))
                return dh = !1,
                yj(s, e, a);
            dh = !!(s.flags & 131072)
        }
    else
        dh = !1,
        I && e.flags & 1048576 && ug(e, ng, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var o = e.type;
        ij(s, e),
        s = e.pendingProps;
        var c = Yf(e, H.current);
        ch(e, a),
        c = Nh(null, e, o, s, c, a);
        var d = Sh();
        return e.flags |= 1,
        typeof c == "object" && c !== null && typeof c.render == "function" && c.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Zf(o) ? (d = !0,
        cg(e)) : d = !1,
        e.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null,
        kh(e),
        c.updater = Ei,
        e.stateNode = c,
        c._reactInternals = e,
        Ii(e, o, s, a),
        e = jj(null, e, o, !0, d, a)) : (e.tag = 0,
        I && d && vg(e),
        Xi(null, e, c, a),
        e = e.child),
        e;
    case 16:
        o = e.elementType;
        e: {
            switch (ij(s, e),
            s = e.pendingProps,
            c = o._init,
            o = c(o._payload),
            e.type = o,
            c = e.tag = Zk(o),
            s = Ci(o, s),
            c) {
            case 0:
                e = cj(null, e, o, s, a);
                break e;
            case 1:
                e = hj(null, e, o, s, a);
                break e;
            case 11:
                e = Yi(null, e, o, s, a);
                break e;
            case 14:
                e = $i(null, e, o, Ci(o.type, s), a);
                break e
            }
            throw Error(p$1(306, o, ""))
        }
        return e;
    case 0:
        return o = e.type,
        c = e.pendingProps,
        c = e.elementType === o ? c : Ci(o, c),
        cj(s, e, o, c, a);
    case 1:
        return o = e.type,
        c = e.pendingProps,
        c = e.elementType === o ? c : Ci(o, c),
        hj(s, e, o, c, a);
    case 3:
        e: {
            if (kj(e),
            s === null)
                throw Error(p$1(387));
            o = e.pendingProps,
            d = e.memoizedState,
            c = d.element,
            lh(s, e),
            qh(e, o, null, a);
            var g = e.memoizedState;
            if (o = g.element,
            d.isDehydrated)
                if (d = {
                    element: o,
                    isDehydrated: !1,
                    cache: g.cache,
                    pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                    transitions: g.transitions
                },
                e.updateQueue.baseState = d,
                e.memoizedState = d,
                e.flags & 256) {
                    c = Ji(Error(p$1(423)), e),
                    e = lj(s, e, o, a, c);
                    break e
                } else if (o !== c) {
                    c = Ji(Error(p$1(424)), e),
                    e = lj(s, e, o, a, c);
                    break e
                } else
                    for (yg = Lf(e.stateNode.containerInfo.firstChild),
                    xg = e,
                    I = !0,
                    zg = null,
                    a = Vg(e, null, o, a),
                    e.child = a; a; )
                        a.flags = a.flags & -3 | 4096,
                        a = a.sibling;
            else {
                if (Ig(),
                o === c) {
                    e = Zi(s, e, a);
                    break e
                }
                Xi(s, e, o, a)
            }
            e = e.child
        }
        return e;
    case 5:
        return Ah(e),
        s === null && Eg(e),
        o = e.type,
        c = e.pendingProps,
        d = s !== null ? s.memoizedProps : null,
        g = c.children,
        Ef(o, c) ? g = null : d !== null && Ef(o, d) && (e.flags |= 32),
        gj(s, e),
        Xi(s, e, g, a),
        e.child;
    case 6:
        return s === null && Eg(e),
        null;
    case 13:
        return oj(s, e, a);
    case 4:
        return yh(e, e.stateNode.containerInfo),
        o = e.pendingProps,
        s === null ? e.child = Ug(e, null, o, a) : Xi(s, e, o, a),
        e.child;
    case 11:
        return o = e.type,
        c = e.pendingProps,
        c = e.elementType === o ? c : Ci(o, c),
        Yi(s, e, o, c, a);
    case 7:
        return Xi(s, e, e.pendingProps, a),
        e.child;
    case 8:
        return Xi(s, e, e.pendingProps.children, a),
        e.child;
    case 12:
        return Xi(s, e, e.pendingProps.children, a),
        e.child;
    case 10:
        e: {
            if (o = e.type._context,
            c = e.pendingProps,
            d = e.memoizedProps,
            g = c.value,
            G(Wg, o._currentValue),
            o._currentValue = g,
            d !== null)
                if (He(d.value, g)) {
                    if (d.children === c.children && !Wf.current) {
                        e = Zi(s, e, a);
                        break e
                    }
                } else
                    for (d = e.child,
                    d !== null && (d.return = e); d !== null; ) {
                        var _ = d.dependencies;
                        if (_ !== null) {
                            g = d.child;
                            for (var b = _.firstContext; b !== null; ) {
                                if (b.context === o) {
                                    if (d.tag === 1) {
                                        b = mh(-1, a & -a),
                                        b.tag = 2;
                                        var j = d.updateQueue;
                                        if (j !== null) {
                                            j = j.shared;
                                            var $ = j.pending;
                                            $ === null ? b.next = b : (b.next = $.next,
                                            $.next = b),
                                            j.pending = b
                                        }
                                    }
                                    d.lanes |= a,
                                    b = d.alternate,
                                    b !== null && (b.lanes |= a),
                                    bh(d.return, a, e),
                                    _.lanes |= a;
                                    break
                                }
                                b = b.next
                            }
                        } else if (d.tag === 10)
                            g = d.type === e.type ? null : d.child;
                        else if (d.tag === 18) {
                            if (g = d.return,
                            g === null)
                                throw Error(p$1(341));
                            g.lanes |= a,
                            _ = g.alternate,
                            _ !== null && (_.lanes |= a),
                            bh(g, a, e),
                            g = d.sibling
                        } else
                            g = d.child;
                        if (g !== null)
                            g.return = d;
                        else
                            for (g = d; g !== null; ) {
                                if (g === e) {
                                    g = null;
                                    break
                                }
                                if (d = g.sibling,
                                d !== null) {
                                    d.return = g.return,
                                    g = d;
                                    break
                                }
                                g = g.return
                            }
                        d = g
                    }
            Xi(s, e, c.children, a),
            e = e.child
        }
        return e;
    case 9:
        return c = e.type,
        o = e.pendingProps.children,
        ch(e, a),
        c = eh(c),
        o = o(c),
        e.flags |= 1,
        Xi(s, e, o, a),
        e.child;
    case 14:
        return o = e.type,
        c = Ci(o, e.pendingProps),
        c = Ci(o.type, c),
        $i(s, e, o, c, a);
    case 15:
        return bj(s, e, e.type, e.pendingProps, a);
    case 17:
        return o = e.type,
        c = e.pendingProps,
        c = e.elementType === o ? c : Ci(o, c),
        ij(s, e),
        e.tag = 1,
        Zf(o) ? (s = !0,
        cg(e)) : s = !1,
        ch(e, a),
        Gi(e, o, c),
        Ii(e, o, c, a),
        jj(null, e, o, !0, s, a);
    case 19:
        return xj(s, e, a);
    case 22:
        return dj(s, e, a)
    }
    throw Error(p$1(156, e.tag))
}
;
function Fk(s, e) {
    return ac(s, e)
}
function $k(s, e, a, o) {
    this.tag = s,
    this.key = a,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = o,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Bg(s, e, a, o) {
    return new $k(s,e,a,o)
}
function aj(s) {
    return s = s.prototype,
    !(!s || !s.isReactComponent)
}
function Zk(s) {
    if (typeof s == "function")
        return aj(s) ? 1 : 0;
    if (s != null) {
        if (s = s.$$typeof,
        s === Da)
            return 11;
        if (s === Ga)
            return 14
    }
    return 2
}
function Pg(s, e) {
    var a = s.alternate;
    return a === null ? (a = Bg(s.tag, e, s.key, s.mode),
    a.elementType = s.elementType,
    a.type = s.type,
    a.stateNode = s.stateNode,
    a.alternate = s,
    s.alternate = a) : (a.pendingProps = e,
    a.type = s.type,
    a.flags = 0,
    a.subtreeFlags = 0,
    a.deletions = null),
    a.flags = s.flags & 14680064,
    a.childLanes = s.childLanes,
    a.lanes = s.lanes,
    a.child = s.child,
    a.memoizedProps = s.memoizedProps,
    a.memoizedState = s.memoizedState,
    a.updateQueue = s.updateQueue,
    e = s.dependencies,
    a.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    a.sibling = s.sibling,
    a.index = s.index,
    a.ref = s.ref,
    a
}
function Rg(s, e, a, o, c, d) {
    var g = 2;
    if (o = s,
    typeof s == "function")
        aj(s) && (g = 1);
    else if (typeof s == "string")
        g = 5;
    else
        e: switch (s) {
        case ya:
            return Tg(a.children, c, d, e);
        case za:
            g = 8,
            c |= 8;
            break;
        case Aa:
            return s = Bg(12, a, e, c | 2),
            s.elementType = Aa,
            s.lanes = d,
            s;
        case Ea:
            return s = Bg(13, a, e, c),
            s.elementType = Ea,
            s.lanes = d,
            s;
        case Fa:
            return s = Bg(19, a, e, c),
            s.elementType = Fa,
            s.lanes = d,
            s;
        case Ia:
            return pj(a, c, d, e);
        default:
            if (typeof s == "object" && s !== null)
                switch (s.$$typeof) {
                case Ba:
                    g = 10;
                    break e;
                case Ca:
                    g = 9;
                    break e;
                case Da:
                    g = 11;
                    break e;
                case Ga:
                    g = 14;
                    break e;
                case Ha:
                    g = 16,
                    o = null;
                    break e
                }
            throw Error(p$1(130, s == null ? s : typeof s, ""))
        }
    return e = Bg(g, a, e, c),
    e.elementType = s,
    e.type = o,
    e.lanes = d,
    e
}
function Tg(s, e, a, o) {
    return s = Bg(7, s, o, e),
    s.lanes = a,
    s
}
function pj(s, e, a, o) {
    return s = Bg(22, s, o, e),
    s.elementType = Ia,
    s.lanes = a,
    s.stateNode = {
        isHidden: !1
    },
    s
}
function Qg(s, e, a) {
    return s = Bg(6, s, null, e),
    s.lanes = a,
    s
}
function Sg(s, e, a) {
    return e = Bg(4, s.children !== null ? s.children : [], s.key, e),
    e.lanes = a,
    e.stateNode = {
        containerInfo: s.containerInfo,
        pendingChildren: null,
        implementation: s.implementation
    },
    e
}
function al(s, e, a, o, c) {
    this.tag = e,
    this.containerInfo = s,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = zc(0),
    this.expirationTimes = zc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = zc(0),
    this.identifierPrefix = o,
    this.onRecoverableError = c,
    this.mutableSourceEagerHydrationData = null
}
function bl(s, e, a, o, c, d, g, _, b) {
    return s = new al(s,e,a,_,b),
    e === 1 ? (e = 1,
    d === !0 && (e |= 8)) : e = 0,
    d = Bg(3, null, null, e),
    s.current = d,
    d.stateNode = s,
    d.memoizedState = {
        element: o,
        isDehydrated: a,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    kh(d),
    s
}
function cl(s, e, a) {
    var o = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: o == null ? null : "" + o,
        children: s,
        containerInfo: e,
        implementation: a
    }
}
function dl(s) {
    if (!s)
        return Vf;
    s = s._reactInternals;
    e: {
        if (Vb(s) !== s || s.tag !== 1)
            throw Error(p$1(170));
        var e = s;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Zf(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(p$1(171))
    }
    if (s.tag === 1) {
        var a = s.type;
        if (Zf(a))
            return bg(s, a, e)
    }
    return e
}
function el(s, e, a, o, c, d, g, _, b) {
    return s = bl(a, o, !0, s, c, d, g, _, b),
    s.context = dl(null),
    a = s.current,
    o = R(),
    c = yi(a),
    d = mh(o, c),
    d.callback = e ?? null,
    nh(a, d, c),
    s.current.lanes = c,
    Ac(s, c, o),
    Dk(s, o),
    s
}
function fl(s, e, a, o) {
    var c = e.current
      , d = R()
      , g = yi(c);
    return a = dl(a),
    e.context === null ? e.context = a : e.pendingContext = a,
    e = mh(d, g),
    e.payload = {
        element: s
    },
    o = o === void 0 ? null : o,
    o !== null && (e.callback = o),
    s = nh(c, e, g),
    s !== null && (gi(s, c, g, d),
    oh(s, c, g)),
    g
}
function gl(s) {
    if (s = s.current,
    !s.child)
        return null;
    switch (s.child.tag) {
    case 5:
        return s.child.stateNode;
    default:
        return s.child.stateNode
    }
}
function hl(s, e) {
    if (s = s.memoizedState,
    s !== null && s.dehydrated !== null) {
        var a = s.retryLane;
        s.retryLane = a !== 0 && a < e ? a : e
    }
}
function il(s, e) {
    hl(s, e),
    (s = s.alternate) && hl(s, e)
}
function jl() {
    return null
}
var kl = typeof reportError == "function" ? reportError : function(s) {
    console.error(s)
}
;
function ll(s) {
    this._internalRoot = s
}
ml.prototype.render = ll.prototype.render = function(s) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(p$1(409));
    fl(s, e, null, null)
}
;
ml.prototype.unmount = ll.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
        this._internalRoot = null;
        var e = s.containerInfo;
        Rk(function() {
            fl(null, s, null, null)
        }),
        e[uf] = null
    }
}
;
function ml(s) {
    this._internalRoot = s
}
ml.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
        var e = Hc();
        s = {
            blockedOn: null,
            target: s,
            priority: e
        };
        for (var a = 0; a < Qc.length && e !== 0 && e < Qc[a].priority; a++)
            ;
        Qc.splice(a, 0, s),
        a === 0 && Vc(s)
    }
}
;
function nl(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11)
}
function ol(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "))
}
function pl() {}
function ql(s, e, a, o, c) {
    if (c) {
        if (typeof o == "function") {
            var d = o;
            o = function() {
                var j = gl(g);
                d.call(j)
            }
        }
        var g = el(e, o, s, 0, null, !1, !1, "", pl);
        return s._reactRootContainer = g,
        s[uf] = g.current,
        sf(s.nodeType === 8 ? s.parentNode : s),
        Rk(),
        g
    }
    for (; c = s.lastChild; )
        s.removeChild(c);
    if (typeof o == "function") {
        var _ = o;
        o = function() {
            var j = gl(b);
            _.call(j)
        }
    }
    var b = bl(s, 0, !1, null, null, !1, !1, "", pl);
    return s._reactRootContainer = b,
    s[uf] = b.current,
    sf(s.nodeType === 8 ? s.parentNode : s),
    Rk(function() {
        fl(e, b, a, o)
    }),
    b
}
function rl(s, e, a, o, c) {
    var d = a._reactRootContainer;
    if (d) {
        var g = d;
        if (typeof c == "function") {
            var _ = c;
            c = function() {
                var b = gl(g);
                _.call(b)
            }
        }
        fl(e, g, s, c)
    } else
        g = ql(a, e, s, c, o);
    return gl(g)
}
Ec = function(s) {
    switch (s.tag) {
    case 3:
        var e = s.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var a = tc(e.pendingLanes);
            a !== 0 && (Cc(e, a | 1),
            Dk(e, B()),
            !(K & 6) && (Gj = B() + 500,
            jg()))
        }
        break;
    case 13:
        Rk(function() {
            var o = ih(s, 1);
            if (o !== null) {
                var c = R();
                gi(o, s, 1, c)
            }
        }),
        il(s, 1)
    }
}
;
Fc = function(s) {
    if (s.tag === 13) {
        var e = ih(s, 134217728);
        if (e !== null) {
            var a = R();
            gi(e, s, 134217728, a)
        }
        il(s, 134217728)
    }
}
;
Gc = function(s) {
    if (s.tag === 13) {
        var e = yi(s)
          , a = ih(s, e);
        if (a !== null) {
            var o = R();
            gi(a, s, e, o)
        }
        il(s, e)
    }
}
;
Hc = function() {
    return C
}
;
Ic = function(s, e) {
    var a = C;
    try {
        return C = s,
        e()
    } finally {
        C = a
    }
}
;
yb = function(s, e, a) {
    switch (e) {
    case "input":
        if (bb(s, a),
        e = a.name,
        a.type === "radio" && e != null) {
            for (a = s; a.parentNode; )
                a = a.parentNode;
            for (a = a.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < a.length; e++) {
                var o = a[e];
                if (o !== s && o.form === s.form) {
                    var c = Db(o);
                    if (!c)
                        throw Error(p$1(90));
                    Wa(o),
                    bb(o, c)
                }
            }
        }
        break;
    case "textarea":
        ib(s, a);
        break;
    case "select":
        e = a.value,
        e != null && fb(s, !!a.multiple, e, !1)
    }
}
;
Gb = Qk;
Hb = Rk;
var sl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue, Db, Eb, Fb, Qk]
}
  , tl = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , ul = {
    bundleType: tl.bundleType,
    version: tl.version,
    rendererPackageName: tl.rendererPackageName,
    rendererConfig: tl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(s) {
        return s = Zb(s),
        s === null ? null : s.stateNode
    },
    findFiberByHostInstance: tl.findFiberByHostInstance || jl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber)
        try {
            kc = vl.inject(ul),
            lc = vl
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(s, e) {
    var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!nl(e))
        throw Error(p$1(200));
    return cl(s, e, null, a)
}
;
reactDom_production_min.createRoot = function(s, e) {
    if (!nl(s))
        throw Error(p$1(299));
    var a = !1
      , o = ""
      , c = kl;
    return e != null && (e.unstable_strictMode === !0 && (a = !0),
    e.identifierPrefix !== void 0 && (o = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (c = e.onRecoverableError)),
    e = bl(s, 1, !1, null, null, a, !1, o, c),
    s[uf] = e.current,
    sf(s.nodeType === 8 ? s.parentNode : s),
    new ll(e)
}
;
reactDom_production_min.findDOMNode = function(s) {
    if (s == null)
        return null;
    if (s.nodeType === 1)
        return s;
    var e = s._reactInternals;
    if (e === void 0)
        throw typeof s.render == "function" ? Error(p$1(188)) : (s = Object.keys(s).join(","),
        Error(p$1(268, s)));
    return s = Zb(e),
    s = s === null ? null : s.stateNode,
    s
}
;
reactDom_production_min.flushSync = function(s) {
    return Rk(s)
}
;
reactDom_production_min.hydrate = function(s, e, a) {
    if (!ol(e))
        throw Error(p$1(200));
    return rl(null, s, e, !0, a)
}
;
reactDom_production_min.hydrateRoot = function(s, e, a) {
    if (!nl(s))
        throw Error(p$1(405));
    var o = a != null && a.hydratedSources || null
      , c = !1
      , d = ""
      , g = kl;
    if (a != null && (a.unstable_strictMode === !0 && (c = !0),
    a.identifierPrefix !== void 0 && (d = a.identifierPrefix),
    a.onRecoverableError !== void 0 && (g = a.onRecoverableError)),
    e = el(e, null, s, 1, a ?? null, c, !1, d, g),
    s[uf] = e.current,
    sf(s),
    o)
        for (s = 0; s < o.length; s++)
            a = o[s],
            c = a._getVersion,
            c = c(a._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [a, c] : e.mutableSourceEagerHydrationData.push(a, c);
    return new ml(e)
}
;
reactDom_production_min.render = function(s, e, a) {
    if (!ol(e))
        throw Error(p$1(200));
    return rl(null, s, e, !1, a)
}
;
reactDom_production_min.unmountComponentAtNode = function(s) {
    if (!ol(s))
        throw Error(p$1(40));
    return s._reactRootContainer ? (Rk(function() {
        rl(null, null, s, !1, function() {
            s._reactRootContainer = null,
            s[uf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(s, e, a, o) {
    if (!ol(a))
        throw Error(p$1(200));
    if (s == null || s._reactInternals === void 0)
        throw Error(p$1(38));
    return rl(s, e, a, !1, o)
}
;
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (s) {
            console.error(s)
        }
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports, createRoot$1, m = reactDomExports;
createRoot$1 = client.createRoot = m.createRoot,
client.hydrateRoot = m.hydrateRoot;
function createDOMMotionComponentProxy(s) {
    if (typeof Proxy > "u")
        return s;
    const e = new Map
      , a = (...o) => s(...o);
    return new Proxy(a,{
        get: (o, c) => c === "create" ? s : (e.has(c) || e.set(c, s(c)),
        e.get(c))
    })
}
function isAnimationControls(s) {
    return s !== null && typeof s == "object" && typeof s.start == "function"
}
const isKeyframesTarget = s => Array.isArray(s);
function shallowCompare(s, e) {
    if (!Array.isArray(e))
        return !1;
    const a = e.length;
    if (a !== s.length)
        return !1;
    for (let o = 0; o < a; o++)
        if (e[o] !== s[o])
            return !1;
    return !0
}
function isVariantLabel(s) {
    return typeof s == "string" || Array.isArray(s)
}
function getValueState(s) {
    const e = [{}, {}];
    return s == null || s.values.forEach( (a, o) => {
        e[0][o] = a.get(),
        e[1][o] = a.getVelocity()
    }
    ),
    e
}
function resolveVariantFromProps(s, e, a, o) {
    if (typeof e == "function") {
        const [c,d] = getValueState(o);
        e = e(a !== void 0 ? a : s.custom, c, d)
    }
    if (typeof e == "string" && (e = s.variants && s.variants[e]),
    typeof e == "function") {
        const [c,d] = getValueState(o);
        e = e(a !== void 0 ? a : s.custom, c, d)
    }
    return e
}
function resolveVariant(s, e, a) {
    const o = s.getProps();
    return resolveVariantFromProps(o, e, a !== void 0 ? a : o.custom, s)
}
const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , variantProps = ["initial", ...variantPriorityOrder]
  , transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , transformProps = new Set(transformPropOrder)
  , secondsToMilliseconds = s => s * 1e3
  , millisecondsToSeconds = s => s / 1e3
  , underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , criticallyDampedSpring = s => ({
    type: "spring",
    stiffness: 550,
    damping: s === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , keyframesTransition = {
    type: "keyframes",
    duration: .8
}
  , ease = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , getDefaultTransition = (s, {keyframes: e}) => e.length > 2 ? keyframesTransition : transformProps.has(s) ? s.startsWith("scale") ? criticallyDampedSpring(e[1]) : underDampedSpring : ease;
function getValueTransition(s, e) {
    return s[e] || s.default || s
}
const MotionGlobalConfig = {
    skipAnimations: !1,
    useManualTiming: !1
}
  , isNotNull = s => s !== null;
function getFinalKeyframe(s, {repeat: e, repeatType: a="loop"}, o) {
    const c = s.filter(isNotNull)
      , d = e && a !== "loop" && e % 2 === 1 ? 0 : c.length - 1;
    return !d || o === void 0 ? c[d] : o
}
const noop = s => s;
function createRenderStep(s) {
    let e = new Set
      , a = new Set
      , o = !1
      , c = !1;
    const d = new WeakSet;
    let g = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };
    function _(j) {
        d.has(j) && (b.schedule(j),
        s()),
        j(g)
    }
    const b = {
        schedule: (j, $=!1, nt=!1) => {
            const rt = nt && o ? e : a;
            return $ && d.add(j),
            rt.has(j) || rt.add(j),
            j
        }
        ,
        cancel: j => {
            a.delete(j),
            d.delete(j)
        }
        ,
        process: j => {
            if (g = j,
            o) {
                c = !0;
                return
            }
            o = !0,
            [e,a] = [a, e],
            a.clear(),
            e.forEach(_),
            o = !1,
            c && (c = !1,
            b.process(j))
        }
    };
    return b
}
const stepsOrder = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
  , maxElapsed = 40;
function createRenderBatcher(s, e) {
    let a = !1
      , o = !0;
    const c = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , d = () => a = !0
      , g = stepsOrder.reduce( (it, ot) => (it[ot] = createRenderStep(d),
    it), {})
      , {read: _, resolveKeyframes: b, update: j, preRender: $, render: nt, postRender: tt} = g
      , rt = () => {
        const it = performance.now();
        a = !1,
        c.delta = o ? 1e3 / 60 : Math.max(Math.min(it - c.timestamp, maxElapsed), 1),
        c.timestamp = it,
        c.isProcessing = !0,
        _.process(c),
        b.process(c),
        j.process(c),
        $.process(c),
        nt.process(c),
        tt.process(c),
        c.isProcessing = !1,
        a && e && (o = !1,
        s(rt))
    }
      , st = () => {
        a = !0,
        o = !0,
        c.isProcessing || s(rt)
    }
    ;
    return {
        schedule: stepsOrder.reduce( (it, ot) => {
            const at = g[ot];
            return it[ot] = (ht, pt=!1, dt=!1) => (a || st(),
            at.schedule(ht, pt, dt)),
            it
        }
        , {}),
        cancel: it => {
            for (let ot = 0; ot < stepsOrder.length; ot++)
                g[stepsOrder[ot]].cancel(it)
        }
        ,
        state: c,
        steps: g
    }
}
const {schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps} = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop, !0)
  , calcBezier = (s, e, a) => (((1 - 3 * a + 3 * e) * s + (3 * a - 6 * e)) * s + 3 * e) * s
  , subdivisionPrecision = 1e-7
  , subdivisionMaxIterations = 12;
function binarySubdivide(s, e, a, o, c) {
    let d, g, _ = 0;
    do
        g = e + (a - e) / 2,
        d = calcBezier(g, o, c) - s,
        d > 0 ? a = g : e = g;
    while (Math.abs(d) > subdivisionPrecision && ++_ < subdivisionMaxIterations);
    return g
}
function cubicBezier(s, e, a, o) {
    if (s === e && a === o)
        return noop;
    const c = d => binarySubdivide(d, 0, 1, s, a);
    return d => d === 0 || d === 1 ? d : calcBezier(c(d), e, o)
}
const mirrorEasing = s => e => e <= .5 ? s(2 * e) / 2 : (2 - s(2 * (1 - e))) / 2
  , reverseEasing = s => e => 1 - s(1 - e)
  , backOut = cubicBezier(.33, 1.53, .69, .99)
  , backIn = reverseEasing(backOut)
  , backInOut = mirrorEasing(backIn)
  , anticipate = s => (s *= 2) < 1 ? .5 * backIn(s) : .5 * (2 - Math.pow(2, -10 * (s - 1)))
  , circIn = s => 1 - Math.sin(Math.acos(s))
  , circOut = reverseEasing(circIn)
  , circInOut = mirrorEasing(circIn)
  , isZeroValueString = s => /^0[^.\s]+$/u.test(s);
function isNone(s) {
    return typeof s == "number" ? s === 0 : s !== null ? s === "none" || s === "0" || isZeroValueString(s) : !0
}
let invariant = noop;
const isNumericalString = s => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(s)
  , checkStringStartsWith = s => e => typeof e == "string" && e.startsWith(s)
  , isCSSVariableName = checkStringStartsWith("--")
  , startsAsVariableToken = checkStringStartsWith("var(--")
  , isCSSVariableToken = s => startsAsVariableToken(s) ? singleCssVariableRegex.test(s.split("/*")[0].trim()) : !1
  , singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(s) {
    const e = splitCSSVariableRegex.exec(s);
    if (!e)
        return [, ];
    const [,a,o,c] = e;
    return [`--${a ?? o}`, c]
}
function getVariableValue(s, e, a=1) {
    const [o,c] = parseCSSVariable(s);
    if (!o)
        return;
    const d = window.getComputedStyle(e).getPropertyValue(o);
    if (d) {
        const g = d.trim();
        return isNumericalString(g) ? parseFloat(g) : g
    }
    return isCSSVariableToken(c) ? getVariableValue(c, e, a + 1) : c
}
const clamp$1 = (s, e, a) => a > e ? e : a < s ? s : a
  , number = {
    test: s => typeof s == "number",
    parse: parseFloat,
    transform: s => s
}
  , alpha = {
    ...number,
    transform: s => clamp$1(0, 1, s)
}
  , scale = {
    ...number,
    default: 1
}
  , createUnitType = s => ({
    test: e => typeof e == "string" && e.endsWith(s) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: e => `${e}${s}`
})
  , degrees = createUnitType("deg")
  , percent = createUnitType("%")
  , px$1 = createUnitType("px")
  , vh = createUnitType("vh")
  , vw = createUnitType("vw")
  , progressPercentage = {
    ...percent,
    parse: s => percent.parse(s) / 100,
    transform: s => percent.transform(s * 100)
}
  , positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
  , isNumOrPxType = s => s === number || s === px$1
  , getPosFromMatrix = (s, e) => parseFloat(s.split(", ")[e])
  , getTranslateFromMatrix = (s, e) => (a, {transform: o}) => {
    if (o === "none" || !o)
        return 0;
    const c = o.match(/^matrix3d\((.+)\)$/u);
    if (c)
        return getPosFromMatrix(c[1], e);
    {
        const d = o.match(/^matrix\((.+)\)$/u);
        return d ? getPosFromMatrix(d[1], s) : 0
    }
}
  , transformKeys = new Set(["x", "y", "z"])
  , nonTranslationalTransformKeys = transformPropOrder.filter(s => !transformKeys.has(s));
function removeNonTranslationalTransform(s) {
    const e = [];
    return nonTranslationalTransformKeys.forEach(a => {
        const o = s.getValue(a);
        o !== void 0 && (e.push([a, o.get()]),
        o.set(a.startsWith("scale") ? 1 : 0))
    }
    ),
    e
}
const positionalValues = {
    width: ({x: s}, {paddingLeft: e="0", paddingRight: a="0"}) => s.max - s.min - parseFloat(e) - parseFloat(a),
    height: ({y: s}, {paddingTop: e="0", paddingBottom: a="0"}) => s.max - s.min - parseFloat(e) - parseFloat(a),
    top: (s, {top: e}) => parseFloat(e),
    left: (s, {left: e}) => parseFloat(e),
    bottom: ({y: s}, {top: e}) => parseFloat(e) + (s.max - s.min),
    right: ({x: s}, {left: e}) => parseFloat(e) + (s.max - s.min),
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const testValueType = s => e => e.test(s)
  , auto = {
    test: s => s === "auto",
    parse: s => s
}
  , dimensionValueTypes = [number, px$1, percent, degrees, vw, vh, auto]
  , findDimensionValueType = s => dimensionValueTypes.find(testValueType(s))
  , toResolve = new Set;
let isScheduled = !1
  , anyNeedsMeasurement = !1;
function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
        const s = Array.from(toResolve).filter(o => o.needsMeasurement)
          , e = new Set(s.map(o => o.element))
          , a = new Map;
        e.forEach(o => {
            const c = removeNonTranslationalTransform(o);
            c.length && (a.set(o, c),
            o.render())
        }
        ),
        s.forEach(o => o.measureInitialState()),
        e.forEach(o => {
            o.render();
            const c = a.get(o);
            c && c.forEach( ([d,g]) => {
                var _;
                (_ = o.getValue(d)) === null || _ === void 0 || _.set(g)
            }
            )
        }
        ),
        s.forEach(o => o.measureEndState()),
        s.forEach(o => {
            o.suspendedScrollY !== void 0 && window.scrollTo(0, o.suspendedScrollY)
        }
        )
    }
    anyNeedsMeasurement = !1,
    isScheduled = !1,
    toResolve.forEach(s => s.complete()),
    toResolve.clear()
}
function readAllKeyframes() {
    toResolve.forEach(s => {
        s.readKeyframes(),
        s.needsMeasurement && (anyNeedsMeasurement = !0)
    }
    )
}
function flushKeyframeResolvers() {
    readAllKeyframes(),
    measureAllKeyframes()
}
class KeyframeResolver {
    constructor(e, a, o, c, d, g=!1) {
        this.isComplete = !1,
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.isScheduled = !1,
        this.unresolvedKeyframes = [...e],
        this.onComplete = a,
        this.name = o,
        this.motionValue = c,
        this.element = d,
        this.isAsync = g
    }
    scheduleResolve() {
        this.isScheduled = !0,
        this.isAsync ? (toResolve.add(this),
        isScheduled || (isScheduled = !0,
        frame.read(readAllKeyframes),
        frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, name: a, element: o, motionValue: c} = this;
        for (let d = 0; d < e.length; d++)
            if (e[d] === null)
                if (d === 0) {
                    const g = c == null ? void 0 : c.get()
                      , _ = e[e.length - 1];
                    if (g !== void 0)
                        e[0] = g;
                    else if (o && a) {
                        const b = o.readValue(a, _);
                        b != null && (e[0] = b)
                    }
                    e[0] === void 0 && (e[0] = _),
                    c && g === void 0 && c.set(e[0])
                } else
                    e[d] = e[d - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
        toResolve.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
        toResolve.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const sanitize = s => Math.round(s * 1e5) / 1e5
  , floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(s) {
    return s == null
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
  , isColorString = (s, e) => a => !!(typeof a == "string" && singleColorRegex.test(a) && a.startsWith(s) || e && !isNullish(a) && Object.prototype.hasOwnProperty.call(a, e))
  , splitColor = (s, e, a) => o => {
    if (typeof o != "string")
        return o;
    const [c,d,g,_] = o.match(floatRegex);
    return {
        [s]: parseFloat(c),
        [e]: parseFloat(d),
        [a]: parseFloat(g),
        alpha: _ !== void 0 ? parseFloat(_) : 1
    }
}
  , clampRgbUnit = s => clamp$1(0, 255, s)
  , rgbUnit = {
    ...number,
    transform: s => Math.round(clampRgbUnit(s))
}
  , rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({red: s, green: e, blue: a, alpha: o=1}) => "rgba(" + rgbUnit.transform(s) + ", " + rgbUnit.transform(e) + ", " + rgbUnit.transform(a) + ", " + sanitize(alpha.transform(o)) + ")"
};
function parseHex(s) {
    let e = ""
      , a = ""
      , o = ""
      , c = "";
    return s.length > 5 ? (e = s.substring(1, 3),
    a = s.substring(3, 5),
    o = s.substring(5, 7),
    c = s.substring(7, 9)) : (e = s.substring(1, 2),
    a = s.substring(2, 3),
    o = s.substring(3, 4),
    c = s.substring(4, 5),
    e += e,
    a += a,
    o += o,
    c += c),
    {
        red: parseInt(e, 16),
        green: parseInt(a, 16),
        blue: parseInt(o, 16),
        alpha: c ? parseInt(c, 16) / 255 : 1
    }
}
const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
}
  , hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({hue: s, saturation: e, lightness: a, alpha: o=1}) => "hsla(" + Math.round(s) + ", " + percent.transform(sanitize(e)) + ", " + percent.transform(sanitize(a)) + ", " + sanitize(alpha.transform(o)) + ")"
}
  , color = {
    test: s => rgba.test(s) || hex.test(s) || hsla.test(s),
    parse: s => rgba.test(s) ? rgba.parse(s) : hsla.test(s) ? hsla.parse(s) : hex.parse(s),
    transform: s => typeof s == "string" ? s : s.hasOwnProperty("red") ? rgba.transform(s) : hsla.transform(s)
}
  , colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(s) {
    var e, a;
    return isNaN(s) && typeof s == "string" && (((e = s.match(floatRegex)) === null || e === void 0 ? void 0 : e.length) || 0) + (((a = s.match(colorRegex)) === null || a === void 0 ? void 0 : a.length) || 0) > 0
}
const NUMBER_TOKEN = "number"
  , COLOR_TOKEN = "color"
  , VAR_TOKEN = "var"
  , VAR_FUNCTION_TOKEN = "var("
  , SPLIT_TOKEN = "${}"
  , complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(s) {
    const e = s.toString()
      , a = []
      , o = {
        color: [],
        number: [],
        var: []
    }
      , c = [];
    let d = 0;
    const _ = e.replace(complexRegex, b => (color.test(b) ? (o.color.push(d),
    c.push(COLOR_TOKEN),
    a.push(color.parse(b))) : b.startsWith(VAR_FUNCTION_TOKEN) ? (o.var.push(d),
    c.push(VAR_TOKEN),
    a.push(b)) : (o.number.push(d),
    c.push(NUMBER_TOKEN),
    a.push(parseFloat(b))),
    ++d,
    SPLIT_TOKEN)).split(SPLIT_TOKEN);
    return {
        values: a,
        split: _,
        indexes: o,
        types: c
    }
}
function parseComplexValue(s) {
    return analyseComplexValue(s).values
}
function createTransformer(s) {
    const {split: e, types: a} = analyseComplexValue(s)
      , o = e.length;
    return c => {
        let d = "";
        for (let g = 0; g < o; g++)
            if (d += e[g],
            c[g] !== void 0) {
                const _ = a[g];
                _ === NUMBER_TOKEN ? d += sanitize(c[g]) : _ === COLOR_TOKEN ? d += color.transform(c[g]) : d += c[g]
            }
        return d
    }
}
const convertNumbersToZero = s => typeof s == "number" ? 0 : s;
function getAnimatableNone$1(s) {
    const e = parseComplexValue(s);
    return createTransformer(s)(e.map(convertNumbersToZero))
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
}
  , maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(s) {
    const [e,a] = s.slice(0, -1).split("(");
    if (e === "drop-shadow")
        return s;
    const [o] = a.match(floatRegex) || [];
    if (!o)
        return s;
    const c = a.replace(o, "");
    let d = maxDefaults.has(e) ? 1 : 0;
    return o !== a && (d *= 100),
    e + "(" + d + c + ")"
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu
  , filter = {
    ...complex,
    getAnimatableNone: s => {
        const e = s.match(functionRegex);
        return e ? e.map(applyDefaultFilter).join(" ") : s
    }
}
  , browserNumberValueTypes = {
    borderWidth: px$1,
    borderTopWidth: px$1,
    borderRightWidth: px$1,
    borderBottomWidth: px$1,
    borderLeftWidth: px$1,
    borderRadius: px$1,
    radius: px$1,
    borderTopLeftRadius: px$1,
    borderTopRightRadius: px$1,
    borderBottomRightRadius: px$1,
    borderBottomLeftRadius: px$1,
    width: px$1,
    maxWidth: px$1,
    height: px$1,
    maxHeight: px$1,
    top: px$1,
    right: px$1,
    bottom: px$1,
    left: px$1,
    padding: px$1,
    paddingTop: px$1,
    paddingRight: px$1,
    paddingBottom: px$1,
    paddingLeft: px$1,
    margin: px$1,
    marginTop: px$1,
    marginRight: px$1,
    marginBottom: px$1,
    marginLeft: px$1,
    backgroundPositionX: px$1,
    backgroundPositionY: px$1
}
  , transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px$1,
    translateX: px$1,
    translateY: px$1,
    translateZ: px$1,
    x: px$1,
    y: px$1,
    z: px$1,
    perspective: px$1,
    transformPerspective: px$1,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px$1
}
  , int = {
    ...number,
    transform: Math.round
}
  , numberValueTypes = {
    ...browserNumberValueTypes,
    ...transformValueTypes,
    zIndex: int,
    size: px$1,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
}
  , defaultValueTypes = {
    ...numberValueTypes,
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
}
  , getDefaultValueType = s => defaultValueTypes[s];
function getAnimatableNone(s, e) {
    let a = getDefaultValueType(s);
    return a !== filter && (a = complex),
    a.getAnimatableNone ? a.getAnimatableNone(e) : void 0
}
const invalidTemplates = new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(s, e, a) {
    let o = 0, c;
    for (; o < s.length && !c; ) {
        const d = s[o];
        typeof d == "string" && !invalidTemplates.has(d) && analyseComplexValue(d).values.length && (c = s[o]),
        o++
    }
    if (c && a)
        for (const d of e)
            s[d] = getAnimatableNone(a, c)
}
class DOMKeyframesResolver extends KeyframeResolver {
    constructor(e, a, o, c, d) {
        super(e, a, o, c, d, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, element: a, name: o} = this;
        if (!a || !a.current)
            return;
        super.readKeyframes();
        for (let b = 0; b < e.length; b++) {
            let j = e[b];
            if (typeof j == "string" && (j = j.trim(),
            isCSSVariableToken(j))) {
                const $ = getVariableValue(j, a.current);
                $ !== void 0 && (e[b] = $),
                b === e.length - 1 && (this.finalKeyframe = j)
            }
        }
        if (this.resolveNoneKeyframes(),
        !positionalKeys.has(o) || e.length !== 2)
            return;
        const [c,d] = e
          , g = findDimensionValueType(c)
          , _ = findDimensionValueType(d);
        if (g !== _)
            if (isNumOrPxType(g) && isNumOrPxType(_))
                for (let b = 0; b < e.length; b++) {
                    const j = e[b];
                    typeof j == "string" && (e[b] = parseFloat(j))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: e, name: a} = this
          , o = [];
        for (let c = 0; c < e.length; c++)
            isNone(e[c]) && o.push(c);
        o.length && makeNoneKeyframesAnimatable(e, o, a)
    }
    measureInitialState() {
        const {element: e, unresolvedKeyframes: a, name: o} = this;
        if (!e || !e.current)
            return;
        o === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = positionalValues[o](e.measureViewportBox(), window.getComputedStyle(e.current)),
        a[0] = this.measuredOrigin;
        const c = a[a.length - 1];
        c !== void 0 && e.getValue(o, c).jump(c, !1)
    }
    measureEndState() {
        var e;
        const {element: a, name: o, unresolvedKeyframes: c} = this;
        if (!a || !a.current)
            return;
        const d = a.getValue(o);
        d && d.jump(this.measuredOrigin, !1);
        const g = c.length - 1
          , _ = c[g];
        c[g] = positionalValues[o](a.measureViewportBox(), window.getComputedStyle(a.current)),
        _ !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = _),
        !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach( ([b,j]) => {
            a.getValue(b).set(j)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
function isGenerator(s) {
    return typeof s == "function"
}
let now$1;
function clearTime() {
    now$1 = void 0
}
const time = {
    now: () => (now$1 === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()),
    now$1),
    set: s => {
        now$1 = s,
        queueMicrotask(clearTime)
    }
}
  , isAnimatable = (s, e) => e === "zIndex" ? !1 : !!(typeof s == "number" || Array.isArray(s) || typeof s == "string" && (complex.test(s) || s === "0") && !s.startsWith("url("));
function hasKeyframesChanged(s) {
    const e = s[0];
    if (s.length === 1)
        return !0;
    for (let a = 0; a < s.length; a++)
        if (s[a] !== e)
            return !0
}
function canAnimate(s, e, a, o) {
    const c = s[0];
    if (c === null)
        return !1;
    if (e === "display" || e === "visibility")
        return !0;
    const d = s[s.length - 1]
      , g = isAnimatable(c, e)
      , _ = isAnimatable(d, e);
    return !g || !_ ? !1 : hasKeyframesChanged(s) || (a === "spring" || isGenerator(a)) && o
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
    constructor({autoplay: e=!0, delay: a=0, type: o="keyframes", repeat: c=0, repeatDelay: d=0, repeatType: g="loop", ..._}) {
        this.isStopped = !1,
        this.hasAttemptedResolve = !1,
        this.createdAt = time.now(),
        this.options = {
            autoplay: e,
            delay: a,
            type: o,
            repeat: c,
            repeatDelay: d,
            repeatType: g,
            ..._
        },
        this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(),
        this._resolved
    }
    onKeyframesResolved(e, a) {
        this.resolvedAt = time.now(),
        this.hasAttemptedResolve = !0;
        const {name: o, type: c, velocity: d, delay: g, onComplete: _, onUpdate: b, isGenerator: j} = this.options;
        if (!j && !canAnimate(e, o, c, d))
            if (g)
                this.options.duration = 0;
            else {
                b == null || b(getFinalKeyframe(e, this.options, a)),
                _ == null || _(),
                this.resolveFinishedPromise();
                return
            }
        const $ = this.initPlayback(e, a);
        $ !== !1 && (this._resolved = {
            keyframes: e,
            finalKeyframe: a,
            ...$
        },
        this.onPostResolved())
    }
    onPostResolved() {}
    then(e, a) {
        return this.currentFinishedPromise.then(e, a)
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(e => {
            this.resolveFinishedPromise = e
        }
        )
    }
}
function velocityPerSecond(s, e) {
    return e ? s * (1e3 / e) : 0
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(s, e, a) {
    const o = Math.max(e - velocitySampleDuration, 0);
    return velocityPerSecond(a - s(o), e - o)
}
const safeMin = .001
  , minDuration = .01
  , maxDuration$1 = 10
  , minDamping = .05
  , maxDamping = 1;
function findSpring({duration: s=800, bounce: e=.25, velocity: a=0, mass: o=1}) {
    let c, d, g = 1 - e;
    g = clamp$1(minDamping, maxDamping, g),
    s = clamp$1(minDuration, maxDuration$1, millisecondsToSeconds(s)),
    g < 1 ? (c = j => {
        const $ = j * g
          , nt = $ * s
          , tt = $ - a
          , rt = calcAngularFreq(j, g)
          , st = Math.exp(-nt);
        return safeMin - tt / rt * st
    }
    ,
    d = j => {
        const nt = j * g * s
          , tt = nt * a + a
          , rt = Math.pow(g, 2) * Math.pow(j, 2) * s
          , st = Math.exp(-nt)
          , lt = calcAngularFreq(Math.pow(j, 2), g);
        return (-c(j) + safeMin > 0 ? -1 : 1) * ((tt - rt) * st) / lt
    }
    ) : (c = j => {
        const $ = Math.exp(-j * s)
          , nt = (j - a) * s + 1;
        return -safeMin + $ * nt
    }
    ,
    d = j => {
        const $ = Math.exp(-j * s)
          , nt = (a - j) * (s * s);
        return $ * nt
    }
    );
    const _ = 5 / s
      , b = approximateRoot(c, d, _);
    if (s = secondsToMilliseconds(s),
    isNaN(b))
        return {
            stiffness: 100,
            damping: 10,
            duration: s
        };
    {
        const j = Math.pow(b, 2) * o;
        return {
            stiffness: j,
            damping: g * 2 * Math.sqrt(o * j),
            duration: s
        }
    }
}
const rootIterations = 12;
function approximateRoot(s, e, a) {
    let o = a;
    for (let c = 1; c < rootIterations; c++)
        o = o - s(o) / e(o);
    return o
}
function calcAngularFreq(s, e) {
    return s * Math.sqrt(1 - e * e)
}
const durationKeys = ["duration", "bounce"]
  , physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(s, e) {
    return e.some(a => s[a] !== void 0)
}
function getSpringOptions(s) {
    let e = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...s
    };
    if (!isSpringType(s, physicsKeys) && isSpringType(s, durationKeys)) {
        const a = findSpring(s);
        e = {
            ...e,
            ...a,
            mass: 1
        },
        e.isResolvedFromDuration = !0
    }
    return e
}
function spring({keyframes: s, restDelta: e, restSpeed: a, ...o}) {
    const c = s[0]
      , d = s[s.length - 1]
      , g = {
        done: !1,
        value: c
    }
      , {stiffness: _, damping: b, mass: j, duration: $, velocity: nt, isResolvedFromDuration: tt} = getSpringOptions({
        ...o,
        velocity: -millisecondsToSeconds(o.velocity || 0)
    })
      , rt = nt || 0
      , st = b / (2 * Math.sqrt(_ * j))
      , lt = d - c
      , ct = millisecondsToSeconds(Math.sqrt(_ / j))
      , it = Math.abs(lt) < 5;
    a || (a = it ? .01 : 2),
    e || (e = it ? .005 : .5);
    let ot;
    if (st < 1) {
        const at = calcAngularFreq(ct, st);
        ot = ht => {
            const pt = Math.exp(-st * ct * ht);
            return d - pt * ((rt + st * ct * lt) / at * Math.sin(at * ht) + lt * Math.cos(at * ht))
        }
    } else if (st === 1)
        ot = at => d - Math.exp(-ct * at) * (lt + (rt + ct * lt) * at);
    else {
        const at = ct * Math.sqrt(st * st - 1);
        ot = ht => {
            const pt = Math.exp(-st * ct * ht)
              , dt = Math.min(at * ht, 300);
            return d - pt * ((rt + st * ct * lt) * Math.sinh(dt) + at * lt * Math.cosh(dt)) / at
        }
    }
    return {
        calculatedDuration: tt && $ || null,
        next: at => {
            const ht = ot(at);
            if (tt)
                g.done = at >= $;
            else {
                let pt = 0;
                st < 1 && (pt = at === 0 ? secondsToMilliseconds(rt) : calcGeneratorVelocity(ot, at, ht));
                const dt = Math.abs(pt) <= a
                  , yt = Math.abs(d - ht) <= e;
                g.done = dt && yt
            }
            return g.value = g.done ? d : ht,
            g
        }
    }
}
function inertia({keyframes: s, velocity: e=0, power: a=.8, timeConstant: o=325, bounceDamping: c=10, bounceStiffness: d=500, modifyTarget: g, min: _, max: b, restDelta: j=.5, restSpeed: $}) {
    const nt = s[0]
      , tt = {
        done: !1,
        value: nt
    }
      , rt = vt => _ !== void 0 && vt < _ || b !== void 0 && vt > b
      , st = vt => _ === void 0 ? b : b === void 0 || Math.abs(_ - vt) < Math.abs(b - vt) ? _ : b;
    let lt = a * e;
    const ct = nt + lt
      , it = g === void 0 ? ct : g(ct);
    it !== ct && (lt = it - nt);
    const ot = vt => -lt * Math.exp(-vt / o)
      , at = vt => it + ot(vt)
      , ht = vt => {
        const xt = ot(vt)
          , _t = at(vt);
        tt.done = Math.abs(xt) <= j,
        tt.value = tt.done ? it : _t
    }
    ;
    let pt, dt;
    const yt = vt => {
        rt(tt.value) && (pt = vt,
        dt = spring({
            keyframes: [tt.value, st(tt.value)],
            velocity: calcGeneratorVelocity(at, vt, tt.value),
            damping: c,
            stiffness: d,
            restDelta: j,
            restSpeed: $
        }))
    }
    ;
    return yt(0),
    {
        calculatedDuration: null,
        next: vt => {
            let xt = !1;
            return !dt && pt === void 0 && (xt = !0,
            ht(vt),
            yt(vt)),
            pt !== void 0 && vt >= pt ? dt.next(vt - pt) : (!xt && ht(vt),
            tt)
        }
    }
}
const easeIn = cubicBezier(.42, 0, 1, 1)
  , easeOut = cubicBezier(0, 0, .58, 1)
  , easeInOut = cubicBezier(.42, 0, .58, 1)
  , isEasingArray = s => Array.isArray(s) && typeof s[0] != "number"
  , easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
}
  , easingDefinitionToFunction = s => {
    if (Array.isArray(s)) {
        invariant(s.length === 4);
        const [e,a,o,c] = s;
        return cubicBezier(e, a, o, c)
    } else if (typeof s == "string")
        return invariant(easingLookup[s] !== void 0),
        easingLookup[s];
    return s
}
  , combineFunctions = (s, e) => a => e(s(a))
  , pipe = (...s) => s.reduce(combineFunctions)
  , progress = (s, e, a) => {
    const o = e - s;
    return o === 0 ? 1 : (a - s) / o
}
  , mixNumber$1 = (s, e, a) => s + (e - s) * a;
function hueToRgb(s, e, a) {
    return a < 0 && (a += 1),
    a > 1 && (a -= 1),
    a < 1 / 6 ? s + (e - s) * 6 * a : a < 1 / 2 ? e : a < 2 / 3 ? s + (e - s) * (2 / 3 - a) * 6 : s
}
function hslaToRgba({hue: s, saturation: e, lightness: a, alpha: o}) {
    s /= 360,
    e /= 100,
    a /= 100;
    let c = 0
      , d = 0
      , g = 0;
    if (!e)
        c = d = g = a;
    else {
        const _ = a < .5 ? a * (1 + e) : a + e - a * e
          , b = 2 * a - _;
        c = hueToRgb(b, _, s + 1 / 3),
        d = hueToRgb(b, _, s),
        g = hueToRgb(b, _, s - 1 / 3)
    }
    return {
        red: Math.round(c * 255),
        green: Math.round(d * 255),
        blue: Math.round(g * 255),
        alpha: o
    }
}
function mixImmediate(s, e) {
    return a => a > 0 ? e : s
}
const mixLinearColor = (s, e, a) => {
    const o = s * s
      , c = a * (e * e - o) + o;
    return c < 0 ? 0 : Math.sqrt(c)
}
  , colorTypes = [hex, rgba, hsla]
  , getColorType = s => colorTypes.find(e => e.test(s));
function asRGBA(s) {
    const e = getColorType(s);
    if (!e)
        return !1;
    let a = e.parse(s);
    return e === hsla && (a = hslaToRgba(a)),
    a
}
const mixColor = (s, e) => {
    const a = asRGBA(s)
      , o = asRGBA(e);
    if (!a || !o)
        return mixImmediate(s, e);
    const c = {
        ...a
    };
    return d => (c.red = mixLinearColor(a.red, o.red, d),
    c.green = mixLinearColor(a.green, o.green, d),
    c.blue = mixLinearColor(a.blue, o.blue, d),
    c.alpha = mixNumber$1(a.alpha, o.alpha, d),
    rgba.transform(c))
}
  , invisibleValues = new Set(["none", "hidden"]);
function mixVisibility(s, e) {
    return invisibleValues.has(s) ? a => a <= 0 ? s : e : a => a >= 1 ? e : s
}
function mixNumber(s, e) {
    return a => mixNumber$1(s, e, a)
}
function getMixer(s) {
    return typeof s == "number" ? mixNumber : typeof s == "string" ? isCSSVariableToken(s) ? mixImmediate : color.test(s) ? mixColor : mixComplex : Array.isArray(s) ? mixArray : typeof s == "object" ? color.test(s) ? mixColor : mixObject : mixImmediate
}
function mixArray(s, e) {
    const a = [...s]
      , o = a.length
      , c = s.map( (d, g) => getMixer(d)(d, e[g]));
    return d => {
        for (let g = 0; g < o; g++)
            a[g] = c[g](d);
        return a
    }
}
function mixObject(s, e) {
    const a = {
        ...s,
        ...e
    }
      , o = {};
    for (const c in a)
        s[c] !== void 0 && e[c] !== void 0 && (o[c] = getMixer(s[c])(s[c], e[c]));
    return c => {
        for (const d in o)
            a[d] = o[d](c);
        return a
    }
}
function matchOrder(s, e) {
    var a;
    const o = []
      , c = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let d = 0; d < e.values.length; d++) {
        const g = e.types[d]
          , _ = s.indexes[g][c[g]]
          , b = (a = s.values[_]) !== null && a !== void 0 ? a : 0;
        o[d] = b,
        c[g]++
    }
    return o
}
const mixComplex = (s, e) => {
    const a = complex.createTransformer(e)
      , o = analyseComplexValue(s)
      , c = analyseComplexValue(e);
    return o.indexes.var.length === c.indexes.var.length && o.indexes.color.length === c.indexes.color.length && o.indexes.number.length >= c.indexes.number.length ? invisibleValues.has(s) && !c.values.length || invisibleValues.has(e) && !o.values.length ? mixVisibility(s, e) : pipe(mixArray(matchOrder(o, c), c.values), a) : mixImmediate(s, e)
}
;
function mix(s, e, a) {
    return typeof s == "number" && typeof e == "number" && typeof a == "number" ? mixNumber$1(s, e, a) : getMixer(s)(s, e)
}
function createMixers(s, e, a) {
    const o = []
      , c = a || mix
      , d = s.length - 1;
    for (let g = 0; g < d; g++) {
        let _ = c(s[g], s[g + 1]);
        if (e) {
            const b = Array.isArray(e) ? e[g] || noop : e;
            _ = pipe(b, _)
        }
        o.push(_)
    }
    return o
}
function interpolate(s, e, {clamp: a=!0, ease: o, mixer: c}={}) {
    const d = s.length;
    if (invariant(d === e.length),
    d === 1)
        return () => e[0];
    if (d === 2 && s[0] === s[1])
        return () => e[1];
    s[0] > s[d - 1] && (s = [...s].reverse(),
    e = [...e].reverse());
    const g = createMixers(e, o, c)
      , _ = g.length
      , b = j => {
        let $ = 0;
        if (_ > 1)
            for (; $ < s.length - 2 && !(j < s[$ + 1]); $++)
                ;
        const nt = progress(s[$], s[$ + 1], j);
        return g[$](nt)
    }
    ;
    return a ? j => b(clamp$1(s[0], s[d - 1], j)) : b
}
function fillOffset(s, e) {
    const a = s[s.length - 1];
    for (let o = 1; o <= e; o++) {
        const c = progress(0, e, o);
        s.push(mixNumber$1(a, 1, c))
    }
}
function defaultOffset(s) {
    const e = [0];
    return fillOffset(e, s.length - 1),
    e
}
function convertOffsetToTimes(s, e) {
    return s.map(a => a * e)
}
function defaultEasing(s, e) {
    return s.map( () => e || easeInOut).splice(0, s.length - 1)
}
function keyframes({duration: s=300, keyframes: e, times: a, ease: o="easeInOut"}) {
    const c = isEasingArray(o) ? o.map(easingDefinitionToFunction) : easingDefinitionToFunction(o)
      , d = {
        done: !1,
        value: e[0]
    }
      , g = convertOffsetToTimes(a && a.length === e.length ? a : defaultOffset(e), s)
      , _ = interpolate(g, e, {
        ease: Array.isArray(c) ? c : defaultEasing(e, c)
    });
    return {
        calculatedDuration: s,
        next: b => (d.value = _(b),
        d.done = b >= s,
        d)
    }
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(s) {
    let e = 0;
    const a = 50;
    let o = s.next(e);
    for (; !o.done && e < maxGeneratorDuration; )
        e += a,
        o = s.next(e);
    return e >= maxGeneratorDuration ? 1 / 0 : e
}
const frameloopDriver = s => {
    const e = ({timestamp: a}) => s(a);
    return {
        start: () => frame.update(e, !0),
        stop: () => cancelFrame(e),
        now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    }
}
  , generators = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
}
  , percentToProgress = s => s / 100;
class MainThreadAnimation extends BaseAnimation {
    constructor(e) {
        super(e),
        this.holdTime = null,
        this.cancelTime = null,
        this.currentTime = 0,
        this.playbackSpeed = 1,
        this.pendingPlayState = "running",
        this.startTime = null,
        this.state = "idle",
        this.stop = () => {
            if (this.resolver.cancel(),
            this.isStopped = !0,
            this.state === "idle")
                return;
            this.teardown();
            const {onStop: b} = this.options;
            b && b()
        }
        ;
        const {name: a, motionValue: o, element: c, keyframes: d} = this.options
          , g = (c == null ? void 0 : c.KeyframeResolver) || KeyframeResolver
          , _ = (b, j) => this.onKeyframesResolved(b, j);
        this.resolver = new g(d,_,a,o,c),
        this.resolver.scheduleResolve()
    }
    initPlayback(e) {
        const {type: a="keyframes", repeat: o=0, repeatDelay: c=0, repeatType: d, velocity: g=0} = this.options
          , _ = isGenerator(a) ? a : generators[a] || keyframes;
        let b, j;
        _ !== keyframes && typeof e[0] != "number" && (b = pipe(percentToProgress, mix(e[0], e[1])),
        e = [0, 100]);
        const $ = _({
            ...this.options,
            keyframes: e
        });
        d === "mirror" && (j = _({
            ...this.options,
            keyframes: [...e].reverse(),
            velocity: -g
        })),
        $.calculatedDuration === null && ($.calculatedDuration = calcGeneratorDuration($));
        const {calculatedDuration: nt} = $
          , tt = nt + c
          , rt = tt * (o + 1) - c;
        return {
            generator: $,
            mirroredGenerator: j,
            mapPercentToKeyframes: b,
            calculatedDuration: nt,
            resolvedDuration: tt,
            totalDuration: rt
        }
    }
    onPostResolved() {
        const {autoplay: e=!0} = this.options;
        this.play(),
        this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState
    }
    tick(e, a=!1) {
        const {resolved: o} = this;
        if (!o) {
            const {keyframes: vt} = this.options;
            return {
                done: !0,
                value: vt[vt.length - 1]
            }
        }
        const {finalKeyframe: c, generator: d, mirroredGenerator: g, mapPercentToKeyframes: _, keyframes: b, calculatedDuration: j, totalDuration: $, resolvedDuration: nt} = o;
        if (this.startTime === null)
            return d.next(0);
        const {delay: tt, repeat: rt, repeatType: st, repeatDelay: lt, onUpdate: ct} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - $ / this.speed, this.startTime)),
        a ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
        const it = this.currentTime - tt * (this.speed >= 0 ? 1 : -1)
          , ot = this.speed >= 0 ? it < 0 : it > $;
        this.currentTime = Math.max(it, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = $);
        let at = this.currentTime
          , ht = d;
        if (rt) {
            const vt = Math.min(this.currentTime, $) / nt;
            let xt = Math.floor(vt)
              , _t = vt % 1;
            !_t && vt >= 1 && (_t = 1),
            _t === 1 && xt--,
            xt = Math.min(xt, rt + 1),
            !!(xt % 2) && (st === "reverse" ? (_t = 1 - _t,
            lt && (_t -= lt / nt)) : st === "mirror" && (ht = g)),
            at = clamp$1(0, 1, _t) * nt
        }
        const pt = ot ? {
            done: !1,
            value: b[0]
        } : ht.next(at);
        _ && (pt.value = _(pt.value));
        let {done: dt} = pt;
        !ot && j !== null && (dt = this.speed >= 0 ? this.currentTime >= $ : this.currentTime <= 0);
        const yt = this.holdTime === null && (this.state === "finished" || this.state === "running" && dt);
        return yt && c !== void 0 && (pt.value = getFinalKeyframe(b, this.options, c)),
        ct && ct(pt.value),
        yt && this.finish(),
        pt
    }
    get duration() {
        const {resolved: e} = this;
        return e ? millisecondsToSeconds(e.calculatedDuration) : 0
    }
    get time() {
        return millisecondsToSeconds(this.currentTime)
    }
    set time(e) {
        e = secondsToMilliseconds(e),
        this.currentTime = e,
        this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(e) {
        const a = this.playbackSpeed !== e;
        this.playbackSpeed = e,
        a && (this.time = millisecondsToSeconds(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
        !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        const {driver: e=frameloopDriver, onPlay: a, startTime: o} = this.options;
        this.driver || (this.driver = e(d => this.tick(d))),
        a && a();
        const c = this.driver.now();
        this.holdTime !== null ? this.startTime = c - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = c) : this.startTime = o ?? this.calcStartTime(),
        this.state === "finished" && this.updateFinishedPromise(),
        this.cancelTime = this.startTime,
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        var e;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
        this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0
    }
    complete() {
        this.state !== "running" && this.play(),
        this.pendingPlayState = this.state = "finished",
        this.holdTime = null
    }
    finish() {
        this.teardown(),
        this.state = "finished";
        const {onComplete: e} = this.options;
        e && e()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
        this.teardown(),
        this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.resolveFinishedPromise(),
        this.updateFinishedPromise(),
        this.startTime = this.cancelTime = null,
        this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(e) {
        return this.startTime = 0,
        this.tick(e, !0)
    }
}
const acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"])
  , isBezierDefinition = s => Array.isArray(s) && typeof s[0] == "number"
  , resolution = 10
  , generateLinearEasing = (s, e) => {
    let a = "";
    const o = Math.max(Math.round(e / resolution), 2);
    for (let c = 0; c < o; c++)
        a += s(progress(0, o - 1, c)) + ", ";
    return `linear(${a.substring(0, a.length - 2)})`
}
;
function memo(s) {
    let e;
    return () => (e === void 0 && (e = s()),
    e)
}
const supportsFlags = {
    linearEasing: void 0
};
function memoSupports(s, e) {
    const a = memo(s);
    return () => {
        var o;
        return (o = supportsFlags[e]) !== null && o !== void 0 ? o : a()
    }
}
const supportsLinearEasing = memoSupports( () => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
, "linearEasing");
function isWaapiSupportedEasing(s) {
    return !!(typeof s == "function" && supportsLinearEasing() || !s || typeof s == "string" && (s in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(s) || Array.isArray(s) && s.every(isWaapiSupportedEasing))
}
const cubicBezierAsString = ([s,e,a,o]) => `cubic-bezier(${s}, ${e}, ${a}, ${o})`
  , supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, .65, .55, 1]),
    circOut: cubicBezierAsString([.55, 0, 1, .45]),
    backIn: cubicBezierAsString([.31, .01, .66, -.59]),
    backOut: cubicBezierAsString([.33, 1.53, .69, .99])
};
function mapEasingToNativeEasing(s, e) {
    if (s)
        return typeof s == "function" && supportsLinearEasing() ? generateLinearEasing(s, e) : isBezierDefinition(s) ? cubicBezierAsString(s) : Array.isArray(s) ? s.map(a => mapEasingToNativeEasing(a, e) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[s]
}
function startWaapiAnimation(s, e, a, {delay: o=0, duration: c=300, repeat: d=0, repeatType: g="loop", ease: _, times: b}={}) {
    const j = {
        [e]: a
    };
    b && (j.offset = b);
    const $ = mapEasingToNativeEasing(_, c);
    return Array.isArray($) && (j.easing = $),
    s.animate(j, {
        delay: o,
        duration: c,
        easing: Array.isArray($) ? "linear" : $,
        fill: "both",
        iterations: d + 1,
        direction: g === "reverse" ? "alternate" : "normal"
    })
}
function attachTimeline(s, e) {
    s.timeline = e,
    s.onfinish = null
}
const supportsWaapi = memo( () => Object.hasOwnProperty.call(Element.prototype, "animate"))
  , sampleDelta = 10
  , maxDuration = 2e4;
function requiresPregeneratedKeyframes(s) {
    return isGenerator(s.type) || s.type === "spring" || !isWaapiSupportedEasing(s.ease)
}
function pregenerateKeyframes(s, e) {
    const a = new MainThreadAnimation({
        ...e,
        keyframes: s,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let o = {
        done: !1,
        value: s[0]
    };
    const c = [];
    let d = 0;
    for (; !o.done && d < maxDuration; )
        o = a.sample(d),
        c.push(o.value),
        d += sampleDelta;
    return {
        times: void 0,
        keyframes: c,
        duration: d - sampleDelta,
        ease: "linear"
    }
}
const unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
};
function isUnsupportedEase(s) {
    return s in unsupportedEasingFunctions
}
class AcceleratedAnimation extends BaseAnimation {
    constructor(e) {
        super(e);
        const {name: a, motionValue: o, element: c, keyframes: d} = this.options;
        this.resolver = new DOMKeyframesResolver(d, (g, _) => this.onKeyframesResolved(g, _),a,o,c),
        this.resolver.scheduleResolve()
    }
    initPlayback(e, a) {
        var o;
        let {duration: c=300, times: d, ease: g, type: _, motionValue: b, name: j, startTime: $} = this.options;
        if (!(!((o = b.owner) === null || o === void 0) && o.current))
            return !1;
        if (typeof g == "string" && supportsLinearEasing() && isUnsupportedEase(g) && (g = unsupportedEasingFunctions[g]),
        requiresPregeneratedKeyframes(this.options)) {
            const {onComplete: tt, onUpdate: rt, motionValue: st, element: lt, ...ct} = this.options
              , it = pregenerateKeyframes(e, ct);
            e = it.keyframes,
            e.length === 1 && (e[1] = e[0]),
            c = it.duration,
            d = it.times,
            g = it.ease,
            _ = "keyframes"
        }
        const nt = startWaapiAnimation(b.owner.current, j, e, {
            ...this.options,
            duration: c,
            times: d,
            ease: g
        });
        return nt.startTime = $ ?? this.calcStartTime(),
        this.pendingTimeline ? (attachTimeline(nt, this.pendingTimeline),
        this.pendingTimeline = void 0) : nt.onfinish = () => {
            const {onComplete: tt} = this.options;
            b.set(getFinalKeyframe(e, this.options, a)),
            tt && tt(),
            this.cancel(),
            this.resolveFinishedPromise()
        }
        ,
        {
            animation: nt,
            duration: c,
            times: d,
            type: _,
            ease: g,
            keyframes: e
        }
    }
    get duration() {
        const {resolved: e} = this;
        if (!e)
            return 0;
        const {duration: a} = e;
        return millisecondsToSeconds(a)
    }
    get time() {
        const {resolved: e} = this;
        if (!e)
            return 0;
        const {animation: a} = e;
        return millisecondsToSeconds(a.currentTime || 0)
    }
    set time(e) {
        const {resolved: a} = this;
        if (!a)
            return;
        const {animation: o} = a;
        o.currentTime = secondsToMilliseconds(e)
    }
    get speed() {
        const {resolved: e} = this;
        if (!e)
            return 1;
        const {animation: a} = e;
        return a.playbackRate
    }
    set speed(e) {
        const {resolved: a} = this;
        if (!a)
            return;
        const {animation: o} = a;
        o.playbackRate = e
    }
    get state() {
        const {resolved: e} = this;
        if (!e)
            return "idle";
        const {animation: a} = e;
        return a.playState
    }
    get startTime() {
        const {resolved: e} = this;
        if (!e)
            return null;
        const {animation: a} = e;
        return a.startTime
    }
    attachTimeline(e) {
        if (!this._resolved)
            this.pendingTimeline = e;
        else {
            const {resolved: a} = this;
            if (!a)
                return noop;
            const {animation: o} = a;
            attachTimeline(o, e)
        }
        return noop
    }
    play() {
        if (this.isStopped)
            return;
        const {resolved: e} = this;
        if (!e)
            return;
        const {animation: a} = e;
        a.playState === "finished" && this.updateFinishedPromise(),
        a.play()
    }
    pause() {
        const {resolved: e} = this;
        if (!e)
            return;
        const {animation: a} = e;
        a.pause()
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        this.resolveFinishedPromise(),
        this.updateFinishedPromise();
        const {resolved: e} = this;
        if (!e)
            return;
        const {animation: a, keyframes: o, duration: c, type: d, ease: g, times: _} = e;
        if (a.playState === "idle" || a.playState === "finished")
            return;
        if (this.time) {
            const {motionValue: j, onUpdate: $, onComplete: nt, element: tt, ...rt} = this.options
              , st = new MainThreadAnimation({
                ...rt,
                keyframes: o,
                duration: c,
                type: d,
                ease: g,
                times: _,
                isGenerator: !0
            })
              , lt = secondsToMilliseconds(this.time);
            j.setWithVelocity(st.sample(lt - sampleDelta).value, st.sample(lt).value, sampleDelta)
        }
        const {onStop: b} = this.options;
        b && b(),
        this.cancel()
    }
    complete() {
        const {resolved: e} = this;
        e && e.animation.finish()
    }
    cancel() {
        const {resolved: e} = this;
        e && e.animation.cancel()
    }
    static supports(e) {
        const {motionValue: a, name: o, repeatDelay: c, repeatType: d, damping: g, type: _} = e;
        return supportsWaapi() && o && acceleratedValues.has(o) && a && a.owner && a.owner.current instanceof HTMLElement && !a.owner.getProps().onUpdate && !c && d !== "mirror" && g !== 0 && _ !== "inertia"
    }
}
const supportsScrollTimeline = memo( () => window.ScrollTimeline !== void 0);
class GroupPlaybackControls {
    constructor(e) {
        this.stop = () => this.runAll("stop"),
        this.animations = e.filter(Boolean)
    }
    then(e, a) {
        return Promise.all(this.animations).then(e).catch(a)
    }
    getAll(e) {
        return this.animations[0][e]
    }
    setAll(e, a) {
        for (let o = 0; o < this.animations.length; o++)
            this.animations[o][e] = a
    }
    attachTimeline(e, a) {
        const o = this.animations.map(c => supportsScrollTimeline() && c.attachTimeline ? c.attachTimeline(e) : a(c));
        return () => {
            o.forEach( (c, d) => {
                c && c(),
                this.animations[d].stop()
            }
            )
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(e) {
        this.setAll("time", e)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(e) {
        this.setAll("speed", e)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let e = 0;
        for (let a = 0; a < this.animations.length; a++)
            e = Math.max(e, this.animations[a].duration);
        return e
    }
    runAll(e) {
        this.animations.forEach(a => a[e]())
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
function isTransitionDefined({when: s, delay: e, delayChildren: a, staggerChildren: o, staggerDirection: c, repeat: d, repeatType: g, repeatDelay: _, from: b, elapsed: j, ...$}) {
    return !!Object.keys($).length
}
const animateMotionValue = (s, e, a, o={}, c, d) => g => {
    const _ = getValueTransition(o, s) || {}
      , b = _.delay || o.delay || 0;
    let {elapsed: j=0} = o;
    j = j - secondsToMilliseconds(b);
    let $ = {
        keyframes: Array.isArray(a) ? a : [null, a],
        ease: "easeOut",
        velocity: e.getVelocity(),
        ..._,
        delay: -j,
        onUpdate: tt => {
            e.set(tt),
            _.onUpdate && _.onUpdate(tt)
        }
        ,
        onComplete: () => {
            g(),
            _.onComplete && _.onComplete()
        }
        ,
        name: s,
        motionValue: e,
        element: d ? void 0 : c
    };
    isTransitionDefined(_) || ($ = {
        ...$,
        ...getDefaultTransition(s, $)
    }),
    $.duration && ($.duration = secondsToMilliseconds($.duration)),
    $.repeatDelay && ($.repeatDelay = secondsToMilliseconds($.repeatDelay)),
    $.from !== void 0 && ($.keyframes[0] = $.from);
    let nt = !1;
    if (($.type === !1 || $.duration === 0 && !$.repeatDelay) && ($.duration = 0,
    $.delay === 0 && (nt = !0)),
    nt && !d && e.get() !== void 0) {
        const tt = getFinalKeyframe($.keyframes, _);
        if (tt !== void 0)
            return frame.update( () => {
                $.onUpdate(tt),
                $.onComplete()
            }
            ),
            new GroupPlaybackControls([])
    }
    return !d && AcceleratedAnimation.supports($) ? new AcceleratedAnimation($) : new MainThreadAnimation($)
}
  , isCustomValue = s => !!(s && typeof s == "object" && s.mix && s.toValue)
  , resolveFinalValueInKeyframes = s => isKeyframesTarget(s) ? s[s.length - 1] || 0 : s;
function addUniqueItem(s, e) {
    s.indexOf(e) === -1 && s.push(e)
}
function removeItem(s, e) {
    const a = s.indexOf(e);
    a > -1 && s.splice(a, 1)
}
class SubscriptionManager {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return addUniqueItem(this.subscriptions, e),
        () => removeItem(this.subscriptions, e)
    }
    notify(e, a, o) {
        const c = this.subscriptions.length;
        if (c)
            if (c === 1)
                this.subscriptions[0](e, a, o);
            else
                for (let d = 0; d < c; d++) {
                    const g = this.subscriptions[d];
                    g && g(e, a, o)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const MAX_VELOCITY_DELTA = 30
  , isFloat = s => !isNaN(parseFloat(s));
class MotionValue {
    constructor(e, a={}) {
        this.version = "11.11.1",
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = (o, c=!0) => {
            const d = time.now();
            this.updatedAt !== d && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(o),
            this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
            c && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(e),
        this.owner = a.owner
    }
    setCurrent(e) {
        this.current = e,
        this.updatedAt = time.now(),
        this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = isFloat(this.current))
    }
    setPrevFrameValue(e=this.current) {
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, a) {
        this.events[e] || (this.events[e] = new SubscriptionManager);
        const o = this.events[e].add(a);
        return e === "change" ? () => {
            o(),
            frame.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : o
    }
    clearListeners() {
        for (const e in this.events)
            this.events[e].clear()
    }
    attach(e, a) {
        this.passiveEffect = e,
        this.stopPassiveEffect = a
    }
    set(e, a=!0) {
        !a || !this.passiveEffect ? this.updateAndNotify(e, a) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, a, o) {
        this.set(a),
        this.prev = void 0,
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt - o
    }
    jump(e, a=!0) {
        this.updateAndNotify(e),
        this.prev = e,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        a && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const e = time.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > MAX_VELOCITY_DELTA)
            return 0;
        const a = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
        return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), a)
    }
    start(e) {
        return this.stop(),
        new Promise(a => {
            this.hasAnimated = !0,
            this.animation = e(a),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function motionValue(s, e) {
    return new MotionValue(s,e)
}
function setMotionValue(s, e, a) {
    s.hasValue(e) ? s.getValue(e).set(a) : s.addValue(e, motionValue(a))
}
function setTarget(s, e) {
    const a = resolveVariant(s, e);
    let {transitionEnd: o={}, transition: c={}, ...d} = a || {};
    d = {
        ...d,
        ...o
    };
    for (const g in d) {
        const _ = resolveFinalValueInKeyframes(d[g]);
        setMotionValue(s, g, _)
    }
}
const camelToDash = s => s.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , optimizedAppearDataId = "framerAppearId"
  , optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(s) {
    return s.props[optimizedAppearDataAttribute]
}
const isMotionValue = s => !!(s && s.getVelocity);
function isWillChangeMotionValue(s) {
    return !!(isMotionValue(s) && s.add)
}
function getWillChangeName(s) {
    if (transformProps.has(s))
        return "transform";
    if (acceleratedValues.has(s))
        return camelToDash(s)
}
function addValueToWillChange(s, e) {
    var a;
    if (!s.applyWillChange)
        return;
    const o = s.getValue("willChange");
    if (isWillChangeMotionValue(o))
        return o.add(e);
    !(!((a = s.props.style) === null || a === void 0) && a.willChange) && getWillChangeName(e) && s.setStaticValue("willChange", "transform")
}
function shouldBlockAnimation({protectedKeys: s, needsAnimating: e}, a) {
    const o = s.hasOwnProperty(a) && e[a] !== !0;
    return e[a] = !1,
    o
}
function animateTarget(s, e, {delay: a=0, transitionOverride: o, type: c}={}) {
    var d;
    let {transition: g=s.getDefaultTransition(), transitionEnd: _, ...b} = e;
    o && (g = o);
    const j = []
      , $ = c && s.animationState && s.animationState.getState()[c];
    for (const nt in b) {
        const tt = s.getValue(nt, (d = s.latestValues[nt]) !== null && d !== void 0 ? d : null)
          , rt = b[nt];
        if (rt === void 0 || $ && shouldBlockAnimation($, nt))
            continue;
        const st = {
            delay: a,
            ...getValueTransition(g || {}, nt)
        };
        let lt = !1;
        if (window.MotionHandoffAnimation) {
            const it = getOptimisedAppearId(s);
            if (it) {
                const ot = window.MotionHandoffAnimation(it, nt, frame);
                ot !== null && (st.startTime = ot,
                lt = !0)
            }
        }
        addValueToWillChange(s, nt),
        tt.start(animateMotionValue(nt, tt, rt, s.shouldReduceMotion && transformProps.has(nt) ? {
            type: !1
        } : st, s, lt));
        const ct = tt.animation;
        ct && j.push(ct)
    }
    return _ && Promise.all(j).then( () => {
        frame.update( () => {
            _ && setTarget(s, _)
        }
        )
    }
    ),
    j
}
function animateVariant(s, e, a={}) {
    var o;
    const c = resolveVariant(s, e, a.type === "exit" ? (o = s.presenceContext) === null || o === void 0 ? void 0 : o.custom : void 0);
    let {transition: d=s.getDefaultTransition() || {}} = c || {};
    a.transitionOverride && (d = a.transitionOverride);
    const g = c ? () => Promise.all(animateTarget(s, c, a)) : () => Promise.resolve()
      , _ = s.variantChildren && s.variantChildren.size ? (j=0) => {
        const {delayChildren: $=0, staggerChildren: nt, staggerDirection: tt} = d;
        return animateChildren(s, e, $ + j, nt, tt, a)
    }
    : () => Promise.resolve()
      , {when: b} = d;
    if (b) {
        const [j,$] = b === "beforeChildren" ? [g, _] : [_, g];
        return j().then( () => $())
    } else
        return Promise.all([g(), _(a.delay)])
}
function animateChildren(s, e, a=0, o=0, c=1, d) {
    const g = []
      , _ = (s.variantChildren.size - 1) * o
      , b = c === 1 ? (j=0) => j * o : (j=0) => _ - j * o;
    return Array.from(s.variantChildren).sort(sortByTreeOrder).forEach( (j, $) => {
        j.notify("AnimationStart", e),
        g.push(animateVariant(j, e, {
            ...d,
            delay: a + b($)
        }).then( () => j.notify("AnimationComplete", e)))
    }
    ),
    Promise.all(g)
}
function sortByTreeOrder(s, e) {
    return s.sortNodePosition(e)
}
function animateVisualElement(s, e, a={}) {
    s.notify("AnimationStart", e);
    let o;
    if (Array.isArray(e)) {
        const c = e.map(d => animateVariant(s, d, a));
        o = Promise.all(c)
    } else if (typeof e == "string")
        o = animateVariant(s, e, a);
    else {
        const c = typeof e == "function" ? resolveVariant(s, e, a.custom) : e;
        o = Promise.all(animateTarget(s, c, a))
    }
    return o.then( () => {
        s.notify("AnimationComplete", e)
    }
    )
}
const numVariantProps = variantProps.length;
function getVariantContext(s) {
    if (!s)
        return;
    if (!s.isControllingVariants) {
        const a = s.parent ? getVariantContext(s.parent) || {} : {};
        return s.props.initial !== void 0 && (a.initial = s.props.initial),
        a
    }
    const e = {};
    for (let a = 0; a < numVariantProps; a++) {
        const o = variantProps[a]
          , c = s.props[o];
        (isVariantLabel(c) || c === !1) && (e[o] = c)
    }
    return e
}
const reversePriorityOrder = [...variantPriorityOrder].reverse()
  , numAnimationTypes = variantPriorityOrder.length;
function animateList(s) {
    return e => Promise.all(e.map( ({animation: a, options: o}) => animateVisualElement(s, a, o)))
}
function createAnimationState(s) {
    let e = animateList(s)
      , a = createState()
      , o = !0;
    const c = b => (j, $) => {
        var nt;
        const tt = resolveVariant(s, $, b === "exit" ? (nt = s.presenceContext) === null || nt === void 0 ? void 0 : nt.custom : void 0);
        if (tt) {
            const {transition: rt, transitionEnd: st, ...lt} = tt;
            j = {
                ...j,
                ...lt,
                ...st
            }
        }
        return j
    }
    ;
    function d(b) {
        e = b(s)
    }
    function g(b) {
        const {props: j} = s
          , $ = getVariantContext(s.parent) || {}
          , nt = []
          , tt = new Set;
        let rt = {}
          , st = 1 / 0;
        for (let ct = 0; ct < numAnimationTypes; ct++) {
            const it = reversePriorityOrder[ct]
              , ot = a[it]
              , at = j[it] !== void 0 ? j[it] : $[it]
              , ht = isVariantLabel(at)
              , pt = it === b ? ot.isActive : null;
            pt === !1 && (st = ct);
            let dt = at === $[it] && at !== j[it] && ht;
            if (dt && o && s.manuallyAnimateOnMount && (dt = !1),
            ot.protectedKeys = {
                ...rt
            },
            !ot.isActive && pt === null || !at && !ot.prevProp || isAnimationControls(at) || typeof at == "boolean")
                continue;
            const yt = checkVariantsDidChange(ot.prevProp, at);
            let vt = yt || it === b && ot.isActive && !dt && ht || ct > st && ht
              , xt = !1;
            const _t = Array.isArray(at) ? at : [at];
            let bt = _t.reduce(c(it), {});
            pt === !1 && (bt = {});
            const {prevResolvedValues: Rt={}} = ot
              , Ft = {
                ...Rt,
                ...bt
            }
              , Bt = Tt => {
                vt = !0,
                tt.has(Tt) && (xt = !0,
                tt.delete(Tt)),
                ot.needsAnimating[Tt] = !0;
                const mt = s.getValue(Tt);
                mt && (mt.liveStyle = !1)
            }
            ;
            for (const Tt in Ft) {
                const mt = bt[Tt]
                  , St = Rt[Tt];
                if (rt.hasOwnProperty(Tt))
                    continue;
                let wt = !1;
                isKeyframesTarget(mt) && isKeyframesTarget(St) ? wt = !shallowCompare(mt, St) : wt = mt !== St,
                wt ? mt != null ? Bt(Tt) : tt.add(Tt) : mt !== void 0 && tt.has(Tt) ? Bt(Tt) : ot.protectedKeys[Tt] = !0
            }
            ot.prevProp = at,
            ot.prevResolvedValues = bt,
            ot.isActive && (rt = {
                ...rt,
                ...bt
            }),
            o && s.blockInitialAnimation && (vt = !1),
            vt && (!(dt && yt) || xt) && nt.push(..._t.map(Tt => ({
                animation: Tt,
                options: {
                    type: it
                }
            })))
        }
        if (tt.size) {
            const ct = {};
            tt.forEach(it => {
                const ot = s.getBaseTarget(it)
                  , at = s.getValue(it);
                at && (at.liveStyle = !0),
                ct[it] = ot ?? null
            }
            ),
            nt.push({
                animation: ct
            })
        }
        let lt = !!nt.length;
        return o && (j.initial === !1 || j.initial === j.animate) && !s.manuallyAnimateOnMount && (lt = !1),
        o = !1,
        lt ? e(nt) : Promise.resolve()
    }
    function _(b, j) {
        var $;
        if (a[b].isActive === j)
            return Promise.resolve();
        ($ = s.variantChildren) === null || $ === void 0 || $.forEach(tt => {
            var rt;
            return (rt = tt.animationState) === null || rt === void 0 ? void 0 : rt.setActive(b, j)
        }
        ),
        a[b].isActive = j;
        const nt = g(b);
        for (const tt in a)
            a[tt].protectedKeys = {};
        return nt
    }
    return {
        animateChanges: g,
        setActive: _,
        setAnimateFunction: d,
        getState: () => a,
        reset: () => {
            a = createState(),
            o = !0
        }
    }
}
function checkVariantsDidChange(s, e) {
    return typeof e == "string" ? e !== s : Array.isArray(e) ? !shallowCompare(e, s) : !1
}
function createTypeState(s=!1) {
    return {
        isActive: s,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function createState() {
    return {
        animate: createTypeState(!0),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
    }
}
class Feature {
    constructor(e) {
        this.isMounted = !1,
        this.node = e
    }
    update() {}
}
class AnimationFeature extends Feature {
    constructor(e) {
        super(e),
        e.animationState || (e.animationState = createAnimationState(e))
    }
    updateAnimationControlsSubscription() {
        const {animate: e} = this.node.getProps();
        isAnimationControls(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: e} = this.node.getProps()
          , {animate: a} = this.node.prevProps || {};
        e !== a && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var e;
        this.node.animationState.reset(),
        (e = this.unmountControls) === null || e === void 0 || e.call(this)
    }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
    constructor() {
        super(...arguments),
        this.id = id$1++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: e, onExitComplete: a} = this.node.presenceContext
          , {isPresent: o} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === o)
            return;
        const c = this.node.animationState.setActive("exit", !e);
        a && !e && c.then( () => a(this.id))
    }
    mount() {
        const {register: e} = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const animations = {
    animation: {
        Feature: AnimationFeature
    },
    exit: {
        Feature: ExitAnimationFeature
    }
}
  , isPrimaryPointer = s => s.pointerType === "mouse" ? typeof s.button != "number" || s.button <= 0 : s.isPrimary !== !1;
function extractEventInfo(s, e="page") {
    return {
        point: {
            x: s[`${e}X`],
            y: s[`${e}Y`]
        }
    }
}
const addPointerInfo = s => e => isPrimaryPointer(e) && s(e, extractEventInfo(e));
function addDomEvent(s, e, a, o={
    passive: !0
}) {
    return s.addEventListener(e, a, o),
    () => s.removeEventListener(e, a)
}
function addPointerEvent(s, e, a, o) {
    return addDomEvent(s, e, addPointerInfo(a), o)
}
const distance = (s, e) => Math.abs(s - e);
function distance2D(s, e) {
    const a = distance(s.x, e.x)
      , o = distance(s.y, e.y);
    return Math.sqrt(a ** 2 + o ** 2)
}
class PanSession {
    constructor(e, a, {transformPagePoint: o, contextWindow: c, dragSnapToOrigin: d=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const nt = getPanInfo(this.lastMoveEventInfo, this.history)
              , tt = this.startEvent !== null
              , rt = distance2D(nt.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!tt && !rt)
                return;
            const {point: st} = nt
              , {timestamp: lt} = frameData;
            this.history.push({
                ...st,
                timestamp: lt
            });
            const {onStart: ct, onMove: it} = this.handlers;
            tt || (ct && ct(this.lastMoveEvent, nt),
            this.startEvent = this.lastMoveEvent),
            it && it(this.lastMoveEvent, nt)
        }
        ,
        this.handlePointerMove = (nt, tt) => {
            this.lastMoveEvent = nt,
            this.lastMoveEventInfo = transformPoint(tt, this.transformPagePoint),
            frame.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (nt, tt) => {
            this.end();
            const {onEnd: rt, onSessionEnd: st, resumeAnimation: lt} = this.handlers;
            if (this.dragSnapToOrigin && lt && lt(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const ct = getPanInfo(nt.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(tt, this.transformPagePoint), this.history);
            this.startEvent && rt && rt(nt, ct),
            st && st(nt, ct)
        }
        ,
        !isPrimaryPointer(e))
            return;
        this.dragSnapToOrigin = d,
        this.handlers = a,
        this.transformPagePoint = o,
        this.contextWindow = c || window;
        const g = extractEventInfo(e)
          , _ = transformPoint(g, this.transformPagePoint)
          , {point: b} = _
          , {timestamp: j} = frameData;
        this.history = [{
            ...b,
            timestamp: j
        }];
        const {onSessionStart: $} = a;
        $ && $(e, getPanInfo(_, this.history)),
        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
        cancelFrame(this.updatePoint)
    }
}
function transformPoint(s, e) {
    return e ? {
        point: e(s.point)
    } : s
}
function subtractPoint(s, e) {
    return {
        x: s.x - e.x,
        y: s.y - e.y
    }
}
function getPanInfo({point: s}, e) {
    return {
        point: s,
        delta: subtractPoint(s, lastDevicePoint(e)),
        offset: subtractPoint(s, startDevicePoint(e)),
        velocity: getVelocity(e, .1)
    }
}
function startDevicePoint(s) {
    return s[0]
}
function lastDevicePoint(s) {
    return s[s.length - 1]
}
function getVelocity(s, e) {
    if (s.length < 2)
        return {
            x: 0,
            y: 0
        };
    let a = s.length - 1
      , o = null;
    const c = lastDevicePoint(s);
    for (; a >= 0 && (o = s[a],
    !(c.timestamp - o.timestamp > secondsToMilliseconds(e))); )
        a--;
    if (!o)
        return {
            x: 0,
            y: 0
        };
    const d = millisecondsToSeconds(c.timestamp - o.timestamp);
    if (d === 0)
        return {
            x: 0,
            y: 0
        };
    const g = {
        x: (c.x - o.x) / d,
        y: (c.y - o.y) / d
    };
    return g.x === 1 / 0 && (g.x = 0),
    g.y === 1 / 0 && (g.y = 0),
    g
}
function createLock(s) {
    let e = null;
    return () => {
        const a = () => {
            e = null
        }
        ;
        return e === null ? (e = s,
        a) : !1
    }
}
const globalHorizontalLock = createLock("dragHorizontal")
  , globalVerticalLock = createLock("dragVertical");
function getGlobalLock(s) {
    let e = !1;
    if (s === "y")
        e = globalVerticalLock();
    else if (s === "x")
        e = globalHorizontalLock();
    else {
        const a = globalHorizontalLock()
          , o = globalVerticalLock();
        a && o ? e = () => {
            a(),
            o()
        }
        : (a && a(),
        o && o())
    }
    return e
}
function isDragActive() {
    const s = getGlobalLock(!0);
    return s ? (s(),
    !1) : !0
}
function isRefObject$1(s) {
    return s && typeof s == "object" && Object.prototype.hasOwnProperty.call(s, "current")
}
const SCALE_PRECISION = 1e-4
  , SCALE_MIN = 1 - SCALE_PRECISION
  , SCALE_MAX = 1 + SCALE_PRECISION
  , TRANSLATE_PRECISION = .01
  , TRANSLATE_MIN = 0 - TRANSLATE_PRECISION
  , TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(s) {
    return s.max - s.min
}
function isNear(s, e, a) {
    return Math.abs(s - e) <= a
}
function calcAxisDelta(s, e, a, o=.5) {
    s.origin = o,
    s.originPoint = mixNumber$1(e.min, e.max, s.origin),
    s.scale = calcLength(a) / calcLength(e),
    s.translate = mixNumber$1(a.min, a.max, s.origin) - s.originPoint,
    (s.scale >= SCALE_MIN && s.scale <= SCALE_MAX || isNaN(s.scale)) && (s.scale = 1),
    (s.translate >= TRANSLATE_MIN && s.translate <= TRANSLATE_MAX || isNaN(s.translate)) && (s.translate = 0)
}
function calcBoxDelta(s, e, a, o) {
    calcAxisDelta(s.x, e.x, a.x, o ? o.originX : void 0),
    calcAxisDelta(s.y, e.y, a.y, o ? o.originY : void 0)
}
function calcRelativeAxis(s, e, a) {
    s.min = a.min + e.min,
    s.max = s.min + calcLength(e)
}
function calcRelativeBox(s, e, a) {
    calcRelativeAxis(s.x, e.x, a.x),
    calcRelativeAxis(s.y, e.y, a.y)
}
function calcRelativeAxisPosition(s, e, a) {
    s.min = e.min - a.min,
    s.max = s.min + calcLength(e)
}
function calcRelativePosition(s, e, a) {
    calcRelativeAxisPosition(s.x, e.x, a.x),
    calcRelativeAxisPosition(s.y, e.y, a.y)
}
function applyConstraints(s, {min: e, max: a}, o) {
    return e !== void 0 && s < e ? s = o ? mixNumber$1(e, s, o.min) : Math.max(s, e) : a !== void 0 && s > a && (s = o ? mixNumber$1(a, s, o.max) : Math.min(s, a)),
    s
}
function calcRelativeAxisConstraints(s, e, a) {
    return {
        min: e !== void 0 ? s.min + e : void 0,
        max: a !== void 0 ? s.max + a - (s.max - s.min) : void 0
    }
}
function calcRelativeConstraints(s, {top: e, left: a, bottom: o, right: c}) {
    return {
        x: calcRelativeAxisConstraints(s.x, a, c),
        y: calcRelativeAxisConstraints(s.y, e, o)
    }
}
function calcViewportAxisConstraints(s, e) {
    let a = e.min - s.min
      , o = e.max - s.max;
    return e.max - e.min < s.max - s.min && ([a,o] = [o, a]),
    {
        min: a,
        max: o
    }
}
function calcViewportConstraints(s, e) {
    return {
        x: calcViewportAxisConstraints(s.x, e.x),
        y: calcViewportAxisConstraints(s.y, e.y)
    }
}
function calcOrigin$1(s, e) {
    let a = .5;
    const o = calcLength(s)
      , c = calcLength(e);
    return c > o ? a = progress(e.min, e.max - o, s.min) : o > c && (a = progress(s.min, s.max - c, e.min)),
    clamp$1(0, 1, a)
}
function rebaseAxisConstraints(s, e) {
    const a = {};
    return e.min !== void 0 && (a.min = e.min - s.min),
    e.max !== void 0 && (a.max = e.max - s.min),
    a
}
const defaultElastic = .35;
function resolveDragElastic(s=defaultElastic) {
    return s === !1 ? s = 0 : s === !0 && (s = defaultElastic),
    {
        x: resolveAxisElastic(s, "left", "right"),
        y: resolveAxisElastic(s, "top", "bottom")
    }
}
function resolveAxisElastic(s, e, a) {
    return {
        min: resolvePointElastic(s, e),
        max: resolvePointElastic(s, a)
    }
}
function resolvePointElastic(s, e) {
    return typeof s == "number" ? s : s[e] || 0
}
const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
})
  , createAxis = () => ({
    min: 0,
    max: 0
})
  , createBox = () => ({
    x: createAxis(),
    y: createAxis()
});
function eachAxis(s) {
    return [s("x"), s("y")]
}
function convertBoundingBoxToBox({top: s, left: e, right: a, bottom: o}) {
    return {
        x: {
            min: e,
            max: a
        },
        y: {
            min: s,
            max: o
        }
    }
}
function convertBoxToBoundingBox({x: s, y: e}) {
    return {
        top: e.min,
        right: s.max,
        bottom: e.max,
        left: s.min
    }
}
function transformBoxPoints(s, e) {
    if (!e)
        return s;
    const a = e({
        x: s.left,
        y: s.top
    })
      , o = e({
        x: s.right,
        y: s.bottom
    });
    return {
        top: a.y,
        left: a.x,
        bottom: o.y,
        right: o.x
    }
}
function isIdentityScale(s) {
    return s === void 0 || s === 1
}
function hasScale({scale: s, scaleX: e, scaleY: a}) {
    return !isIdentityScale(s) || !isIdentityScale(e) || !isIdentityScale(a)
}
function hasTransform(s) {
    return hasScale(s) || has2DTranslate(s) || s.z || s.rotate || s.rotateX || s.rotateY || s.skewX || s.skewY
}
function has2DTranslate(s) {
    return is2DTranslate(s.x) || is2DTranslate(s.y)
}
function is2DTranslate(s) {
    return s && s !== "0%"
}
function scalePoint(s, e, a) {
    const o = s - a
      , c = e * o;
    return a + c
}
function applyPointDelta(s, e, a, o, c) {
    return c !== void 0 && (s = scalePoint(s, c, o)),
    scalePoint(s, a, o) + e
}
function applyAxisDelta(s, e=0, a=1, o, c) {
    s.min = applyPointDelta(s.min, e, a, o, c),
    s.max = applyPointDelta(s.max, e, a, o, c)
}
function applyBoxDelta(s, {x: e, y: a}) {
    applyAxisDelta(s.x, e.translate, e.scale, e.originPoint),
    applyAxisDelta(s.y, a.translate, a.scale, a.originPoint)
}
const TREE_SCALE_SNAP_MIN = .999999999999
  , TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(s, e, a, o=!1) {
    const c = a.length;
    if (!c)
        return;
    e.x = e.y = 1;
    let d, g;
    for (let _ = 0; _ < c; _++) {
        d = a[_],
        g = d.projectionDelta;
        const {visualElement: b} = d.options;
        b && b.props.style && b.props.style.display === "contents" || (o && d.options.layoutScroll && d.scroll && d !== d.root && transformBox(s, {
            x: -d.scroll.offset.x,
            y: -d.scroll.offset.y
        }),
        g && (e.x *= g.x.scale,
        e.y *= g.y.scale,
        applyBoxDelta(s, g)),
        o && hasTransform(d.latestValues) && transformBox(s, d.latestValues))
    }
    e.x < TREE_SCALE_SNAP_MAX && e.x > TREE_SCALE_SNAP_MIN && (e.x = 1),
    e.y < TREE_SCALE_SNAP_MAX && e.y > TREE_SCALE_SNAP_MIN && (e.y = 1)
}
function translateAxis(s, e) {
    s.min = s.min + e,
    s.max = s.max + e
}
function transformAxis(s, e, a, o, c=.5) {
    const d = mixNumber$1(s.min, s.max, c);
    applyAxisDelta(s, e, a, d, o)
}
function transformBox(s, e) {
    transformAxis(s.x, e.x, e.scaleX, e.scale, e.originX),
    transformAxis(s.y, e.y, e.scaleY, e.scale, e.originY)
}
function measureViewportBox(s, e) {
    return convertBoundingBoxToBox(transformBoxPoints(s.getBoundingClientRect(), e))
}
function measurePageBox(s, e, a) {
    const o = measureViewportBox(s, a)
      , {scroll: c} = e;
    return c && (translateAxis(o.x, c.offset.x),
    translateAxis(o.y, c.offset.y)),
    o
}
const getContextWindow = ({current: s}) => s ? s.ownerDocument.defaultView : null
  , elementDragControls = new WeakMap;
class VisualElementDragControls {
    constructor(e) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = createBox(),
        this.visualElement = e
    }
    start(e, {snapToCursor: a=!1}={}) {
        const {presenceContext: o} = this.visualElement;
        if (o && o.isPresent === !1)
            return;
        const c = $ => {
            const {dragSnapToOrigin: nt} = this.getProps();
            nt ? this.pauseAnimation() : this.stopAnimation(),
            a && this.snapToCursor(extractEventInfo($, "page").point)
        }
          , d = ($, nt) => {
            const {drag: tt, dragPropagation: rt, onDragStart: st} = this.getProps();
            if (tt && !rt && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = getGlobalLock(tt),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            eachAxis(ct => {
                let it = this.getAxisMotionValue(ct).get() || 0;
                if (percent.test(it)) {
                    const {projection: ot} = this.visualElement;
                    if (ot && ot.layout) {
                        const at = ot.layout.layoutBox[ct];
                        at && (it = calcLength(at) * (parseFloat(it) / 100))
                    }
                }
                this.originPoint[ct] = it
            }
            ),
            st && frame.postRender( () => st($, nt)),
            addValueToWillChange(this.visualElement, "transform");
            const {animationState: lt} = this.visualElement;
            lt && lt.setActive("whileDrag", !0)
        }
          , g = ($, nt) => {
            const {dragPropagation: tt, dragDirectionLock: rt, onDirectionLock: st, onDrag: lt} = this.getProps();
            if (!tt && !this.openGlobalLock)
                return;
            const {offset: ct} = nt;
            if (rt && this.currentDirection === null) {
                this.currentDirection = getCurrentDirection(ct),
                this.currentDirection !== null && st && st(this.currentDirection);
                return
            }
            this.updateAxis("x", nt.point, ct),
            this.updateAxis("y", nt.point, ct),
            this.visualElement.render(),
            lt && lt($, nt)
        }
          , _ = ($, nt) => this.stop($, nt)
          , b = () => eachAxis($ => {
            var nt;
            return this.getAnimationState($) === "paused" && ((nt = this.getAxisMotionValue($).animation) === null || nt === void 0 ? void 0 : nt.play())
        }
        )
          , {dragSnapToOrigin: j} = this.getProps();
        this.panSession = new PanSession(e,{
            onSessionStart: c,
            onStart: d,
            onMove: g,
            onSessionEnd: _,
            resumeAnimation: b
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: j,
            contextWindow: getContextWindow(this.visualElement)
        })
    }
    stop(e, a) {
        const o = this.isDragging;
        if (this.cancel(),
        !o)
            return;
        const {velocity: c} = a;
        this.startAnimation(c);
        const {onDragEnd: d} = this.getProps();
        d && frame.postRender( () => d(e, a))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: e, animationState: a} = this.visualElement;
        e && (e.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: o} = this.getProps();
        !o && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        a && a.setActive("whileDrag", !1)
    }
    updateAxis(e, a, o) {
        const {drag: c} = this.getProps();
        if (!o || !shouldDrag(e, c, this.currentDirection))
            return;
        const d = this.getAxisMotionValue(e);
        let g = this.originPoint[e] + o[e];
        this.constraints && this.constraints[e] && (g = applyConstraints(g, this.constraints[e], this.elastic[e])),
        d.set(g)
    }
    resolveConstraints() {
        var e;
        const {dragConstraints: a, dragElastic: o} = this.getProps()
          , c = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout
          , d = this.constraints;
        a && isRefObject$1(a) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : a && c ? this.constraints = calcRelativeConstraints(c.layoutBox, a) : this.constraints = !1,
        this.elastic = resolveDragElastic(o),
        d !== this.constraints && c && this.constraints && !this.hasMutatedConstraints && eachAxis(g => {
            this.constraints !== !1 && this.getAxisMotionValue(g) && (this.constraints[g] = rebaseAxisConstraints(c.layoutBox[g], this.constraints[g]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: e, onMeasureDragConstraints: a} = this.getProps();
        if (!e || !isRefObject$1(e))
            return !1;
        const o = e.current
          , {projection: c} = this.visualElement;
        if (!c || !c.layout)
            return !1;
        const d = measurePageBox(o, c.root, this.visualElement.getTransformPagePoint());
        let g = calcViewportConstraints(c.layout.layoutBox, d);
        if (a) {
            const _ = a(convertBoxToBoundingBox(g));
            this.hasMutatedConstraints = !!_,
            _ && (g = convertBoundingBoxToBox(_))
        }
        return g
    }
    startAnimation(e) {
        const {drag: a, dragMomentum: o, dragElastic: c, dragTransition: d, dragSnapToOrigin: g, onDragTransitionEnd: _} = this.getProps()
          , b = this.constraints || {}
          , j = eachAxis($ => {
            if (!shouldDrag($, a, this.currentDirection))
                return;
            let nt = b && b[$] || {};
            g && (nt = {
                min: 0,
                max: 0
            });
            const tt = c ? 200 : 1e6
              , rt = c ? 40 : 1e7
              , st = {
                type: "inertia",
                velocity: o ? e[$] : 0,
                bounceStiffness: tt,
                bounceDamping: rt,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...d,
                ...nt
            };
            return this.startAxisValueAnimation($, st)
        }
        );
        return Promise.all(j).then(_)
    }
    startAxisValueAnimation(e, a) {
        const o = this.getAxisMotionValue(e);
        return addValueToWillChange(this.visualElement, e),
        o.start(animateMotionValue(e, o, 0, a, this.visualElement, !1))
    }
    stopAnimation() {
        eachAxis(e => this.getAxisMotionValue(e).stop())
    }
    pauseAnimation() {
        eachAxis(e => {
            var a;
            return (a = this.getAxisMotionValue(e).animation) === null || a === void 0 ? void 0 : a.pause()
        }
        )
    }
    getAnimationState(e) {
        var a;
        return (a = this.getAxisMotionValue(e).animation) === null || a === void 0 ? void 0 : a.state
    }
    getAxisMotionValue(e) {
        const a = `_drag${e.toUpperCase()}`
          , o = this.visualElement.getProps()
          , c = o[a];
        return c || this.visualElement.getValue(e, (o.initial ? o.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        eachAxis(a => {
            const {drag: o} = this.getProps();
            if (!shouldDrag(a, o, this.currentDirection))
                return;
            const {projection: c} = this.visualElement
              , d = this.getAxisMotionValue(a);
            if (c && c.layout) {
                const {min: g, max: _} = c.layout.layoutBox[a];
                d.set(e[a] - mixNumber$1(g, _, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: e, dragConstraints: a} = this.getProps()
          , {projection: o} = this.visualElement;
        if (!isRefObject$1(a) || !o || !this.constraints)
            return;
        this.stopAnimation();
        const c = {
            x: 0,
            y: 0
        };
        eachAxis(g => {
            const _ = this.getAxisMotionValue(g);
            if (_ && this.constraints !== !1) {
                const b = _.get();
                c[g] = calcOrigin$1({
                    min: b,
                    max: b
                }, this.constraints[g])
            }
        }
        );
        const {transformTemplate: d} = this.visualElement.getProps();
        this.visualElement.current.style.transform = d ? d({}, "") : "none",
        o.root && o.root.updateScroll(),
        o.updateLayout(),
        this.resolveConstraints(),
        eachAxis(g => {
            if (!shouldDrag(g, e, null))
                return;
            const _ = this.getAxisMotionValue(g)
              , {min: b, max: j} = this.constraints[g];
            _.set(mixNumber$1(b, j, c[g]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        elementDragControls.set(this.visualElement, this);
        const e = this.visualElement.current
          , a = addPointerEvent(e, "pointerdown", b => {
            const {drag: j, dragListener: $=!0} = this.getProps();
            j && $ && this.start(b)
        }
        )
          , o = () => {
            const {dragConstraints: b} = this.getProps();
            isRefObject$1(b) && b.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: c} = this.visualElement
          , d = c.addEventListener("measure", o);
        c && !c.layout && (c.root && c.root.updateScroll(),
        c.updateLayout()),
        frame.read(o);
        const g = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints())
          , _ = c.addEventListener("didUpdate", ({delta: b, hasLayoutChanged: j}) => {
            this.isDragging && j && (eachAxis($ => {
                const nt = this.getAxisMotionValue($);
                nt && (this.originPoint[$] += b[$].translate,
                nt.set(nt.get() + b[$].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            g(),
            a(),
            d(),
            _ && _()
        }
    }
    getProps() {
        const e = this.visualElement.getProps()
          , {drag: a=!1, dragDirectionLock: o=!1, dragPropagation: c=!1, dragConstraints: d=!1, dragElastic: g=defaultElastic, dragMomentum: _=!0} = e;
        return {
            ...e,
            drag: a,
            dragDirectionLock: o,
            dragPropagation: c,
            dragConstraints: d,
            dragElastic: g,
            dragMomentum: _
        }
    }
}
function shouldDrag(s, e, a) {
    return (e === !0 || e === s) && (a === null || a === s)
}
function getCurrentDirection(s, e=10) {
    let a = null;
    return Math.abs(s.y) > e ? a = "y" : Math.abs(s.x) > e && (a = "x"),
    a
}
class DragGesture extends Feature {
    constructor(e) {
        super(e),
        this.removeGroupControls = noop,
        this.removeListeners = noop,
        this.controls = new VisualElementDragControls(e)
    }
    mount() {
        const {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || noop
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const asyncHandler = s => (e, a) => {
    s && frame.postRender( () => s(e, a))
}
;
class PanGesture extends Feature {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = noop
    }
    onPointerDown(e) {
        this.session = new PanSession(e,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: getContextWindow(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: e, onPanStart: a, onPan: o, onPanEnd: c} = this.node.getProps();
        return {
            onSessionStart: asyncHandler(e),
            onStart: asyncHandler(a),
            onMove: o,
            onEnd: (d, g) => {
                delete this.session,
                c && frame.postRender( () => c(d, g))
            }
        }
    }
    mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
const PresenceContext = reactExports.createContext(null);
function usePresence() {
    const s = reactExports.useContext(PresenceContext);
    if (s === null)
        return [!0, null];
    const {isPresent: e, onExitComplete: a, register: o} = s
      , c = reactExports.useId();
    reactExports.useEffect( () => o(c), []);
    const d = reactExports.useCallback( () => a && a(c), [c, a]);
    return !e && a ? [!1, d] : [!0]
}
const LayoutGroupContext = reactExports.createContext({})
  , SwitchLayoutGroupContext = reactExports.createContext({})
  , globalProjectionState = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function pixelsToPercent(s, e) {
    return e.max === e.min ? 0 : s / (e.max - e.min) * 100
}
const correctBorderRadius = {
    correct: (s, e) => {
        if (!e.target)
            return s;
        if (typeof s == "string")
            if (px$1.test(s))
                s = parseFloat(s);
            else
                return s;
        const a = pixelsToPercent(s, e.target.x)
          , o = pixelsToPercent(s, e.target.y);
        return `${a}% ${o}%`
    }
}
  , correctBoxShadow = {
    correct: (s, {treeScale: e, projectionDelta: a}) => {
        const o = s
          , c = complex.parse(s);
        if (c.length > 5)
            return o;
        const d = complex.createTransformer(s)
          , g = typeof c[0] != "number" ? 1 : 0
          , _ = a.x.scale * e.x
          , b = a.y.scale * e.y;
        c[0 + g] /= _,
        c[1 + g] /= b;
        const j = mixNumber$1(_, b, .5);
        return typeof c[2 + g] == "number" && (c[2 + g] /= j),
        typeof c[3 + g] == "number" && (c[3 + g] /= j),
        d(c)
    }
}
  , scaleCorrectors = {};
function addScaleCorrector(s) {
    Object.assign(scaleCorrectors, s)
}
const {schedule: microtask, cancel: cancelMicrotask} = createRenderBatcher(queueMicrotask, !1);
class MeasureLayoutWithContext extends reactExports.Component {
    componentDidMount() {
        const {visualElement: e, layoutGroup: a, switchLayoutGroup: o, layoutId: c} = this.props
          , {projection: d} = e;
        addScaleCorrector(defaultScaleCorrectors),
        d && (a.group && a.group.add(d),
        o && o.register && c && o.register(d),
        d.root.didUpdate(),
        d.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        d.setOptions({
            ...d.options,
            onExitComplete: () => this.safeToRemove()
        })),
        globalProjectionState.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {layoutDependency: a, visualElement: o, drag: c, isPresent: d} = this.props
          , g = o.projection;
        return g && (g.isPresent = d,
        c || e.layoutDependency !== a || a === void 0 ? g.willUpdate() : this.safeToRemove(),
        e.isPresent !== d && (d ? g.promote() : g.relegate() || frame.postRender( () => {
            const _ = g.getStack();
            (!_ || !_.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(),
        microtask.postRender( () => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: e, layoutGroup: a, switchLayoutGroup: o} = this.props
          , {projection: c} = e;
        c && (c.scheduleCheckAfterUnmount(),
        a && a.group && a.group.remove(c),
        o && o.deregister && o.deregister(c))
    }
    safeToRemove() {
        const {safeToRemove: e} = this.props;
        e && e()
    }
    render() {
        return null
    }
}
function MeasureLayout(s) {
    const [e,a] = usePresence()
      , o = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
        ...s,
        layoutGroup: o,
        switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
        isPresent: e,
        safeToRemove: a
    })
}
const defaultScaleCorrectors = {
    borderRadius: {
        ...correctBorderRadius,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
}
  , borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , numBorders = borders.length
  , asNumber = s => typeof s == "string" ? parseFloat(s) : s
  , isPx = s => typeof s == "number" || px$1.test(s);
function mixValues(s, e, a, o, c, d) {
    c ? (s.opacity = mixNumber$1(0, a.opacity !== void 0 ? a.opacity : 1, easeCrossfadeIn(o)),
    s.opacityExit = mixNumber$1(e.opacity !== void 0 ? e.opacity : 1, 0, easeCrossfadeOut(o))) : d && (s.opacity = mixNumber$1(e.opacity !== void 0 ? e.opacity : 1, a.opacity !== void 0 ? a.opacity : 1, o));
    for (let g = 0; g < numBorders; g++) {
        const _ = `border${borders[g]}Radius`;
        let b = getRadius(e, _)
          , j = getRadius(a, _);
        if (b === void 0 && j === void 0)
            continue;
        b || (b = 0),
        j || (j = 0),
        b === 0 || j === 0 || isPx(b) === isPx(j) ? (s[_] = Math.max(mixNumber$1(asNumber(b), asNumber(j), o), 0),
        (percent.test(j) || percent.test(b)) && (s[_] += "%")) : s[_] = j
    }
    (e.rotate || a.rotate) && (s.rotate = mixNumber$1(e.rotate || 0, a.rotate || 0, o))
}
function getRadius(s, e) {
    return s[e] !== void 0 ? s[e] : s.borderRadius
}
const easeCrossfadeIn = compress(0, .5, circOut)
  , easeCrossfadeOut = compress(.5, .95, noop);
function compress(s, e, a) {
    return o => o < s ? 0 : o > e ? 1 : a(progress(s, e, o))
}
function copyAxisInto(s, e) {
    s.min = e.min,
    s.max = e.max
}
function copyBoxInto(s, e) {
    copyAxisInto(s.x, e.x),
    copyAxisInto(s.y, e.y)
}
function copyAxisDeltaInto(s, e) {
    s.translate = e.translate,
    s.scale = e.scale,
    s.originPoint = e.originPoint,
    s.origin = e.origin
}
function removePointDelta(s, e, a, o, c) {
    return s -= e,
    s = scalePoint(s, 1 / a, o),
    c !== void 0 && (s = scalePoint(s, 1 / c, o)),
    s
}
function removeAxisDelta(s, e=0, a=1, o=.5, c, d=s, g=s) {
    if (percent.test(e) && (e = parseFloat(e),
    e = mixNumber$1(g.min, g.max, e / 100) - g.min),
    typeof e != "number")
        return;
    let _ = mixNumber$1(d.min, d.max, o);
    s === d && (_ -= e),
    s.min = removePointDelta(s.min, e, a, _, c),
    s.max = removePointDelta(s.max, e, a, _, c)
}
function removeAxisTransforms(s, e, [a,o,c], d, g) {
    removeAxisDelta(s, e[a], e[o], e[c], e.scale, d, g)
}
const xKeys = ["x", "scaleX", "originX"]
  , yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(s, e, a, o) {
    removeAxisTransforms(s.x, e, xKeys, a ? a.x : void 0, o ? o.x : void 0),
    removeAxisTransforms(s.y, e, yKeys, a ? a.y : void 0, o ? o.y : void 0)
}
function isAxisDeltaZero(s) {
    return s.translate === 0 && s.scale === 1
}
function isDeltaZero(s) {
    return isAxisDeltaZero(s.x) && isAxisDeltaZero(s.y)
}
function axisEquals(s, e) {
    return s.min === e.min && s.max === e.max
}
function boxEquals(s, e) {
    return axisEquals(s.x, e.x) && axisEquals(s.y, e.y)
}
function axisEqualsRounded(s, e) {
    return Math.round(s.min) === Math.round(e.min) && Math.round(s.max) === Math.round(e.max)
}
function boxEqualsRounded(s, e) {
    return axisEqualsRounded(s.x, e.x) && axisEqualsRounded(s.y, e.y)
}
function aspectRatio(s) {
    return calcLength(s.x) / calcLength(s.y)
}
function axisDeltaEquals(s, e) {
    return s.translate === e.translate && s.scale === e.scale && s.originPoint === e.originPoint
}
class NodeStack {
    constructor() {
        this.members = []
    }
    add(e) {
        addUniqueItem(this.members, e),
        e.scheduleRender()
    }
    remove(e) {
        if (removeItem(this.members, e),
        e === this.prevLead && (this.prevLead = void 0),
        e === this.lead) {
            const a = this.members[this.members.length - 1];
            a && this.promote(a)
        }
    }
    relegate(e) {
        const a = this.members.findIndex(c => e === c);
        if (a === 0)
            return !1;
        let o;
        for (let c = a; c >= 0; c--) {
            const d = this.members[c];
            if (d.isPresent !== !1) {
                o = d;
                break
            }
        }
        return o ? (this.promote(o),
        !0) : !1
    }
    promote(e, a) {
        const o = this.lead;
        if (e !== o && (this.prevLead = o,
        this.lead = e,
        e.show(),
        o)) {
            o.instance && o.scheduleRender(),
            e.scheduleRender(),
            e.resumeFrom = o,
            a && (e.resumeFrom.preserveOpacity = !0),
            o.snapshot && (e.snapshot = o.snapshot,
            e.snapshot.latestValues = o.animationValues || o.latestValues),
            e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {crossfade: c} = e.options;
            c === !1 && o.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            const {options: a, resumingFrom: o} = e;
            a.onExitComplete && a.onExitComplete(),
            o && o.options.onExitComplete && o.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function buildProjectionTransform(s, e, a) {
    let o = "";
    const c = s.x.translate / e.x
      , d = s.y.translate / e.y
      , g = (a == null ? void 0 : a.z) || 0;
    if ((c || d || g) && (o = `translate3d(${c}px, ${d}px, ${g}px) `),
    (e.x !== 1 || e.y !== 1) && (o += `scale(${1 / e.x}, ${1 / e.y}) `),
    a) {
        const {transformPerspective: j, rotate: $, rotateX: nt, rotateY: tt, skewX: rt, skewY: st} = a;
        j && (o = `perspective(${j}px) ${o}`),
        $ && (o += `rotate(${$}deg) `),
        nt && (o += `rotateX(${nt}deg) `),
        tt && (o += `rotateY(${tt}deg) `),
        rt && (o += `skewX(${rt}deg) `),
        st && (o += `skewY(${st}deg) `)
    }
    const _ = s.x.scale * e.x
      , b = s.y.scale * e.y;
    return (_ !== 1 || b !== 1) && (o += `scale(${_}, ${b})`),
    o || "none"
}
const compareByDepth = (s, e) => s.depth - e.depth;
class FlatTree {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(e) {
        addUniqueItem(this.children, e),
        this.isDirty = !0
    }
    remove(e) {
        removeItem(this.children, e),
        this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(compareByDepth),
        this.isDirty = !1,
        this.children.forEach(e)
    }
}
function resolveMotionValue(s) {
    const e = isMotionValue(s) ? s.get() : s;
    return isCustomValue(e) ? e.toValue() : e
}
function delay(s, e) {
    const a = time.now()
      , o = ({timestamp: c}) => {
        const d = c - a;
        d >= e && (cancelFrame(o),
        s(d - e))
    }
    ;
    return frame.read(o, !0),
    () => cancelFrame(o)
}
function isSVGElement(s) {
    return s instanceof SVGElement && s.tagName !== "svg"
}
function animateSingleValue(s, e, a) {
    const o = isMotionValue(s) ? s : motionValue(s);
    return o.start(animateMotionValue("", o, e, a)),
    o.animation
}
const metrics = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
}
  , isDebug = typeof window < "u" && window.MotionDebug !== void 0
  , transformAxes = ["", "X", "Y", "Z"]
  , hiddenVisibility = {
    visibility: "hidden"
}
  , animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(s, e, a, o) {
    const {latestValues: c} = e;
    c[s] && (a[s] = c[s],
    e.setStaticValue(s, 0),
    o && (o[s] = 0))
}
function cancelTreeOptimisedTransformAnimations(s) {
    if (s.hasCheckedOptimisedAppear = !0,
    s.root === s)
        return;
    const {visualElement: e} = s.options;
    if (!e)
        return;
    const a = getOptimisedAppearId(e);
    if (window.MotionHasOptimisedAnimation(a, "transform")) {
        const {layout: c, layoutId: d} = s.options;
        window.MotionCancelOptimisedAnimation(a, "transform", frame, !(c || d))
    }
    const {parent: o} = s;
    o && !o.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(o)
}
function createProjectionNode$1({attachResizeListener: s, defaultParent: e, measureScroll: a, checkIsScrollRoot: o, resetTransform: c}) {
    return class {
        constructor(g={}, _=e == null ? void 0 : e()) {
            this.id = id++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                isDebug && (metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0),
                this.nodes.forEach(propagateDirtyNodes),
                this.nodes.forEach(resolveTargetDelta),
                this.nodes.forEach(calcProjection),
                this.nodes.forEach(cleanDirtyNodes),
                isDebug && window.MotionDebug.record(metrics)
            }
            ,
            this.resolvedRelativeTargetAt = 0,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = g,
            this.root = _ ? _.root || _ : this,
            this.path = _ ? [..._.path, _] : [],
            this.parent = _,
            this.depth = _ ? _.depth + 1 : 0;
            for (let b = 0; b < this.path.length; b++)
                this.path[b].shouldResetTransform = !0;
            this.root === this && (this.nodes = new FlatTree)
        }
        addEventListener(g, _) {
            return this.eventHandlers.has(g) || this.eventHandlers.set(g, new SubscriptionManager),
            this.eventHandlers.get(g).add(_)
        }
        notifyListeners(g, ..._) {
            const b = this.eventHandlers.get(g);
            b && b.notify(..._)
        }
        hasListeners(g) {
            return this.eventHandlers.has(g)
        }
        mount(g, _=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = isSVGElement(g),
            this.instance = g;
            const {layoutId: b, layout: j, visualElement: $} = this.options;
            if ($ && !$.current && $.mount(g),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            _ && (j || b) && (this.isLayoutDirty = !0),
            s) {
                let nt;
                const tt = () => this.root.updateBlockedByResize = !1;
                s(g, () => {
                    this.root.updateBlockedByResize = !0,
                    nt && nt(),
                    nt = delay(tt, 250),
                    globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(finishAnimation))
                }
                )
            }
            b && this.root.registerSharedNode(b, this),
            this.options.animate !== !1 && $ && (b || j) && this.addEventListener("didUpdate", ({delta: nt, hasLayoutChanged: tt, hasRelativeTargetChanged: rt, layout: st}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const lt = this.options.transition || $.getDefaultTransition() || defaultLayoutTransition
                  , {onLayoutAnimationStart: ct, onLayoutAnimationComplete: it} = $.getProps()
                  , ot = !this.targetLayout || !boxEqualsRounded(this.targetLayout, st) || rt
                  , at = !tt && rt;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || at || tt && (ot || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(nt, at);
                    const ht = {
                        ...getValueTransition(lt, "layout"),
                        onPlay: ct,
                        onComplete: it
                    };
                    ($.shouldReduceMotion || this.options.layoutRoot) && (ht.delay = 0,
                    ht.type = !1),
                    this.startAnimation(ht)
                } else
                    tt || finishAnimation(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = st
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const g = this.getStack();
            g && g.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            cancelFrame(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(resetSkewAndRotation),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: g} = this.options;
            return g && g.getProps().transformTemplate
        }
        willUpdate(g=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let $ = 0; $ < this.path.length; $++) {
                const nt = this.path[$];
                nt.shouldResetTransform = !0,
                nt.updateScroll("snapshot"),
                nt.options.layoutRoot && nt.willUpdate(!1)
            }
            const {layoutId: _, layout: b} = this.options;
            if (_ === void 0 && !b)
                return;
            const j = this.getTransformTemplate();
            this.prevTransformTemplateValue = j ? j(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            g && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(clearMeasurements);
                return
            }
            this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
            this.isUpdating = !1,
            this.nodes.forEach(resetTransformStyle),
            this.nodes.forEach(updateLayout),
            this.nodes.forEach(notifyLayoutUpdate),
            this.clearAllSnapshots();
            const _ = time.now();
            frameData.delta = clamp$1(0, 1e3 / 60, _ - frameData.timestamp),
            frameData.timestamp = _,
            frameData.isProcessing = !0,
            frameSteps.update.process(frameData),
            frameSteps.preRender.process(frameData),
            frameSteps.render.process(frameData),
            frameData.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            microtask.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(clearSnapshot),
            this.sharedNodes.forEach(removeLeadSnapshots)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            frame.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            frame.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let b = 0; b < this.path.length; b++)
                    this.path[b].updateScroll();
            const g = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = createBox(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: _} = this.options;
            _ && _.notify("LayoutMeasure", this.layout.layoutBox, g ? g.layoutBox : void 0)
        }
        updateScroll(g="measure") {
            let _ = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === g && (_ = !1),
            _) {
                const b = o(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: g,
                    isRoot: b,
                    offset: a(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : b
                }
            }
        }
        resetTransform() {
            if (!c)
                return;
            const g = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , _ = this.projectionDelta && !isDeltaZero(this.projectionDelta)
              , b = this.getTransformTemplate()
              , j = b ? b(this.latestValues, "") : void 0
              , $ = j !== this.prevTransformTemplateValue;
            g && (_ || hasTransform(this.latestValues) || $) && (c(this.instance, j),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(g=!0) {
            const _ = this.measurePageBox();
            let b = this.removeElementScroll(_);
            return g && (b = this.removeTransform(b)),
            roundBox(b),
            {
                animationId: this.root.animationId,
                measuredBox: _,
                layoutBox: b,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var g;
            const {visualElement: _} = this.options;
            if (!_)
                return createBox();
            const b = _.measureViewportBox();
            if (!(((g = this.scroll) === null || g === void 0 ? void 0 : g.wasRoot) || this.path.some(checkNodeWasScrollRoot))) {
                const {scroll: $} = this.root;
                $ && (translateAxis(b.x, $.offset.x),
                translateAxis(b.y, $.offset.y))
            }
            return b
        }
        removeElementScroll(g) {
            var _;
            const b = createBox();
            if (copyBoxInto(b, g),
            !((_ = this.scroll) === null || _ === void 0) && _.wasRoot)
                return b;
            for (let j = 0; j < this.path.length; j++) {
                const $ = this.path[j]
                  , {scroll: nt, options: tt} = $;
                $ !== this.root && nt && tt.layoutScroll && (nt.wasRoot && copyBoxInto(b, g),
                translateAxis(b.x, nt.offset.x),
                translateAxis(b.y, nt.offset.y))
            }
            return b
        }
        applyTransform(g, _=!1) {
            const b = createBox();
            copyBoxInto(b, g);
            for (let j = 0; j < this.path.length; j++) {
                const $ = this.path[j];
                !_ && $.options.layoutScroll && $.scroll && $ !== $.root && transformBox(b, {
                    x: -$.scroll.offset.x,
                    y: -$.scroll.offset.y
                }),
                hasTransform($.latestValues) && transformBox(b, $.latestValues)
            }
            return hasTransform(this.latestValues) && transformBox(b, this.latestValues),
            b
        }
        removeTransform(g) {
            const _ = createBox();
            copyBoxInto(_, g);
            for (let b = 0; b < this.path.length; b++) {
                const j = this.path[b];
                if (!j.instance || !hasTransform(j.latestValues))
                    continue;
                hasScale(j.latestValues) && j.updateSnapshot();
                const $ = createBox()
                  , nt = j.measurePageBox();
                copyBoxInto($, nt),
                removeBoxTransforms(_, j.latestValues, j.snapshot ? j.snapshot.layoutBox : void 0, $)
            }
            return hasTransform(this.latestValues) && removeBoxTransforms(_, this.latestValues),
            _
        }
        setTargetDelta(g) {
            this.targetDelta = g,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(g) {
            this.options = {
                ...this.options,
                ...g,
                crossfade: g.crossfade !== void 0 ? g.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(g=!1) {
            var _;
            const b = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = b.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = b.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = b.isSharedProjectionDirty);
            const j = !!this.resumingFrom || this !== b;
            if (!(g || j && this.isSharedProjectionDirty || this.isProjectionDirty || !((_ = this.parent) === null || _ === void 0) && _.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            const {layout: nt, layoutId: tt} = this.options;
            if (!(!this.layout || !(nt || tt))) {
                if (this.resolvedRelativeTargetAt = frameData.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const rt = this.getClosestProjectingParent();
                    rt && rt.layout && this.animationProgress !== 1 ? (this.relativeParent = rt,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = createBox(),
                    this.relativeTargetOrigin = createBox(),
                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, rt.layout.layoutBox),
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = createBox(),
                    this.targetWithTransforms = createBox()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox),
                    applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const rt = this.getClosestProjectingParent();
                        rt && !!rt.resumingFrom == !!this.resumingFrom && !rt.options.layoutScroll && rt.target && this.animationProgress !== 1 ? (this.relativeParent = rt,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = createBox(),
                        this.relativeTargetOrigin = createBox(),
                        calcRelativePosition(this.relativeTargetOrigin, this.target, rt.target),
                        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    isDebug && metrics.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var g;
            const _ = this.getLead()
              , b = !!this.resumingFrom || this !== _;
            let j = !0;
            if ((this.isProjectionDirty || !((g = this.parent) === null || g === void 0) && g.isProjectionDirty) && (j = !1),
            b && (this.isSharedProjectionDirty || this.isTransformDirty) && (j = !1),
            this.resolvedRelativeTargetAt === frameData.timestamp && (j = !1),
            j)
                return;
            const {layout: $, layoutId: nt} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !($ || nt))
                return;
            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
            const tt = this.treeScale.x
              , rt = this.treeScale.y;
            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, b),
            _.layout && !_.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (_.target = _.layout.layoutBox,
            _.targetWithTransforms = createBox());
            const {target: st} = _;
            if (!st) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x),
            copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)),
            calcBoxDelta(this.projectionDelta, this.layoutCorrected, st, this.latestValues),
            (this.treeScale.x !== tt || this.treeScale.y !== rt || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", st)),
            isDebug && metrics.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(g=!0) {
            var _;
            if ((_ = this.options.visualElement) === null || _ === void 0 || _.scheduleRender(),
            g) {
                const b = this.getStack();
                b && b.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = createDelta(),
            this.projectionDelta = createDelta(),
            this.projectionDeltaWithTransform = createDelta()
        }
        setAnimationOrigin(g, _=!1) {
            const b = this.snapshot
              , j = b ? b.latestValues : {}
              , $ = {
                ...this.latestValues
            }
              , nt = createDelta();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !_;
            const tt = createBox()
              , rt = b ? b.source : void 0
              , st = this.layout ? this.layout.source : void 0
              , lt = rt !== st
              , ct = this.getStack()
              , it = !ct || ct.members.length <= 1
              , ot = !!(lt && !it && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
            this.animationProgress = 0;
            let at;
            this.mixTargetDelta = ht => {
                const pt = ht / 1e3;
                mixAxisDelta(nt.x, g.x, pt),
                mixAxisDelta(nt.y, g.y, pt),
                this.setTargetDelta(nt),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(tt, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                mixBox(this.relativeTarget, this.relativeTargetOrigin, tt, pt),
                at && boxEquals(this.relativeTarget, at) && (this.isProjectionDirty = !1),
                at || (at = createBox()),
                copyBoxInto(at, this.relativeTarget)),
                lt && (this.animationValues = $,
                mixValues($, j, this.latestValues, pt, ot, it)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = pt
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(g) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (cancelFrame(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = frame.update( () => {
                globalProjectionState.hasAnimatedSinceResize = !0,
                this.currentAnimation = animateSingleValue(0, animationTarget, {
                    ...g,
                    onUpdate: _ => {
                        this.mixTargetDelta(_),
                        g.onUpdate && g.onUpdate(_)
                    }
                    ,
                    onComplete: () => {
                        g.onComplete && g.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const g = this.getStack();
            g && g.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const g = this.getLead();
            let {targetWithTransforms: _, target: b, layout: j, latestValues: $} = g;
            if (!(!_ || !b || !j)) {
                if (this !== g && this.layout && j && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, j.layoutBox)) {
                    b = this.target || createBox();
                    const nt = calcLength(this.layout.layoutBox.x);
                    b.x.min = g.target.x.min,
                    b.x.max = b.x.min + nt;
                    const tt = calcLength(this.layout.layoutBox.y);
                    b.y.min = g.target.y.min,
                    b.y.max = b.y.min + tt
                }
                copyBoxInto(_, b),
                transformBox(_, $),
                calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, _, $)
            }
        }
        registerSharedNode(g, _) {
            this.sharedNodes.has(g) || this.sharedNodes.set(g, new NodeStack),
            this.sharedNodes.get(g).add(_);
            const j = _.options.initialPromotionConfig;
            _.promote({
                transition: j ? j.transition : void 0,
                preserveFollowOpacity: j && j.shouldPreserveFollowOpacity ? j.shouldPreserveFollowOpacity(_) : void 0
            })
        }
        isLead() {
            const g = this.getStack();
            return g ? g.lead === this : !0
        }
        getLead() {
            var g;
            const {layoutId: _} = this.options;
            return _ ? ((g = this.getStack()) === null || g === void 0 ? void 0 : g.lead) || this : this
        }
        getPrevLead() {
            var g;
            const {layoutId: _} = this.options;
            return _ ? (g = this.getStack()) === null || g === void 0 ? void 0 : g.prevLead : void 0
        }
        getStack() {
            const {layoutId: g} = this.options;
            if (g)
                return this.root.sharedNodes.get(g)
        }
        promote({needsReset: g, transition: _, preserveFollowOpacity: b}={}) {
            const j = this.getStack();
            j && j.promote(this, b),
            g && (this.projectionDelta = void 0,
            this.needsReset = !0),
            _ && this.setOptions({
                transition: _
            })
        }
        relegate() {
            const g = this.getStack();
            return g ? g.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: g} = this.options;
            if (!g)
                return;
            let _ = !1;
            const {latestValues: b} = g;
            if ((b.z || b.rotate || b.rotateX || b.rotateY || b.rotateZ || b.skewX || b.skewY) && (_ = !0),
            !_)
                return;
            const j = {};
            b.z && resetDistortingTransform("z", g, j, this.animationValues);
            for (let $ = 0; $ < transformAxes.length; $++)
                resetDistortingTransform(`rotate${transformAxes[$]}`, g, j, this.animationValues),
                resetDistortingTransform(`skew${transformAxes[$]}`, g, j, this.animationValues);
            g.render();
            for (const $ in j)
                g.setStaticValue($, j[$]),
                this.animationValues && (this.animationValues[$] = j[$]);
            g.scheduleRender()
        }
        getProjectionStyles(g) {
            var _, b;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return hiddenVisibility;
            const j = {
                visibility: ""
            }
              , $ = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                j.opacity = "",
                j.pointerEvents = resolveMotionValue(g == null ? void 0 : g.pointerEvents) || "",
                j.transform = $ ? $(this.latestValues, "") : "none",
                j;
            const nt = this.getLead();
            if (!this.projectionDelta || !this.layout || !nt.target) {
                const lt = {};
                return this.options.layoutId && (lt.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                lt.pointerEvents = resolveMotionValue(g == null ? void 0 : g.pointerEvents) || ""),
                this.hasProjected && !hasTransform(this.latestValues) && (lt.transform = $ ? $({}, "") : "none",
                this.hasProjected = !1),
                lt
            }
            const tt = nt.animationValues || nt.latestValues;
            this.applyTransformsToTarget(),
            j.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, tt),
            $ && (j.transform = $(tt, j.transform));
            const {x: rt, y: st} = this.projectionDelta;
            j.transformOrigin = `${rt.origin * 100}% ${st.origin * 100}% 0`,
            nt.animationValues ? j.opacity = nt === this ? (b = (_ = tt.opacity) !== null && _ !== void 0 ? _ : this.latestValues.opacity) !== null && b !== void 0 ? b : 1 : this.preserveOpacity ? this.latestValues.opacity : tt.opacityExit : j.opacity = nt === this ? tt.opacity !== void 0 ? tt.opacity : "" : tt.opacityExit !== void 0 ? tt.opacityExit : 0;
            for (const lt in scaleCorrectors) {
                if (tt[lt] === void 0)
                    continue;
                const {correct: ct, applyTo: it} = scaleCorrectors[lt]
                  , ot = j.transform === "none" ? tt[lt] : ct(tt[lt], nt);
                if (it) {
                    const at = it.length;
                    for (let ht = 0; ht < at; ht++)
                        j[it[ht]] = ot
                } else
                    j[lt] = ot
            }
            return this.options.layoutId && (j.pointerEvents = nt === this ? resolveMotionValue(g == null ? void 0 : g.pointerEvents) || "" : "none"),
            j
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(g => {
                var _;
                return (_ = g.currentAnimation) === null || _ === void 0 ? void 0 : _.stop()
            }
            ),
            this.root.nodes.forEach(clearMeasurements),
            this.root.sharedNodes.clear()
        }
    }
}
function updateLayout(s) {
    s.updateLayout()
}
function notifyLayoutUpdate(s) {
    var e;
    const a = ((e = s.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || s.snapshot;
    if (s.isLead() && s.layout && a && s.hasListeners("didUpdate")) {
        const {layoutBox: o, measuredBox: c} = s.layout
          , {animationType: d} = s.options
          , g = a.source !== s.layout.source;
        d === "size" ? eachAxis(nt => {
            const tt = g ? a.measuredBox[nt] : a.layoutBox[nt]
              , rt = calcLength(tt);
            tt.min = o[nt].min,
            tt.max = tt.min + rt
        }
        ) : shouldAnimatePositionOnly(d, a.layoutBox, o) && eachAxis(nt => {
            const tt = g ? a.measuredBox[nt] : a.layoutBox[nt]
              , rt = calcLength(o[nt]);
            tt.max = tt.min + rt,
            s.relativeTarget && !s.currentAnimation && (s.isProjectionDirty = !0,
            s.relativeTarget[nt].max = s.relativeTarget[nt].min + rt)
        }
        );
        const _ = createDelta();
        calcBoxDelta(_, o, a.layoutBox);
        const b = createDelta();
        g ? calcBoxDelta(b, s.applyTransform(c, !0), a.measuredBox) : calcBoxDelta(b, o, a.layoutBox);
        const j = !isDeltaZero(_);
        let $ = !1;
        if (!s.resumeFrom) {
            const nt = s.getClosestProjectingParent();
            if (nt && !nt.resumeFrom) {
                const {snapshot: tt, layout: rt} = nt;
                if (tt && rt) {
                    const st = createBox();
                    calcRelativePosition(st, a.layoutBox, tt.layoutBox);
                    const lt = createBox();
                    calcRelativePosition(lt, o, rt.layoutBox),
                    boxEqualsRounded(st, lt) || ($ = !0),
                    nt.options.layoutRoot && (s.relativeTarget = lt,
                    s.relativeTargetOrigin = st,
                    s.relativeParent = nt)
                }
            }
        }
        s.notifyListeners("didUpdate", {
            layout: o,
            snapshot: a,
            delta: b,
            layoutDelta: _,
            hasLayoutChanged: j,
            hasRelativeTargetChanged: $
        })
    } else if (s.isLead()) {
        const {onExitComplete: o} = s.options;
        o && o()
    }
    s.options.transition = void 0
}
function propagateDirtyNodes(s) {
    isDebug && metrics.totalNodes++,
    s.parent && (s.isProjecting() || (s.isProjectionDirty = s.parent.isProjectionDirty),
    s.isSharedProjectionDirty || (s.isSharedProjectionDirty = !!(s.isProjectionDirty || s.parent.isProjectionDirty || s.parent.isSharedProjectionDirty)),
    s.isTransformDirty || (s.isTransformDirty = s.parent.isTransformDirty))
}
function cleanDirtyNodes(s) {
    s.isProjectionDirty = s.isSharedProjectionDirty = s.isTransformDirty = !1
}
function clearSnapshot(s) {
    s.clearSnapshot()
}
function clearMeasurements(s) {
    s.clearMeasurements()
}
function clearIsLayoutDirty(s) {
    s.isLayoutDirty = !1
}
function resetTransformStyle(s) {
    const {visualElement: e} = s.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    s.resetTransform()
}
function finishAnimation(s) {
    s.finishAnimation(),
    s.targetDelta = s.relativeTarget = s.target = void 0,
    s.isProjectionDirty = !0
}
function resolveTargetDelta(s) {
    s.resolveTargetDelta()
}
function calcProjection(s) {
    s.calcProjection()
}
function resetSkewAndRotation(s) {
    s.resetSkewAndRotation()
}
function removeLeadSnapshots(s) {
    s.removeLeadSnapshot()
}
function mixAxisDelta(s, e, a) {
    s.translate = mixNumber$1(e.translate, 0, a),
    s.scale = mixNumber$1(e.scale, 1, a),
    s.origin = e.origin,
    s.originPoint = e.originPoint
}
function mixAxis(s, e, a, o) {
    s.min = mixNumber$1(e.min, a.min, o),
    s.max = mixNumber$1(e.max, a.max, o)
}
function mixBox(s, e, a, o) {
    mixAxis(s.x, e.x, a.x, o),
    mixAxis(s.y, e.y, a.y, o)
}
function hasOpacityCrossfade(s) {
    return s.animationValues && s.animationValues.opacityExit !== void 0
}
const defaultLayoutTransition = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , userAgentContains = s => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(s)
  , roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(s) {
    s.min = roundPoint(s.min),
    s.max = roundPoint(s.max)
}
function roundBox(s) {
    roundAxis(s.x),
    roundAxis(s.y)
}
function shouldAnimatePositionOnly(s, e, a) {
    return s === "position" || s === "preserve-aspect" && !isNear(aspectRatio(e), aspectRatio(a), .2)
}
function checkNodeWasScrollRoot(s) {
    var e;
    return s !== s.root && ((e = s.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
}
const DocumentProjectionNode = createProjectionNode$1({
    attachResizeListener: (s, e) => addDomEvent(s, "resize", e),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , rootProjectionNode = {
    current: void 0
}
  , HTMLProjectionNode = createProjectionNode$1({
    measureScroll: s => ({
        x: s.scrollLeft,
        y: s.scrollTop
    }),
    defaultParent: () => {
        if (!rootProjectionNode.current) {
            const s = new DocumentProjectionNode({});
            s.mount(window),
            s.setOptions({
                layoutScroll: !0
            }),
            rootProjectionNode.current = s
        }
        return rootProjectionNode.current
    }
    ,
    resetTransform: (s, e) => {
        s.style.transform = e !== void 0 ? e : "none"
    }
    ,
    checkIsScrollRoot: s => window.getComputedStyle(s).position === "fixed"
})
  , drag = {
    pan: {
        Feature: PanGesture
    },
    drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
};
function addHoverEvent(s, e) {
    const a = e ? "pointerenter" : "pointerleave"
      , o = e ? "onHoverStart" : "onHoverEnd"
      , c = (d, g) => {
        if (d.pointerType === "touch" || isDragActive())
            return;
        const _ = s.getProps();
        s.animationState && _.whileHover && s.animationState.setActive("whileHover", e);
        const b = _[o];
        b && frame.postRender( () => b(d, g))
    }
    ;
    return addPointerEvent(s.current, a, c, {
        passive: !s.getProps()[o]
    })
}
class HoverGesture extends Feature {
    mount() {
        this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1))
    }
    unmount() {}
}
class FocusGesture extends Feature {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
const isNodeOrChild = (s, e) => e ? s === e ? !0 : isNodeOrChild(s, e.parentElement) : !1;
function fireSyntheticPointerEvent(s, e) {
    if (!e)
        return;
    const a = new PointerEvent("pointer" + s);
    e(a, extractEventInfo(a))
}
class PressGesture extends Feature {
    constructor() {
        super(...arguments),
        this.removeStartListeners = noop,
        this.removeEndListeners = noop,
        this.removeAccessibleListeners = noop,
        this.startPointerPress = (e, a) => {
            if (this.isPressing)
                return;
            this.removeEndListeners();
            const o = this.node.getProps()
              , d = addPointerEvent(window, "pointerup", (_, b) => {
                if (!this.checkPressEnd())
                    return;
                const {onTap: j, onTapCancel: $, globalTapTarget: nt} = this.node.getProps()
                  , tt = !nt && !isNodeOrChild(this.node.current, _.target) ? $ : j;
                tt && frame.update( () => tt(_, b))
            }
            , {
                passive: !(o.onTap || o.onPointerUp)
            })
              , g = addPointerEvent(window, "pointercancel", (_, b) => this.cancelPress(_, b), {
                passive: !(o.onTapCancel || o.onPointerCancel)
            });
            this.removeEndListeners = pipe(d, g),
            this.startPress(e, a)
        }
        ,
        this.startAccessiblePress = () => {
            const e = d => {
                if (d.key !== "Enter" || this.isPressing)
                    return;
                const g = _ => {
                    _.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (b, j) => {
                        const {onTap: $} = this.node.getProps();
                        $ && frame.postRender( () => $(b, j))
                    }
                    )
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = addDomEvent(this.node.current, "keyup", g),
                fireSyntheticPointerEvent("down", (_, b) => {
                    this.startPress(_, b)
                }
                )
            }
              , a = addDomEvent(this.node.current, "keydown", e)
              , o = () => {
                this.isPressing && fireSyntheticPointerEvent("cancel", (d, g) => this.cancelPress(d, g))
            }
              , c = addDomEvent(this.node.current, "blur", o);
            this.removeAccessibleListeners = pipe(a, c)
        }
    }
    startPress(e, a) {
        this.isPressing = !0;
        const {onTapStart: o, whileTap: c} = this.node.getProps();
        c && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        o && frame.postRender( () => o(e, a))
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !isDragActive()
    }
    cancelPress(e, a) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: o} = this.node.getProps();
        o && frame.postRender( () => o(e, a))
    }
    mount() {
        const e = this.node.getProps()
          , a = addPointerEvent(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(e.onTapStart || e.onPointerStart)
        })
          , o = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = pipe(a, o)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const observerCallbacks = new WeakMap
  , observers = new WeakMap
  , fireObserverCallback = s => {
    const e = observerCallbacks.get(s.target);
    e && e(s)
}
  , fireAllObserverCallbacks = s => {
    s.forEach(fireObserverCallback)
}
;
function initIntersectionObserver({root: s, ...e}) {
    const a = s || document;
    observers.has(a) || observers.set(a, {});
    const o = observers.get(a)
      , c = JSON.stringify(e);
    return o[c] || (o[c] = new IntersectionObserver(fireAllObserverCallbacks,{
        root: s,
        ...e
    })),
    o[c]
}
function observeIntersection(s, e, a) {
    const o = initIntersectionObserver(e);
    return observerCallbacks.set(s, a),
    o.observe(s),
    () => {
        observerCallbacks.delete(s),
        o.unobserve(s)
    }
}
const thresholdNames = {
    some: 0,
    all: 1
};
class InViewFeature extends Feature {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: e={}} = this.node.getProps()
          , {root: a, margin: o, amount: c="some", once: d} = e
          , g = {
            root: a ? a.current : void 0,
            rootMargin: o,
            threshold: typeof c == "number" ? c : thresholdNames[c]
        }
          , _ = b => {
            const {isIntersecting: j} = b;
            if (this.isInView === j || (this.isInView = j,
            d && !j && this.hasEnteredView))
                return;
            j && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", j);
            const {onViewportEnter: $, onViewportLeave: nt} = this.node.getProps()
              , tt = j ? $ : nt;
            tt && tt(b)
        }
        ;
        return observeIntersection(this.node.current, g, _)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: e, prevProps: a} = this.node;
        ["amount", "margin", "root"].some(hasViewportOptionChanged(e, a)) && this.startObserver()
    }
    unmount() {}
}
function hasViewportOptionChanged({viewport: s={}}, {viewport: e={}}={}) {
    return a => s[a] !== e[a]
}
const gestureAnimations = {
    inView: {
        Feature: InViewFeature
    },
    tap: {
        Feature: PressGesture
    },
    focus: {
        Feature: FocusGesture
    },
    hover: {
        Feature: HoverGesture
    }
}
  , layout$1 = {
    layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
}
  , MotionConfigContext = reactExports.createContext({
    transformPagePoint: s => s,
    isStatic: !1,
    reducedMotion: "never"
})
  , MotionContext = reactExports.createContext({})
  , isBrowser = typeof window < "u"
  , useIsomorphicLayoutEffect$3 = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect
  , LazyContext = reactExports.createContext({
    strict: !1
});
function useVisualElement(s, e, a, o, c) {
    var d, g;
    const {visualElement: _} = reactExports.useContext(MotionContext)
      , b = reactExports.useContext(LazyContext)
      , j = reactExports.useContext(PresenceContext)
      , $ = reactExports.useContext(MotionConfigContext).reducedMotion
      , nt = reactExports.useRef();
    o = o || b.renderer,
    !nt.current && o && (nt.current = o(s, {
        visualState: e,
        parent: _,
        props: a,
        presenceContext: j,
        blockInitialAnimation: j ? j.initial === !1 : !1,
        reducedMotionConfig: $
    }));
    const tt = nt.current
      , rt = reactExports.useContext(SwitchLayoutGroupContext);
    tt && !tt.projection && c && (tt.type === "html" || tt.type === "svg") && createProjectionNode(nt.current, a, c, rt),
    reactExports.useInsertionEffect( () => {
        tt && tt.update(a, j)
    }
    );
    const st = a[optimizedAppearDataAttribute]
      , lt = reactExports.useRef(!!st && !(!((d = window.MotionHandoffIsComplete) === null || d === void 0) && d.call(window, st)) && ((g = window.MotionHasOptimisedAnimation) === null || g === void 0 ? void 0 : g.call(window, st)));
    return useIsomorphicLayoutEffect$3( () => {
        tt && (window.MotionIsMounted = !0,
        tt.updateFeatures(),
        microtask.render(tt.render),
        lt.current && tt.animationState && tt.animationState.animateChanges())
    }
    ),
    reactExports.useEffect( () => {
        tt && (!lt.current && tt.animationState && tt.animationState.animateChanges(),
        lt.current && (queueMicrotask( () => {
            var ct;
            (ct = window.MotionHandoffMarkAsComplete) === null || ct === void 0 || ct.call(window, st)
        }
        ),
        lt.current = !1))
    }
    ),
    tt
}
function createProjectionNode(s, e, a, o) {
    const {layoutId: c, layout: d, drag: g, dragConstraints: _, layoutScroll: b, layoutRoot: j} = e;
    s.projection = new a(s.latestValues,e["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(s.parent)),
    s.projection.setOptions({
        layoutId: c,
        layout: d,
        alwaysMeasureLayout: !!g || _ && isRefObject$1(_),
        visualElement: s,
        animationType: typeof d == "string" ? d : "both",
        initialPromotionConfig: o,
        layoutScroll: b,
        layoutRoot: j
    })
}
function getClosestProjectingNode(s) {
    if (s)
        return s.options.allowProjection !== !1 ? s.projection : getClosestProjectingNode(s.parent)
}
function useMotionRef(s, e, a) {
    return reactExports.useCallback(o => {
        o && s.mount && s.mount(o),
        e && (o ? e.mount(o) : e.unmount()),
        a && (typeof a == "function" ? a(o) : isRefObject$1(a) && (a.current = o))
    }
    , [e])
}
function isControllingVariants(s) {
    return isAnimationControls(s.animate) || variantProps.some(e => isVariantLabel(s[e]))
}
function isVariantNode(s) {
    return !!(isControllingVariants(s) || s.variants)
}
function getCurrentTreeVariants(s, e) {
    if (isControllingVariants(s)) {
        const {initial: a, animate: o} = s;
        return {
            initial: a === !1 || isVariantLabel(a) ? a : void 0,
            animate: isVariantLabel(o) ? o : void 0
        }
    }
    return s.inherit !== !1 ? e : {}
}
function useCreateMotionContext(s) {
    const {initial: e, animate: a} = getCurrentTreeVariants(s, reactExports.useContext(MotionContext));
    return reactExports.useMemo( () => ({
        initial: e,
        animate: a
    }), [variantLabelsAsDependency(e), variantLabelsAsDependency(a)])
}
function variantLabelsAsDependency(s) {
    return Array.isArray(s) ? s.join(" ") : s
}
const featureProps = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , featureDefinitions = {};
for (const s in featureProps)
    featureDefinitions[s] = {
        isEnabled: e => featureProps[s].some(a => !!e[a])
    };
function loadFeatures(s) {
    for (const e in s)
        featureDefinitions[e] = {
            ...featureDefinitions[e],
            ...s[e]
        }
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createRendererMotionComponent({preloadedFeatures: s, createVisualElement: e, useRender: a, useVisualState: o, Component: c}) {
    s && loadFeatures(s);
    function d(_, b) {
        let j;
        const $ = {
            ...reactExports.useContext(MotionConfigContext),
            ..._,
            layoutId: useLayoutId(_)
        }
          , {isStatic: nt} = $
          , tt = useCreateMotionContext(_)
          , rt = o(_, nt);
        if (!nt && isBrowser) {
            useStrictMode();
            const st = getProjectionFunctionality($);
            j = st.MeasureLayout,
            tt.visualElement = useVisualElement(c, rt, $, e, st.ProjectionNode)
        }
        return jsxRuntimeExports.jsxs(MotionContext.Provider, {
            value: tt,
            children: [j && tt.visualElement ? jsxRuntimeExports.jsx(j, {
                visualElement: tt.visualElement,
                ...$
            }) : null, a(c, _, useMotionRef(rt, tt.visualElement, b), rt, nt, tt.visualElement)]
        })
    }
    const g = reactExports.forwardRef(d);
    return g[motionComponentSymbol] = c,
    g
}
function useLayoutId({layoutId: s}) {
    const e = reactExports.useContext(LayoutGroupContext).id;
    return e && s !== void 0 ? e + "-" + s : s
}
function useStrictMode(s, e) {
    reactExports.useContext(LazyContext).strict
}
function getProjectionFunctionality(s) {
    const {drag: e, layout: a} = featureDefinitions;
    if (!e && !a)
        return {};
    const o = {
        ...e,
        ...a
    };
    return {
        MeasureLayout: e != null && e.isEnabled(s) || a != null && a.isEnabled(s) ? o.MeasureLayout : void 0,
        ProjectionNode: o.ProjectionNode
    }
}
const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function isSVGComponent(s) {
    return typeof s != "string" || s.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(s) > -1 || /[A-Z]/u.test(s))
}
function renderHTML(s, {style: e, vars: a}, o, c) {
    Object.assign(s.style, e, c && c.getProjectionStyles(o));
    for (const d in a)
        s.style.setProperty(d, a[d])
}
const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function renderSVG(s, e, a, o) {
    renderHTML(s, e, void 0, o);
    for (const c in e.attrs)
        s.setAttribute(camelCaseAttributes.has(c) ? c : camelToDash(c), e.attrs[c])
}
function isForcedMotionValue(s, {layout: e, layoutId: a}) {
    return transformProps.has(s) || s.startsWith("origin") || (e || a !== void 0) && (!!scaleCorrectors[s] || s === "opacity")
}
function scrapeMotionValuesFromProps$1(s, e, a) {
    var o;
    const {style: c} = s
      , d = {};
    for (const g in c)
        (isMotionValue(c[g]) || e.style && isMotionValue(e.style[g]) || isForcedMotionValue(g, s) || ((o = a == null ? void 0 : a.getValue(g)) === null || o === void 0 ? void 0 : o.liveStyle) !== void 0) && (d[g] = c[g]);
    return a && c && typeof c.willChange == "string" && (a.applyWillChange = !1),
    d
}
function scrapeMotionValuesFromProps(s, e, a) {
    const o = scrapeMotionValuesFromProps$1(s, e, a);
    for (const c in s)
        if (isMotionValue(s[c]) || isMotionValue(e[c])) {
            const d = transformPropOrder.indexOf(c) !== -1 ? "attr" + c.charAt(0).toUpperCase() + c.substring(1) : c;
            o[d] = s[c]
        }
    return o
}
function useConstant(s) {
    const e = reactExports.useRef(null);
    return e.current === null && (e.current = s()),
    e.current
}
function makeState({applyWillChange: s=!1, scrapeMotionValuesFromProps: e, createRenderState: a, onMount: o}, c, d, g, _) {
    const b = {
        latestValues: makeLatestValues(c, d, g, _ ? !1 : s, e),
        renderState: a()
    };
    return o && (b.mount = j => o(c, j, b)),
    b
}
const makeUseVisualState = s => (e, a) => {
    const o = reactExports.useContext(MotionContext)
      , c = reactExports.useContext(PresenceContext)
      , d = () => makeState(s, e, o, c, a);
    return a ? d() : useConstant(d)
}
;
function forEachDefinition(s, e, a) {
    const o = Array.isArray(e) ? e : [e];
    for (let c = 0; c < o.length; c++) {
        const d = resolveVariantFromProps(s, o[c]);
        if (d) {
            const {transitionEnd: g, transition: _, ...b} = d;
            a(b, g)
        }
    }
}
function makeLatestValues(s, e, a, o, c) {
    var d;
    const g = {};
    let _ = o && ((d = s.style) === null || d === void 0 ? void 0 : d.willChange) === void 0;
    const b = c(s, {});
    for (const lt in b)
        g[lt] = resolveMotionValue(b[lt]);
    let {initial: j, animate: $} = s;
    const nt = isControllingVariants(s)
      , tt = isVariantNode(s);
    e && tt && !nt && s.inherit !== !1 && (j === void 0 && (j = e.initial),
    $ === void 0 && ($ = e.animate));
    let rt = a ? a.initial === !1 : !1;
    rt = rt || j === !1;
    const st = rt ? $ : j;
    return st && typeof st != "boolean" && !isAnimationControls(st) && forEachDefinition(s, st, (lt, ct) => {
        for (const it in lt) {
            let ot = lt[it];
            if (Array.isArray(ot)) {
                const at = rt ? ot.length - 1 : 0;
                ot = ot[at]
            }
            ot !== null && (g[it] = ot)
        }
        for (const it in ct)
            g[it] = ct[it]
    }
    ),
    _ && $ && j !== !1 && !isAnimationControls($) && forEachDefinition(s, $, lt => {
        for (const ct in lt)
            if (getWillChangeName(ct)) {
                g.willChange = "transform";
                return
            }
    }
    ),
    g
}
const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
})
  , createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
})
  , getValueAsType = (s, e) => e && typeof s == "number" ? e.transform(s) : s
  , translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , numTransforms = transformPropOrder.length;
function buildTransform(s, e, a) {
    let o = ""
      , c = !0;
    for (let d = 0; d < numTransforms; d++) {
        const g = transformPropOrder[d]
          , _ = s[g];
        if (_ === void 0)
            continue;
        let b = !0;
        if (typeof _ == "number" ? b = _ === (g.startsWith("scale") ? 1 : 0) : b = parseFloat(_) === 0,
        !b || a) {
            const j = getValueAsType(_, numberValueTypes[g]);
            if (!b) {
                c = !1;
                const $ = translateAlias[g] || g;
                o += `${$}(${j}) `
            }
            a && (e[g] = j)
        }
    }
    return o = o.trim(),
    a ? o = a(e, c ? "" : o) : c && (o = "none"),
    o
}
function buildHTMLStyles(s, e, a) {
    const {style: o, vars: c, transformOrigin: d} = s;
    let g = !1
      , _ = !1;
    for (const b in e) {
        const j = e[b];
        if (transformProps.has(b)) {
            g = !0;
            continue
        } else if (isCSSVariableName(b)) {
            c[b] = j;
            continue
        } else {
            const $ = getValueAsType(j, numberValueTypes[b]);
            b.startsWith("origin") ? (_ = !0,
            d[b] = $) : o[b] = $
        }
    }
    if (e.transform || (g || a ? o.transform = buildTransform(e, s.transform, a) : o.transform && (o.transform = "none")),
    _) {
        const {originX: b="50%", originY: j="50%", originZ: $=0} = d;
        o.transformOrigin = `${b} ${j} ${$}`
    }
}
function calcOrigin(s, e, a) {
    return typeof s == "string" ? s : px$1.transform(e + a * s)
}
function calcSVGTransformOrigin(s, e, a) {
    const o = calcOrigin(e, s.x, s.width)
      , c = calcOrigin(a, s.y, s.height);
    return `${o} ${c}`
}
const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function buildSVGPath(s, e, a=1, o=0, c=!0) {
    s.pathLength = 1;
    const d = c ? dashKeys : camelKeys;
    s[d.offset] = px$1.transform(-o);
    const g = px$1.transform(e)
      , _ = px$1.transform(a);
    s[d.array] = `${g} ${_}`
}
function buildSVGAttrs(s, {attrX: e, attrY: a, attrScale: o, originX: c, originY: d, pathLength: g, pathSpacing: _=1, pathOffset: b=0, ...j}, $, nt) {
    if (buildHTMLStyles(s, j, nt),
    $) {
        s.style.viewBox && (s.attrs.viewBox = s.style.viewBox);
        return
    }
    s.attrs = s.style,
    s.style = {};
    const {attrs: tt, style: rt, dimensions: st} = s;
    tt.transform && (st && (rt.transform = tt.transform),
    delete tt.transform),
    st && (c !== void 0 || d !== void 0 || rt.transform) && (rt.transformOrigin = calcSVGTransformOrigin(st, c !== void 0 ? c : .5, d !== void 0 ? d : .5)),
    e !== void 0 && (tt.x = e),
    a !== void 0 && (tt.y = a),
    o !== void 0 && (tt.scale = o),
    g !== void 0 && buildSVGPath(tt, g, _, b, !1)
}
const isSVGTag = s => typeof s == "string" && s.toLowerCase() === "svg"
  , svgMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (s, e, {renderState: a, latestValues: o}) => {
            frame.read( () => {
                try {
                    a.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
                } catch {
                    a.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }
            ),
            frame.render( () => {
                buildSVGAttrs(a, o, isSVGTag(e.tagName), s.transformTemplate),
                renderSVG(e, a)
            }
            )
        }
    })
}
  , htmlMotionConfig = {
    useVisualState: makeUseVisualState({
        applyWillChange: !0,
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
    })
};
function copyRawValuesOnly(s, e, a) {
    for (const o in e)
        !isMotionValue(e[o]) && !isForcedMotionValue(o, a) && (s[o] = e[o])
}
function useInitialMotionValues({transformTemplate: s}, e) {
    return reactExports.useMemo( () => {
        const a = createHtmlRenderState();
        return buildHTMLStyles(a, e, s),
        Object.assign({}, a.vars, a.style)
    }
    , [e])
}
function useStyle(s, e) {
    const a = s.style || {}
      , o = {};
    return copyRawValuesOnly(o, a, s),
    Object.assign(o, useInitialMotionValues(s, e)),
    o
}
function useHTMLProps(s, e) {
    const a = {}
      , o = useStyle(s, e);
    return s.drag && s.dragListener !== !1 && (a.draggable = !1,
    o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = "none",
    o.touchAction = s.drag === !0 ? "none" : `pan-${s.drag === "x" ? "y" : "x"}`),
    s.tabIndex === void 0 && (s.onTap || s.onTapStart || s.whileTap) && (a.tabIndex = 0),
    a.style = o,
    a
}
const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function isValidMotionProp(s) {
    return s.startsWith("while") || s.startsWith("drag") && s !== "draggable" || s.startsWith("layout") || s.startsWith("onTap") || s.startsWith("onPan") || s.startsWith("onLayout") || validMotionProps.has(s)
}
let shouldForward = s => !isValidMotionProp(s);
function loadExternalIsValidProp(s) {
    s && (shouldForward = e => e.startsWith("on") ? !isValidMotionProp(e) : s(e))
}
try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
} catch {}
function filterProps(s, e, a) {
    const o = {};
    for (const c in s)
        c === "values" && typeof s.values == "object" || (shouldForward(c) || a === !0 && isValidMotionProp(c) || !e && !isValidMotionProp(c) || s.draggable && c.startsWith("onDrag")) && (o[c] = s[c]);
    return o
}
function useSVGProps(s, e, a, o) {
    const c = reactExports.useMemo( () => {
        const d = createSvgRenderState();
        return buildSVGAttrs(d, e, isSVGTag(o), s.transformTemplate),
        {
            ...d.attrs,
            style: {
                ...d.style
            }
        }
    }
    , [e]);
    if (s.style) {
        const d = {};
        copyRawValuesOnly(d, s.style, s),
        c.style = {
            ...d,
            ...c.style
        }
    }
    return c
}
function createUseRender(s=!1) {
    return (a, o, c, {latestValues: d}, g) => {
        const b = (isSVGComponent(a) ? useSVGProps : useHTMLProps)(o, d, g, a)
          , j = filterProps(o, typeof a == "string", s)
          , $ = a !== reactExports.Fragment ? {
            ...j,
            ...b,
            ref: c
        } : {}
          , {children: nt} = o
          , tt = reactExports.useMemo( () => isMotionValue(nt) ? nt.get() : nt, [nt]);
        return reactExports.createElement(a, {
            ...$,
            children: tt
        })
    }
}
function createMotionComponentFactory(s, e) {
    return function(o, {forwardMotionProps: c}={
        forwardMotionProps: !1
    }) {
        const g = {
            ...isSVGComponent(o) ? svgMotionConfig : htmlMotionConfig,
            preloadedFeatures: s,
            useRender: createUseRender(c),
            createVisualElement: e,
            Component: o
        };
        return createRendererMotionComponent(g)
    }
}
const prefersReducedMotion = {
    current: null
}
  , hasReducedMotionListener = {
    current: !1
};
function initPrefersReducedMotion() {
    if (hasReducedMotionListener.current = !0,
    !!isBrowser)
        if (window.matchMedia) {
            const s = window.matchMedia("(prefers-reduced-motion)")
              , e = () => prefersReducedMotion.current = s.matches;
            s.addListener(e),
            e()
        } else
            prefersReducedMotion.current = !1
}
function updateMotionValuesFromProps(s, e, a) {
    for (const o in e) {
        const c = e[o]
          , d = a[o];
        if (isMotionValue(c))
            s.addValue(o, c);
        else if (isMotionValue(d))
            s.addValue(o, motionValue(c, {
                owner: s
            }));
        else if (d !== c)
            if (s.hasValue(o)) {
                const g = s.getValue(o);
                g.liveStyle === !0 ? g.jump(c) : g.hasAnimated || g.set(c)
            } else {
                const g = s.getStaticValue(o);
                s.addValue(o, motionValue(g !== void 0 ? g : c, {
                    owner: s
                }))
            }
    }
    for (const o in a)
        e[o] === void 0 && s.removeValue(o);
    return e
}
const visualElementStore = new WeakMap
  , valueTypes = [...dimensionValueTypes, color, complex]
  , findValueType = s => valueTypes.find(testValueType(s))
  , propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class VisualElement {
    scrapeMotionValuesFromProps(e, a, o) {
        return {}
    }
    constructor({parent: e, props: a, presenceContext: o, reducedMotionConfig: c, blockInitialAnimation: d, visualState: g}, _={}) {
        this.applyWillChange = !1,
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = KeyframeResolver,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.renderScheduledAt = 0,
        this.scheduleRender = () => {
            const tt = time.now();
            this.renderScheduledAt < tt && (this.renderScheduledAt = tt,
            frame.render(this.render, !1, !0))
        }
        ;
        const {latestValues: b, renderState: j} = g;
        this.latestValues = b,
        this.baseTarget = {
            ...b
        },
        this.initialValues = a.initial ? {
            ...b
        } : {},
        this.renderState = j,
        this.parent = e,
        this.props = a,
        this.presenceContext = o,
        this.depth = e ? e.depth + 1 : 0,
        this.reducedMotionConfig = c,
        this.options = _,
        this.blockInitialAnimation = !!d,
        this.isControllingVariants = isControllingVariants(a),
        this.isVariantNode = isVariantNode(a),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(e && e.current);
        const {willChange: $, ...nt} = this.scrapeMotionValuesFromProps(a, {}, this);
        for (const tt in nt) {
            const rt = nt[tt];
            b[tt] !== void 0 && isMotionValue(rt) && rt.set(b[tt], !1)
        }
    }
    mount(e) {
        this.current = e,
        visualElementStore.set(e, this),
        this.projection && !this.projection.instance && this.projection.mount(e),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (a, o) => this.bindToMotionValue(o, a)),
        hasReducedMotionListener.current || initPrefersReducedMotion(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        visualElementStore.delete(this.current),
        this.projection && this.projection.unmount(),
        cancelFrame(this.notifyUpdate),
        cancelFrame(this.render),
        this.valueSubscriptions.forEach(e => e()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const e in this.events)
            this.events[e].clear();
        for (const e in this.features) {
            const a = this.features[e];
            a && (a.unmount(),
            a.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(e, a) {
        this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
        const o = transformProps.has(e)
          , c = a.on("change", _ => {
            this.latestValues[e] = _,
            this.props.onUpdate && frame.preRender(this.notifyUpdate),
            o && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , d = a.on("renderRequest", this.scheduleRender);
        let g;
        window.MotionCheckAppearSync && (g = window.MotionCheckAppearSync(this, e, a)),
        this.valueSubscriptions.set(e, () => {
            c(),
            d(),
            g && g(),
            a.owner && a.stop()
        }
        )
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
        let e = "animation";
        for (e in featureDefinitions) {
            const a = featureDefinitions[e];
            if (!a)
                continue;
            const {isEnabled: o, Feature: c} = a;
            if (!this.features[e] && c && o(this.props) && (this.features[e] = new c(this)),
            this.features[e]) {
                const d = this.features[e];
                d.isMounted ? d.update() : (d.mount(),
                d.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, a) {
        this.latestValues[e] = a
    }
    update(e, a) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = e,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = a;
        for (let o = 0; o < propEventHandlers.length; o++) {
            const c = propEventHandlers[o];
            this.propEventSubscriptions[c] && (this.propEventSubscriptions[c](),
            delete this.propEventSubscriptions[c]);
            const d = "on" + c
              , g = e[d];
            g && (this.propEventSubscriptions[c] = this.on(c, g))
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(e) {
        const a = this.getClosestVariantNode();
        if (a)
            return a.variantChildren && a.variantChildren.add(e),
            () => a.variantChildren.delete(e)
    }
    addValue(e, a) {
        const o = this.values.get(e);
        a !== o && (o && this.removeValue(e),
        this.bindToMotionValue(e, a),
        this.values.set(e, a),
        this.latestValues[e] = a.get())
    }
    removeValue(e) {
        this.values.delete(e);
        const a = this.valueSubscriptions.get(e);
        a && (a(),
        this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, a) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let o = this.values.get(e);
        return o === void 0 && a !== void 0 && (o = motionValue(a === null ? void 0 : a, {
            owner: this
        }),
        this.addValue(e, o)),
        o
    }
    readValue(e, a) {
        var o;
        let c = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (o = this.getBaseTargetFromProps(this.props, e)) !== null && o !== void 0 ? o : this.readValueFromInstance(this.current, e, this.options);
        return c != null && (typeof c == "string" && (isNumericalString(c) || isZeroValueString(c)) ? c = parseFloat(c) : !findValueType(c) && complex.test(a) && (c = getAnimatableNone(e, a)),
        this.setBaseTarget(e, isMotionValue(c) ? c.get() : c)),
        isMotionValue(c) ? c.get() : c
    }
    setBaseTarget(e, a) {
        this.baseTarget[e] = a
    }
    getBaseTarget(e) {
        var a;
        const {initial: o} = this.props;
        let c;
        if (typeof o == "string" || typeof o == "object") {
            const g = resolveVariantFromProps(this.props, o, (a = this.presenceContext) === null || a === void 0 ? void 0 : a.custom);
            g && (c = g[e])
        }
        if (o && c !== void 0)
            return c;
        const d = this.getBaseTargetFromProps(this.props, e);
        return d !== void 0 && !isMotionValue(d) ? d : this.initialValues[e] !== void 0 && c === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, a) {
        return this.events[e] || (this.events[e] = new SubscriptionManager),
        this.events[e].add(a)
    }
    notify(e, ...a) {
        this.events[e] && this.events[e].notify(...a)
    }
}
class DOMVisualElement extends VisualElement {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = DOMKeyframesResolver
    }
    sortInstanceNodePosition(e, a) {
        return e.compareDocumentPosition(a) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, a) {
        return e.style ? e.style[a] : void 0
    }
    removeValueFromRenderState(e, {vars: a, style: o}) {
        delete a[e],
        delete o[e]
    }
}
function getComputedStyle(s) {
    return window.getComputedStyle(s)
}
class HTMLVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "html",
        this.applyWillChange = !0,
        this.renderInstance = renderHTML
    }
    readValueFromInstance(e, a) {
        if (transformProps.has(a)) {
            const o = getDefaultValueType(a);
            return o && o.default || 0
        } else {
            const o = getComputedStyle(e)
              , c = (isCSSVariableName(a) ? o.getPropertyValue(a) : o[a]) || 0;
            return typeof c == "string" ? c.trim() : c
        }
    }
    measureInstanceViewportBox(e, {transformPagePoint: a}) {
        return measureViewportBox(e, a)
    }
    build(e, a, o) {
        buildHTMLStyles(e, a, o.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, a, o) {
        return scrapeMotionValuesFromProps$1(e, a, o)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: e} = this.props;
        isMotionValue(e) && (this.childSubscription = e.on("change", a => {
            this.current && (this.current.textContent = `${a}`)
        }
        ))
    }
}
class SVGVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1,
        this.measureInstanceViewportBox = createBox
    }
    getBaseTargetFromProps(e, a) {
        return e[a]
    }
    readValueFromInstance(e, a) {
        if (transformProps.has(a)) {
            const o = getDefaultValueType(a);
            return o && o.default || 0
        }
        return a = camelCaseAttributes.has(a) ? a : camelToDash(a),
        e.getAttribute(a)
    }
    scrapeMotionValuesFromProps(e, a, o) {
        return scrapeMotionValuesFromProps(e, a, o)
    }
    build(e, a, o) {
        buildSVGAttrs(e, a, this.isSVGTag, o.transformTemplate)
    }
    renderInstance(e, a, o, c) {
        renderSVG(e, a, o, c)
    }
    mount(e) {
        this.isSVGTag = isSVGTag(e.tagName),
        super.mount(e)
    }
}
const createDomVisualElement = (s, e) => isSVGComponent(s) ? new SVGVisualElement(e) : new HTMLVisualElement(e,{
    allowProjection: s !== reactExports.Fragment
})
  , createMotionComponent = createMotionComponentFactory({
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout$1
}, createDomVisualElement)
  , motion = createDOMMotionComponentProxy(createMotionComponent)
  , styles = {
    boxWidth: "xl:max-w-[1280px] w-full",
    heading2: "font-poppins font-semibold xs:text-[48px] text-[40px] text-white xs:leading-[76.8px] leading-[66.8px] w-full",
    paragraph: "font-poppins font-normal text-dimWhite text-[18px] leading-[30.8px]",
    flexCenter: "flex justify-center items-center",
    flexStart: "flex justify-center items-start",
    flexEnd: "flex md:justify-end items-center",
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-12 py-4",
    marginX: "sm:mx-16 mx-6",
    marginY: "sm:my-16 my-6"
}
  , layout = {
    section: `flex md:flex-row flex-col ${styles.paddingY}`,
    sectionReverse: `flex md:flex-row flex-col-reverse ${styles.paddingY}  `,
    sectionImgReverse: `flex-1 flex ${styles.flexCenter} md:mr-10 mr-0 md:mt-0 mt-10 relative`,
    sectionImg: `flex-1 flex ${styles.flexCenter} md:ml-10 ml-0 md:mt-0 mt-10 relative`,
    sectionImgReverseEnd: `flex-1 flex ${styles.flexEnd} md:mr-12 ml-4 mb-4 md:mb-0 md:mt-0 mt-10 relative`,
    sectionInfo: `flex-1 ${styles.flexStart} flex-col`
};
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "167"
  , MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , CullFaceNone = 0
  , CullFaceBack = 1
  , CullFaceFront = 2
  , CullFaceFrontBack = 3
  , BasicShadowMap = 0
  , PCFShadowMap = 1
  , PCFSoftShadowMap = 2
  , VSMShadowMap = 3
  , FrontSide = 0
  , BackSide = 1
  , DoubleSide = 2
  , NoBlending = 0
  , NormalBlending = 1
  , AdditiveBlending = 2
  , SubtractiveBlending = 3
  , MultiplyBlending = 4
  , CustomBlending = 5
  , AddEquation = 100
  , SubtractEquation = 101
  , ReverseSubtractEquation = 102
  , MinEquation = 103
  , MaxEquation = 104
  , ZeroFactor = 200
  , OneFactor = 201
  , SrcColorFactor = 202
  , OneMinusSrcColorFactor = 203
  , SrcAlphaFactor = 204
  , OneMinusSrcAlphaFactor = 205
  , DstAlphaFactor = 206
  , OneMinusDstAlphaFactor = 207
  , DstColorFactor = 208
  , OneMinusDstColorFactor = 209
  , SrcAlphaSaturateFactor = 210
  , ConstantColorFactor = 211
  , OneMinusConstantColorFactor = 212
  , ConstantAlphaFactor = 213
  , OneMinusConstantAlphaFactor = 214
  , NeverDepth = 0
  , AlwaysDepth = 1
  , LessDepth = 2
  , LessEqualDepth = 3
  , EqualDepth = 4
  , GreaterEqualDepth = 5
  , GreaterDepth = 6
  , NotEqualDepth = 7
  , MultiplyOperation = 0
  , MixOperation = 1
  , AddOperation = 2
  , NoToneMapping = 0
  , LinearToneMapping = 1
  , ReinhardToneMapping = 2
  , CineonToneMapping = 3
  , ACESFilmicToneMapping = 4
  , CustomToneMapping = 5
  , AgXToneMapping = 6
  , NeutralToneMapping = 7
  , AttachedBindMode = "attached"
  , DetachedBindMode = "detached"
  , UVMapping = 300
  , CubeReflectionMapping = 301
  , CubeRefractionMapping = 302
  , EquirectangularReflectionMapping = 303
  , EquirectangularRefractionMapping = 304
  , CubeUVReflectionMapping = 306
  , RepeatWrapping = 1e3
  , ClampToEdgeWrapping = 1001
  , MirroredRepeatWrapping = 1002
  , NearestFilter = 1003
  , NearestMipmapNearestFilter = 1004
  , NearestMipMapNearestFilter = 1004
  , NearestMipmapLinearFilter = 1005
  , NearestMipMapLinearFilter = 1005
  , LinearFilter = 1006
  , LinearMipmapNearestFilter = 1007
  , LinearMipMapNearestFilter = 1007
  , LinearMipmapLinearFilter = 1008
  , LinearMipMapLinearFilter = 1008
  , UnsignedByteType = 1009
  , ByteType = 1010
  , ShortType = 1011
  , UnsignedShortType = 1012
  , IntType = 1013
  , UnsignedIntType = 1014
  , FloatType = 1015
  , HalfFloatType = 1016
  , UnsignedShort4444Type = 1017
  , UnsignedShort5551Type = 1018
  , UnsignedInt248Type = 1020
  , UnsignedInt5999Type = 35902
  , AlphaFormat = 1021
  , RGBFormat = 1022
  , RGBAFormat = 1023
  , LuminanceFormat = 1024
  , LuminanceAlphaFormat = 1025
  , DepthFormat = 1026
  , DepthStencilFormat = 1027
  , RedFormat = 1028
  , RedIntegerFormat = 1029
  , RGFormat = 1030
  , RGIntegerFormat = 1031
  , RGBIntegerFormat = 1032
  , RGBAIntegerFormat = 1033
  , RGB_S3TC_DXT1_Format = 33776
  , RGBA_S3TC_DXT1_Format = 33777
  , RGBA_S3TC_DXT3_Format = 33778
  , RGBA_S3TC_DXT5_Format = 33779
  , RGB_PVRTC_4BPPV1_Format = 35840
  , RGB_PVRTC_2BPPV1_Format = 35841
  , RGBA_PVRTC_4BPPV1_Format = 35842
  , RGBA_PVRTC_2BPPV1_Format = 35843
  , RGB_ETC1_Format = 36196
  , RGB_ETC2_Format = 37492
  , RGBA_ETC2_EAC_Format = 37496
  , RGBA_ASTC_4x4_Format = 37808
  , RGBA_ASTC_5x4_Format = 37809
  , RGBA_ASTC_5x5_Format = 37810
  , RGBA_ASTC_6x5_Format = 37811
  , RGBA_ASTC_6x6_Format = 37812
  , RGBA_ASTC_8x5_Format = 37813
  , RGBA_ASTC_8x6_Format = 37814
  , RGBA_ASTC_8x8_Format = 37815
  , RGBA_ASTC_10x5_Format = 37816
  , RGBA_ASTC_10x6_Format = 37817
  , RGBA_ASTC_10x8_Format = 37818
  , RGBA_ASTC_10x10_Format = 37819
  , RGBA_ASTC_12x10_Format = 37820
  , RGBA_ASTC_12x12_Format = 37821
  , RGBA_BPTC_Format = 36492
  , RGB_BPTC_SIGNED_Format = 36494
  , RGB_BPTC_UNSIGNED_Format = 36495
  , RED_RGTC1_Format = 36283
  , SIGNED_RED_RGTC1_Format = 36284
  , RED_GREEN_RGTC2_Format = 36285
  , SIGNED_RED_GREEN_RGTC2_Format = 36286
  , LoopOnce = 2200
  , LoopRepeat = 2201
  , LoopPingPong = 2202
  , InterpolateDiscrete = 2300
  , InterpolateLinear = 2301
  , InterpolateSmooth = 2302
  , ZeroCurvatureEnding = 2400
  , ZeroSlopeEnding = 2401
  , WrapAroundEnding = 2402
  , NormalAnimationBlendMode = 2500
  , AdditiveAnimationBlendMode = 2501
  , TrianglesDrawMode = 0
  , TriangleStripDrawMode = 1
  , TriangleFanDrawMode = 2
  , BasicDepthPacking = 3200
  , RGBADepthPacking = 3201
  , RGBDepthPacking = 3202
  , RGDepthPacking = 3203
  , TangentSpaceNormalMap = 0
  , ObjectSpaceNormalMap = 1
  , NoColorSpace = ""
  , SRGBColorSpace = "srgb"
  , LinearSRGBColorSpace = "srgb-linear"
  , DisplayP3ColorSpace = "display-p3"
  , LinearDisplayP3ColorSpace = "display-p3-linear"
  , LinearTransfer = "linear"
  , SRGBTransfer = "srgb"
  , Rec709Primaries = "rec709"
  , P3Primaries = "p3"
  , ZeroStencilOp = 0
  , KeepStencilOp = 7680
  , ReplaceStencilOp = 7681
  , IncrementStencilOp = 7682
  , DecrementStencilOp = 7683
  , IncrementWrapStencilOp = 34055
  , DecrementWrapStencilOp = 34056
  , InvertStencilOp = 5386
  , NeverStencilFunc = 512
  , LessStencilFunc = 513
  , EqualStencilFunc = 514
  , LessEqualStencilFunc = 515
  , GreaterStencilFunc = 516
  , NotEqualStencilFunc = 517
  , GreaterEqualStencilFunc = 518
  , AlwaysStencilFunc = 519
  , NeverCompare = 512
  , LessCompare = 513
  , EqualCompare = 514
  , LessEqualCompare = 515
  , GreaterCompare = 516
  , NotEqualCompare = 517
  , GreaterEqualCompare = 518
  , AlwaysCompare = 519
  , StaticDrawUsage = 35044
  , DynamicDrawUsage = 35048
  , StreamDrawUsage = 35040
  , StaticReadUsage = 35045
  , DynamicReadUsage = 35049
  , StreamReadUsage = 35041
  , StaticCopyUsage = 35046
  , DynamicCopyUsage = 35050
  , StreamCopyUsage = 35042
  , GLSL1 = "100"
  , GLSL3 = "300 es"
  , WebGLCoordinateSystem = 2e3
  , WebGPUCoordinateSystem = 2001;
class EventDispatcher {
    addEventListener(e, a) {
        this._listeners === void 0 && (this._listeners = {});
        const o = this._listeners;
        o[e] === void 0 && (o[e] = []),
        o[e].indexOf(a) === -1 && o[e].push(a)
    }
    hasEventListener(e, a) {
        if (this._listeners === void 0)
            return !1;
        const o = this._listeners;
        return o[e] !== void 0 && o[e].indexOf(a) !== -1
    }
    removeEventListener(e, a) {
        if (this._listeners === void 0)
            return;
        const c = this._listeners[e];
        if (c !== void 0) {
            const d = c.indexOf(a);
            d !== -1 && c.splice(d, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const o = this._listeners[e.type];
        if (o !== void 0) {
            e.target = this;
            const c = o.slice(0);
            for (let d = 0, g = c.length; d < g; d++)
                c[d].call(this, e);
            e.target = null
        }
    }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180
  , RAD2DEG = 180 / Math.PI;
function generateUUID() {
    const s = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , a = Math.random() * 4294967295 | 0
      , o = Math.random() * 4294967295 | 0;
    return (_lut[s & 255] + _lut[s >> 8 & 255] + _lut[s >> 16 & 255] + _lut[s >> 24 & 255] + "-" + _lut[e & 255] + _lut[e >> 8 & 255] + "-" + _lut[e >> 16 & 15 | 64] + _lut[e >> 24 & 255] + "-" + _lut[a & 63 | 128] + _lut[a >> 8 & 255] + "-" + _lut[a >> 16 & 255] + _lut[a >> 24 & 255] + _lut[o & 255] + _lut[o >> 8 & 255] + _lut[o >> 16 & 255] + _lut[o >> 24 & 255]).toLowerCase()
}
function clamp(s, e, a) {
    return Math.max(e, Math.min(a, s))
}
function euclideanModulo(s, e) {
    return (s % e + e) % e
}
function mapLinear(s, e, a, o, c) {
    return o + (s - e) * (c - o) / (a - e)
}
function inverseLerp(s, e, a) {
    return s !== e ? (a - s) / (e - s) : 0
}
function lerp(s, e, a) {
    return (1 - a) * s + a * e
}
function damp(s, e, a, o) {
    return lerp(s, e, 1 - Math.exp(-a * o))
}
function pingpong(s, e=1) {
    return e - Math.abs(euclideanModulo(s, e * 2) - e)
}
function smoothstep(s, e, a) {
    return s <= e ? 0 : s >= a ? 1 : (s = (s - e) / (a - e),
    s * s * (3 - 2 * s))
}
function smootherstep(s, e, a) {
    return s <= e ? 0 : s >= a ? 1 : (s = (s - e) / (a - e),
    s * s * s * (s * (s * 6 - 15) + 10))
}
function randInt(s, e) {
    return s + Math.floor(Math.random() * (e - s + 1))
}
function randFloat(s, e) {
    return s + Math.random() * (e - s)
}
function randFloatSpread(s) {
    return s * (.5 - Math.random())
}
function seededRandom(s) {
    s !== void 0 && (_seed = s);
    let e = _seed += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function degToRad(s) {
    return s * DEG2RAD
}
function radToDeg(s) {
    return s * RAD2DEG
}
function isPowerOfTwo(s) {
    return (s & s - 1) === 0 && s !== 0
}
function ceilPowerOfTwo(s) {
    return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2))
}
function floorPowerOfTwo(s) {
    return Math.pow(2, Math.floor(Math.log(s) / Math.LN2))
}
function setQuaternionFromProperEuler(s, e, a, o, c) {
    const d = Math.cos
      , g = Math.sin
      , _ = d(a / 2)
      , b = g(a / 2)
      , j = d((e + o) / 2)
      , $ = g((e + o) / 2)
      , nt = d((e - o) / 2)
      , tt = g((e - o) / 2)
      , rt = d((o - e) / 2)
      , st = g((o - e) / 2);
    switch (c) {
    case "XYX":
        s.set(_ * $, b * nt, b * tt, _ * j);
        break;
    case "YZY":
        s.set(b * tt, _ * $, b * nt, _ * j);
        break;
    case "ZXZ":
        s.set(b * nt, b * tt, _ * $, _ * j);
        break;
    case "XZX":
        s.set(_ * $, b * st, b * rt, _ * j);
        break;
    case "YXY":
        s.set(b * rt, _ * $, b * st, _ * j);
        break;
    case "ZYZ":
        s.set(b * st, b * rt, _ * $, _ * j);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + c)
    }
}
function denormalize(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return s / 4294967295;
    case Uint16Array:
        return s / 65535;
    case Uint8Array:
        return s / 255;
    case Int32Array:
        return Math.max(s / 2147483647, -1);
    case Int16Array:
        return Math.max(s / 32767, -1);
    case Int8Array:
        return Math.max(s / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function normalize(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return Math.round(s * 4294967295);
    case Uint16Array:
        return Math.round(s * 65535);
    case Uint8Array:
        return Math.round(s * 255);
    case Int32Array:
        return Math.round(s * 2147483647);
    case Int16Array:
        return Math.round(s * 32767);
    case Int8Array:
        return Math.round(s * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const MathUtils = {
    DEG2RAD,
    RAD2DEG,
    generateUUID,
    clamp,
    euclideanModulo,
    mapLinear,
    inverseLerp,
    lerp,
    damp,
    pingpong,
    smoothstep,
    smootherstep,
    randInt,
    randFloat,
    randFloatSpread,
    seededRandom,
    degToRad,
    radToDeg,
    isPowerOfTwo,
    ceilPowerOfTwo,
    floorPowerOfTwo,
    setQuaternionFromProperEuler,
    normalize,
    denormalize
};
class Vector2 {
    constructor(e=0, a=0) {
        Vector2.prototype.isVector2 = !0,
        this.x = e,
        this.y = a
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, a) {
        return this.x = e,
        this.y = a,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, a) {
        switch (e) {
        case 0:
            this.x = a;
            break;
        case 1:
            this.y = a;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, a) {
        return this.x = e.x + a.x,
        this.y = e.y + a.y,
        this
    }
    addScaledVector(e, a) {
        return this.x += e.x * a,
        this.y += e.y * a,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, a) {
        return this.x = e.x - a.x,
        this.y = e.y - a.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const a = this.x
          , o = this.y
          , c = e.elements;
        return this.x = c[0] * a + c[3] * o + c[6],
        this.y = c[1] * a + c[4] * o + c[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, a) {
        return this.x = Math.max(e.x, Math.min(a.x, this.x)),
        this.y = Math.max(e.y, Math.min(a.y, this.y)),
        this
    }
    clampScalar(e, a) {
        return this.x = Math.max(e, Math.min(a, this.x)),
        this.y = Math.max(e, Math.min(a, this.y)),
        this
    }
    clampLength(e, a) {
        const o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(a, o)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const a = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (a === 0)
            return Math.PI / 2;
        const o = this.dot(e) / a;
        return Math.acos(clamp(o, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const a = this.x - e.x
          , o = this.y - e.y;
        return a * a + o * o
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, a) {
        return this.x += (e.x - this.x) * a,
        this.y += (e.y - this.y) * a,
        this
    }
    lerpVectors(e, a, o) {
        return this.x = e.x + (a.x - e.x) * o,
        this.y = e.y + (a.y - e.y) * o,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, a=0) {
        return this.x = e[a],
        this.y = e[a + 1],
        this
    }
    toArray(e=[], a=0) {
        return e[a] = this.x,
        e[a + 1] = this.y,
        e
    }
    fromBufferAttribute(e, a) {
        return this.x = e.getX(a),
        this.y = e.getY(a),
        this
    }
    rotateAround(e, a) {
        const o = Math.cos(a)
          , c = Math.sin(a)
          , d = this.x - e.x
          , g = this.y - e.y;
        return this.x = d * o - g * c + e.x,
        this.y = d * c + g * o + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Matrix3 {
    constructor(e, a, o, c, d, g, _, b, j) {
        Matrix3.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, a, o, c, d, g, _, b, j)
    }
    set(e, a, o, c, d, g, _, b, j) {
        const $ = this.elements;
        return $[0] = e,
        $[1] = c,
        $[2] = _,
        $[3] = a,
        $[4] = d,
        $[5] = b,
        $[6] = o,
        $[7] = g,
        $[8] = j,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const a = this.elements
          , o = e.elements;
        return a[0] = o[0],
        a[1] = o[1],
        a[2] = o[2],
        a[3] = o[3],
        a[4] = o[4],
        a[5] = o[5],
        a[6] = o[6],
        a[7] = o[7],
        a[8] = o[8],
        this
    }
    extractBasis(e, a, o) {
        return e.setFromMatrix3Column(this, 0),
        a.setFromMatrix3Column(this, 1),
        o.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const a = e.elements;
        return this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, a) {
        const o = e.elements
          , c = a.elements
          , d = this.elements
          , g = o[0]
          , _ = o[3]
          , b = o[6]
          , j = o[1]
          , $ = o[4]
          , nt = o[7]
          , tt = o[2]
          , rt = o[5]
          , st = o[8]
          , lt = c[0]
          , ct = c[3]
          , it = c[6]
          , ot = c[1]
          , at = c[4]
          , ht = c[7]
          , pt = c[2]
          , dt = c[5]
          , yt = c[8];
        return d[0] = g * lt + _ * ot + b * pt,
        d[3] = g * ct + _ * at + b * dt,
        d[6] = g * it + _ * ht + b * yt,
        d[1] = j * lt + $ * ot + nt * pt,
        d[4] = j * ct + $ * at + nt * dt,
        d[7] = j * it + $ * ht + nt * yt,
        d[2] = tt * lt + rt * ot + st * pt,
        d[5] = tt * ct + rt * at + st * dt,
        d[8] = tt * it + rt * ht + st * yt,
        this
    }
    multiplyScalar(e) {
        const a = this.elements;
        return a[0] *= e,
        a[3] *= e,
        a[6] *= e,
        a[1] *= e,
        a[4] *= e,
        a[7] *= e,
        a[2] *= e,
        a[5] *= e,
        a[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , a = e[0]
          , o = e[1]
          , c = e[2]
          , d = e[3]
          , g = e[4]
          , _ = e[5]
          , b = e[6]
          , j = e[7]
          , $ = e[8];
        return a * g * $ - a * _ * j - o * d * $ + o * _ * b + c * d * j - c * g * b
    }
    invert() {
        const e = this.elements
          , a = e[0]
          , o = e[1]
          , c = e[2]
          , d = e[3]
          , g = e[4]
          , _ = e[5]
          , b = e[6]
          , j = e[7]
          , $ = e[8]
          , nt = $ * g - _ * j
          , tt = _ * b - $ * d
          , rt = j * d - g * b
          , st = a * nt + o * tt + c * rt;
        if (st === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const lt = 1 / st;
        return e[0] = nt * lt,
        e[1] = (c * j - $ * o) * lt,
        e[2] = (_ * o - c * g) * lt,
        e[3] = tt * lt,
        e[4] = ($ * a - c * b) * lt,
        e[5] = (c * d - _ * a) * lt,
        e[6] = rt * lt,
        e[7] = (o * b - j * a) * lt,
        e[8] = (g * a - o * d) * lt,
        this
    }
    transpose() {
        let e;
        const a = this.elements;
        return e = a[1],
        a[1] = a[3],
        a[3] = e,
        e = a[2],
        a[2] = a[6],
        a[6] = e,
        e = a[5],
        a[5] = a[7],
        a[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const a = this.elements;
        return e[0] = a[0],
        e[1] = a[3],
        e[2] = a[6],
        e[3] = a[1],
        e[4] = a[4],
        e[5] = a[7],
        e[6] = a[2],
        e[7] = a[5],
        e[8] = a[8],
        this
    }
    setUvTransform(e, a, o, c, d, g, _) {
        const b = Math.cos(d)
          , j = Math.sin(d);
        return this.set(o * b, o * j, -o * (b * g + j * _) + g + e, -c * j, c * b, -c * (-j * g + b * _) + _ + a, 0, 0, 1),
        this
    }
    scale(e, a) {
        return this.premultiply(_m3.makeScale(e, a)),
        this
    }
    rotate(e) {
        return this.premultiply(_m3.makeRotation(-e)),
        this
    }
    translate(e, a) {
        return this.premultiply(_m3.makeTranslation(e, a)),
        this
    }
    makeTranslation(e, a) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, a, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const a = Math.cos(e)
          , o = Math.sin(e);
        return this.set(a, -o, 0, o, a, 0, 0, 0, 1),
        this
    }
    makeScale(e, a) {
        return this.set(e, 0, 0, 0, a, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const a = this.elements
          , o = e.elements;
        for (let c = 0; c < 9; c++)
            if (a[c] !== o[c])
                return !1;
        return !0
    }
    fromArray(e, a=0) {
        for (let o = 0; o < 9; o++)
            this.elements[o] = e[o + a];
        return this
    }
    toArray(e=[], a=0) {
        const o = this.elements;
        return e[a] = o[0],
        e[a + 1] = o[1],
        e[a + 2] = o[2],
        e[a + 3] = o[3],
        e[a + 4] = o[4],
        e[a + 5] = o[5],
        e[a + 6] = o[6],
        e[a + 7] = o[7],
        e[a + 8] = o[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const _m3 = new Matrix3;
function arrayNeedsUint32(s) {
    for (let e = s.length - 1; e >= 0; --e)
        if (s[e] >= 65535)
            return !0;
    return !1
}
const TYPED_ARRAYS = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function getTypedArray(s, e) {
    return new TYPED_ARRAYS[s](e)
}
function createElementNS(s) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", s)
}
function createCanvasElement() {
    const s = createElementNS("canvas");
    return s.style.display = "block",
    s
}
const _cache = {};
function warnOnce(s) {
    s in _cache || (_cache[s] = !0,
    console.warn(s))
}
function probeAsync(s, e, a) {
    return new Promise(function(o, c) {
        function d() {
            switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case s.WAIT_FAILED:
                c();
                break;
            case s.TIMEOUT_EXPIRED:
                setTimeout(d, a);
                break;
            default:
                o()
            }
        }
        setTimeout(d, a)
    }
    )
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , COLOR_SPACES = {
    [LinearSRGBColorSpace]: {
        transfer: LinearTransfer,
        primaries: Rec709Primaries,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: s => s,
        fromReference: s => s
    },
    [SRGBColorSpace]: {
        transfer: SRGBTransfer,
        primaries: Rec709Primaries,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: s => s.convertSRGBToLinear(),
        fromReference: s => s.convertLinearToSRGB()
    },
    [LinearDisplayP3ColorSpace]: {
        transfer: LinearTransfer,
        primaries: P3Primaries,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: s => s.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
        fromReference: s => s.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
    },
    [DisplayP3ColorSpace]: {
        transfer: SRGBTransfer,
        primaries: P3Primaries,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: s => s.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
        fromReference: s => s.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
    }
}
  , SUPPORTED_WORKING_COLOR_SPACES = new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace])
  , ColorManagement = {
    enabled: !0,
    _workingColorSpace: LinearSRGBColorSpace,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(s) {
        if (!SUPPORTED_WORKING_COLOR_SPACES.has(s))
            throw new Error(`Unsupported working color space, "${s}".`);
        this._workingColorSpace = s
    },
    convert: function(s, e, a) {
        if (this.enabled === !1 || e === a || !e || !a)
            return s;
        const o = COLOR_SPACES[e].toReference
          , c = COLOR_SPACES[a].fromReference;
        return c(o(s))
    },
    fromWorkingColorSpace: function(s, e) {
        return this.convert(s, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(s, e) {
        return this.convert(s, e, this._workingColorSpace)
    },
    getPrimaries: function(s) {
        return COLOR_SPACES[s].primaries
    },
    getTransfer: function(s) {
        return s === NoColorSpace ? LinearTransfer : COLOR_SPACES[s].transfer
    },
    getLuminanceCoefficients: function(s, e=this._workingColorSpace) {
        return s.fromArray(COLOR_SPACES[e].luminanceCoefficients)
    }
};
function SRGBToLinear(s) {
    return s < .04045 ? s * .0773993808 : Math.pow(s * .9478672986 + .0521327014, 2.4)
}
function LinearToSRGB(s) {
    return s < .0031308 ? s * 12.92 : 1.055 * Math.pow(s, .41666) - .055
}
let _canvas;
class ImageUtils {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let a;
        if (e instanceof HTMLCanvasElement)
            a = e;
        else {
            _canvas === void 0 && (_canvas = createElementNS("canvas")),
            _canvas.width = e.width,
            _canvas.height = e.height;
            const o = _canvas.getContext("2d");
            e instanceof ImageData ? o.putImageData(e, 0, 0) : o.drawImage(e, 0, 0, e.width, e.height),
            a = _canvas
        }
        return a.width > 2048 || a.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        a.toDataURL("image/jpeg", .6)) : a.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const a = createElementNS("canvas");
            a.width = e.width,
            a.height = e.height;
            const o = a.getContext("2d");
            o.drawImage(e, 0, 0, e.width, e.height);
            const c = o.getImageData(0, 0, e.width, e.height)
              , d = c.data;
            for (let g = 0; g < d.length; g++)
                d[g] = SRGBToLinear(d[g] / 255) * 255;
            return o.putImageData(c, 0, 0),
            a
        } else if (e.data) {
            const a = e.data.slice(0);
            for (let o = 0; o < a.length; o++)
                a instanceof Uint8Array || a instanceof Uint8ClampedArray ? a[o] = Math.floor(SRGBToLinear(a[o] / 255) * 255) : a[o] = SRGBToLinear(a[o]);
            return {
                data: a,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let _sourceId = 0;
class Source {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: _sourceId++
        }),
        this.uuid = generateUUID(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const a = e === void 0 || typeof e == "string";
        if (!a && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const o = {
            uuid: this.uuid,
            url: ""
        }
          , c = this.data;
        if (c !== null) {
            let d;
            if (Array.isArray(c)) {
                d = [];
                for (let g = 0, _ = c.length; g < _; g++)
                    c[g].isDataTexture ? d.push(serializeImage(c[g].image)) : d.push(serializeImage(c[g]))
            } else
                d = serializeImage(c);
            o.url = d
        }
        return a || (e.images[this.uuid] = o),
        o
    }
}
function serializeImage(s) {
    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? ImageUtils.getDataURL(s) : s.data ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let _textureId = 0;
class Texture extends EventDispatcher {
    constructor(e=Texture.DEFAULT_IMAGE, a=Texture.DEFAULT_MAPPING, o=ClampToEdgeWrapping, c=ClampToEdgeWrapping, d=LinearFilter, g=LinearMipmapLinearFilter, _=RGBAFormat, b=UnsignedByteType, j=Texture.DEFAULT_ANISOTROPY, $=NoColorSpace) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: _textureId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.source = new Source(e),
        this.mipmaps = [],
        this.mapping = a,
        this.channel = 0,
        this.wrapS = o,
        this.wrapT = c,
        this.magFilter = d,
        this.minFilter = g,
        this.anisotropy = j,
        this.format = _,
        this.internalFormat = null,
        this.type = b,
        this.offset = new Vector2(0,0),
        this.repeat = new Vector2(1,1),
        this.center = new Vector2(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Matrix3,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = $,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const a = e === void 0 || typeof e == "string";
        if (!a && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const o = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (o.userData = this.userData),
        a || (e.textures[this.uuid] = o),
        o
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== UVMapping)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case RepeatWrapping:
                e.x = e.x - Math.floor(e.x);
                break;
            case ClampToEdgeWrapping:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case RepeatWrapping:
                e.y = e.y - Math.floor(e.y);
                break;
            case ClampToEdgeWrapping:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
    constructor(e=0, a=0, o=0, c=1) {
        Vector4.prototype.isVector4 = !0,
        this.x = e,
        this.y = a,
        this.z = o,
        this.w = c
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, a, o, c) {
        return this.x = e,
        this.y = a,
        this.z = o,
        this.w = c,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, a) {
        switch (e) {
        case 0:
            this.x = a;
            break;
        case 1:
            this.y = a;
            break;
        case 2:
            this.z = a;
            break;
        case 3:
            this.w = a;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, a) {
        return this.x = e.x + a.x,
        this.y = e.y + a.y,
        this.z = e.z + a.z,
        this.w = e.w + a.w,
        this
    }
    addScaledVector(e, a) {
        return this.x += e.x * a,
        this.y += e.y * a,
        this.z += e.z * a,
        this.w += e.w * a,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, a) {
        return this.x = e.x - a.x,
        this.y = e.y - a.y,
        this.z = e.z - a.z,
        this.w = e.w - a.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const a = this.x
          , o = this.y
          , c = this.z
          , d = this.w
          , g = e.elements;
        return this.x = g[0] * a + g[4] * o + g[8] * c + g[12] * d,
        this.y = g[1] * a + g[5] * o + g[9] * c + g[13] * d,
        this.z = g[2] * a + g[6] * o + g[10] * c + g[14] * d,
        this.w = g[3] * a + g[7] * o + g[11] * c + g[15] * d,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const a = Math.sqrt(1 - e.w * e.w);
        return a < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / a,
        this.y = e.y / a,
        this.z = e.z / a),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let a, o, c, d;
        const b = e.elements
          , j = b[0]
          , $ = b[4]
          , nt = b[8]
          , tt = b[1]
          , rt = b[5]
          , st = b[9]
          , lt = b[2]
          , ct = b[6]
          , it = b[10];
        if (Math.abs($ - tt) < .01 && Math.abs(nt - lt) < .01 && Math.abs(st - ct) < .01) {
            if (Math.abs($ + tt) < .1 && Math.abs(nt + lt) < .1 && Math.abs(st + ct) < .1 && Math.abs(j + rt + it - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            a = Math.PI;
            const at = (j + 1) / 2
              , ht = (rt + 1) / 2
              , pt = (it + 1) / 2
              , dt = ($ + tt) / 4
              , yt = (nt + lt) / 4
              , vt = (st + ct) / 4;
            return at > ht && at > pt ? at < .01 ? (o = 0,
            c = .707106781,
            d = .707106781) : (o = Math.sqrt(at),
            c = dt / o,
            d = yt / o) : ht > pt ? ht < .01 ? (o = .707106781,
            c = 0,
            d = .707106781) : (c = Math.sqrt(ht),
            o = dt / c,
            d = vt / c) : pt < .01 ? (o = .707106781,
            c = .707106781,
            d = 0) : (d = Math.sqrt(pt),
            o = yt / d,
            c = vt / d),
            this.set(o, c, d, a),
            this
        }
        let ot = Math.sqrt((ct - st) * (ct - st) + (nt - lt) * (nt - lt) + (tt - $) * (tt - $));
        return Math.abs(ot) < .001 && (ot = 1),
        this.x = (ct - st) / ot,
        this.y = (nt - lt) / ot,
        this.z = (tt - $) / ot,
        this.w = Math.acos((j + rt + it - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const a = e.elements;
        return this.x = a[12],
        this.y = a[13],
        this.z = a[14],
        this.w = a[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, a) {
        return this.x = Math.max(e.x, Math.min(a.x, this.x)),
        this.y = Math.max(e.y, Math.min(a.y, this.y)),
        this.z = Math.max(e.z, Math.min(a.z, this.z)),
        this.w = Math.max(e.w, Math.min(a.w, this.w)),
        this
    }
    clampScalar(e, a) {
        return this.x = Math.max(e, Math.min(a, this.x)),
        this.y = Math.max(e, Math.min(a, this.y)),
        this.z = Math.max(e, Math.min(a, this.z)),
        this.w = Math.max(e, Math.min(a, this.w)),
        this
    }
    clampLength(e, a) {
        const o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(a, o)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, a) {
        return this.x += (e.x - this.x) * a,
        this.y += (e.y - this.y) * a,
        this.z += (e.z - this.z) * a,
        this.w += (e.w - this.w) * a,
        this
    }
    lerpVectors(e, a, o) {
        return this.x = e.x + (a.x - e.x) * o,
        this.y = e.y + (a.y - e.y) * o,
        this.z = e.z + (a.z - e.z) * o,
        this.w = e.w + (a.w - e.w) * o,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, a=0) {
        return this.x = e[a],
        this.y = e[a + 1],
        this.z = e[a + 2],
        this.w = e[a + 3],
        this
    }
    toArray(e=[], a=0) {
        return e[a] = this.x,
        e[a + 1] = this.y,
        e[a + 2] = this.z,
        e[a + 3] = this.w,
        e
    }
    fromBufferAttribute(e, a) {
        return this.x = e.getX(a),
        this.y = e.getY(a),
        this.z = e.getZ(a),
        this.w = e.getW(a),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class RenderTarget extends EventDispatcher {
    constructor(e=1, a=1, o={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = a,
        this.depth = 1,
        this.scissor = new Vector4(0,0,e,a),
        this.scissorTest = !1,
        this.viewport = new Vector4(0,0,e,a);
        const c = {
            width: e,
            height: a,
            depth: 1
        };
        o = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: LinearFilter,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, o);
        const d = new Texture(c,o.mapping,o.wrapS,o.wrapT,o.magFilter,o.minFilter,o.format,o.type,o.anisotropy,o.colorSpace);
        d.flipY = !1,
        d.generateMipmaps = o.generateMipmaps,
        d.internalFormat = o.internalFormat,
        this.textures = [];
        const g = o.count;
        for (let _ = 0; _ < g; _++)
            this.textures[_] = d.clone(),
            this.textures[_].isRenderTargetTexture = !0;
        this.depthBuffer = o.depthBuffer,
        this.stencilBuffer = o.stencilBuffer,
        this.resolveDepthBuffer = o.resolveDepthBuffer,
        this.resolveStencilBuffer = o.resolveStencilBuffer,
        this.depthTexture = o.depthTexture,
        this.samples = o.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, a, o=1) {
        if (this.width !== e || this.height !== a || this.depth !== o) {
            this.width = e,
            this.height = a,
            this.depth = o;
            for (let c = 0, d = this.textures.length; c < d; c++)
                this.textures[c].image.width = e,
                this.textures[c].image.height = a,
                this.textures[c].image.depth = o;
            this.dispose()
        }
        this.viewport.set(0, 0, e, a),
        this.scissor.set(0, 0, e, a)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let o = 0, c = e.textures.length; o < c; o++)
            this.textures[o] = e.textures[o].clone(),
            this.textures[o].isRenderTargetTexture = !0;
        const a = Object.assign({}, e.texture.image);
        return this.texture.source = new Source(a),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class WebGLRenderTarget extends RenderTarget {
    constructor(e=1, a=1, o={}) {
        super(e, a, o),
        this.isWebGLRenderTarget = !0
    }
}
class DataArrayTexture extends Texture {
    constructor(e=null, a=1, o=1, c=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: a,
            height: o,
            depth: c
        },
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.wrapR = ClampToEdgeWrapping,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
    constructor(e=1, a=1, o=1, c={}) {
        super(e, a, c),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = o,
        this.texture = new DataArrayTexture(null,e,a,o),
        this.texture.isRenderTargetTexture = !0
    }
}
class Data3DTexture extends Texture {
    constructor(e=null, a=1, o=1, c=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: a,
            height: o,
            depth: c
        },
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.wrapR = ClampToEdgeWrapping,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
    constructor(e=1, a=1, o=1, c={}) {
        super(e, a, c),
        this.isWebGL3DRenderTarget = !0,
        this.depth = o,
        this.texture = new Data3DTexture(null,e,a,o),
        this.texture.isRenderTargetTexture = !0
    }
}
class Quaternion {
    constructor(e=0, a=0, o=0, c=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = a,
        this._z = o,
        this._w = c
    }
    static slerpFlat(e, a, o, c, d, g, _) {
        let b = o[c + 0]
          , j = o[c + 1]
          , $ = o[c + 2]
          , nt = o[c + 3];
        const tt = d[g + 0]
          , rt = d[g + 1]
          , st = d[g + 2]
          , lt = d[g + 3];
        if (_ === 0) {
            e[a + 0] = b,
            e[a + 1] = j,
            e[a + 2] = $,
            e[a + 3] = nt;
            return
        }
        if (_ === 1) {
            e[a + 0] = tt,
            e[a + 1] = rt,
            e[a + 2] = st,
            e[a + 3] = lt;
            return
        }
        if (nt !== lt || b !== tt || j !== rt || $ !== st) {
            let ct = 1 - _;
            const it = b * tt + j * rt + $ * st + nt * lt
              , ot = it >= 0 ? 1 : -1
              , at = 1 - it * it;
            if (at > Number.EPSILON) {
                const pt = Math.sqrt(at)
                  , dt = Math.atan2(pt, it * ot);
                ct = Math.sin(ct * dt) / pt,
                _ = Math.sin(_ * dt) / pt
            }
            const ht = _ * ot;
            if (b = b * ct + tt * ht,
            j = j * ct + rt * ht,
            $ = $ * ct + st * ht,
            nt = nt * ct + lt * ht,
            ct === 1 - _) {
                const pt = 1 / Math.sqrt(b * b + j * j + $ * $ + nt * nt);
                b *= pt,
                j *= pt,
                $ *= pt,
                nt *= pt
            }
        }
        e[a] = b,
        e[a + 1] = j,
        e[a + 2] = $,
        e[a + 3] = nt
    }
    static multiplyQuaternionsFlat(e, a, o, c, d, g) {
        const _ = o[c]
          , b = o[c + 1]
          , j = o[c + 2]
          , $ = o[c + 3]
          , nt = d[g]
          , tt = d[g + 1]
          , rt = d[g + 2]
          , st = d[g + 3];
        return e[a] = _ * st + $ * nt + b * rt - j * tt,
        e[a + 1] = b * st + $ * tt + j * nt - _ * rt,
        e[a + 2] = j * st + $ * rt + _ * tt - b * nt,
        e[a + 3] = $ * st - _ * nt - b * tt - j * rt,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, a, o, c) {
        return this._x = e,
        this._y = a,
        this._z = o,
        this._w = c,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, a=!0) {
        const o = e._x
          , c = e._y
          , d = e._z
          , g = e._order
          , _ = Math.cos
          , b = Math.sin
          , j = _(o / 2)
          , $ = _(c / 2)
          , nt = _(d / 2)
          , tt = b(o / 2)
          , rt = b(c / 2)
          , st = b(d / 2);
        switch (g) {
        case "XYZ":
            this._x = tt * $ * nt + j * rt * st,
            this._y = j * rt * nt - tt * $ * st,
            this._z = j * $ * st + tt * rt * nt,
            this._w = j * $ * nt - tt * rt * st;
            break;
        case "YXZ":
            this._x = tt * $ * nt + j * rt * st,
            this._y = j * rt * nt - tt * $ * st,
            this._z = j * $ * st - tt * rt * nt,
            this._w = j * $ * nt + tt * rt * st;
            break;
        case "ZXY":
            this._x = tt * $ * nt - j * rt * st,
            this._y = j * rt * nt + tt * $ * st,
            this._z = j * $ * st + tt * rt * nt,
            this._w = j * $ * nt - tt * rt * st;
            break;
        case "ZYX":
            this._x = tt * $ * nt - j * rt * st,
            this._y = j * rt * nt + tt * $ * st,
            this._z = j * $ * st - tt * rt * nt,
            this._w = j * $ * nt + tt * rt * st;
            break;
        case "YZX":
            this._x = tt * $ * nt + j * rt * st,
            this._y = j * rt * nt + tt * $ * st,
            this._z = j * $ * st - tt * rt * nt,
            this._w = j * $ * nt - tt * rt * st;
            break;
        case "XZY":
            this._x = tt * $ * nt - j * rt * st,
            this._y = j * rt * nt - tt * $ * st,
            this._z = j * $ * st + tt * rt * nt,
            this._w = j * $ * nt + tt * rt * st;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + g)
        }
        return a === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, a) {
        const o = a / 2
          , c = Math.sin(o);
        return this._x = e.x * c,
        this._y = e.y * c,
        this._z = e.z * c,
        this._w = Math.cos(o),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const a = e.elements
          , o = a[0]
          , c = a[4]
          , d = a[8]
          , g = a[1]
          , _ = a[5]
          , b = a[9]
          , j = a[2]
          , $ = a[6]
          , nt = a[10]
          , tt = o + _ + nt;
        if (tt > 0) {
            const rt = .5 / Math.sqrt(tt + 1);
            this._w = .25 / rt,
            this._x = ($ - b) * rt,
            this._y = (d - j) * rt,
            this._z = (g - c) * rt
        } else if (o > _ && o > nt) {
            const rt = 2 * Math.sqrt(1 + o - _ - nt);
            this._w = ($ - b) / rt,
            this._x = .25 * rt,
            this._y = (c + g) / rt,
            this._z = (d + j) / rt
        } else if (_ > nt) {
            const rt = 2 * Math.sqrt(1 + _ - o - nt);
            this._w = (d - j) / rt,
            this._x = (c + g) / rt,
            this._y = .25 * rt,
            this._z = (b + $) / rt
        } else {
            const rt = 2 * Math.sqrt(1 + nt - o - _);
            this._w = (g - c) / rt,
            this._x = (d + j) / rt,
            this._y = (b + $) / rt,
            this._z = .25 * rt
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, a) {
        let o = e.dot(a) + 1;
        return o < Number.EPSILON ? (o = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = o) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = o)) : (this._x = e.y * a.z - e.z * a.y,
        this._y = e.z * a.x - e.x * a.z,
        this._z = e.x * a.y - e.y * a.x,
        this._w = o),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1)))
    }
    rotateTowards(e, a) {
        const o = this.angleTo(e);
        if (o === 0)
            return this;
        const c = Math.min(1, a / o);
        return this.slerp(e, c),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, a) {
        const o = e._x
          , c = e._y
          , d = e._z
          , g = e._w
          , _ = a._x
          , b = a._y
          , j = a._z
          , $ = a._w;
        return this._x = o * $ + g * _ + c * j - d * b,
        this._y = c * $ + g * b + d * _ - o * j,
        this._z = d * $ + g * j + o * b - c * _,
        this._w = g * $ - o * _ - c * b - d * j,
        this._onChangeCallback(),
        this
    }
    slerp(e, a) {
        if (a === 0)
            return this;
        if (a === 1)
            return this.copy(e);
        const o = this._x
          , c = this._y
          , d = this._z
          , g = this._w;
        let _ = g * e._w + o * e._x + c * e._y + d * e._z;
        if (_ < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        _ = -_) : this.copy(e),
        _ >= 1)
            return this._w = g,
            this._x = o,
            this._y = c,
            this._z = d,
            this;
        const b = 1 - _ * _;
        if (b <= Number.EPSILON) {
            const rt = 1 - a;
            return this._w = rt * g + a * this._w,
            this._x = rt * o + a * this._x,
            this._y = rt * c + a * this._y,
            this._z = rt * d + a * this._z,
            this.normalize(),
            this
        }
        const j = Math.sqrt(b)
          , $ = Math.atan2(j, _)
          , nt = Math.sin((1 - a) * $) / j
          , tt = Math.sin(a * $) / j;
        return this._w = g * nt + this._w * tt,
        this._x = o * nt + this._x * tt,
        this._y = c * nt + this._y * tt,
        this._z = d * nt + this._z * tt,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, a, o) {
        return this.copy(e).slerp(a, o)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , a = 2 * Math.PI * Math.random()
          , o = Math.random()
          , c = Math.sqrt(1 - o)
          , d = Math.sqrt(o);
        return this.set(c * Math.sin(e), c * Math.cos(e), d * Math.sin(a), d * Math.cos(a))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, a=0) {
        return this._x = e[a],
        this._y = e[a + 1],
        this._z = e[a + 2],
        this._w = e[a + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], a=0) {
        return e[a] = this._x,
        e[a + 1] = this._y,
        e[a + 2] = this._z,
        e[a + 3] = this._w,
        e
    }
    fromBufferAttribute(e, a) {
        return this._x = e.getX(a),
        this._y = e.getY(a),
        this._z = e.getZ(a),
        this._w = e.getW(a),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class Vector3 {
    constructor(e=0, a=0, o=0) {
        Vector3.prototype.isVector3 = !0,
        this.x = e,
        this.y = a,
        this.z = o
    }
    set(e, a, o) {
        return o === void 0 && (o = this.z),
        this.x = e,
        this.y = a,
        this.z = o,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, a) {
        switch (e) {
        case 0:
            this.x = a;
            break;
        case 1:
            this.y = a;
            break;
        case 2:
            this.z = a;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, a) {
        return this.x = e.x + a.x,
        this.y = e.y + a.y,
        this.z = e.z + a.z,
        this
    }
    addScaledVector(e, a) {
        return this.x += e.x * a,
        this.y += e.y * a,
        this.z += e.z * a,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, a) {
        return this.x = e.x - a.x,
        this.y = e.y - a.y,
        this.z = e.z - a.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, a) {
        return this.x = e.x * a.x,
        this.y = e.y * a.y,
        this.z = e.z * a.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(_quaternion$4.setFromEuler(e))
    }
    applyAxisAngle(e, a) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, a))
    }
    applyMatrix3(e) {
        const a = this.x
          , o = this.y
          , c = this.z
          , d = e.elements;
        return this.x = d[0] * a + d[3] * o + d[6] * c,
        this.y = d[1] * a + d[4] * o + d[7] * c,
        this.z = d[2] * a + d[5] * o + d[8] * c,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const a = this.x
          , o = this.y
          , c = this.z
          , d = e.elements
          , g = 1 / (d[3] * a + d[7] * o + d[11] * c + d[15]);
        return this.x = (d[0] * a + d[4] * o + d[8] * c + d[12]) * g,
        this.y = (d[1] * a + d[5] * o + d[9] * c + d[13]) * g,
        this.z = (d[2] * a + d[6] * o + d[10] * c + d[14]) * g,
        this
    }
    applyQuaternion(e) {
        const a = this.x
          , o = this.y
          , c = this.z
          , d = e.x
          , g = e.y
          , _ = e.z
          , b = e.w
          , j = 2 * (g * c - _ * o)
          , $ = 2 * (_ * a - d * c)
          , nt = 2 * (d * o - g * a);
        return this.x = a + b * j + g * nt - _ * $,
        this.y = o + b * $ + _ * j - d * nt,
        this.z = c + b * nt + d * $ - g * j,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const a = this.x
          , o = this.y
          , c = this.z
          , d = e.elements;
        return this.x = d[0] * a + d[4] * o + d[8] * c,
        this.y = d[1] * a + d[5] * o + d[9] * c,
        this.z = d[2] * a + d[6] * o + d[10] * c,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, a) {
        return this.x = Math.max(e.x, Math.min(a.x, this.x)),
        this.y = Math.max(e.y, Math.min(a.y, this.y)),
        this.z = Math.max(e.z, Math.min(a.z, this.z)),
        this
    }
    clampScalar(e, a) {
        return this.x = Math.max(e, Math.min(a, this.x)),
        this.y = Math.max(e, Math.min(a, this.y)),
        this.z = Math.max(e, Math.min(a, this.z)),
        this
    }
    clampLength(e, a) {
        const o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(a, o)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, a) {
        return this.x += (e.x - this.x) * a,
        this.y += (e.y - this.y) * a,
        this.z += (e.z - this.z) * a,
        this
    }
    lerpVectors(e, a, o) {
        return this.x = e.x + (a.x - e.x) * o,
        this.y = e.y + (a.y - e.y) * o,
        this.z = e.z + (a.z - e.z) * o,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, a) {
        const o = e.x
          , c = e.y
          , d = e.z
          , g = a.x
          , _ = a.y
          , b = a.z;
        return this.x = c * b - d * _,
        this.y = d * g - o * b,
        this.z = o * _ - c * g,
        this
    }
    projectOnVector(e) {
        const a = e.lengthSq();
        if (a === 0)
            return this.set(0, 0, 0);
        const o = e.dot(this) / a;
        return this.copy(e).multiplyScalar(o)
    }
    projectOnPlane(e) {
        return _vector$c.copy(this).projectOnVector(e),
        this.sub(_vector$c)
    }
    reflect(e) {
        return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const a = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (a === 0)
            return Math.PI / 2;
        const o = this.dot(e) / a;
        return Math.acos(clamp(o, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const a = this.x - e.x
          , o = this.y - e.y
          , c = this.z - e.z;
        return a * a + o * o + c * c
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, a, o) {
        const c = Math.sin(a) * e;
        return this.x = c * Math.sin(o),
        this.y = Math.cos(a) * e,
        this.z = c * Math.cos(o),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, a, o) {
        return this.x = e * Math.sin(a),
        this.y = o,
        this.z = e * Math.cos(a),
        this
    }
    setFromMatrixPosition(e) {
        const a = e.elements;
        return this.x = a[12],
        this.y = a[13],
        this.z = a[14],
        this
    }
    setFromMatrixScale(e) {
        const a = this.setFromMatrixColumn(e, 0).length()
          , o = this.setFromMatrixColumn(e, 1).length()
          , c = this.setFromMatrixColumn(e, 2).length();
        return this.x = a,
        this.y = o,
        this.z = c,
        this
    }
    setFromMatrixColumn(e, a) {
        return this.fromArray(e.elements, a * 4)
    }
    setFromMatrix3Column(e, a) {
        return this.fromArray(e.elements, a * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, a=0) {
        return this.x = e[a],
        this.y = e[a + 1],
        this.z = e[a + 2],
        this
    }
    toArray(e=[], a=0) {
        return e[a] = this.x,
        e[a + 1] = this.y,
        e[a + 2] = this.z,
        e
    }
    fromBufferAttribute(e, a) {
        return this.x = e.getX(a),
        this.y = e.getY(a),
        this.z = e.getZ(a),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , a = Math.random() * 2 - 1
          , o = Math.sqrt(1 - a * a);
        return this.x = o * Math.cos(e),
        this.y = a,
        this.z = o * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const _vector$c = new Vector3
  , _quaternion$4 = new Quaternion;
class Box3 {
    constructor(e=new Vector3(1 / 0,1 / 0,1 / 0), a=new Vector3(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = a
    }
    set(e, a) {
        return this.min.copy(e),
        this.max.copy(a),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let a = 0, o = e.length; a < o; a += 3)
            this.expandByPoint(_vector$b.fromArray(e, a));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let a = 0, o = e.count; a < o; a++)
            this.expandByPoint(_vector$b.fromBufferAttribute(e, a));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let a = 0, o = e.length; a < o; a++)
            this.expandByPoint(e[a]);
        return this
    }
    setFromCenterAndSize(e, a) {
        const o = _vector$b.copy(a).multiplyScalar(.5);
        return this.min.copy(e).sub(o),
        this.max.copy(e).add(o),
        this
    }
    setFromObject(e, a=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, a)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, a=!1) {
        e.updateWorldMatrix(!1, !1);
        const o = e.geometry;
        if (o !== void 0) {
            const d = o.getAttribute("position");
            if (a === !0 && d !== void 0 && e.isInstancedMesh !== !0)
                for (let g = 0, _ = d.count; g < _; g++)
                    e.isMesh === !0 ? e.getVertexPosition(g, _vector$b) : _vector$b.fromBufferAttribute(d, g),
                    _vector$b.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(_vector$b);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                _box$4.copy(e.boundingBox)) : (o.boundingBox === null && o.computeBoundingBox(),
                _box$4.copy(o.boundingBox)),
                _box$4.applyMatrix4(e.matrixWorld),
                this.union(_box$4)
        }
        const c = e.children;
        for (let d = 0, g = c.length; d < g; d++)
            this.expandByObject(c[d], a);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, a) {
        return a.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, _vector$b),
        _vector$b.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let a, o;
        return e.normal.x > 0 ? (a = e.normal.x * this.min.x,
        o = e.normal.x * this.max.x) : (a = e.normal.x * this.max.x,
        o = e.normal.x * this.min.x),
        e.normal.y > 0 ? (a += e.normal.y * this.min.y,
        o += e.normal.y * this.max.y) : (a += e.normal.y * this.max.y,
        o += e.normal.y * this.min.y),
        e.normal.z > 0 ? (a += e.normal.z * this.min.z,
        o += e.normal.z * this.max.z) : (a += e.normal.z * this.max.z,
        o += e.normal.z * this.min.z),
        a <= -e.constant && o >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(_center),
        _extents.subVectors(this.max, _center),
        _v0$3.subVectors(e.a, _center),
        _v1$7.subVectors(e.b, _center),
        _v2$4.subVectors(e.c, _center),
        _f0.subVectors(_v1$7, _v0$3),
        _f1.subVectors(_v2$4, _v1$7),
        _f2.subVectors(_v0$3, _v2$4);
        let a = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
        return !satForAxes(a, _v0$3, _v1$7, _v2$4, _extents) || (a = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !satForAxes(a, _v0$3, _v1$7, _v2$4, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1),
        a = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z],
        satForAxes(a, _v0$3, _v1$7, _v2$4, _extents))
    }
    clampPoint(e, a) {
        return a.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, _vector$b).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(_vector$b).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(_points),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3]
  , _vector$b = new Vector3
  , _box$4 = new Box3
  , _v0$3 = new Vector3
  , _v1$7 = new Vector3
  , _v2$4 = new Vector3
  , _f0 = new Vector3
  , _f1 = new Vector3
  , _f2 = new Vector3
  , _center = new Vector3
  , _extents = new Vector3
  , _triangleNormal = new Vector3
  , _testAxis = new Vector3;
function satForAxes(s, e, a, o, c) {
    for (let d = 0, g = s.length - 3; d <= g; d += 3) {
        _testAxis.fromArray(s, d);
        const _ = c.x * Math.abs(_testAxis.x) + c.y * Math.abs(_testAxis.y) + c.z * Math.abs(_testAxis.z)
          , b = e.dot(_testAxis)
          , j = a.dot(_testAxis)
          , $ = o.dot(_testAxis);
        if (Math.max(-Math.max(b, j, $), Math.min(b, j, $)) > _)
            return !1
    }
    return !0
}
const _box$3 = new Box3
  , _v1$6 = new Vector3
  , _v2$3 = new Vector3;
class Sphere {
    constructor(e=new Vector3, a=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = a
    }
    set(e, a) {
        return this.center.copy(e),
        this.radius = a,
        this
    }
    setFromPoints(e, a) {
        const o = this.center;
        a !== void 0 ? o.copy(a) : _box$3.setFromPoints(e).getCenter(o);
        let c = 0;
        for (let d = 0, g = e.length; d < g; d++)
            c = Math.max(c, o.distanceToSquared(e[d]));
        return this.radius = Math.sqrt(c),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const a = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= a * a
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, a) {
        const o = this.center.distanceToSquared(e);
        return a.copy(e),
        o > this.radius * this.radius && (a.sub(this.center).normalize(),
        a.multiplyScalar(this.radius).add(this.center)),
        a
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        _v1$6.subVectors(e, this.center);
        const a = _v1$6.lengthSq();
        if (a > this.radius * this.radius) {
            const o = Math.sqrt(a)
              , c = (o - this.radius) * .5;
            this.center.addScaledVector(_v1$6, c / o),
            this.radius += c
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (_v2$3.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(_v1$6.copy(e.center).add(_v2$3)),
        this.expandByPoint(_v1$6.copy(e.center).sub(_v2$3))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _vector$a = new Vector3
  , _segCenter = new Vector3
  , _segDir = new Vector3
  , _diff = new Vector3
  , _edge1 = new Vector3
  , _edge2 = new Vector3
  , _normal$1 = new Vector3;
class Ray {
    constructor(e=new Vector3, a=new Vector3(0,0,-1)) {
        this.origin = e,
        this.direction = a
    }
    set(e, a) {
        return this.origin.copy(e),
        this.direction.copy(a),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, a) {
        return a.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, _vector$a)),
        this
    }
    closestPointToPoint(e, a) {
        a.subVectors(e, this.origin);
        const o = a.dot(this.direction);
        return o < 0 ? a.copy(this.origin) : a.copy(this.origin).addScaledVector(this.direction, o)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const a = _vector$a.subVectors(e, this.origin).dot(this.direction);
        return a < 0 ? this.origin.distanceToSquared(e) : (_vector$a.copy(this.origin).addScaledVector(this.direction, a),
        _vector$a.distanceToSquared(e))
    }
    distanceSqToSegment(e, a, o, c) {
        _segCenter.copy(e).add(a).multiplyScalar(.5),
        _segDir.copy(a).sub(e).normalize(),
        _diff.copy(this.origin).sub(_segCenter);
        const d = e.distanceTo(a) * .5
          , g = -this.direction.dot(_segDir)
          , _ = _diff.dot(this.direction)
          , b = -_diff.dot(_segDir)
          , j = _diff.lengthSq()
          , $ = Math.abs(1 - g * g);
        let nt, tt, rt, st;
        if ($ > 0)
            if (nt = g * b - _,
            tt = g * _ - b,
            st = d * $,
            nt >= 0)
                if (tt >= -st)
                    if (tt <= st) {
                        const lt = 1 / $;
                        nt *= lt,
                        tt *= lt,
                        rt = nt * (nt + g * tt + 2 * _) + tt * (g * nt + tt + 2 * b) + j
                    } else
                        tt = d,
                        nt = Math.max(0, -(g * tt + _)),
                        rt = -nt * nt + tt * (tt + 2 * b) + j;
                else
                    tt = -d,
                    nt = Math.max(0, -(g * tt + _)),
                    rt = -nt * nt + tt * (tt + 2 * b) + j;
            else
                tt <= -st ? (nt = Math.max(0, -(-g * d + _)),
                tt = nt > 0 ? -d : Math.min(Math.max(-d, -b), d),
                rt = -nt * nt + tt * (tt + 2 * b) + j) : tt <= st ? (nt = 0,
                tt = Math.min(Math.max(-d, -b), d),
                rt = tt * (tt + 2 * b) + j) : (nt = Math.max(0, -(g * d + _)),
                tt = nt > 0 ? d : Math.min(Math.max(-d, -b), d),
                rt = -nt * nt + tt * (tt + 2 * b) + j);
        else
            tt = g > 0 ? -d : d,
            nt = Math.max(0, -(g * tt + _)),
            rt = -nt * nt + tt * (tt + 2 * b) + j;
        return o && o.copy(this.origin).addScaledVector(this.direction, nt),
        c && c.copy(_segCenter).addScaledVector(_segDir, tt),
        rt
    }
    intersectSphere(e, a) {
        _vector$a.subVectors(e.center, this.origin);
        const o = _vector$a.dot(this.direction)
          , c = _vector$a.dot(_vector$a) - o * o
          , d = e.radius * e.radius;
        if (c > d)
            return null;
        const g = Math.sqrt(d - c)
          , _ = o - g
          , b = o + g;
        return b < 0 ? null : _ < 0 ? this.at(b, a) : this.at(_, a)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const a = e.normal.dot(this.direction);
        if (a === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const o = -(this.origin.dot(e.normal) + e.constant) / a;
        return o >= 0 ? o : null
    }
    intersectPlane(e, a) {
        const o = this.distanceToPlane(e);
        return o === null ? null : this.at(o, a)
    }
    intersectsPlane(e) {
        const a = e.distanceToPoint(this.origin);
        return a === 0 || e.normal.dot(this.direction) * a < 0
    }
    intersectBox(e, a) {
        let o, c, d, g, _, b;
        const j = 1 / this.direction.x
          , $ = 1 / this.direction.y
          , nt = 1 / this.direction.z
          , tt = this.origin;
        return j >= 0 ? (o = (e.min.x - tt.x) * j,
        c = (e.max.x - tt.x) * j) : (o = (e.max.x - tt.x) * j,
        c = (e.min.x - tt.x) * j),
        $ >= 0 ? (d = (e.min.y - tt.y) * $,
        g = (e.max.y - tt.y) * $) : (d = (e.max.y - tt.y) * $,
        g = (e.min.y - tt.y) * $),
        o > g || d > c || ((d > o || isNaN(o)) && (o = d),
        (g < c || isNaN(c)) && (c = g),
        nt >= 0 ? (_ = (e.min.z - tt.z) * nt,
        b = (e.max.z - tt.z) * nt) : (_ = (e.max.z - tt.z) * nt,
        b = (e.min.z - tt.z) * nt),
        o > b || _ > c) || ((_ > o || o !== o) && (o = _),
        (b < c || c !== c) && (c = b),
        c < 0) ? null : this.at(o >= 0 ? o : c, a)
    }
    intersectsBox(e) {
        return this.intersectBox(e, _vector$a) !== null
    }
    intersectTriangle(e, a, o, c, d) {
        _edge1.subVectors(a, e),
        _edge2.subVectors(o, e),
        _normal$1.crossVectors(_edge1, _edge2);
        let g = this.direction.dot(_normal$1), _;
        if (g > 0) {
            if (c)
                return null;
            _ = 1
        } else if (g < 0)
            _ = -1,
            g = -g;
        else
            return null;
        _diff.subVectors(this.origin, e);
        const b = _ * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (b < 0)
            return null;
        const j = _ * this.direction.dot(_edge1.cross(_diff));
        if (j < 0 || b + j > g)
            return null;
        const $ = -_ * _diff.dot(_normal$1);
        return $ < 0 ? null : this.at($ / g, d)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Matrix4 {
    constructor(e, a, o, c, d, g, _, b, j, $, nt, tt, rt, st, lt, ct) {
        Matrix4.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, a, o, c, d, g, _, b, j, $, nt, tt, rt, st, lt, ct)
    }
    set(e, a, o, c, d, g, _, b, j, $, nt, tt, rt, st, lt, ct) {
        const it = this.elements;
        return it[0] = e,
        it[4] = a,
        it[8] = o,
        it[12] = c,
        it[1] = d,
        it[5] = g,
        it[9] = _,
        it[13] = b,
        it[2] = j,
        it[6] = $,
        it[10] = nt,
        it[14] = tt,
        it[3] = rt,
        it[7] = st,
        it[11] = lt,
        it[15] = ct,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Matrix4().fromArray(this.elements)
    }
    copy(e) {
        const a = this.elements
          , o = e.elements;
        return a[0] = o[0],
        a[1] = o[1],
        a[2] = o[2],
        a[3] = o[3],
        a[4] = o[4],
        a[5] = o[5],
        a[6] = o[6],
        a[7] = o[7],
        a[8] = o[8],
        a[9] = o[9],
        a[10] = o[10],
        a[11] = o[11],
        a[12] = o[12],
        a[13] = o[13],
        a[14] = o[14],
        a[15] = o[15],
        this
    }
    copyPosition(e) {
        const a = this.elements
          , o = e.elements;
        return a[12] = o[12],
        a[13] = o[13],
        a[14] = o[14],
        this
    }
    setFromMatrix3(e) {
        const a = e.elements;
        return this.set(a[0], a[3], a[6], 0, a[1], a[4], a[7], 0, a[2], a[5], a[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, a, o) {
        return e.setFromMatrixColumn(this, 0),
        a.setFromMatrixColumn(this, 1),
        o.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, a, o) {
        return this.set(e.x, a.x, o.x, 0, e.y, a.y, o.y, 0, e.z, a.z, o.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const a = this.elements
          , o = e.elements
          , c = 1 / _v1$5.setFromMatrixColumn(e, 0).length()
          , d = 1 / _v1$5.setFromMatrixColumn(e, 1).length()
          , g = 1 / _v1$5.setFromMatrixColumn(e, 2).length();
        return a[0] = o[0] * c,
        a[1] = o[1] * c,
        a[2] = o[2] * c,
        a[3] = 0,
        a[4] = o[4] * d,
        a[5] = o[5] * d,
        a[6] = o[6] * d,
        a[7] = 0,
        a[8] = o[8] * g,
        a[9] = o[9] * g,
        a[10] = o[10] * g,
        a[11] = 0,
        a[12] = 0,
        a[13] = 0,
        a[14] = 0,
        a[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const a = this.elements
          , o = e.x
          , c = e.y
          , d = e.z
          , g = Math.cos(o)
          , _ = Math.sin(o)
          , b = Math.cos(c)
          , j = Math.sin(c)
          , $ = Math.cos(d)
          , nt = Math.sin(d);
        if (e.order === "XYZ") {
            const tt = g * $
              , rt = g * nt
              , st = _ * $
              , lt = _ * nt;
            a[0] = b * $,
            a[4] = -b * nt,
            a[8] = j,
            a[1] = rt + st * j,
            a[5] = tt - lt * j,
            a[9] = -_ * b,
            a[2] = lt - tt * j,
            a[6] = st + rt * j,
            a[10] = g * b
        } else if (e.order === "YXZ") {
            const tt = b * $
              , rt = b * nt
              , st = j * $
              , lt = j * nt;
            a[0] = tt + lt * _,
            a[4] = st * _ - rt,
            a[8] = g * j,
            a[1] = g * nt,
            a[5] = g * $,
            a[9] = -_,
            a[2] = rt * _ - st,
            a[6] = lt + tt * _,
            a[10] = g * b
        } else if (e.order === "ZXY") {
            const tt = b * $
              , rt = b * nt
              , st = j * $
              , lt = j * nt;
            a[0] = tt - lt * _,
            a[4] = -g * nt,
            a[8] = st + rt * _,
            a[1] = rt + st * _,
            a[5] = g * $,
            a[9] = lt - tt * _,
            a[2] = -g * j,
            a[6] = _,
            a[10] = g * b
        } else if (e.order === "ZYX") {
            const tt = g * $
              , rt = g * nt
              , st = _ * $
              , lt = _ * nt;
            a[0] = b * $,
            a[4] = st * j - rt,
            a[8] = tt * j + lt,
            a[1] = b * nt,
            a[5] = lt * j + tt,
            a[9] = rt * j - st,
            a[2] = -j,
            a[6] = _ * b,
            a[10] = g * b
        } else if (e.order === "YZX") {
            const tt = g * b
              , rt = g * j
              , st = _ * b
              , lt = _ * j;
            a[0] = b * $,
            a[4] = lt - tt * nt,
            a[8] = st * nt + rt,
            a[1] = nt,
            a[5] = g * $,
            a[9] = -_ * $,
            a[2] = -j * $,
            a[6] = rt * nt + st,
            a[10] = tt - lt * nt
        } else if (e.order === "XZY") {
            const tt = g * b
              , rt = g * j
              , st = _ * b
              , lt = _ * j;
            a[0] = b * $,
            a[4] = -nt,
            a[8] = j * $,
            a[1] = tt * nt + lt,
            a[5] = g * $,
            a[9] = rt * nt - st,
            a[2] = st * nt - rt,
            a[6] = _ * $,
            a[10] = lt * nt + tt
        }
        return a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[12] = 0,
        a[13] = 0,
        a[14] = 0,
        a[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(_zero, e, _one)
    }
    lookAt(e, a, o) {
        const c = this.elements;
        return _z.subVectors(e, a),
        _z.lengthSq() === 0 && (_z.z = 1),
        _z.normalize(),
        _x.crossVectors(o, _z),
        _x.lengthSq() === 0 && (Math.abs(o.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4,
        _z.normalize(),
        _x.crossVectors(o, _z)),
        _x.normalize(),
        _y.crossVectors(_z, _x),
        c[0] = _x.x,
        c[4] = _y.x,
        c[8] = _z.x,
        c[1] = _x.y,
        c[5] = _y.y,
        c[9] = _z.y,
        c[2] = _x.z,
        c[6] = _y.z,
        c[10] = _z.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, a) {
        const o = e.elements
          , c = a.elements
          , d = this.elements
          , g = o[0]
          , _ = o[4]
          , b = o[8]
          , j = o[12]
          , $ = o[1]
          , nt = o[5]
          , tt = o[9]
          , rt = o[13]
          , st = o[2]
          , lt = o[6]
          , ct = o[10]
          , it = o[14]
          , ot = o[3]
          , at = o[7]
          , ht = o[11]
          , pt = o[15]
          , dt = c[0]
          , yt = c[4]
          , vt = c[8]
          , xt = c[12]
          , _t = c[1]
          , bt = c[5]
          , Rt = c[9]
          , Ft = c[13]
          , Bt = c[2]
          , Dt = c[6]
          , Mt = c[10]
          , Tt = c[14]
          , mt = c[3]
          , St = c[7]
          , wt = c[11]
          , Ct = c[15];
        return d[0] = g * dt + _ * _t + b * Bt + j * mt,
        d[4] = g * yt + _ * bt + b * Dt + j * St,
        d[8] = g * vt + _ * Rt + b * Mt + j * wt,
        d[12] = g * xt + _ * Ft + b * Tt + j * Ct,
        d[1] = $ * dt + nt * _t + tt * Bt + rt * mt,
        d[5] = $ * yt + nt * bt + tt * Dt + rt * St,
        d[9] = $ * vt + nt * Rt + tt * Mt + rt * wt,
        d[13] = $ * xt + nt * Ft + tt * Tt + rt * Ct,
        d[2] = st * dt + lt * _t + ct * Bt + it * mt,
        d[6] = st * yt + lt * bt + ct * Dt + it * St,
        d[10] = st * vt + lt * Rt + ct * Mt + it * wt,
        d[14] = st * xt + lt * Ft + ct * Tt + it * Ct,
        d[3] = ot * dt + at * _t + ht * Bt + pt * mt,
        d[7] = ot * yt + at * bt + ht * Dt + pt * St,
        d[11] = ot * vt + at * Rt + ht * Mt + pt * wt,
        d[15] = ot * xt + at * Ft + ht * Tt + pt * Ct,
        this
    }
    multiplyScalar(e) {
        const a = this.elements;
        return a[0] *= e,
        a[4] *= e,
        a[8] *= e,
        a[12] *= e,
        a[1] *= e,
        a[5] *= e,
        a[9] *= e,
        a[13] *= e,
        a[2] *= e,
        a[6] *= e,
        a[10] *= e,
        a[14] *= e,
        a[3] *= e,
        a[7] *= e,
        a[11] *= e,
        a[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , a = e[0]
          , o = e[4]
          , c = e[8]
          , d = e[12]
          , g = e[1]
          , _ = e[5]
          , b = e[9]
          , j = e[13]
          , $ = e[2]
          , nt = e[6]
          , tt = e[10]
          , rt = e[14]
          , st = e[3]
          , lt = e[7]
          , ct = e[11]
          , it = e[15];
        return st * (+d * b * nt - c * j * nt - d * _ * tt + o * j * tt + c * _ * rt - o * b * rt) + lt * (+a * b * rt - a * j * tt + d * g * tt - c * g * rt + c * j * $ - d * b * $) + ct * (+a * j * nt - a * _ * rt - d * g * nt + o * g * rt + d * _ * $ - o * j * $) + it * (-c * _ * $ - a * b * nt + a * _ * tt + c * g * nt - o * g * tt + o * b * $)
    }
    transpose() {
        const e = this.elements;
        let a;
        return a = e[1],
        e[1] = e[4],
        e[4] = a,
        a = e[2],
        e[2] = e[8],
        e[8] = a,
        a = e[6],
        e[6] = e[9],
        e[9] = a,
        a = e[3],
        e[3] = e[12],
        e[12] = a,
        a = e[7],
        e[7] = e[13],
        e[13] = a,
        a = e[11],
        e[11] = e[14],
        e[14] = a,
        this
    }
    setPosition(e, a, o) {
        const c = this.elements;
        return e.isVector3 ? (c[12] = e.x,
        c[13] = e.y,
        c[14] = e.z) : (c[12] = e,
        c[13] = a,
        c[14] = o),
        this
    }
    invert() {
        const e = this.elements
          , a = e[0]
          , o = e[1]
          , c = e[2]
          , d = e[3]
          , g = e[4]
          , _ = e[5]
          , b = e[6]
          , j = e[7]
          , $ = e[8]
          , nt = e[9]
          , tt = e[10]
          , rt = e[11]
          , st = e[12]
          , lt = e[13]
          , ct = e[14]
          , it = e[15]
          , ot = nt * ct * j - lt * tt * j + lt * b * rt - _ * ct * rt - nt * b * it + _ * tt * it
          , at = st * tt * j - $ * ct * j - st * b * rt + g * ct * rt + $ * b * it - g * tt * it
          , ht = $ * lt * j - st * nt * j + st * _ * rt - g * lt * rt - $ * _ * it + g * nt * it
          , pt = st * nt * b - $ * lt * b - st * _ * tt + g * lt * tt + $ * _ * ct - g * nt * ct
          , dt = a * ot + o * at + c * ht + d * pt;
        if (dt === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const yt = 1 / dt;
        return e[0] = ot * yt,
        e[1] = (lt * tt * d - nt * ct * d - lt * c * rt + o * ct * rt + nt * c * it - o * tt * it) * yt,
        e[2] = (_ * ct * d - lt * b * d + lt * c * j - o * ct * j - _ * c * it + o * b * it) * yt,
        e[3] = (nt * b * d - _ * tt * d - nt * c * j + o * tt * j + _ * c * rt - o * b * rt) * yt,
        e[4] = at * yt,
        e[5] = ($ * ct * d - st * tt * d + st * c * rt - a * ct * rt - $ * c * it + a * tt * it) * yt,
        e[6] = (st * b * d - g * ct * d - st * c * j + a * ct * j + g * c * it - a * b * it) * yt,
        e[7] = (g * tt * d - $ * b * d + $ * c * j - a * tt * j - g * c * rt + a * b * rt) * yt,
        e[8] = ht * yt,
        e[9] = (st * nt * d - $ * lt * d - st * o * rt + a * lt * rt + $ * o * it - a * nt * it) * yt,
        e[10] = (g * lt * d - st * _ * d + st * o * j - a * lt * j - g * o * it + a * _ * it) * yt,
        e[11] = ($ * _ * d - g * nt * d - $ * o * j + a * nt * j + g * o * rt - a * _ * rt) * yt,
        e[12] = pt * yt,
        e[13] = ($ * lt * c - st * nt * c + st * o * tt - a * lt * tt - $ * o * ct + a * nt * ct) * yt,
        e[14] = (st * _ * c - g * lt * c - st * o * b + a * lt * b + g * o * ct - a * _ * ct) * yt,
        e[15] = (g * nt * c - $ * _ * c + $ * o * b - a * nt * b - g * o * tt + a * _ * tt) * yt,
        this
    }
    scale(e) {
        const a = this.elements
          , o = e.x
          , c = e.y
          , d = e.z;
        return a[0] *= o,
        a[4] *= c,
        a[8] *= d,
        a[1] *= o,
        a[5] *= c,
        a[9] *= d,
        a[2] *= o,
        a[6] *= c,
        a[10] *= d,
        a[3] *= o,
        a[7] *= c,
        a[11] *= d,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , a = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , o = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , c = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(a, o, c))
    }
    makeTranslation(e, a, o) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, a, 0, 0, 1, o, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const a = Math.cos(e)
          , o = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, a, -o, 0, 0, o, a, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const a = Math.cos(e)
          , o = Math.sin(e);
        return this.set(a, 0, o, 0, 0, 1, 0, 0, -o, 0, a, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const a = Math.cos(e)
          , o = Math.sin(e);
        return this.set(a, -o, 0, 0, o, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, a) {
        const o = Math.cos(a)
          , c = Math.sin(a)
          , d = 1 - o
          , g = e.x
          , _ = e.y
          , b = e.z
          , j = d * g
          , $ = d * _;
        return this.set(j * g + o, j * _ - c * b, j * b + c * _, 0, j * _ + c * b, $ * _ + o, $ * b - c * g, 0, j * b - c * _, $ * b + c * g, d * b * b + o, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, a, o) {
        return this.set(e, 0, 0, 0, 0, a, 0, 0, 0, 0, o, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, a, o, c, d, g) {
        return this.set(1, o, d, 0, e, 1, g, 0, a, c, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, a, o) {
        const c = this.elements
          , d = a._x
          , g = a._y
          , _ = a._z
          , b = a._w
          , j = d + d
          , $ = g + g
          , nt = _ + _
          , tt = d * j
          , rt = d * $
          , st = d * nt
          , lt = g * $
          , ct = g * nt
          , it = _ * nt
          , ot = b * j
          , at = b * $
          , ht = b * nt
          , pt = o.x
          , dt = o.y
          , yt = o.z;
        return c[0] = (1 - (lt + it)) * pt,
        c[1] = (rt + ht) * pt,
        c[2] = (st - at) * pt,
        c[3] = 0,
        c[4] = (rt - ht) * dt,
        c[5] = (1 - (tt + it)) * dt,
        c[6] = (ct + ot) * dt,
        c[7] = 0,
        c[8] = (st + at) * yt,
        c[9] = (ct - ot) * yt,
        c[10] = (1 - (tt + lt)) * yt,
        c[11] = 0,
        c[12] = e.x,
        c[13] = e.y,
        c[14] = e.z,
        c[15] = 1,
        this
    }
    decompose(e, a, o) {
        const c = this.elements;
        let d = _v1$5.set(c[0], c[1], c[2]).length();
        const g = _v1$5.set(c[4], c[5], c[6]).length()
          , _ = _v1$5.set(c[8], c[9], c[10]).length();
        this.determinant() < 0 && (d = -d),
        e.x = c[12],
        e.y = c[13],
        e.z = c[14],
        _m1$4.copy(this);
        const j = 1 / d
          , $ = 1 / g
          , nt = 1 / _;
        return _m1$4.elements[0] *= j,
        _m1$4.elements[1] *= j,
        _m1$4.elements[2] *= j,
        _m1$4.elements[4] *= $,
        _m1$4.elements[5] *= $,
        _m1$4.elements[6] *= $,
        _m1$4.elements[8] *= nt,
        _m1$4.elements[9] *= nt,
        _m1$4.elements[10] *= nt,
        a.setFromRotationMatrix(_m1$4),
        o.x = d,
        o.y = g,
        o.z = _,
        this
    }
    makePerspective(e, a, o, c, d, g, _=WebGLCoordinateSystem) {
        const b = this.elements
          , j = 2 * d / (a - e)
          , $ = 2 * d / (o - c)
          , nt = (a + e) / (a - e)
          , tt = (o + c) / (o - c);
        let rt, st;
        if (_ === WebGLCoordinateSystem)
            rt = -(g + d) / (g - d),
            st = -2 * g * d / (g - d);
        else if (_ === WebGPUCoordinateSystem)
            rt = -g / (g - d),
            st = -g * d / (g - d);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + _);
        return b[0] = j,
        b[4] = 0,
        b[8] = nt,
        b[12] = 0,
        b[1] = 0,
        b[5] = $,
        b[9] = tt,
        b[13] = 0,
        b[2] = 0,
        b[6] = 0,
        b[10] = rt,
        b[14] = st,
        b[3] = 0,
        b[7] = 0,
        b[11] = -1,
        b[15] = 0,
        this
    }
    makeOrthographic(e, a, o, c, d, g, _=WebGLCoordinateSystem) {
        const b = this.elements
          , j = 1 / (a - e)
          , $ = 1 / (o - c)
          , nt = 1 / (g - d)
          , tt = (a + e) * j
          , rt = (o + c) * $;
        let st, lt;
        if (_ === WebGLCoordinateSystem)
            st = (g + d) * nt,
            lt = -2 * nt;
        else if (_ === WebGPUCoordinateSystem)
            st = d * nt,
            lt = -1 * nt;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + _);
        return b[0] = 2 * j,
        b[4] = 0,
        b[8] = 0,
        b[12] = -tt,
        b[1] = 0,
        b[5] = 2 * $,
        b[9] = 0,
        b[13] = -rt,
        b[2] = 0,
        b[6] = 0,
        b[10] = lt,
        b[14] = -st,
        b[3] = 0,
        b[7] = 0,
        b[11] = 0,
        b[15] = 1,
        this
    }
    equals(e) {
        const a = this.elements
          , o = e.elements;
        for (let c = 0; c < 16; c++)
            if (a[c] !== o[c])
                return !1;
        return !0
    }
    fromArray(e, a=0) {
        for (let o = 0; o < 16; o++)
            this.elements[o] = e[o + a];
        return this
    }
    toArray(e=[], a=0) {
        const o = this.elements;
        return e[a] = o[0],
        e[a + 1] = o[1],
        e[a + 2] = o[2],
        e[a + 3] = o[3],
        e[a + 4] = o[4],
        e[a + 5] = o[5],
        e[a + 6] = o[6],
        e[a + 7] = o[7],
        e[a + 8] = o[8],
        e[a + 9] = o[9],
        e[a + 10] = o[10],
        e[a + 11] = o[11],
        e[a + 12] = o[12],
        e[a + 13] = o[13],
        e[a + 14] = o[14],
        e[a + 15] = o[15],
        e
    }
}
const _v1$5 = new Vector3
  , _m1$4 = new Matrix4
  , _zero = new Vector3(0,0,0)
  , _one = new Vector3(1,1,1)
  , _x = new Vector3
  , _y = new Vector3
  , _z = new Vector3
  , _matrix$2 = new Matrix4
  , _quaternion$3 = new Quaternion;
class Euler {
    constructor(e=0, a=0, o=0, c=Euler.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = a,
        this._z = o,
        this._order = c
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, a, o, c=this._order) {
        return this._x = e,
        this._y = a,
        this._z = o,
        this._order = c,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, a=this._order, o=!0) {
        const c = e.elements
          , d = c[0]
          , g = c[4]
          , _ = c[8]
          , b = c[1]
          , j = c[5]
          , $ = c[9]
          , nt = c[2]
          , tt = c[6]
          , rt = c[10];
        switch (a) {
        case "XYZ":
            this._y = Math.asin(clamp(_, -1, 1)),
            Math.abs(_) < .9999999 ? (this._x = Math.atan2(-$, rt),
            this._z = Math.atan2(-g, d)) : (this._x = Math.atan2(tt, j),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-clamp($, -1, 1)),
            Math.abs($) < .9999999 ? (this._y = Math.atan2(_, rt),
            this._z = Math.atan2(b, j)) : (this._y = Math.atan2(-nt, d),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(clamp(tt, -1, 1)),
            Math.abs(tt) < .9999999 ? (this._y = Math.atan2(-nt, rt),
            this._z = Math.atan2(-g, j)) : (this._y = 0,
            this._z = Math.atan2(b, d));
            break;
        case "ZYX":
            this._y = Math.asin(-clamp(nt, -1, 1)),
            Math.abs(nt) < .9999999 ? (this._x = Math.atan2(tt, rt),
            this._z = Math.atan2(b, d)) : (this._x = 0,
            this._z = Math.atan2(-g, j));
            break;
        case "YZX":
            this._z = Math.asin(clamp(b, -1, 1)),
            Math.abs(b) < .9999999 ? (this._x = Math.atan2(-$, j),
            this._y = Math.atan2(-nt, d)) : (this._x = 0,
            this._y = Math.atan2(_, rt));
            break;
        case "XZY":
            this._z = Math.asin(-clamp(g, -1, 1)),
            Math.abs(g) < .9999999 ? (this._x = Math.atan2(tt, j),
            this._y = Math.atan2(_, d)) : (this._x = Math.atan2(-$, rt),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + a)
        }
        return this._order = a,
        o === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, a, o) {
        return _matrix$2.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(_matrix$2, a, o)
    }
    setFromVector3(e, a=this._order) {
        return this.set(e.x, e.y, e.z, a)
    }
    reorder(e) {
        return _quaternion$3.setFromEuler(this),
        this.setFromQuaternion(_quaternion$3, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], a=0) {
        return e[a] = this._x,
        e[a + 1] = this._y,
        e[a + 2] = this._z,
        e[a + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let _object3DId = 0;
const _v1$4 = new Vector3
  , _q1 = new Quaternion
  , _m1$3 = new Matrix4
  , _target = new Vector3
  , _position$3 = new Vector3
  , _scale$2 = new Vector3
  , _quaternion$2 = new Quaternion
  , _xAxis = new Vector3(1,0,0)
  , _yAxis = new Vector3(0,1,0)
  , _zAxis = new Vector3(0,0,1)
  , _addedEvent = {
    type: "added"
}
  , _removedEvent = {
    type: "removed"
}
  , _childaddedEvent = {
    type: "childadded",
    child: null
}
  , _childremovedEvent = {
    type: "childremoved",
    child: null
};
class Object3D extends EventDispatcher {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: _object3DId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Object3D.DEFAULT_UP.clone();
        const e = new Vector3
          , a = new Euler
          , o = new Quaternion
          , c = new Vector3(1,1,1);
        function d() {
            o.setFromEuler(a, !1)
        }
        function g() {
            a.setFromQuaternion(o, void 0, !1)
        }
        a._onChange(d),
        o._onChange(g),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: a
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: o
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: c
            },
            modelViewMatrix: {
                value: new Matrix4
            },
            normalMatrix: {
                value: new Matrix3
            }
        }),
        this.matrix = new Matrix4,
        this.matrixWorld = new Matrix4,
        this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Layers,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, a) {
        this.quaternion.setFromAxisAngle(e, a)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, a) {
        return _q1.setFromAxisAngle(e, a),
        this.quaternion.multiply(_q1),
        this
    }
    rotateOnWorldAxis(e, a) {
        return _q1.setFromAxisAngle(e, a),
        this.quaternion.premultiply(_q1),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(_xAxis, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(_yAxis, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(_zAxis, e)
    }
    translateOnAxis(e, a) {
        return _v1$4.copy(e).applyQuaternion(this.quaternion),
        this.position.add(_v1$4.multiplyScalar(a)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(_xAxis, e)
    }
    translateY(e) {
        return this.translateOnAxis(_yAxis, e)
    }
    translateZ(e) {
        return this.translateOnAxis(_zAxis, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(_m1$3.copy(this.matrixWorld).invert())
    }
    lookAt(e, a, o) {
        e.isVector3 ? _target.copy(e) : _target.set(e, a, o);
        const c = this.parent;
        this.updateWorldMatrix(!0, !1),
        _position$3.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? _m1$3.lookAt(_position$3, _target, this.up) : _m1$3.lookAt(_target, _position$3, this.up),
        this.quaternion.setFromRotationMatrix(_m1$3),
        c && (_m1$3.extractRotation(c.matrixWorld),
        _q1.setFromRotationMatrix(_m1$3),
        this.quaternion.premultiply(_q1.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let a = 0; a < arguments.length; a++)
                this.add(arguments[a]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(_addedEvent),
        _childaddedEvent.child = e,
        this.dispatchEvent(_childaddedEvent),
        _childaddedEvent.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let o = 0; o < arguments.length; o++)
                this.remove(arguments[o]);
            return this
        }
        const a = this.children.indexOf(e);
        return a !== -1 && (e.parent = null,
        this.children.splice(a, 1),
        e.dispatchEvent(_removedEvent),
        _childremovedEvent.child = e,
        this.dispatchEvent(_childremovedEvent),
        _childremovedEvent.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        _m1$3.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        _m1$3.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(_m1$3),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(_addedEvent),
        _childaddedEvent.child = e,
        this.dispatchEvent(_childaddedEvent),
        _childaddedEvent.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, a) {
        if (this[e] === a)
            return this;
        for (let o = 0, c = this.children.length; o < c; o++) {
            const g = this.children[o].getObjectByProperty(e, a);
            if (g !== void 0)
                return g
        }
    }
    getObjectsByProperty(e, a, o=[]) {
        this[e] === a && o.push(this);
        const c = this.children;
        for (let d = 0, g = c.length; d < g; d++)
            c[d].getObjectsByProperty(e, a, o);
        return o
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(_position$3, e, _scale$2),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(_position$3, _quaternion$2, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const a = this.matrixWorld.elements;
        return e.set(a[8], a[9], a[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const a = this.children;
        for (let o = 0, c = a.length; o < c; o++)
            a[o].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const a = this.children;
        for (let o = 0, c = a.length; o < c; o++)
            a[o].traverseVisible(e)
    }
    traverseAncestors(e) {
        const a = this.parent;
        a !== null && (e(a),
        a.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const a = this.children;
        for (let o = 0, c = a.length; o < c; o++)
            a[o].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, a) {
        const o = this.parent;
        if (e === !0 && o !== null && o.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        a === !0) {
            const c = this.children;
            for (let d = 0, g = c.length; d < g; d++)
                c[d].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const a = e === void 0 || typeof e == "string"
          , o = {};
        a && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        o.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const c = {};
        c.uuid = this.uuid,
        c.type = this.type,
        this.name !== "" && (c.name = this.name),
        this.castShadow === !0 && (c.castShadow = !0),
        this.receiveShadow === !0 && (c.receiveShadow = !0),
        this.visible === !1 && (c.visible = !1),
        this.frustumCulled === !1 && (c.frustumCulled = !1),
        this.renderOrder !== 0 && (c.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (c.userData = this.userData),
        c.layers = this.layers.mask,
        c.matrix = this.matrix.toArray(),
        c.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (c.matrixAutoUpdate = !1),
        this.isInstancedMesh && (c.type = "InstancedMesh",
        c.count = this.count,
        c.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (c.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (c.type = "BatchedMesh",
        c.perObjectFrustumCulled = this.perObjectFrustumCulled,
        c.sortObjects = this.sortObjects,
        c.drawRanges = this._drawRanges,
        c.reservedRanges = this._reservedRanges,
        c.visibility = this._visibility,
        c.active = this._active,
        c.bounds = this._bounds.map(_ => ({
            boxInitialized: _.boxInitialized,
            boxMin: _.box.min.toArray(),
            boxMax: _.box.max.toArray(),
            sphereInitialized: _.sphereInitialized,
            sphereRadius: _.sphere.radius,
            sphereCenter: _.sphere.center.toArray()
        })),
        c.maxInstanceCount = this._maxInstanceCount,
        c.maxVertexCount = this._maxVertexCount,
        c.maxIndexCount = this._maxIndexCount,
        c.geometryInitialized = this._geometryInitialized,
        c.geometryCount = this._geometryCount,
        c.matricesTexture = this._matricesTexture.toJSON(e),
        this._colorsTexture !== null && (c.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (c.boundingSphere = {
            center: c.boundingSphere.center.toArray(),
            radius: c.boundingSphere.radius
        }),
        this.boundingBox !== null && (c.boundingBox = {
            min: c.boundingBox.min.toArray(),
            max: c.boundingBox.max.toArray()
        }));
        function d(_, b) {
            return _[b.uuid] === void 0 && (_[b.uuid] = b.toJSON(e)),
            b.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? c.background = this.background.toJSON() : this.background.isTexture && (c.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (c.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            c.geometry = d(e.geometries, this.geometry);
            const _ = this.geometry.parameters;
            if (_ !== void 0 && _.shapes !== void 0) {
                const b = _.shapes;
                if (Array.isArray(b))
                    for (let j = 0, $ = b.length; j < $; j++) {
                        const nt = b[j];
                        d(e.shapes, nt)
                    }
                else
                    d(e.shapes, b)
            }
        }
        if (this.isSkinnedMesh && (c.bindMode = this.bindMode,
        c.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (d(e.skeletons, this.skeleton),
        c.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const _ = [];
                for (let b = 0, j = this.material.length; b < j; b++)
                    _.push(d(e.materials, this.material[b]));
                c.material = _
            } else
                c.material = d(e.materials, this.material);
        if (this.children.length > 0) {
            c.children = [];
            for (let _ = 0; _ < this.children.length; _++)
                c.children.push(this.children[_].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            c.animations = [];
            for (let _ = 0; _ < this.animations.length; _++) {
                const b = this.animations[_];
                c.animations.push(d(e.animations, b))
            }
        }
        if (a) {
            const _ = g(e.geometries)
              , b = g(e.materials)
              , j = g(e.textures)
              , $ = g(e.images)
              , nt = g(e.shapes)
              , tt = g(e.skeletons)
              , rt = g(e.animations)
              , st = g(e.nodes);
            _.length > 0 && (o.geometries = _),
            b.length > 0 && (o.materials = b),
            j.length > 0 && (o.textures = j),
            $.length > 0 && (o.images = $),
            nt.length > 0 && (o.shapes = nt),
            tt.length > 0 && (o.skeletons = tt),
            rt.length > 0 && (o.animations = rt),
            st.length > 0 && (o.nodes = st)
        }
        return o.object = c,
        o;
        function g(_) {
            const b = [];
            for (const j in _) {
                const $ = _[j];
                delete $.metadata,
                b.push($)
            }
            return b
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, a=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        a === !0)
            for (let o = 0; o < e.children.length; o++) {
                const c = e.children[o];
                this.add(c.clone())
            }
        return this
    }
}
Object3D.DEFAULT_UP = new Vector3(0,1,0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const _v0$2 = new Vector3
  , _v1$3 = new Vector3
  , _v2$2 = new Vector3
  , _v3$2 = new Vector3
  , _vab = new Vector3
  , _vac = new Vector3
  , _vbc = new Vector3
  , _vap = new Vector3
  , _vbp = new Vector3
  , _vcp = new Vector3;
class Triangle {
    constructor(e=new Vector3, a=new Vector3, o=new Vector3) {
        this.a = e,
        this.b = a,
        this.c = o
    }
    static getNormal(e, a, o, c) {
        c.subVectors(o, a),
        _v0$2.subVectors(e, a),
        c.cross(_v0$2);
        const d = c.lengthSq();
        return d > 0 ? c.multiplyScalar(1 / Math.sqrt(d)) : c.set(0, 0, 0)
    }
    static getBarycoord(e, a, o, c, d) {
        _v0$2.subVectors(c, a),
        _v1$3.subVectors(o, a),
        _v2$2.subVectors(e, a);
        const g = _v0$2.dot(_v0$2)
          , _ = _v0$2.dot(_v1$3)
          , b = _v0$2.dot(_v2$2)
          , j = _v1$3.dot(_v1$3)
          , $ = _v1$3.dot(_v2$2)
          , nt = g * j - _ * _;
        if (nt === 0)
            return d.set(0, 0, 0),
            null;
        const tt = 1 / nt
          , rt = (j * b - _ * $) * tt
          , st = (g * $ - _ * b) * tt;
        return d.set(1 - rt - st, st, rt)
    }
    static containsPoint(e, a, o, c) {
        return this.getBarycoord(e, a, o, c, _v3$2) === null ? !1 : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1
    }
    static getInterpolation(e, a, o, c, d, g, _, b) {
        return this.getBarycoord(e, a, o, c, _v3$2) === null ? (b.x = 0,
        b.y = 0,
        "z"in b && (b.z = 0),
        "w"in b && (b.w = 0),
        null) : (b.setScalar(0),
        b.addScaledVector(d, _v3$2.x),
        b.addScaledVector(g, _v3$2.y),
        b.addScaledVector(_, _v3$2.z),
        b)
    }
    static isFrontFacing(e, a, o, c) {
        return _v0$2.subVectors(o, a),
        _v1$3.subVectors(e, a),
        _v0$2.cross(_v1$3).dot(c) < 0
    }
    set(e, a, o) {
        return this.a.copy(e),
        this.b.copy(a),
        this.c.copy(o),
        this
    }
    setFromPointsAndIndices(e, a, o, c) {
        return this.a.copy(e[a]),
        this.b.copy(e[o]),
        this.c.copy(e[c]),
        this
    }
    setFromAttributeAndIndices(e, a, o, c) {
        return this.a.fromBufferAttribute(e, a),
        this.b.fromBufferAttribute(e, o),
        this.c.fromBufferAttribute(e, c),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return _v0$2.subVectors(this.c, this.b),
        _v1$3.subVectors(this.a, this.b),
        _v0$2.cross(_v1$3).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Triangle.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, a) {
        return Triangle.getBarycoord(e, this.a, this.b, this.c, a)
    }
    getInterpolation(e, a, o, c, d) {
        return Triangle.getInterpolation(e, this.a, this.b, this.c, a, o, c, d)
    }
    containsPoint(e) {
        return Triangle.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, a) {
        const o = this.a
          , c = this.b
          , d = this.c;
        let g, _;
        _vab.subVectors(c, o),
        _vac.subVectors(d, o),
        _vap.subVectors(e, o);
        const b = _vab.dot(_vap)
          , j = _vac.dot(_vap);
        if (b <= 0 && j <= 0)
            return a.copy(o);
        _vbp.subVectors(e, c);
        const $ = _vab.dot(_vbp)
          , nt = _vac.dot(_vbp);
        if ($ >= 0 && nt <= $)
            return a.copy(c);
        const tt = b * nt - $ * j;
        if (tt <= 0 && b >= 0 && $ <= 0)
            return g = b / (b - $),
            a.copy(o).addScaledVector(_vab, g);
        _vcp.subVectors(e, d);
        const rt = _vab.dot(_vcp)
          , st = _vac.dot(_vcp);
        if (st >= 0 && rt <= st)
            return a.copy(d);
        const lt = rt * j - b * st;
        if (lt <= 0 && j >= 0 && st <= 0)
            return _ = j / (j - st),
            a.copy(o).addScaledVector(_vac, _);
        const ct = $ * st - rt * nt;
        if (ct <= 0 && nt - $ >= 0 && rt - st >= 0)
            return _vbc.subVectors(d, c),
            _ = (nt - $) / (nt - $ + (rt - st)),
            a.copy(c).addScaledVector(_vbc, _);
        const it = 1 / (ct + lt + tt);
        return g = lt * it,
        _ = tt * it,
        a.copy(o).addScaledVector(_vab, g).addScaledVector(_vac, _)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , _hslA = {
    h: 0,
    s: 0,
    l: 0
}
  , _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function hue2rgb(s, e, a) {
    return a < 0 && (a += 1),
    a > 1 && (a -= 1),
    a < 1 / 6 ? s + (e - s) * 6 * a : a < 1 / 2 ? e : a < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - a) : s
}
class Color {
    constructor(e, a, o) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, a, o)
    }
    set(e, a, o) {
        if (a === void 0 && o === void 0) {
            const c = e;
            c && c.isColor ? this.copy(c) : typeof c == "number" ? this.setHex(c) : typeof c == "string" && this.setStyle(c)
        } else
            this.setRGB(e, a, o);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, a=SRGBColorSpace) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        ColorManagement.toWorkingColorSpace(this, a),
        this
    }
    setRGB(e, a, o, c=ColorManagement.workingColorSpace) {
        return this.r = e,
        this.g = a,
        this.b = o,
        ColorManagement.toWorkingColorSpace(this, c),
        this
    }
    setHSL(e, a, o, c=ColorManagement.workingColorSpace) {
        if (e = euclideanModulo(e, 1),
        a = clamp(a, 0, 1),
        o = clamp(o, 0, 1),
        a === 0)
            this.r = this.g = this.b = o;
        else {
            const d = o <= .5 ? o * (1 + a) : o + a - o * a
              , g = 2 * o - d;
            this.r = hue2rgb(g, d, e + 1 / 3),
            this.g = hue2rgb(g, d, e),
            this.b = hue2rgb(g, d, e - 1 / 3)
        }
        return ColorManagement.toWorkingColorSpace(this, c),
        this
    }
    setStyle(e, a=SRGBColorSpace) {
        function o(d) {
            d !== void 0 && parseFloat(d) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let c;
        if (c = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let d;
            const g = c[1]
              , _ = c[2];
            switch (g) {
            case "rgb":
            case "rgba":
                if (d = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_))
                    return o(d[4]),
                    this.setRGB(Math.min(255, parseInt(d[1], 10)) / 255, Math.min(255, parseInt(d[2], 10)) / 255, Math.min(255, parseInt(d[3], 10)) / 255, a);
                if (d = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_))
                    return o(d[4]),
                    this.setRGB(Math.min(100, parseInt(d[1], 10)) / 100, Math.min(100, parseInt(d[2], 10)) / 100, Math.min(100, parseInt(d[3], 10)) / 100, a);
                break;
            case "hsl":
            case "hsla":
                if (d = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_))
                    return o(d[4]),
                    this.setHSL(parseFloat(d[1]) / 360, parseFloat(d[2]) / 100, parseFloat(d[3]) / 100, a);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (c = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const d = c[1]
              , g = d.length;
            if (g === 3)
                return this.setRGB(parseInt(d.charAt(0), 16) / 15, parseInt(d.charAt(1), 16) / 15, parseInt(d.charAt(2), 16) / 15, a);
            if (g === 6)
                return this.setHex(parseInt(d, 16), a);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, a);
        return this
    }
    setColorName(e, a=SRGBColorSpace) {
        const o = _colorKeywords[e.toLowerCase()];
        return o !== void 0 ? this.setHex(o, a) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = SRGBToLinear(e.r),
        this.g = SRGBToLinear(e.g),
        this.b = SRGBToLinear(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = LinearToSRGB(e.r),
        this.g = LinearToSRGB(e.g),
        this.b = LinearToSRGB(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=SRGBColorSpace) {
        return ColorManagement.fromWorkingColorSpace(_color.copy(this), e),
        Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255))
    }
    getHexString(e=SRGBColorSpace) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, a=ColorManagement.workingColorSpace) {
        ColorManagement.fromWorkingColorSpace(_color.copy(this), a);
        const o = _color.r
          , c = _color.g
          , d = _color.b
          , g = Math.max(o, c, d)
          , _ = Math.min(o, c, d);
        let b, j;
        const $ = (_ + g) / 2;
        if (_ === g)
            b = 0,
            j = 0;
        else {
            const nt = g - _;
            switch (j = $ <= .5 ? nt / (g + _) : nt / (2 - g - _),
            g) {
            case o:
                b = (c - d) / nt + (c < d ? 6 : 0);
                break;
            case c:
                b = (d - o) / nt + 2;
                break;
            case d:
                b = (o - c) / nt + 4;
                break
            }
            b /= 6
        }
        return e.h = b,
        e.s = j,
        e.l = $,
        e
    }
    getRGB(e, a=ColorManagement.workingColorSpace) {
        return ColorManagement.fromWorkingColorSpace(_color.copy(this), a),
        e.r = _color.r,
        e.g = _color.g,
        e.b = _color.b,
        e
    }
    getStyle(e=SRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(_color.copy(this), e);
        const a = _color.r
          , o = _color.g
          , c = _color.b;
        return e !== SRGBColorSpace ? `color(${e} ${a.toFixed(3)} ${o.toFixed(3)} ${c.toFixed(3)})` : `rgb(${Math.round(a * 255)},${Math.round(o * 255)},${Math.round(c * 255)})`
    }
    offsetHSL(e, a, o) {
        return this.getHSL(_hslA),
        this.setHSL(_hslA.h + e, _hslA.s + a, _hslA.l + o)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, a) {
        return this.r = e.r + a.r,
        this.g = e.g + a.g,
        this.b = e.b + a.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, a) {
        return this.r += (e.r - this.r) * a,
        this.g += (e.g - this.g) * a,
        this.b += (e.b - this.b) * a,
        this
    }
    lerpColors(e, a, o) {
        return this.r = e.r + (a.r - e.r) * o,
        this.g = e.g + (a.g - e.g) * o,
        this.b = e.b + (a.b - e.b) * o,
        this
    }
    lerpHSL(e, a) {
        this.getHSL(_hslA),
        e.getHSL(_hslB);
        const o = lerp(_hslA.h, _hslB.h, a)
          , c = lerp(_hslA.s, _hslB.s, a)
          , d = lerp(_hslA.l, _hslB.l, a);
        return this.setHSL(o, c, d),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const a = this.r
          , o = this.g
          , c = this.b
          , d = e.elements;
        return this.r = d[0] * a + d[3] * o + d[6] * c,
        this.g = d[1] * a + d[4] * o + d[7] * c,
        this.b = d[2] * a + d[5] * o + d[8] * c,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, a=0) {
        return this.r = e[a],
        this.g = e[a + 1],
        this.b = e[a + 2],
        this
    }
    toArray(e=[], a=0) {
        return e[a] = this.r,
        e[a + 1] = this.g,
        e[a + 2] = this.b,
        e
    }
    fromBufferAttribute(e, a) {
        return this.r = e.getX(a),
        this.g = e.getY(a),
        this.b = e.getZ(a),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const _color = new Color;
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: _materialId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "Material",
        this.blending = NormalBlending,
        this.side = FrontSide,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = SrcAlphaFactor,
        this.blendDst = OneMinusSrcAlphaFactor,
        this.blendEquation = AddEquation,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Color(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = LessEqualDepth,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = AlwaysStencilFunc,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = KeepStencilOp,
        this.stencilZFail = KeepStencilOp,
        this.stencilZPass = KeepStencilOp,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const a in e) {
                const o = e[a];
                if (o === void 0) {
                    console.warn(`THREE.Material: parameter '${a}' has value of undefined.`);
                    continue
                }
                const c = this[a];
                if (c === void 0) {
                    console.warn(`THREE.Material: '${a}' is not a property of THREE.${this.type}.`);
                    continue
                }
                c && c.isColor ? c.set(o) : c && c.isVector3 && o && o.isVector3 ? c.copy(o) : this[a] = o
            }
    }
    toJSON(e) {
        const a = e === void 0 || typeof e == "string";
        a && (e = {
            textures: {},
            images: {}
        });
        const o = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        o.uuid = this.uuid,
        o.type = this.type,
        this.name !== "" && (o.name = this.name),
        this.color && this.color.isColor && (o.color = this.color.getHex()),
        this.roughness !== void 0 && (o.roughness = this.roughness),
        this.metalness !== void 0 && (o.metalness = this.metalness),
        this.sheen !== void 0 && (o.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (o.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (o.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (o.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (o.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (o.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (o.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (o.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (o.shininess = this.shininess),
        this.clearcoat !== void 0 && (o.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (o.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (o.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (o.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (o.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        o.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (o.dispersion = this.dispersion),
        this.iridescence !== void 0 && (o.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (o.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (o.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (o.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (o.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (o.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (o.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (o.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (o.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (o.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (o.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (o.lightMap = this.lightMap.toJSON(e).uuid,
        o.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (o.aoMap = this.aoMap.toJSON(e).uuid,
        o.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (o.bumpMap = this.bumpMap.toJSON(e).uuid,
        o.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (o.normalMap = this.normalMap.toJSON(e).uuid,
        o.normalMapType = this.normalMapType,
        o.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (o.displacementMap = this.displacementMap.toJSON(e).uuid,
        o.displacementScale = this.displacementScale,
        o.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (o.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (o.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (o.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (o.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (o.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (o.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (o.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (o.combine = this.combine)),
        this.envMapRotation !== void 0 && (o.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (o.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (o.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (o.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (o.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (o.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (o.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (o.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (o.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (o.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (o.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (o.size = this.size),
        this.shadowSide !== null && (o.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (o.sizeAttenuation = this.sizeAttenuation),
        this.blending !== NormalBlending && (o.blending = this.blending),
        this.side !== FrontSide && (o.side = this.side),
        this.vertexColors === !0 && (o.vertexColors = !0),
        this.opacity < 1 && (o.opacity = this.opacity),
        this.transparent === !0 && (o.transparent = !0),
        this.blendSrc !== SrcAlphaFactor && (o.blendSrc = this.blendSrc),
        this.blendDst !== OneMinusSrcAlphaFactor && (o.blendDst = this.blendDst),
        this.blendEquation !== AddEquation && (o.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (o.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (o.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (o.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (o.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (o.blendAlpha = this.blendAlpha),
        this.depthFunc !== LessEqualDepth && (o.depthFunc = this.depthFunc),
        this.depthTest === !1 && (o.depthTest = this.depthTest),
        this.depthWrite === !1 && (o.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (o.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (o.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== AlwaysStencilFunc && (o.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (o.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (o.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== KeepStencilOp && (o.stencilFail = this.stencilFail),
        this.stencilZFail !== KeepStencilOp && (o.stencilZFail = this.stencilZFail),
        this.stencilZPass !== KeepStencilOp && (o.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (o.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (o.rotation = this.rotation),
        this.polygonOffset === !0 && (o.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (o.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (o.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (o.linewidth = this.linewidth),
        this.dashSize !== void 0 && (o.dashSize = this.dashSize),
        this.gapSize !== void 0 && (o.gapSize = this.gapSize),
        this.scale !== void 0 && (o.scale = this.scale),
        this.dithering === !0 && (o.dithering = !0),
        this.alphaTest > 0 && (o.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (o.alphaHash = !0),
        this.alphaToCoverage === !0 && (o.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (o.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (o.forceSinglePass = !0),
        this.wireframe === !0 && (o.wireframe = !0),
        this.wireframeLinewidth > 1 && (o.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (o.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (o.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (o.flatShading = !0),
        this.visible === !1 && (o.visible = !1),
        this.toneMapped === !1 && (o.toneMapped = !1),
        this.fog === !1 && (o.fog = !1),
        Object.keys(this.userData).length > 0 && (o.userData = this.userData);
        function c(d) {
            const g = [];
            for (const _ in d) {
                const b = d[_];
                delete b.metadata,
                g.push(b)
            }
            return g
        }
        if (a) {
            const d = c(e.textures)
              , g = c(e.images);
            d.length > 0 && (o.textures = d),
            g.length > 0 && (o.images = g)
        }
        return o
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const a = e.clippingPlanes;
        let o = null;
        if (a !== null) {
            const c = a.length;
            o = new Array(c);
            for (let d = 0; d !== c; ++d)
                o[d] = a[d].clone()
        }
        return this.clippingPlanes = o,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
    onBeforeRender() {
        console.warn("Material: onBeforeRender() has been removed.")
    }
}
class MeshBasicMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Euler,
        this.combine = MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const _tables = _generateTables();
function _generateTables() {
    const s = new ArrayBuffer(4)
      , e = new Float32Array(s)
      , a = new Uint32Array(s)
      , o = new Uint32Array(512)
      , c = new Uint32Array(512);
    for (let b = 0; b < 256; ++b) {
        const j = b - 127;
        j < -27 ? (o[b] = 0,
        o[b | 256] = 32768,
        c[b] = 24,
        c[b | 256] = 24) : j < -14 ? (o[b] = 1024 >> -j - 14,
        o[b | 256] = 1024 >> -j - 14 | 32768,
        c[b] = -j - 1,
        c[b | 256] = -j - 1) : j <= 15 ? (o[b] = j + 15 << 10,
        o[b | 256] = j + 15 << 10 | 32768,
        c[b] = 13,
        c[b | 256] = 13) : j < 128 ? (o[b] = 31744,
        o[b | 256] = 64512,
        c[b] = 24,
        c[b | 256] = 24) : (o[b] = 31744,
        o[b | 256] = 64512,
        c[b] = 13,
        c[b | 256] = 13)
    }
    const d = new Uint32Array(2048)
      , g = new Uint32Array(64)
      , _ = new Uint32Array(64);
    for (let b = 1; b < 1024; ++b) {
        let j = b << 13
          , $ = 0;
        for (; !(j & 8388608); )
            j <<= 1,
            $ -= 8388608;
        j &= -8388609,
        $ += 947912704,
        d[b] = j | $
    }
    for (let b = 1024; b < 2048; ++b)
        d[b] = 939524096 + (b - 1024 << 13);
    for (let b = 1; b < 31; ++b)
        g[b] = b << 23;
    g[31] = 1199570944,
    g[32] = 2147483648;
    for (let b = 33; b < 63; ++b)
        g[b] = 2147483648 + (b - 32 << 23);
    g[63] = 3347054592;
    for (let b = 1; b < 64; ++b)
        b !== 32 && (_[b] = 1024);
    return {
        floatView: e,
        uint32View: a,
        baseTable: o,
        shiftTable: c,
        mantissaTable: d,
        exponentTable: g,
        offsetTable: _
    }
}
function toHalfFloat(s) {
    Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    s = clamp(s, -65504, 65504),
    _tables.floatView[0] = s;
    const e = _tables.uint32View[0]
      , a = e >> 23 & 511;
    return _tables.baseTable[a] + ((e & 8388607) >> _tables.shiftTable[a])
}
function fromHalfFloat(s) {
    const e = s >> 10;
    return _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[e] + (s & 1023)] + _tables.exponentTable[e],
    _tables.floatView[0]
}
const DataUtils = {
    toHalfFloat,
    fromHalfFloat
}
  , _vector$9 = new Vector3
  , _vector2$1 = new Vector2;
class BufferAttribute {
    constructor(e, a, o=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = a,
        this.count = e !== void 0 ? e.length / a : 0,
        this.normalized = o,
        this.usage = StaticDrawUsage,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = FloatType,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return warnOnce("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, a) {
        this.updateRanges.push({
            start: e,
            count: a
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, a, o) {
        e *= this.itemSize,
        o *= a.itemSize;
        for (let c = 0, d = this.itemSize; c < d; c++)
            this.array[e + c] = a.array[o + c];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let a = 0, o = this.count; a < o; a++)
                _vector2$1.fromBufferAttribute(this, a),
                _vector2$1.applyMatrix3(e),
                this.setXY(a, _vector2$1.x, _vector2$1.y);
        else if (this.itemSize === 3)
            for (let a = 0, o = this.count; a < o; a++)
                _vector$9.fromBufferAttribute(this, a),
                _vector$9.applyMatrix3(e),
                this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyMatrix4(e) {
        for (let a = 0, o = this.count; a < o; a++)
            _vector$9.fromBufferAttribute(this, a),
            _vector$9.applyMatrix4(e),
            this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let a = 0, o = this.count; a < o; a++)
            _vector$9.fromBufferAttribute(this, a),
            _vector$9.applyNormalMatrix(e),
            this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    transformDirection(e) {
        for (let a = 0, o = this.count; a < o; a++)
            _vector$9.fromBufferAttribute(this, a),
            _vector$9.transformDirection(e),
            this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    set(e, a=0) {
        return this.array.set(e, a),
        this
    }
    getComponent(e, a) {
        let o = this.array[e * this.itemSize + a];
        return this.normalized && (o = denormalize(o, this.array)),
        o
    }
    setComponent(e, a, o) {
        return this.normalized && (o = normalize(o, this.array)),
        this.array[e * this.itemSize + a] = o,
        this
    }
    getX(e) {
        let a = this.array[e * this.itemSize];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setX(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize] = a,
        this
    }
    getY(e) {
        let a = this.array[e * this.itemSize + 1];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setY(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize + 1] = a,
        this
    }
    getZ(e) {
        let a = this.array[e * this.itemSize + 2];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setZ(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize + 2] = a,
        this
    }
    getW(e) {
        let a = this.array[e * this.itemSize + 3];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setW(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize + 3] = a,
        this
    }
    setXY(e, a, o) {
        return e *= this.itemSize,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array)),
        this.array[e + 0] = a,
        this.array[e + 1] = o,
        this
    }
    setXYZ(e, a, o, c) {
        return e *= this.itemSize,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array),
        c = normalize(c, this.array)),
        this.array[e + 0] = a,
        this.array[e + 1] = o,
        this.array[e + 2] = c,
        this
    }
    setXYZW(e, a, o, c, d) {
        return e *= this.itemSize,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array),
        c = normalize(c, this.array),
        d = normalize(d, this.array)),
        this.array[e + 0] = a,
        this.array[e + 1] = o,
        this.array[e + 2] = c,
        this.array[e + 3] = d,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== StaticDrawUsage && (e.usage = this.usage),
        e
    }
}
class Int8BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Int8Array(e), a, o)
    }
}
class Uint8BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Uint8Array(e), a, o)
    }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Uint8ClampedArray(e), a, o)
    }
}
class Int16BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Int16Array(e), a, o)
    }
}
class Uint16BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Uint16Array(e), a, o)
    }
}
class Int32BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Int32Array(e), a, o)
    }
}
class Uint32BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Uint32Array(e), a, o)
    }
}
class Float16BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Uint16Array(e), a, o),
        this.isFloat16BufferAttribute = !0
    }
    getX(e) {
        let a = fromHalfFloat(this.array[e * this.itemSize]);
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setX(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize] = toHalfFloat(a),
        this
    }
    getY(e) {
        let a = fromHalfFloat(this.array[e * this.itemSize + 1]);
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setY(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize + 1] = toHalfFloat(a),
        this
    }
    getZ(e) {
        let a = fromHalfFloat(this.array[e * this.itemSize + 2]);
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setZ(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize + 2] = toHalfFloat(a),
        this
    }
    getW(e) {
        let a = fromHalfFloat(this.array[e * this.itemSize + 3]);
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setW(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.array[e * this.itemSize + 3] = toHalfFloat(a),
        this
    }
    setXY(e, a, o) {
        return e *= this.itemSize,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array)),
        this.array[e + 0] = toHalfFloat(a),
        this.array[e + 1] = toHalfFloat(o),
        this
    }
    setXYZ(e, a, o, c) {
        return e *= this.itemSize,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array),
        c = normalize(c, this.array)),
        this.array[e + 0] = toHalfFloat(a),
        this.array[e + 1] = toHalfFloat(o),
        this.array[e + 2] = toHalfFloat(c),
        this
    }
    setXYZW(e, a, o, c, d) {
        return e *= this.itemSize,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array),
        c = normalize(c, this.array),
        d = normalize(d, this.array)),
        this.array[e + 0] = toHalfFloat(a),
        this.array[e + 1] = toHalfFloat(o),
        this.array[e + 2] = toHalfFloat(c),
        this.array[e + 3] = toHalfFloat(d),
        this
    }
}
class Float32BufferAttribute extends BufferAttribute {
    constructor(e, a, o) {
        super(new Float32Array(e), a, o)
    }
}
let _id$2 = 0;
const _m1$2 = new Matrix4
  , _obj = new Object3D
  , _offset = new Vector3
  , _box$2 = new Box3
  , _boxMorphTargets = new Box3
  , _vector$8 = new Vector3;
class BufferGeometry extends EventDispatcher {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: _id$2++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (arrayNeedsUint32(e) ? Uint32BufferAttribute : Uint16BufferAttribute)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, a) {
        return this.attributes[e] = a,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, a, o=0) {
        this.groups.push({
            start: e,
            count: a,
            materialIndex: o
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, a) {
        this.drawRange.start = e,
        this.drawRange.count = a
    }
    applyMatrix4(e) {
        const a = this.attributes.position;
        a !== void 0 && (a.applyMatrix4(e),
        a.needsUpdate = !0);
        const o = this.attributes.normal;
        if (o !== void 0) {
            const d = new Matrix3().getNormalMatrix(e);
            o.applyNormalMatrix(d),
            o.needsUpdate = !0
        }
        const c = this.attributes.tangent;
        return c !== void 0 && (c.transformDirection(e),
        c.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return _m1$2.makeRotationFromQuaternion(e),
        this.applyMatrix4(_m1$2),
        this
    }
    rotateX(e) {
        return _m1$2.makeRotationX(e),
        this.applyMatrix4(_m1$2),
        this
    }
    rotateY(e) {
        return _m1$2.makeRotationY(e),
        this.applyMatrix4(_m1$2),
        this
    }
    rotateZ(e) {
        return _m1$2.makeRotationZ(e),
        this.applyMatrix4(_m1$2),
        this
    }
    translate(e, a, o) {
        return _m1$2.makeTranslation(e, a, o),
        this.applyMatrix4(_m1$2),
        this
    }
    scale(e, a, o) {
        return _m1$2.makeScale(e, a, o),
        this.applyMatrix4(_m1$2),
        this
    }
    lookAt(e) {
        return _obj.lookAt(e),
        _obj.updateMatrix(),
        this.applyMatrix4(_obj.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(_offset).negate(),
        this.translate(_offset.x, _offset.y, _offset.z),
        this
    }
    setFromPoints(e) {
        const a = [];
        for (let o = 0, c = e.length; o < c; o++) {
            const d = e[o];
            a.push(d.x, d.y, d.z || 0)
        }
        return this.setAttribute("position", new Float32BufferAttribute(a,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Box3);
        const e = this.attributes.position
          , a = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new Vector3(-1 / 0,-1 / 0,-1 / 0), new Vector3(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            a)
                for (let o = 0, c = a.length; o < c; o++) {
                    const d = a[o];
                    _box$2.setFromBufferAttribute(d),
                    this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min),
                    this.boundingBox.expandByPoint(_vector$8),
                    _vector$8.addVectors(this.boundingBox.max, _box$2.max),
                    this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min),
                    this.boundingBox.expandByPoint(_box$2.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Sphere);
        const e = this.attributes.position
          , a = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new Vector3, 1 / 0);
            return
        }
        if (e) {
            const o = this.boundingSphere.center;
            if (_box$2.setFromBufferAttribute(e),
            a)
                for (let d = 0, g = a.length; d < g; d++) {
                    const _ = a[d];
                    _boxMorphTargets.setFromBufferAttribute(_),
                    this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min),
                    _box$2.expandByPoint(_vector$8),
                    _vector$8.addVectors(_box$2.max, _boxMorphTargets.max),
                    _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min),
                    _box$2.expandByPoint(_boxMorphTargets.max))
                }
            _box$2.getCenter(o);
            let c = 0;
            for (let d = 0, g = e.count; d < g; d++)
                _vector$8.fromBufferAttribute(e, d),
                c = Math.max(c, o.distanceToSquared(_vector$8));
            if (a)
                for (let d = 0, g = a.length; d < g; d++) {
                    const _ = a[d]
                      , b = this.morphTargetsRelative;
                    for (let j = 0, $ = _.count; j < $; j++)
                        _vector$8.fromBufferAttribute(_, j),
                        b && (_offset.fromBufferAttribute(e, j),
                        _vector$8.add(_offset)),
                        c = Math.max(c, o.distanceToSquared(_vector$8))
                }
            this.boundingSphere.radius = Math.sqrt(c),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , a = this.attributes;
        if (e === null || a.position === void 0 || a.normal === void 0 || a.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const o = a.position
          , c = a.normal
          , d = a.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * o.count),4));
        const g = this.getAttribute("tangent")
          , _ = []
          , b = [];
        for (let vt = 0; vt < o.count; vt++)
            _[vt] = new Vector3,
            b[vt] = new Vector3;
        const j = new Vector3
          , $ = new Vector3
          , nt = new Vector3
          , tt = new Vector2
          , rt = new Vector2
          , st = new Vector2
          , lt = new Vector3
          , ct = new Vector3;
        function it(vt, xt, _t) {
            j.fromBufferAttribute(o, vt),
            $.fromBufferAttribute(o, xt),
            nt.fromBufferAttribute(o, _t),
            tt.fromBufferAttribute(d, vt),
            rt.fromBufferAttribute(d, xt),
            st.fromBufferAttribute(d, _t),
            $.sub(j),
            nt.sub(j),
            rt.sub(tt),
            st.sub(tt);
            const bt = 1 / (rt.x * st.y - st.x * rt.y);
            isFinite(bt) && (lt.copy($).multiplyScalar(st.y).addScaledVector(nt, -rt.y).multiplyScalar(bt),
            ct.copy(nt).multiplyScalar(rt.x).addScaledVector($, -st.x).multiplyScalar(bt),
            _[vt].add(lt),
            _[xt].add(lt),
            _[_t].add(lt),
            b[vt].add(ct),
            b[xt].add(ct),
            b[_t].add(ct))
        }
        let ot = this.groups;
        ot.length === 0 && (ot = [{
            start: 0,
            count: e.count
        }]);
        for (let vt = 0, xt = ot.length; vt < xt; ++vt) {
            const _t = ot[vt]
              , bt = _t.start
              , Rt = _t.count;
            for (let Ft = bt, Bt = bt + Rt; Ft < Bt; Ft += 3)
                it(e.getX(Ft + 0), e.getX(Ft + 1), e.getX(Ft + 2))
        }
        const at = new Vector3
          , ht = new Vector3
          , pt = new Vector3
          , dt = new Vector3;
        function yt(vt) {
            pt.fromBufferAttribute(c, vt),
            dt.copy(pt);
            const xt = _[vt];
            at.copy(xt),
            at.sub(pt.multiplyScalar(pt.dot(xt))).normalize(),
            ht.crossVectors(dt, xt);
            const bt = ht.dot(b[vt]) < 0 ? -1 : 1;
            g.setXYZW(vt, at.x, at.y, at.z, bt)
        }
        for (let vt = 0, xt = ot.length; vt < xt; ++vt) {
            const _t = ot[vt]
              , bt = _t.start
              , Rt = _t.count;
            for (let Ft = bt, Bt = bt + Rt; Ft < Bt; Ft += 3)
                yt(e.getX(Ft + 0)),
                yt(e.getX(Ft + 1)),
                yt(e.getX(Ft + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , a = this.getAttribute("position");
        if (a !== void 0) {
            let o = this.getAttribute("normal");
            if (o === void 0)
                o = new BufferAttribute(new Float32Array(a.count * 3),3),
                this.setAttribute("normal", o);
            else
                for (let tt = 0, rt = o.count; tt < rt; tt++)
                    o.setXYZ(tt, 0, 0, 0);
            const c = new Vector3
              , d = new Vector3
              , g = new Vector3
              , _ = new Vector3
              , b = new Vector3
              , j = new Vector3
              , $ = new Vector3
              , nt = new Vector3;
            if (e)
                for (let tt = 0, rt = e.count; tt < rt; tt += 3) {
                    const st = e.getX(tt + 0)
                      , lt = e.getX(tt + 1)
                      , ct = e.getX(tt + 2);
                    c.fromBufferAttribute(a, st),
                    d.fromBufferAttribute(a, lt),
                    g.fromBufferAttribute(a, ct),
                    $.subVectors(g, d),
                    nt.subVectors(c, d),
                    $.cross(nt),
                    _.fromBufferAttribute(o, st),
                    b.fromBufferAttribute(o, lt),
                    j.fromBufferAttribute(o, ct),
                    _.add($),
                    b.add($),
                    j.add($),
                    o.setXYZ(st, _.x, _.y, _.z),
                    o.setXYZ(lt, b.x, b.y, b.z),
                    o.setXYZ(ct, j.x, j.y, j.z)
                }
            else
                for (let tt = 0, rt = a.count; tt < rt; tt += 3)
                    c.fromBufferAttribute(a, tt + 0),
                    d.fromBufferAttribute(a, tt + 1),
                    g.fromBufferAttribute(a, tt + 2),
                    $.subVectors(g, d),
                    nt.subVectors(c, d),
                    $.cross(nt),
                    o.setXYZ(tt + 0, $.x, $.y, $.z),
                    o.setXYZ(tt + 1, $.x, $.y, $.z),
                    o.setXYZ(tt + 2, $.x, $.y, $.z);
            this.normalizeNormals(),
            o.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let a = 0, o = e.count; a < o; a++)
            _vector$8.fromBufferAttribute(e, a),
            _vector$8.normalize(),
            e.setXYZ(a, _vector$8.x, _vector$8.y, _vector$8.z)
    }
    toNonIndexed() {
        function e(_, b) {
            const j = _.array
              , $ = _.itemSize
              , nt = _.normalized
              , tt = new j.constructor(b.length * $);
            let rt = 0
              , st = 0;
            for (let lt = 0, ct = b.length; lt < ct; lt++) {
                _.isInterleavedBufferAttribute ? rt = b[lt] * _.data.stride + _.offset : rt = b[lt] * $;
                for (let it = 0; it < $; it++)
                    tt[st++] = j[rt++]
            }
            return new BufferAttribute(tt,$,nt)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const a = new BufferGeometry
          , o = this.index.array
          , c = this.attributes;
        for (const _ in c) {
            const b = c[_]
              , j = e(b, o);
            a.setAttribute(_, j)
        }
        const d = this.morphAttributes;
        for (const _ in d) {
            const b = []
              , j = d[_];
            for (let $ = 0, nt = j.length; $ < nt; $++) {
                const tt = j[$]
                  , rt = e(tt, o);
                b.push(rt)
            }
            a.morphAttributes[_] = b
        }
        a.morphTargetsRelative = this.morphTargetsRelative;
        const g = this.groups;
        for (let _ = 0, b = g.length; _ < b; _++) {
            const j = g[_];
            a.addGroup(j.start, j.count, j.materialIndex)
        }
        return a
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const b = this.parameters;
            for (const j in b)
                b[j] !== void 0 && (e[j] = b[j]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const a = this.index;
        a !== null && (e.data.index = {
            type: a.array.constructor.name,
            array: Array.prototype.slice.call(a.array)
        });
        const o = this.attributes;
        for (const b in o) {
            const j = o[b];
            e.data.attributes[b] = j.toJSON(e.data)
        }
        const c = {};
        let d = !1;
        for (const b in this.morphAttributes) {
            const j = this.morphAttributes[b]
              , $ = [];
            for (let nt = 0, tt = j.length; nt < tt; nt++) {
                const rt = j[nt];
                $.push(rt.toJSON(e.data))
            }
            $.length > 0 && (c[b] = $,
            d = !0)
        }
        d && (e.data.morphAttributes = c,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const g = this.groups;
        g.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(g)));
        const _ = this.boundingSphere;
        return _ !== null && (e.data.boundingSphere = {
            center: _.center.toArray(),
            radius: _.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const a = {};
        this.name = e.name;
        const o = e.index;
        o !== null && this.setIndex(o.clone(a));
        const c = e.attributes;
        for (const j in c) {
            const $ = c[j];
            this.setAttribute(j, $.clone(a))
        }
        const d = e.morphAttributes;
        for (const j in d) {
            const $ = []
              , nt = d[j];
            for (let tt = 0, rt = nt.length; tt < rt; tt++)
                $.push(nt[tt].clone(a));
            this.morphAttributes[j] = $
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const g = e.groups;
        for (let j = 0, $ = g.length; j < $; j++) {
            const nt = g[j];
            this.addGroup(nt.start, nt.count, nt.materialIndex)
        }
        const _ = e.boundingBox;
        _ !== null && (this.boundingBox = _.clone());
        const b = e.boundingSphere;
        return b !== null && (this.boundingSphere = b.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const _inverseMatrix$3 = new Matrix4
  , _ray$3 = new Ray
  , _sphere$6 = new Sphere
  , _sphereHitAt = new Vector3
  , _vA$1 = new Vector3
  , _vB$1 = new Vector3
  , _vC$1 = new Vector3
  , _tempA = new Vector3
  , _morphA = new Vector3
  , _uvA$1 = new Vector2
  , _uvB$1 = new Vector2
  , _uvC$1 = new Vector2
  , _normalA = new Vector3
  , _normalB = new Vector3
  , _normalC = new Vector3
  , _intersectionPoint = new Vector3
  , _intersectionPointWorld = new Vector3;
class Mesh extends Object3D {
    constructor(e=new BufferGeometry, a=new MeshBasicMaterial) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = a,
        this.updateMorphTargets()
    }
    copy(e, a) {
        return super.copy(e, a),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const a = this.geometry.morphAttributes
          , o = Object.keys(a);
        if (o.length > 0) {
            const c = a[o[0]];
            if (c !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let d = 0, g = c.length; d < g; d++) {
                    const _ = c[d].name || String(d);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[_] = d
                }
            }
        }
    }
    getVertexPosition(e, a) {
        const o = this.geometry
          , c = o.attributes.position
          , d = o.morphAttributes.position
          , g = o.morphTargetsRelative;
        a.fromBufferAttribute(c, e);
        const _ = this.morphTargetInfluences;
        if (d && _) {
            _morphA.set(0, 0, 0);
            for (let b = 0, j = d.length; b < j; b++) {
                const $ = _[b]
                  , nt = d[b];
                $ !== 0 && (_tempA.fromBufferAttribute(nt, e),
                g ? _morphA.addScaledVector(_tempA, $) : _morphA.addScaledVector(_tempA.sub(a), $))
            }
            a.add(_morphA)
        }
        return a
    }
    raycast(e, a) {
        const o = this.geometry
          , c = this.material
          , d = this.matrixWorld;
        c !== void 0 && (o.boundingSphere === null && o.computeBoundingSphere(),
        _sphere$6.copy(o.boundingSphere),
        _sphere$6.applyMatrix4(d),
        _ray$3.copy(e.ray).recast(e.near),
        !(_sphere$6.containsPoint(_ray$3.origin) === !1 && (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null || _ray$3.origin.distanceToSquared(_sphereHitAt) > (e.far - e.near) ** 2)) && (_inverseMatrix$3.copy(d).invert(),
        _ray$3.copy(e.ray).applyMatrix4(_inverseMatrix$3),
        !(o.boundingBox !== null && _ray$3.intersectsBox(o.boundingBox) === !1) && this._computeIntersections(e, a, _ray$3)))
    }
    _computeIntersections(e, a, o) {
        let c;
        const d = this.geometry
          , g = this.material
          , _ = d.index
          , b = d.attributes.position
          , j = d.attributes.uv
          , $ = d.attributes.uv1
          , nt = d.attributes.normal
          , tt = d.groups
          , rt = d.drawRange;
        if (_ !== null)
            if (Array.isArray(g))
                for (let st = 0, lt = tt.length; st < lt; st++) {
                    const ct = tt[st]
                      , it = g[ct.materialIndex]
                      , ot = Math.max(ct.start, rt.start)
                      , at = Math.min(_.count, Math.min(ct.start + ct.count, rt.start + rt.count));
                    for (let ht = ot, pt = at; ht < pt; ht += 3) {
                        const dt = _.getX(ht)
                          , yt = _.getX(ht + 1)
                          , vt = _.getX(ht + 2);
                        c = checkGeometryIntersection(this, it, e, o, j, $, nt, dt, yt, vt),
                        c && (c.faceIndex = Math.floor(ht / 3),
                        c.face.materialIndex = ct.materialIndex,
                        a.push(c))
                    }
                }
            else {
                const st = Math.max(0, rt.start)
                  , lt = Math.min(_.count, rt.start + rt.count);
                for (let ct = st, it = lt; ct < it; ct += 3) {
                    const ot = _.getX(ct)
                      , at = _.getX(ct + 1)
                      , ht = _.getX(ct + 2);
                    c = checkGeometryIntersection(this, g, e, o, j, $, nt, ot, at, ht),
                    c && (c.faceIndex = Math.floor(ct / 3),
                    a.push(c))
                }
            }
        else if (b !== void 0)
            if (Array.isArray(g))
                for (let st = 0, lt = tt.length; st < lt; st++) {
                    const ct = tt[st]
                      , it = g[ct.materialIndex]
                      , ot = Math.max(ct.start, rt.start)
                      , at = Math.min(b.count, Math.min(ct.start + ct.count, rt.start + rt.count));
                    for (let ht = ot, pt = at; ht < pt; ht += 3) {
                        const dt = ht
                          , yt = ht + 1
                          , vt = ht + 2;
                        c = checkGeometryIntersection(this, it, e, o, j, $, nt, dt, yt, vt),
                        c && (c.faceIndex = Math.floor(ht / 3),
                        c.face.materialIndex = ct.materialIndex,
                        a.push(c))
                    }
                }
            else {
                const st = Math.max(0, rt.start)
                  , lt = Math.min(b.count, rt.start + rt.count);
                for (let ct = st, it = lt; ct < it; ct += 3) {
                    const ot = ct
                      , at = ct + 1
                      , ht = ct + 2;
                    c = checkGeometryIntersection(this, g, e, o, j, $, nt, ot, at, ht),
                    c && (c.faceIndex = Math.floor(ct / 3),
                    a.push(c))
                }
            }
    }
}
function checkIntersection$1(s, e, a, o, c, d, g, _) {
    let b;
    if (e.side === BackSide ? b = o.intersectTriangle(g, d, c, !0, _) : b = o.intersectTriangle(c, d, g, e.side === FrontSide, _),
    b === null)
        return null;
    _intersectionPointWorld.copy(_),
    _intersectionPointWorld.applyMatrix4(s.matrixWorld);
    const j = a.ray.origin.distanceTo(_intersectionPointWorld);
    return j < a.near || j > a.far ? null : {
        distance: j,
        point: _intersectionPointWorld.clone(),
        object: s
    }
}
function checkGeometryIntersection(s, e, a, o, c, d, g, _, b, j) {
    s.getVertexPosition(_, _vA$1),
    s.getVertexPosition(b, _vB$1),
    s.getVertexPosition(j, _vC$1);
    const $ = checkIntersection$1(s, e, a, o, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if ($) {
        c && (_uvA$1.fromBufferAttribute(c, _),
        _uvB$1.fromBufferAttribute(c, b),
        _uvC$1.fromBufferAttribute(c, j),
        $.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2)),
        d && (_uvA$1.fromBufferAttribute(d, _),
        _uvB$1.fromBufferAttribute(d, b),
        _uvC$1.fromBufferAttribute(d, j),
        $.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2)),
        g && (_normalA.fromBufferAttribute(g, _),
        _normalB.fromBufferAttribute(g, b),
        _normalC.fromBufferAttribute(g, j),
        $.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3),
        $.normal.dot(o.direction) > 0 && $.normal.multiplyScalar(-1));
        const nt = {
            a: _,
            b,
            c: j,
            normal: new Vector3,
            materialIndex: 0
        };
        Triangle.getNormal(_vA$1, _vB$1, _vC$1, nt.normal),
        $.face = nt
    }
    return $
}
class BoxGeometry extends BufferGeometry {
    constructor(e=1, a=1, o=1, c=1, d=1, g=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: a,
            depth: o,
            widthSegments: c,
            heightSegments: d,
            depthSegments: g
        };
        const _ = this;
        c = Math.floor(c),
        d = Math.floor(d),
        g = Math.floor(g);
        const b = []
          , j = []
          , $ = []
          , nt = [];
        let tt = 0
          , rt = 0;
        st("z", "y", "x", -1, -1, o, a, e, g, d, 0),
        st("z", "y", "x", 1, -1, o, a, -e, g, d, 1),
        st("x", "z", "y", 1, 1, e, o, a, c, g, 2),
        st("x", "z", "y", 1, -1, e, o, -a, c, g, 3),
        st("x", "y", "z", 1, -1, e, a, o, c, d, 4),
        st("x", "y", "z", -1, -1, e, a, -o, c, d, 5),
        this.setIndex(b),
        this.setAttribute("position", new Float32BufferAttribute(j,3)),
        this.setAttribute("normal", new Float32BufferAttribute($,3)),
        this.setAttribute("uv", new Float32BufferAttribute(nt,2));
        function st(lt, ct, it, ot, at, ht, pt, dt, yt, vt, xt) {
            const _t = ht / yt
              , bt = pt / vt
              , Rt = ht / 2
              , Ft = pt / 2
              , Bt = dt / 2
              , Dt = yt + 1
              , Mt = vt + 1;
            let Tt = 0
              , mt = 0;
            const St = new Vector3;
            for (let wt = 0; wt < Mt; wt++) {
                const Ct = wt * bt - Ft;
                for (let Ht = 0; Ht < Dt; Ht++) {
                    const en = Ht * _t - Rt;
                    St[lt] = en * ot,
                    St[ct] = Ct * at,
                    St[it] = Bt,
                    j.push(St.x, St.y, St.z),
                    St[lt] = 0,
                    St[ct] = 0,
                    St[it] = dt > 0 ? 1 : -1,
                    $.push(St.x, St.y, St.z),
                    nt.push(Ht / yt),
                    nt.push(1 - wt / vt),
                    Tt += 1
                }
            }
            for (let wt = 0; wt < vt; wt++)
                for (let Ct = 0; Ct < yt; Ct++) {
                    const Ht = tt + Ct + Dt * wt
                      , en = tt + Ct + Dt * (wt + 1)
                      , Ot = tt + (Ct + 1) + Dt * (wt + 1)
                      , Yt = tt + (Ct + 1) + Dt * wt;
                    b.push(Ht, en, Yt),
                    b.push(en, Ot, Yt),
                    mt += 6
                }
            _.addGroup(rt, mt, xt),
            rt += mt,
            tt += Tt
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new BoxGeometry(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function cloneUniforms(s) {
    const e = {};
    for (const a in s) {
        e[a] = {};
        for (const o in s[a]) {
            const c = s[a][o];
            c && (c.isColor || c.isMatrix3 || c.isMatrix4 || c.isVector2 || c.isVector3 || c.isVector4 || c.isTexture || c.isQuaternion) ? c.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[a][o] = null) : e[a][o] = c.clone() : Array.isArray(c) ? e[a][o] = c.slice() : e[a][o] = c
        }
    }
    return e
}
function mergeUniforms(s) {
    const e = {};
    for (let a = 0; a < s.length; a++) {
        const o = cloneUniforms(s[a]);
        for (const c in o)
            e[c] = o[c]
    }
    return e
}
function cloneUniformsGroups(s) {
    const e = [];
    for (let a = 0; a < s.length; a++)
        e.push(s[a].clone());
    return e
}
function getUnlitUniformColorSpace(s) {
    const e = s.getRenderTarget();
    return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : ColorManagement.workingColorSpace
}
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = default_vertex,
        this.fragmentShader = default_fragment,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = cloneUniforms(e.uniforms),
        this.uniformsGroups = cloneUniformsGroups(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const a = super.toJSON(e);
        a.glslVersion = this.glslVersion,
        a.uniforms = {};
        for (const c in this.uniforms) {
            const g = this.uniforms[c].value;
            g && g.isTexture ? a.uniforms[c] = {
                type: "t",
                value: g.toJSON(e).uuid
            } : g && g.isColor ? a.uniforms[c] = {
                type: "c",
                value: g.getHex()
            } : g && g.isVector2 ? a.uniforms[c] = {
                type: "v2",
                value: g.toArray()
            } : g && g.isVector3 ? a.uniforms[c] = {
                type: "v3",
                value: g.toArray()
            } : g && g.isVector4 ? a.uniforms[c] = {
                type: "v4",
                value: g.toArray()
            } : g && g.isMatrix3 ? a.uniforms[c] = {
                type: "m3",
                value: g.toArray()
            } : g && g.isMatrix4 ? a.uniforms[c] = {
                type: "m4",
                value: g.toArray()
            } : a.uniforms[c] = {
                value: g
            }
        }
        Object.keys(this.defines).length > 0 && (a.defines = this.defines),
        a.vertexShader = this.vertexShader,
        a.fragmentShader = this.fragmentShader,
        a.lights = this.lights,
        a.clipping = this.clipping;
        const o = {};
        for (const c in this.extensions)
            this.extensions[c] === !0 && (o[c] = !0);
        return Object.keys(o).length > 0 && (a.extensions = o),
        a
    }
}
class Camera extends Object3D {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Matrix4,
        this.projectionMatrix = new Matrix4,
        this.projectionMatrixInverse = new Matrix4,
        this.coordinateSystem = WebGLCoordinateSystem
    }
    copy(e, a) {
        return super.copy(e, a),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, a) {
        super.updateWorldMatrix(e, a),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _v3$1 = new Vector3
  , _minTarget = new Vector2
  , _maxTarget = new Vector2;
class PerspectiveCamera extends Camera {
    constructor(e=50, a=1, o=.1, c=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = o,
        this.far = c,
        this.focus = 10,
        this.aspect = a,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, a) {
        return super.copy(e, a),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const a = .5 * this.getFilmHeight() / e;
        this.fov = RAD2DEG * 2 * Math.atan(a),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(DEG2RAD * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, a, o) {
        _v3$1.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        a.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z),
        _v3$1.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        o.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z)
    }
    getViewSize(e, a) {
        return this.getViewBounds(e, _minTarget, _maxTarget),
        a.subVectors(_maxTarget, _minTarget)
    }
    setViewOffset(e, a, o, c, d, g) {
        this.aspect = e / a,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = a,
        this.view.offsetX = o,
        this.view.offsetY = c,
        this.view.width = d,
        this.view.height = g,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let a = e * Math.tan(DEG2RAD * .5 * this.fov) / this.zoom
          , o = 2 * a
          , c = this.aspect * o
          , d = -.5 * c;
        const g = this.view;
        if (this.view !== null && this.view.enabled) {
            const b = g.fullWidth
              , j = g.fullHeight;
            d += g.offsetX * c / b,
            a -= g.offsetY * o / j,
            c *= g.width / b,
            o *= g.height / j
        }
        const _ = this.filmOffset;
        _ !== 0 && (d += e * _ / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(d, d + c, a, a - o, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return a.object.fov = this.fov,
        a.object.zoom = this.zoom,
        a.object.near = this.near,
        a.object.far = this.far,
        a.object.focus = this.focus,
        a.object.aspect = this.aspect,
        this.view !== null && (a.object.view = Object.assign({}, this.view)),
        a.object.filmGauge = this.filmGauge,
        a.object.filmOffset = this.filmOffset,
        a
    }
}
const fov = -90
  , aspect = 1;
class CubeCamera extends Object3D {
    constructor(e, a, o) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = o,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const c = new PerspectiveCamera(fov,aspect,e,a);
        c.layers = this.layers,
        this.add(c);
        const d = new PerspectiveCamera(fov,aspect,e,a);
        d.layers = this.layers,
        this.add(d);
        const g = new PerspectiveCamera(fov,aspect,e,a);
        g.layers = this.layers,
        this.add(g);
        const _ = new PerspectiveCamera(fov,aspect,e,a);
        _.layers = this.layers,
        this.add(_);
        const b = new PerspectiveCamera(fov,aspect,e,a);
        b.layers = this.layers,
        this.add(b);
        const j = new PerspectiveCamera(fov,aspect,e,a);
        j.layers = this.layers,
        this.add(j)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , a = this.children.concat()
          , [o,c,d,g,_,b] = a;
        for (const j of a)
            this.remove(j);
        if (e === WebGLCoordinateSystem)
            o.up.set(0, 1, 0),
            o.lookAt(1, 0, 0),
            c.up.set(0, 1, 0),
            c.lookAt(-1, 0, 0),
            d.up.set(0, 0, -1),
            d.lookAt(0, 1, 0),
            g.up.set(0, 0, 1),
            g.lookAt(0, -1, 0),
            _.up.set(0, 1, 0),
            _.lookAt(0, 0, 1),
            b.up.set(0, 1, 0),
            b.lookAt(0, 0, -1);
        else if (e === WebGPUCoordinateSystem)
            o.up.set(0, -1, 0),
            o.lookAt(-1, 0, 0),
            c.up.set(0, -1, 0),
            c.lookAt(1, 0, 0),
            d.up.set(0, 0, 1),
            d.lookAt(0, 1, 0),
            g.up.set(0, 0, -1),
            g.lookAt(0, -1, 0),
            _.up.set(0, -1, 0),
            _.lookAt(0, 0, 1),
            b.up.set(0, -1, 0),
            b.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const j of a)
            this.add(j),
            j.updateMatrixWorld()
    }
    update(e, a) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: o, activeMipmapLevel: c} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [d,g,_,b,j,$] = this.children
          , nt = e.getRenderTarget()
          , tt = e.getActiveCubeFace()
          , rt = e.getActiveMipmapLevel()
          , st = e.xr.enabled;
        e.xr.enabled = !1;
        const lt = o.texture.generateMipmaps;
        o.texture.generateMipmaps = !1,
        e.setRenderTarget(o, 0, c),
        e.render(a, d),
        e.setRenderTarget(o, 1, c),
        e.render(a, g),
        e.setRenderTarget(o, 2, c),
        e.render(a, _),
        e.setRenderTarget(o, 3, c),
        e.render(a, b),
        e.setRenderTarget(o, 4, c),
        e.render(a, j),
        o.texture.generateMipmaps = lt,
        e.setRenderTarget(o, 5, c),
        e.render(a, $),
        e.setRenderTarget(nt, tt, rt),
        e.xr.enabled = st,
        o.texture.needsPMREMUpdate = !0
    }
}
class CubeTexture extends Texture {
    constructor(e, a, o, c, d, g, _, b, j, $) {
        e = e !== void 0 ? e : [],
        a = a !== void 0 ? a : CubeReflectionMapping,
        super(e, a, o, c, d, g, _, b, j, $),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor(e=1, a={}) {
        super(e, e, a),
        this.isWebGLCubeRenderTarget = !0;
        const o = {
            width: e,
            height: e,
            depth: 1
        }
          , c = [o, o, o, o, o, o];
        this.texture = new CubeTexture(c,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = a.generateMipmaps !== void 0 ? a.generateMipmaps : !1,
        this.texture.minFilter = a.minFilter !== void 0 ? a.minFilter : LinearFilter
    }
    fromEquirectangularTexture(e, a) {
        this.texture.type = a.type,
        this.texture.colorSpace = a.colorSpace,
        this.texture.generateMipmaps = a.generateMipmaps,
        this.texture.minFilter = a.minFilter,
        this.texture.magFilter = a.magFilter;
        const o = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , c = new BoxGeometry(5,5,5)
          , d = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(o.uniforms),
            vertexShader: o.vertexShader,
            fragmentShader: o.fragmentShader,
            side: BackSide,
            blending: NoBlending
        });
        d.uniforms.tEquirect.value = a;
        const g = new Mesh(c,d)
          , _ = a.minFilter;
        return a.minFilter === LinearMipmapLinearFilter && (a.minFilter = LinearFilter),
        new CubeCamera(1,10,this).update(e, g),
        a.minFilter = _,
        g.geometry.dispose(),
        g.material.dispose(),
        this
    }
    clear(e, a, o, c) {
        const d = e.getRenderTarget();
        for (let g = 0; g < 6; g++)
            e.setRenderTarget(this, g),
            e.clear(a, o, c);
        e.setRenderTarget(d)
    }
}
const _vector1 = new Vector3
  , _vector2 = new Vector3
  , _normalMatrix = new Matrix3;
class Plane {
    constructor(e=new Vector3(1,0,0), a=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = a
    }
    set(e, a) {
        return this.normal.copy(e),
        this.constant = a,
        this
    }
    setComponents(e, a, o, c) {
        return this.normal.set(e, a, o),
        this.constant = c,
        this
    }
    setFromNormalAndCoplanarPoint(e, a) {
        return this.normal.copy(e),
        this.constant = -a.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, a, o) {
        const c = _vector1.subVectors(o, a).cross(_vector2.subVectors(e, a)).normalize();
        return this.setFromNormalAndCoplanarPoint(c, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, a) {
        return a.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, a) {
        const o = e.delta(_vector1)
          , c = this.normal.dot(o);
        if (c === 0)
            return this.distanceToPoint(e.start) === 0 ? a.copy(e.start) : null;
        const d = -(e.start.dot(this.normal) + this.constant) / c;
        return d < 0 || d > 1 ? null : a.copy(e.start).addScaledVector(o, d)
    }
    intersectsLine(e) {
        const a = this.distanceToPoint(e.start)
          , o = this.distanceToPoint(e.end);
        return a < 0 && o > 0 || o < 0 && a > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, a) {
        const o = a || _normalMatrix.getNormalMatrix(e)
          , c = this.coplanarPoint(_vector1).applyMatrix4(e)
          , d = this.normal.applyMatrix3(o).normalize();
        return this.constant = -c.dot(d),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _sphere$5 = new Sphere
  , _vector$7 = new Vector3;
class Frustum {
    constructor(e=new Plane, a=new Plane, o=new Plane, c=new Plane, d=new Plane, g=new Plane) {
        this.planes = [e, a, o, c, d, g]
    }
    set(e, a, o, c, d, g) {
        const _ = this.planes;
        return _[0].copy(e),
        _[1].copy(a),
        _[2].copy(o),
        _[3].copy(c),
        _[4].copy(d),
        _[5].copy(g),
        this
    }
    copy(e) {
        const a = this.planes;
        for (let o = 0; o < 6; o++)
            a[o].copy(e.planes[o]);
        return this
    }
    setFromProjectionMatrix(e, a=WebGLCoordinateSystem) {
        const o = this.planes
          , c = e.elements
          , d = c[0]
          , g = c[1]
          , _ = c[2]
          , b = c[3]
          , j = c[4]
          , $ = c[5]
          , nt = c[6]
          , tt = c[7]
          , rt = c[8]
          , st = c[9]
          , lt = c[10]
          , ct = c[11]
          , it = c[12]
          , ot = c[13]
          , at = c[14]
          , ht = c[15];
        if (o[0].setComponents(b - d, tt - j, ct - rt, ht - it).normalize(),
        o[1].setComponents(b + d, tt + j, ct + rt, ht + it).normalize(),
        o[2].setComponents(b + g, tt + $, ct + st, ht + ot).normalize(),
        o[3].setComponents(b - g, tt - $, ct - st, ht - ot).normalize(),
        o[4].setComponents(b - _, tt - nt, ct - lt, ht - at).normalize(),
        a === WebGLCoordinateSystem)
            o[5].setComponents(b + _, tt + nt, ct + lt, ht + at).normalize();
        else if (a === WebGPUCoordinateSystem)
            o[5].setComponents(_, nt, lt, at).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + a);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            _sphere$5.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const a = e.geometry;
            a.boundingSphere === null && a.computeBoundingSphere(),
            _sphere$5.copy(a.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(_sphere$5)
    }
    intersectsSprite(e) {
        return _sphere$5.center.set(0, 0, 0),
        _sphere$5.radius = .7071067811865476,
        _sphere$5.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(_sphere$5)
    }
    intersectsSphere(e) {
        const a = this.planes
          , o = e.center
          , c = -e.radius;
        for (let d = 0; d < 6; d++)
            if (a[d].distanceToPoint(o) < c)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const a = this.planes;
        for (let o = 0; o < 6; o++) {
            const c = a[o];
            if (_vector$7.x = c.normal.x > 0 ? e.max.x : e.min.x,
            _vector$7.y = c.normal.y > 0 ? e.max.y : e.min.y,
            _vector$7.z = c.normal.z > 0 ? e.max.z : e.min.z,
            c.distanceToPoint(_vector$7) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const a = this.planes;
        for (let o = 0; o < 6; o++)
            if (a[o].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function WebGLAnimation() {
    let s = null
      , e = !1
      , a = null
      , o = null;
    function c(d, g) {
        a(d, g),
        o = s.requestAnimationFrame(c)
    }
    return {
        start: function() {
            e !== !0 && a !== null && (o = s.requestAnimationFrame(c),
            e = !0)
        },
        stop: function() {
            s.cancelAnimationFrame(o),
            e = !1
        },
        setAnimationLoop: function(d) {
            a = d
        },
        setContext: function(d) {
            s = d
        }
    }
}
function WebGLAttributes(s) {
    const e = new WeakMap;
    function a(_, b) {
        const j = _.array
          , $ = _.usage
          , nt = j.byteLength
          , tt = s.createBuffer();
        s.bindBuffer(b, tt),
        s.bufferData(b, j, $),
        _.onUploadCallback();
        let rt;
        if (j instanceof Float32Array)
            rt = s.FLOAT;
        else if (j instanceof Uint16Array)
            _.isFloat16BufferAttribute ? rt = s.HALF_FLOAT : rt = s.UNSIGNED_SHORT;
        else if (j instanceof Int16Array)
            rt = s.SHORT;
        else if (j instanceof Uint32Array)
            rt = s.UNSIGNED_INT;
        else if (j instanceof Int32Array)
            rt = s.INT;
        else if (j instanceof Int8Array)
            rt = s.BYTE;
        else if (j instanceof Uint8Array)
            rt = s.UNSIGNED_BYTE;
        else if (j instanceof Uint8ClampedArray)
            rt = s.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + j);
        return {
            buffer: tt,
            type: rt,
            bytesPerElement: j.BYTES_PER_ELEMENT,
            version: _.version,
            size: nt
        }
    }
    function o(_, b, j) {
        const $ = b.array
          , nt = b._updateRange
          , tt = b.updateRanges;
        if (s.bindBuffer(j, _),
        nt.count === -1 && tt.length === 0 && s.bufferSubData(j, 0, $),
        tt.length !== 0) {
            for (let rt = 0, st = tt.length; rt < st; rt++) {
                const lt = tt[rt];
                s.bufferSubData(j, lt.start * $.BYTES_PER_ELEMENT, $, lt.start, lt.count)
            }
            b.clearUpdateRanges()
        }
        nt.count !== -1 && (s.bufferSubData(j, nt.offset * $.BYTES_PER_ELEMENT, $, nt.offset, nt.count),
        nt.count = -1),
        b.onUploadCallback()
    }
    function c(_) {
        return _.isInterleavedBufferAttribute && (_ = _.data),
        e.get(_)
    }
    function d(_) {
        _.isInterleavedBufferAttribute && (_ = _.data);
        const b = e.get(_);
        b && (s.deleteBuffer(b.buffer),
        e.delete(_))
    }
    function g(_, b) {
        if (_.isInterleavedBufferAttribute && (_ = _.data),
        _.isGLBufferAttribute) {
            const $ = e.get(_);
            (!$ || $.version < _.version) && e.set(_, {
                buffer: _.buffer,
                type: _.type,
                bytesPerElement: _.elementSize,
                version: _.version
            });
            return
        }
        const j = e.get(_);
        if (j === void 0)
            e.set(_, a(_, b));
        else if (j.version < _.version) {
            if (j.size !== _.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            o(j.buffer, _, b),
            j.version = _.version
        }
    }
    return {
        get: c,
        remove: d,
        update: g
    }
}
class PlaneGeometry extends BufferGeometry {
    constructor(e=1, a=1, o=1, c=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: a,
            widthSegments: o,
            heightSegments: c
        };
        const d = e / 2
          , g = a / 2
          , _ = Math.floor(o)
          , b = Math.floor(c)
          , j = _ + 1
          , $ = b + 1
          , nt = e / _
          , tt = a / b
          , rt = []
          , st = []
          , lt = []
          , ct = [];
        for (let it = 0; it < $; it++) {
            const ot = it * tt - g;
            for (let at = 0; at < j; at++) {
                const ht = at * nt - d;
                st.push(ht, -ot, 0),
                lt.push(0, 0, 1),
                ct.push(at / _),
                ct.push(1 - it / b)
            }
        }
        for (let it = 0; it < b; it++)
            for (let ot = 0; ot < _; ot++) {
                const at = ot + j * it
                  , ht = ot + j * (it + 1)
                  , pt = ot + 1 + j * (it + 1)
                  , dt = ot + 1 + j * it;
                rt.push(at, ht, dt),
                rt.push(ht, pt, dt)
            }
        this.setIndex(rt),
        this.setAttribute("position", new Float32BufferAttribute(st,3)),
        this.setAttribute("normal", new Float32BufferAttribute(lt,3)),
        this.setAttribute("uv", new Float32BufferAttribute(ct,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new PlaneGeometry(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , batching_pars_vertex = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , colorspace_pars_fragment = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , morphcolor_vertex = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , opaque_fragment$1 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , vertex$e = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , vertex$a = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , vertex$2 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    batching_pars_vertex,
    batching_vertex,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphinstance_vertex,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment: opaque_fragment$1,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
}
  , UniformsLib = {
    common: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Matrix3
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Matrix3
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new Matrix3
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new Matrix3
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new Matrix3
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new Matrix3
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new Matrix3
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new Matrix3
        },
        normalScale: {
            value: new Vector2(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new Matrix3
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new Matrix3
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new Matrix3
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new Matrix3
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Matrix3
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3
        }
    },
    sprite: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector2(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Matrix3
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Matrix3
        },
        alphaTest: {
            value: 0
        }
    }
}
  , ShaderLib = {
    basic: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            specular: {
                value: new Color(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
        uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new Matrix3
            }
        },
        vertexShader: ShaderChunk.backgroundCube_vert,
        fragmentShader: ShaderChunk.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
            referencePosition: {
                value: new Vector3
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
            color: {
                value: new Color(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new Matrix3
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new Matrix3
        },
        clearcoatNormalScale: {
            value: new Vector2(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new Matrix3
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new Matrix3
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new Matrix3
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Color(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new Matrix3
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new Matrix3
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new Matrix3
        },
        transmissionSamplerSize: {
            value: new Vector2
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new Matrix3
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Color(0)
        },
        specularColor: {
            value: new Color(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new Matrix3
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new Matrix3
        },
        anisotropyVector: {
            value: new Vector2
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new Matrix3
        }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = {
    r: 0,
    b: 0,
    g: 0
}
  , _e1$1 = new Euler
  , _m1$1 = new Matrix4;
function WebGLBackground(s, e, a, o, c, d, g) {
    const _ = new Color(0);
    let b = d === !0 ? 0 : 1, j, $, nt = null, tt = 0, rt = null;
    function st(ot) {
        let at = ot.isScene === !0 ? ot.background : null;
        return at && at.isTexture && (at = (ot.backgroundBlurriness > 0 ? a : e).get(at)),
        at
    }
    function lt(ot) {
        let at = !1;
        const ht = st(ot);
        ht === null ? it(_, b) : ht && ht.isColor && (it(ht, 1),
        at = !0);
        const pt = s.xr.getEnvironmentBlendMode();
        pt === "additive" ? o.buffers.color.setClear(0, 0, 0, 1, g) : pt === "alpha-blend" && o.buffers.color.setClear(0, 0, 0, 0, g),
        (s.autoClear || at) && (o.buffers.depth.setTest(!0),
        o.buffers.depth.setMask(!0),
        o.buffers.color.setMask(!0),
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil))
    }
    function ct(ot, at) {
        const ht = st(at);
        ht && (ht.isCubeTexture || ht.mapping === CubeUVReflectionMapping) ? ($ === void 0 && ($ = new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        $.geometry.deleteAttribute("normal"),
        $.geometry.deleteAttribute("uv"),
        $.onBeforeRender = function(pt, dt, yt) {
            this.matrixWorld.copyPosition(yt.matrixWorld)
        }
        ,
        Object.defineProperty($.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        c.update($)),
        _e1$1.copy(at.backgroundRotation),
        _e1$1.x *= -1,
        _e1$1.y *= -1,
        _e1$1.z *= -1,
        ht.isCubeTexture && ht.isRenderTargetTexture === !1 && (_e1$1.y *= -1,
        _e1$1.z *= -1),
        $.material.uniforms.envMap.value = ht,
        $.material.uniforms.flipEnvMap.value = ht.isCubeTexture && ht.isRenderTargetTexture === !1 ? -1 : 1,
        $.material.uniforms.backgroundBlurriness.value = at.backgroundBlurriness,
        $.material.uniforms.backgroundIntensity.value = at.backgroundIntensity,
        $.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)),
        $.material.toneMapped = ColorManagement.getTransfer(ht.colorSpace) !== SRGBTransfer,
        (nt !== ht || tt !== ht.version || rt !== s.toneMapping) && ($.material.needsUpdate = !0,
        nt = ht,
        tt = ht.version,
        rt = s.toneMapping),
        $.layers.enableAll(),
        ot.unshift($, $.geometry, $.material, 0, 0, null)) : ht && ht.isTexture && (j === void 0 && (j = new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        j.geometry.deleteAttribute("normal"),
        Object.defineProperty(j.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        c.update(j)),
        j.material.uniforms.t2D.value = ht,
        j.material.uniforms.backgroundIntensity.value = at.backgroundIntensity,
        j.material.toneMapped = ColorManagement.getTransfer(ht.colorSpace) !== SRGBTransfer,
        ht.matrixAutoUpdate === !0 && ht.updateMatrix(),
        j.material.uniforms.uvTransform.value.copy(ht.matrix),
        (nt !== ht || tt !== ht.version || rt !== s.toneMapping) && (j.material.needsUpdate = !0,
        nt = ht,
        tt = ht.version,
        rt = s.toneMapping),
        j.layers.enableAll(),
        ot.unshift(j, j.geometry, j.material, 0, 0, null))
    }
    function it(ot, at) {
        ot.getRGB(_rgb, getUnlitUniformColorSpace(s)),
        o.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, at, g)
    }
    return {
        getClearColor: function() {
            return _
        },
        setClearColor: function(ot, at=1) {
            _.set(ot),
            b = at,
            it(_, b)
        },
        getClearAlpha: function() {
            return b
        },
        setClearAlpha: function(ot) {
            b = ot,
            it(_, b)
        },
        render: lt,
        addToRenderList: ct
    }
}
function WebGLBindingStates(s, e) {
    const a = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , o = {}
      , c = tt(null);
    let d = c
      , g = !1;
    function _(_t, bt, Rt, Ft, Bt) {
        let Dt = !1;
        const Mt = nt(Ft, Rt, bt);
        d !== Mt && (d = Mt,
        j(d.object)),
        Dt = rt(_t, Ft, Rt, Bt),
        Dt && st(_t, Ft, Rt, Bt),
        Bt !== null && e.update(Bt, s.ELEMENT_ARRAY_BUFFER),
        (Dt || g) && (g = !1,
        ht(_t, bt, Rt, Ft),
        Bt !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(Bt).buffer))
    }
    function b() {
        return s.createVertexArray()
    }
    function j(_t) {
        return s.bindVertexArray(_t)
    }
    function $(_t) {
        return s.deleteVertexArray(_t)
    }
    function nt(_t, bt, Rt) {
        const Ft = Rt.wireframe === !0;
        let Bt = o[_t.id];
        Bt === void 0 && (Bt = {},
        o[_t.id] = Bt);
        let Dt = Bt[bt.id];
        Dt === void 0 && (Dt = {},
        Bt[bt.id] = Dt);
        let Mt = Dt[Ft];
        return Mt === void 0 && (Mt = tt(b()),
        Dt[Ft] = Mt),
        Mt
    }
    function tt(_t) {
        const bt = []
          , Rt = []
          , Ft = [];
        for (let Bt = 0; Bt < a; Bt++)
            bt[Bt] = 0,
            Rt[Bt] = 0,
            Ft[Bt] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: bt,
            enabledAttributes: Rt,
            attributeDivisors: Ft,
            object: _t,
            attributes: {},
            index: null
        }
    }
    function rt(_t, bt, Rt, Ft) {
        const Bt = d.attributes
          , Dt = bt.attributes;
        let Mt = 0;
        const Tt = Rt.getAttributes();
        for (const mt in Tt)
            if (Tt[mt].location >= 0) {
                const wt = Bt[mt];
                let Ct = Dt[mt];
                if (Ct === void 0 && (mt === "instanceMatrix" && _t.instanceMatrix && (Ct = _t.instanceMatrix),
                mt === "instanceColor" && _t.instanceColor && (Ct = _t.instanceColor)),
                wt === void 0 || wt.attribute !== Ct || Ct && wt.data !== Ct.data)
                    return !0;
                Mt++
            }
        return d.attributesNum !== Mt || d.index !== Ft
    }
    function st(_t, bt, Rt, Ft) {
        const Bt = {}
          , Dt = bt.attributes;
        let Mt = 0;
        const Tt = Rt.getAttributes();
        for (const mt in Tt)
            if (Tt[mt].location >= 0) {
                let wt = Dt[mt];
                wt === void 0 && (mt === "instanceMatrix" && _t.instanceMatrix && (wt = _t.instanceMatrix),
                mt === "instanceColor" && _t.instanceColor && (wt = _t.instanceColor));
                const Ct = {};
                Ct.attribute = wt,
                wt && wt.data && (Ct.data = wt.data),
                Bt[mt] = Ct,
                Mt++
            }
        d.attributes = Bt,
        d.attributesNum = Mt,
        d.index = Ft
    }
    function lt() {
        const _t = d.newAttributes;
        for (let bt = 0, Rt = _t.length; bt < Rt; bt++)
            _t[bt] = 0
    }
    function ct(_t) {
        it(_t, 0)
    }
    function it(_t, bt) {
        const Rt = d.newAttributes
          , Ft = d.enabledAttributes
          , Bt = d.attributeDivisors;
        Rt[_t] = 1,
        Ft[_t] === 0 && (s.enableVertexAttribArray(_t),
        Ft[_t] = 1),
        Bt[_t] !== bt && (s.vertexAttribDivisor(_t, bt),
        Bt[_t] = bt)
    }
    function ot() {
        const _t = d.newAttributes
          , bt = d.enabledAttributes;
        for (let Rt = 0, Ft = bt.length; Rt < Ft; Rt++)
            bt[Rt] !== _t[Rt] && (s.disableVertexAttribArray(Rt),
            bt[Rt] = 0)
    }
    function at(_t, bt, Rt, Ft, Bt, Dt, Mt) {
        Mt === !0 ? s.vertexAttribIPointer(_t, bt, Rt, Bt, Dt) : s.vertexAttribPointer(_t, bt, Rt, Ft, Bt, Dt)
    }
    function ht(_t, bt, Rt, Ft) {
        lt();
        const Bt = Ft.attributes
          , Dt = Rt.getAttributes()
          , Mt = bt.defaultAttributeValues;
        for (const Tt in Dt) {
            const mt = Dt[Tt];
            if (mt.location >= 0) {
                let St = Bt[Tt];
                if (St === void 0 && (Tt === "instanceMatrix" && _t.instanceMatrix && (St = _t.instanceMatrix),
                Tt === "instanceColor" && _t.instanceColor && (St = _t.instanceColor)),
                St !== void 0) {
                    const wt = St.normalized
                      , Ct = St.itemSize
                      , Ht = e.get(St);
                    if (Ht === void 0)
                        continue;
                    const en = Ht.buffer
                      , Ot = Ht.type
                      , Yt = Ht.bytesPerElement
                      , rn = Ot === s.INT || Ot === s.UNSIGNED_INT || St.gpuType === IntType;
                    if (St.isInterleavedBufferAttribute) {
                        const Xt = St.data
                          , An = Xt.stride
                          , Ln = St.offset;
                        if (Xt.isInstancedInterleavedBuffer) {
                            for (let _n = 0; _n < mt.locationSize; _n++)
                                it(mt.location + _n, Xt.meshPerAttribute);
                            _t.isInstancedMesh !== !0 && Ft._maxInstanceCount === void 0 && (Ft._maxInstanceCount = Xt.meshPerAttribute * Xt.count)
                        } else
                            for (let _n = 0; _n < mt.locationSize; _n++)
                                ct(mt.location + _n);
                        s.bindBuffer(s.ARRAY_BUFFER, en);
                        for (let _n = 0; _n < mt.locationSize; _n++)
                            at(mt.location + _n, Ct / mt.locationSize, Ot, wt, An * Yt, (Ln + Ct / mt.locationSize * _n) * Yt, rn)
                    } else {
                        if (St.isInstancedBufferAttribute) {
                            for (let Xt = 0; Xt < mt.locationSize; Xt++)
                                it(mt.location + Xt, St.meshPerAttribute);
                            _t.isInstancedMesh !== !0 && Ft._maxInstanceCount === void 0 && (Ft._maxInstanceCount = St.meshPerAttribute * St.count)
                        } else
                            for (let Xt = 0; Xt < mt.locationSize; Xt++)
                                ct(mt.location + Xt);
                        s.bindBuffer(s.ARRAY_BUFFER, en);
                        for (let Xt = 0; Xt < mt.locationSize; Xt++)
                            at(mt.location + Xt, Ct / mt.locationSize, Ot, wt, Ct * Yt, Ct / mt.locationSize * Xt * Yt, rn)
                    }
                } else if (Mt !== void 0) {
                    const wt = Mt[Tt];
                    if (wt !== void 0)
                        switch (wt.length) {
                        case 2:
                            s.vertexAttrib2fv(mt.location, wt);
                            break;
                        case 3:
                            s.vertexAttrib3fv(mt.location, wt);
                            break;
                        case 4:
                            s.vertexAttrib4fv(mt.location, wt);
                            break;
                        default:
                            s.vertexAttrib1fv(mt.location, wt)
                        }
                }
            }
        }
        ot()
    }
    function pt() {
        vt();
        for (const _t in o) {
            const bt = o[_t];
            for (const Rt in bt) {
                const Ft = bt[Rt];
                for (const Bt in Ft)
                    $(Ft[Bt].object),
                    delete Ft[Bt];
                delete bt[Rt]
            }
            delete o[_t]
        }
    }
    function dt(_t) {
        if (o[_t.id] === void 0)
            return;
        const bt = o[_t.id];
        for (const Rt in bt) {
            const Ft = bt[Rt];
            for (const Bt in Ft)
                $(Ft[Bt].object),
                delete Ft[Bt];
            delete bt[Rt]
        }
        delete o[_t.id]
    }
    function yt(_t) {
        for (const bt in o) {
            const Rt = o[bt];
            if (Rt[_t.id] === void 0)
                continue;
            const Ft = Rt[_t.id];
            for (const Bt in Ft)
                $(Ft[Bt].object),
                delete Ft[Bt];
            delete Rt[_t.id]
        }
    }
    function vt() {
        xt(),
        g = !0,
        d !== c && (d = c,
        j(d.object))
    }
    function xt() {
        c.geometry = null,
        c.program = null,
        c.wireframe = !1
    }
    return {
        setup: _,
        reset: vt,
        resetDefaultState: xt,
        dispose: pt,
        releaseStatesOfGeometry: dt,
        releaseStatesOfProgram: yt,
        initAttributes: lt,
        enableAttribute: ct,
        disableUnusedAttributes: ot
    }
}
function WebGLBufferRenderer(s, e, a) {
    let o;
    function c(j) {
        o = j
    }
    function d(j, $) {
        s.drawArrays(o, j, $),
        a.update($, o, 1)
    }
    function g(j, $, nt) {
        nt !== 0 && (s.drawArraysInstanced(o, j, $, nt),
        a.update($, o, nt))
    }
    function _(j, $, nt) {
        if (nt === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(o, j, 0, $, 0, nt);
        let rt = 0;
        for (let st = 0; st < nt; st++)
            rt += $[st];
        a.update(rt, o, 1)
    }
    function b(j, $, nt, tt) {
        if (nt === 0)
            return;
        const rt = e.get("WEBGL_multi_draw");
        if (rt === null)
            for (let st = 0; st < j.length; st++)
                g(j[st], $[st], tt[st]);
        else {
            rt.multiDrawArraysInstancedWEBGL(o, j, 0, $, 0, tt, 0, nt);
            let st = 0;
            for (let lt = 0; lt < nt; lt++)
                st += $[lt];
            for (let lt = 0; lt < tt.length; lt++)
                a.update(st, o, tt[lt])
        }
    }
    this.setMode = c,
    this.render = d,
    this.renderInstances = g,
    this.renderMultiDraw = _,
    this.renderMultiDrawInstances = b
}
function WebGLCapabilities(s, e, a, o) {
    let c;
    function d() {
        if (c !== void 0)
            return c;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const dt = e.get("EXT_texture_filter_anisotropic");
            c = s.getParameter(dt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            c = 0;
        return c
    }
    function g(dt) {
        return !(dt !== RGBAFormat && o.convert(dt) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function _(dt) {
        const yt = dt === HalfFloatType && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(dt !== UnsignedByteType && o.convert(dt) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && dt !== FloatType && !yt)
    }
    function b(dt) {
        if (dt === "highp") {
            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
                return "highp";
            dt = "mediump"
        }
        return dt === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let j = a.precision !== void 0 ? a.precision : "highp";
    const $ = b(j);
    $ !== j && (console.warn("THREE.WebGLRenderer:", j, "not supported, using", $, "instead."),
    j = $);
    const nt = a.logarithmicDepthBuffer === !0
      , tt = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS)
      , rt = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , st = s.getParameter(s.MAX_TEXTURE_SIZE)
      , lt = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE)
      , ct = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , it = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS)
      , ot = s.getParameter(s.MAX_VARYING_VECTORS)
      , at = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS)
      , ht = rt > 0
      , pt = s.getParameter(s.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: d,
        getMaxPrecision: b,
        textureFormatReadable: g,
        textureTypeReadable: _,
        precision: j,
        logarithmicDepthBuffer: nt,
        maxTextures: tt,
        maxVertexTextures: rt,
        maxTextureSize: st,
        maxCubemapSize: lt,
        maxAttributes: ct,
        maxVertexUniforms: it,
        maxVaryings: ot,
        maxFragmentUniforms: at,
        vertexTextures: ht,
        maxSamples: pt
    }
}
function WebGLClipping(s) {
    const e = this;
    let a = null
      , o = 0
      , c = !1
      , d = !1;
    const g = new Plane
      , _ = new Matrix3
      , b = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = b,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(nt, tt) {
        const rt = nt.length !== 0 || tt || o !== 0 || c;
        return c = tt,
        o = nt.length,
        rt
    }
    ,
    this.beginShadows = function() {
        d = !0,
        $(null)
    }
    ,
    this.endShadows = function() {
        d = !1
    }
    ,
    this.setGlobalState = function(nt, tt) {
        a = $(nt, tt, 0)
    }
    ,
    this.setState = function(nt, tt, rt) {
        const st = nt.clippingPlanes
          , lt = nt.clipIntersection
          , ct = nt.clipShadows
          , it = s.get(nt);
        if (!c || st === null || st.length === 0 || d && !ct)
            d ? $(null) : j();
        else {
            const ot = d ? 0 : o
              , at = ot * 4;
            let ht = it.clippingState || null;
            b.value = ht,
            ht = $(st, tt, at, rt);
            for (let pt = 0; pt !== at; ++pt)
                ht[pt] = a[pt];
            it.clippingState = ht,
            this.numIntersection = lt ? this.numPlanes : 0,
            this.numPlanes += ot
        }
    }
    ;
    function j() {
        b.value !== a && (b.value = a,
        b.needsUpdate = o > 0),
        e.numPlanes = o,
        e.numIntersection = 0
    }
    function $(nt, tt, rt, st) {
        const lt = nt !== null ? nt.length : 0;
        let ct = null;
        if (lt !== 0) {
            if (ct = b.value,
            st !== !0 || ct === null) {
                const it = rt + lt * 4
                  , ot = tt.matrixWorldInverse;
                _.getNormalMatrix(ot),
                (ct === null || ct.length < it) && (ct = new Float32Array(it));
                for (let at = 0, ht = rt; at !== lt; ++at,
                ht += 4)
                    g.copy(nt[at]).applyMatrix4(ot, _),
                    g.normal.toArray(ct, ht),
                    ct[ht + 3] = g.constant
            }
            b.value = ct,
            b.needsUpdate = !0
        }
        return e.numPlanes = lt,
        e.numIntersection = 0,
        ct
    }
}
function WebGLCubeMaps(s) {
    let e = new WeakMap;
    function a(g, _) {
        return _ === EquirectangularReflectionMapping ? g.mapping = CubeReflectionMapping : _ === EquirectangularRefractionMapping && (g.mapping = CubeRefractionMapping),
        g
    }
    function o(g) {
        if (g && g.isTexture) {
            const _ = g.mapping;
            if (_ === EquirectangularReflectionMapping || _ === EquirectangularRefractionMapping)
                if (e.has(g)) {
                    const b = e.get(g).texture;
                    return a(b, g.mapping)
                } else {
                    const b = g.image;
                    if (b && b.height > 0) {
                        const j = new WebGLCubeRenderTarget(b.height);
                        return j.fromEquirectangularTexture(s, g),
                        e.set(g, j),
                        g.addEventListener("dispose", c),
                        a(j.texture, g.mapping)
                    } else
                        return null
                }
        }
        return g
    }
    function c(g) {
        const _ = g.target;
        _.removeEventListener("dispose", c);
        const b = e.get(_);
        b !== void 0 && (e.delete(_),
        b.dispose())
    }
    function d() {
        e = new WeakMap
    }
    return {
        get: o,
        dispose: d
    }
}
class OrthographicCamera extends Camera {
    constructor(e=-1, a=1, o=1, c=-1, d=.1, g=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = a,
        this.top = o,
        this.bottom = c,
        this.near = d,
        this.far = g,
        this.updateProjectionMatrix()
    }
    copy(e, a) {
        return super.copy(e, a),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, a, o, c, d, g) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = a,
        this.view.offsetX = o,
        this.view.offsetY = c,
        this.view.width = d,
        this.view.height = g,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , a = (this.top - this.bottom) / (2 * this.zoom)
          , o = (this.right + this.left) / 2
          , c = (this.top + this.bottom) / 2;
        let d = o - e
          , g = o + e
          , _ = c + a
          , b = c - a;
        if (this.view !== null && this.view.enabled) {
            const j = (this.right - this.left) / this.view.fullWidth / this.zoom
              , $ = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            d += j * this.view.offsetX,
            g = d + j * this.view.width,
            _ -= $ * this.view.offsetY,
            b = _ - $ * this.view.height
        }
        this.projectionMatrix.makeOrthographic(d, g, _, b, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return a.object.zoom = this.zoom,
        a.object.left = this.left,
        a.object.right = this.right,
        a.object.top = this.top,
        a.object.bottom = this.bottom,
        a.object.near = this.near,
        a.object.far = this.far,
        this.view !== null && (a.object.view = Object.assign({}, this.view)),
        a
    }
}
const LOD_MIN = 4
  , EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582]
  , MAX_SAMPLES = 20
  , _flatCamera = new OrthographicCamera
  , _clearColor = new Color;
let _oldTarget = null
  , _oldActiveCubeFace = 0
  , _oldActiveMipmapLevel = 0
  , _oldXrEnabled = !1;
const PHI = (1 + Math.sqrt(5)) / 2
  , INV_PHI = 1 / PHI
  , _axisDirections = [new Vector3(-PHI,INV_PHI,0), new Vector3(PHI,INV_PHI,0), new Vector3(-INV_PHI,0,PHI), new Vector3(INV_PHI,0,PHI), new Vector3(0,PHI,-INV_PHI), new Vector3(0,PHI,INV_PHI), new Vector3(-1,1,-1), new Vector3(1,1,-1), new Vector3(-1,1,1), new Vector3(1,1,1)];
class PMREMGenerator {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, a=0, o=.1, c=100) {
        _oldTarget = this._renderer.getRenderTarget(),
        _oldActiveCubeFace = this._renderer.getActiveCubeFace(),
        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(),
        _oldXrEnabled = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(256);
        const d = this._allocateTargets();
        return d.depthBuffer = !0,
        this._sceneToCubeUV(e, o, c, d),
        a > 0 && this._blur(d, 0, 0, a),
        this._applyPMREM(d),
        this._cleanup(d),
        d
    }
    fromEquirectangular(e, a=null) {
        return this._fromTexture(e, a)
    }
    fromCubemap(e, a=null) {
        return this._fromTexture(e, a)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel),
        this._renderer.xr.enabled = _oldXrEnabled,
        e.scissorTest = !1,
        _setViewport(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, a) {
        e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        _oldTarget = this._renderer.getRenderTarget(),
        _oldActiveCubeFace = this._renderer.getActiveCubeFace(),
        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(),
        _oldXrEnabled = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const o = a || this._allocateTargets();
        return this._textureToCubeUV(e, o),
        this._applyPMREM(o),
        this._cleanup(o),
        o
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , a = 4 * this._cubeSize
          , o = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: !1,
            type: HalfFloatType,
            format: RGBAFormat,
            colorSpace: LinearSRGBColorSpace,
            depthBuffer: !1
        }
          , c = _createRenderTarget(e, a, o);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== a) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = _createRenderTarget(e, a, o);
            const {_lodMax: d} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = _createPlanes(d)),
            this._blurMaterial = _getBlurShader(d, e, a)
        }
        return c
    }
    _compileMaterial(e) {
        const a = new Mesh(this._lodPlanes[0],e);
        this._renderer.compile(a, _flatCamera)
    }
    _sceneToCubeUV(e, a, o, c) {
        const _ = new PerspectiveCamera(90,1,a,o)
          , b = [1, -1, 1, 1, 1, 1]
          , j = [1, 1, 1, -1, -1, -1]
          , $ = this._renderer
          , nt = $.autoClear
          , tt = $.toneMapping;
        $.getClearColor(_clearColor),
        $.toneMapping = NoToneMapping,
        $.autoClear = !1;
        const rt = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: !1,
            depthTest: !1
        })
          , st = new Mesh(new BoxGeometry,rt);
        let lt = !1;
        const ct = e.background;
        ct ? ct.isColor && (rt.color.copy(ct),
        e.background = null,
        lt = !0) : (rt.color.copy(_clearColor),
        lt = !0);
        for (let it = 0; it < 6; it++) {
            const ot = it % 3;
            ot === 0 ? (_.up.set(0, b[it], 0),
            _.lookAt(j[it], 0, 0)) : ot === 1 ? (_.up.set(0, 0, b[it]),
            _.lookAt(0, j[it], 0)) : (_.up.set(0, b[it], 0),
            _.lookAt(0, 0, j[it]));
            const at = this._cubeSize;
            _setViewport(c, ot * at, it > 2 ? at : 0, at, at),
            $.setRenderTarget(c),
            lt && $.render(st, _),
            $.render(e, _)
        }
        st.geometry.dispose(),
        st.material.dispose(),
        $.toneMapping = tt,
        $.autoClear = nt,
        e.background = ct
    }
    _textureToCubeUV(e, a) {
        const o = this._renderer
          , c = e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping;
        c ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial());
        const d = c ? this._cubemapMaterial : this._equirectMaterial
          , g = new Mesh(this._lodPlanes[0],d)
          , _ = d.uniforms;
        _.envMap.value = e;
        const b = this._cubeSize;
        _setViewport(a, 0, 0, 3 * b, 2 * b),
        o.setRenderTarget(a),
        o.render(g, _flatCamera)
    }
    _applyPMREM(e) {
        const a = this._renderer
          , o = a.autoClear;
        a.autoClear = !1;
        const c = this._lodPlanes.length;
        for (let d = 1; d < c; d++) {
            const g = Math.sqrt(this._sigmas[d] * this._sigmas[d] - this._sigmas[d - 1] * this._sigmas[d - 1])
              , _ = _axisDirections[(c - d - 1) % _axisDirections.length];
            this._blur(e, d - 1, d, g, _)
        }
        a.autoClear = o
    }
    _blur(e, a, o, c, d) {
        const g = this._pingPongRenderTarget;
        this._halfBlur(e, g, a, o, c, "latitudinal", d),
        this._halfBlur(g, e, o, o, c, "longitudinal", d)
    }
    _halfBlur(e, a, o, c, d, g, _) {
        const b = this._renderer
          , j = this._blurMaterial;
        g !== "latitudinal" && g !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const $ = 3
          , nt = new Mesh(this._lodPlanes[c],j)
          , tt = j.uniforms
          , rt = this._sizeLods[o] - 1
          , st = isFinite(d) ? Math.PI / (2 * rt) : 2 * Math.PI / (2 * MAX_SAMPLES - 1)
          , lt = d / st
          , ct = isFinite(d) ? 1 + Math.floor($ * lt) : MAX_SAMPLES;
        ct > MAX_SAMPLES && console.warn(`sigmaRadians, ${d}, is too large and will clip, as it requested ${ct} samples when the maximum is set to ${MAX_SAMPLES}`);
        const it = [];
        let ot = 0;
        for (let yt = 0; yt < MAX_SAMPLES; ++yt) {
            const vt = yt / lt
              , xt = Math.exp(-vt * vt / 2);
            it.push(xt),
            yt === 0 ? ot += xt : yt < ct && (ot += 2 * xt)
        }
        for (let yt = 0; yt < it.length; yt++)
            it[yt] = it[yt] / ot;
        tt.envMap.value = e.texture,
        tt.samples.value = ct,
        tt.weights.value = it,
        tt.latitudinal.value = g === "latitudinal",
        _ && (tt.poleAxis.value = _);
        const {_lodMax: at} = this;
        tt.dTheta.value = st,
        tt.mipInt.value = at - o;
        const ht = this._sizeLods[c]
          , pt = 3 * ht * (c > at - LOD_MIN ? c - at + LOD_MIN : 0)
          , dt = 4 * (this._cubeSize - ht);
        _setViewport(a, pt, dt, 3 * ht, 2 * ht),
        b.setRenderTarget(a),
        b.render(nt, _flatCamera)
    }
}
function _createPlanes(s) {
    const e = []
      , a = []
      , o = [];
    let c = s;
    const d = s - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let g = 0; g < d; g++) {
        const _ = Math.pow(2, c);
        a.push(_);
        let b = 1 / _;
        g > s - LOD_MIN ? b = EXTRA_LOD_SIGMA[g - s + LOD_MIN - 1] : g === 0 && (b = 0),
        o.push(b);
        const j = 1 / (_ - 2)
          , $ = -j
          , nt = 1 + j
          , tt = [$, $, nt, $, nt, nt, $, $, nt, nt, $, nt]
          , rt = 6
          , st = 6
          , lt = 3
          , ct = 2
          , it = 1
          , ot = new Float32Array(lt * st * rt)
          , at = new Float32Array(ct * st * rt)
          , ht = new Float32Array(it * st * rt);
        for (let dt = 0; dt < rt; dt++) {
            const yt = dt % 3 * 2 / 3 - 1
              , vt = dt > 2 ? 0 : -1
              , xt = [yt, vt, 0, yt + 2 / 3, vt, 0, yt + 2 / 3, vt + 1, 0, yt, vt, 0, yt + 2 / 3, vt + 1, 0, yt, vt + 1, 0];
            ot.set(xt, lt * st * dt),
            at.set(tt, ct * st * dt);
            const _t = [dt, dt, dt, dt, dt, dt];
            ht.set(_t, it * st * dt)
        }
        const pt = new BufferGeometry;
        pt.setAttribute("position", new BufferAttribute(ot,lt)),
        pt.setAttribute("uv", new BufferAttribute(at,ct)),
        pt.setAttribute("faceIndex", new BufferAttribute(ht,it)),
        e.push(pt),
        c > LOD_MIN && c--
    }
    return {
        lodPlanes: e,
        sizeLods: a,
        sigmas: o
    }
}
function _createRenderTarget(s, e, a) {
    const o = new WebGLRenderTarget(s,e,a);
    return o.texture.mapping = CubeUVReflectionMapping,
    o.texture.name = "PMREM.cubeUv",
    o.scissorTest = !0,
    o
}
function _setViewport(s, e, a, o, c) {
    s.viewport.set(e, a, o, c),
    s.scissor.set(e, a, o, c)
}
function _getBlurShader(s, e, a) {
    const o = new Float32Array(MAX_SAMPLES)
      , c = new Vector3(0,1,0);
    return new ShaderMaterial({
        name: "SphericalGaussianBlur",
        defines: {
            n: MAX_SAMPLES,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / a,
            CUBEUV_MAX_MIP: `${s}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: o
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: c
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getEquirectMaterial() {
    return new ShaderMaterial({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCubemapMaterial() {
    return new ShaderMaterial({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function WebGLCubeUVMaps(s) {
    let e = new WeakMap
      , a = null;
    function o(_) {
        if (_ && _.isTexture) {
            const b = _.mapping
              , j = b === EquirectangularReflectionMapping || b === EquirectangularRefractionMapping
              , $ = b === CubeReflectionMapping || b === CubeRefractionMapping;
            if (j || $) {
                let nt = e.get(_);
                const tt = nt !== void 0 ? nt.texture.pmremVersion : 0;
                if (_.isRenderTargetTexture && _.pmremVersion !== tt)
                    return a === null && (a = new PMREMGenerator(s)),
                    nt = j ? a.fromEquirectangular(_, nt) : a.fromCubemap(_, nt),
                    nt.texture.pmremVersion = _.pmremVersion,
                    e.set(_, nt),
                    nt.texture;
                if (nt !== void 0)
                    return nt.texture;
                {
                    const rt = _.image;
                    return j && rt && rt.height > 0 || $ && rt && c(rt) ? (a === null && (a = new PMREMGenerator(s)),
                    nt = j ? a.fromEquirectangular(_) : a.fromCubemap(_),
                    nt.texture.pmremVersion = _.pmremVersion,
                    e.set(_, nt),
                    _.addEventListener("dispose", d),
                    nt.texture) : null
                }
            }
        }
        return _
    }
    function c(_) {
        let b = 0;
        const j = 6;
        for (let $ = 0; $ < j; $++)
            _[$] !== void 0 && b++;
        return b === j
    }
    function d(_) {
        const b = _.target;
        b.removeEventListener("dispose", d);
        const j = e.get(b);
        j !== void 0 && (e.delete(b),
        j.dispose())
    }
    function g() {
        e = new WeakMap,
        a !== null && (a.dispose(),
        a = null)
    }
    return {
        get: o,
        dispose: g
    }
}
function WebGLExtensions(s) {
    const e = {};
    function a(o) {
        if (e[o] !== void 0)
            return e[o];
        let c;
        switch (o) {
        case "WEBGL_depth_texture":
            c = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            c = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            c = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            c = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            c = s.getExtension(o)
        }
        return e[o] = c,
        c
    }
    return {
        has: function(o) {
            return a(o) !== null
        },
        init: function() {
            a("EXT_color_buffer_float"),
            a("WEBGL_clip_cull_distance"),
            a("OES_texture_float_linear"),
            a("EXT_color_buffer_half_float"),
            a("WEBGL_multisampled_render_to_texture"),
            a("WEBGL_render_shared_exponent")
        },
        get: function(o) {
            const c = a(o);
            return c === null && warnOnce("THREE.WebGLRenderer: " + o + " extension not supported."),
            c
        }
    }
}
function WebGLGeometries(s, e, a, o) {
    const c = {}
      , d = new WeakMap;
    function g(nt) {
        const tt = nt.target;
        tt.index !== null && e.remove(tt.index);
        for (const st in tt.attributes)
            e.remove(tt.attributes[st]);
        for (const st in tt.morphAttributes) {
            const lt = tt.morphAttributes[st];
            for (let ct = 0, it = lt.length; ct < it; ct++)
                e.remove(lt[ct])
        }
        tt.removeEventListener("dispose", g),
        delete c[tt.id];
        const rt = d.get(tt);
        rt && (e.remove(rt),
        d.delete(tt)),
        o.releaseStatesOfGeometry(tt),
        tt.isInstancedBufferGeometry === !0 && delete tt._maxInstanceCount,
        a.memory.geometries--
    }
    function _(nt, tt) {
        return c[tt.id] === !0 || (tt.addEventListener("dispose", g),
        c[tt.id] = !0,
        a.memory.geometries++),
        tt
    }
    function b(nt) {
        const tt = nt.attributes;
        for (const st in tt)
            e.update(tt[st], s.ARRAY_BUFFER);
        const rt = nt.morphAttributes;
        for (const st in rt) {
            const lt = rt[st];
            for (let ct = 0, it = lt.length; ct < it; ct++)
                e.update(lt[ct], s.ARRAY_BUFFER)
        }
    }
    function j(nt) {
        const tt = []
          , rt = nt.index
          , st = nt.attributes.position;
        let lt = 0;
        if (rt !== null) {
            const ot = rt.array;
            lt = rt.version;
            for (let at = 0, ht = ot.length; at < ht; at += 3) {
                const pt = ot[at + 0]
                  , dt = ot[at + 1]
                  , yt = ot[at + 2];
                tt.push(pt, dt, dt, yt, yt, pt)
            }
        } else if (st !== void 0) {
            const ot = st.array;
            lt = st.version;
            for (let at = 0, ht = ot.length / 3 - 1; at < ht; at += 3) {
                const pt = at + 0
                  , dt = at + 1
                  , yt = at + 2;
                tt.push(pt, dt, dt, yt, yt, pt)
            }
        } else
            return;
        const ct = new (arrayNeedsUint32(tt) ? Uint32BufferAttribute : Uint16BufferAttribute)(tt,1);
        ct.version = lt;
        const it = d.get(nt);
        it && e.remove(it),
        d.set(nt, ct)
    }
    function $(nt) {
        const tt = d.get(nt);
        if (tt) {
            const rt = nt.index;
            rt !== null && tt.version < rt.version && j(nt)
        } else
            j(nt);
        return d.get(nt)
    }
    return {
        get: _,
        update: b,
        getWireframeAttribute: $
    }
}
function WebGLIndexedBufferRenderer(s, e, a) {
    let o;
    function c(tt) {
        o = tt
    }
    let d, g;
    function _(tt) {
        d = tt.type,
        g = tt.bytesPerElement
    }
    function b(tt, rt) {
        s.drawElements(o, rt, d, tt * g),
        a.update(rt, o, 1)
    }
    function j(tt, rt, st) {
        st !== 0 && (s.drawElementsInstanced(o, rt, d, tt * g, st),
        a.update(rt, o, st))
    }
    function $(tt, rt, st) {
        if (st === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(o, rt, 0, d, tt, 0, st);
        let ct = 0;
        for (let it = 0; it < st; it++)
            ct += rt[it];
        a.update(ct, o, 1)
    }
    function nt(tt, rt, st, lt) {
        if (st === 0)
            return;
        const ct = e.get("WEBGL_multi_draw");
        if (ct === null)
            for (let it = 0; it < tt.length; it++)
                j(tt[it] / g, rt[it], lt[it]);
        else {
            ct.multiDrawElementsInstancedWEBGL(o, rt, 0, d, tt, 0, lt, 0, st);
            let it = 0;
            for (let ot = 0; ot < st; ot++)
                it += rt[ot];
            for (let ot = 0; ot < lt.length; ot++)
                a.update(it, o, lt[ot])
        }
    }
    this.setMode = c,
    this.setIndex = _,
    this.render = b,
    this.renderInstances = j,
    this.renderMultiDraw = $,
    this.renderMultiDrawInstances = nt
}
function WebGLInfo(s) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , a = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function o(d, g, _) {
        switch (a.calls++,
        g) {
        case s.TRIANGLES:
            a.triangles += _ * (d / 3);
            break;
        case s.LINES:
            a.lines += _ * (d / 2);
            break;
        case s.LINE_STRIP:
            a.lines += _ * (d - 1);
            break;
        case s.LINE_LOOP:
            a.lines += _ * d;
            break;
        case s.POINTS:
            a.points += _ * d;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", g);
            break
        }
    }
    function c() {
        a.calls = 0,
        a.triangles = 0,
        a.points = 0,
        a.lines = 0
    }
    return {
        memory: e,
        render: a,
        programs: null,
        autoReset: !0,
        reset: c,
        update: o
    }
}
function WebGLMorphtargets(s, e, a) {
    const o = new WeakMap
      , c = new Vector4;
    function d(g, _, b) {
        const j = g.morphTargetInfluences
          , $ = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color
          , nt = $ !== void 0 ? $.length : 0;
        let tt = o.get(_);
        if (tt === void 0 || tt.count !== nt) {
            let _t = function() {
                vt.dispose(),
                o.delete(_),
                _.removeEventListener("dispose", _t)
            };
            var rt = _t;
            tt !== void 0 && tt.texture.dispose();
            const st = _.morphAttributes.position !== void 0
              , lt = _.morphAttributes.normal !== void 0
              , ct = _.morphAttributes.color !== void 0
              , it = _.morphAttributes.position || []
              , ot = _.morphAttributes.normal || []
              , at = _.morphAttributes.color || [];
            let ht = 0;
            st === !0 && (ht = 1),
            lt === !0 && (ht = 2),
            ct === !0 && (ht = 3);
            let pt = _.attributes.position.count * ht
              , dt = 1;
            pt > e.maxTextureSize && (dt = Math.ceil(pt / e.maxTextureSize),
            pt = e.maxTextureSize);
            const yt = new Float32Array(pt * dt * 4 * nt)
              , vt = new DataArrayTexture(yt,pt,dt,nt);
            vt.type = FloatType,
            vt.needsUpdate = !0;
            const xt = ht * 4;
            for (let bt = 0; bt < nt; bt++) {
                const Rt = it[bt]
                  , Ft = ot[bt]
                  , Bt = at[bt]
                  , Dt = pt * dt * 4 * bt;
                for (let Mt = 0; Mt < Rt.count; Mt++) {
                    const Tt = Mt * xt;
                    st === !0 && (c.fromBufferAttribute(Rt, Mt),
                    yt[Dt + Tt + 0] = c.x,
                    yt[Dt + Tt + 1] = c.y,
                    yt[Dt + Tt + 2] = c.z,
                    yt[Dt + Tt + 3] = 0),
                    lt === !0 && (c.fromBufferAttribute(Ft, Mt),
                    yt[Dt + Tt + 4] = c.x,
                    yt[Dt + Tt + 5] = c.y,
                    yt[Dt + Tt + 6] = c.z,
                    yt[Dt + Tt + 7] = 0),
                    ct === !0 && (c.fromBufferAttribute(Bt, Mt),
                    yt[Dt + Tt + 8] = c.x,
                    yt[Dt + Tt + 9] = c.y,
                    yt[Dt + Tt + 10] = c.z,
                    yt[Dt + Tt + 11] = Bt.itemSize === 4 ? c.w : 1)
                }
            }
            tt = {
                count: nt,
                texture: vt,
                size: new Vector2(pt,dt)
            },
            o.set(_, tt),
            _.addEventListener("dispose", _t)
        }
        if (g.isInstancedMesh === !0 && g.morphTexture !== null)
            b.getUniforms().setValue(s, "morphTexture", g.morphTexture, a);
        else {
            let st = 0;
            for (let ct = 0; ct < j.length; ct++)
                st += j[ct];
            const lt = _.morphTargetsRelative ? 1 : 1 - st;
            b.getUniforms().setValue(s, "morphTargetBaseInfluence", lt),
            b.getUniforms().setValue(s, "morphTargetInfluences", j)
        }
        b.getUniforms().setValue(s, "morphTargetsTexture", tt.texture, a),
        b.getUniforms().setValue(s, "morphTargetsTextureSize", tt.size)
    }
    return {
        update: d
    }
}
function WebGLObjects(s, e, a, o) {
    let c = new WeakMap;
    function d(b) {
        const j = o.render.frame
          , $ = b.geometry
          , nt = e.get(b, $);
        if (c.get(nt) !== j && (e.update(nt),
        c.set(nt, j)),
        b.isInstancedMesh && (b.hasEventListener("dispose", _) === !1 && b.addEventListener("dispose", _),
        c.get(b) !== j && (a.update(b.instanceMatrix, s.ARRAY_BUFFER),
        b.instanceColor !== null && a.update(b.instanceColor, s.ARRAY_BUFFER),
        c.set(b, j))),
        b.isSkinnedMesh) {
            const tt = b.skeleton;
            c.get(tt) !== j && (tt.update(),
            c.set(tt, j))
        }
        return nt
    }
    function g() {
        c = new WeakMap
    }
    function _(b) {
        const j = b.target;
        j.removeEventListener("dispose", _),
        a.remove(j.instanceMatrix),
        j.instanceColor !== null && a.remove(j.instanceColor)
    }
    return {
        update: d,
        dispose: g
    }
}
class DepthTexture extends Texture {
    constructor(e, a, o, c, d, g, _, b, j, $=DepthFormat) {
        if ($ !== DepthFormat && $ !== DepthStencilFormat)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        o === void 0 && $ === DepthFormat && (o = UnsignedIntType),
        o === void 0 && $ === DepthStencilFormat && (o = UnsignedInt248Type),
        super(null, c, d, g, _, b, $, o, j),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: a
        },
        this.magFilter = _ !== void 0 ? _ : NearestFilter,
        this.minFilter = b !== void 0 ? b : NearestFilter,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return this.compareFunction !== null && (a.compareFunction = this.compareFunction),
        a
    }
}
const emptyTexture = new Texture
  , emptyShadowTexture = new DepthTexture(1,1)
  , emptyArrayTexture = new DataArrayTexture
  , empty3dTexture = new Data3DTexture
  , emptyCubeTexture = new CubeTexture
  , arrayCacheF32 = []
  , arrayCacheI32 = []
  , mat4array = new Float32Array(16)
  , mat3array = new Float32Array(9)
  , mat2array = new Float32Array(4);
function flatten(s, e, a) {
    const o = s[0];
    if (o <= 0 || o > 0)
        return s;
    const c = e * a;
    let d = arrayCacheF32[c];
    if (d === void 0 && (d = new Float32Array(c),
    arrayCacheF32[c] = d),
    e !== 0) {
        o.toArray(d, 0);
        for (let g = 1, _ = 0; g !== e; ++g)
            _ += a,
            s[g].toArray(d, _)
    }
    return d
}
function arraysEqual(s, e) {
    if (s.length !== e.length)
        return !1;
    for (let a = 0, o = s.length; a < o; a++)
        if (s[a] !== e[a])
            return !1;
    return !0
}
function copyArray(s, e) {
    for (let a = 0, o = e.length; a < o; a++)
        s[a] = e[a]
}
function allocTexUnits(s, e) {
    let a = arrayCacheI32[e];
    a === void 0 && (a = new Int32Array(e),
    arrayCacheI32[e] = a);
    for (let o = 0; o !== e; ++o)
        a[o] = s.allocateTextureUnit();
    return a
}
function setValueV1f(s, e) {
    const a = this.cache;
    a[0] !== e && (s.uniform1f(this.addr, e),
    a[0] = e)
}
function setValueV2f(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y),
        a[0] = e.x,
        a[1] = e.y);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform2fv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueV3f(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z),
        a[0] = e.x,
        a[1] = e.y,
        a[2] = e.z);
    else if (e.r !== void 0)
        (a[0] !== e.r || a[1] !== e.g || a[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b),
        a[0] = e.r,
        a[1] = e.g,
        a[2] = e.b);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform3fv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueV4f(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z || a[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        a[0] = e.x,
        a[1] = e.y,
        a[2] = e.z,
        a[3] = e.w);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform4fv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueM2(s, e) {
    const a = this.cache
      , o = e.elements;
    if (o === void 0) {
        if (arraysEqual(a, e))
            return;
        s.uniformMatrix2fv(this.addr, !1, e),
        copyArray(a, e)
    } else {
        if (arraysEqual(a, o))
            return;
        mat2array.set(o),
        s.uniformMatrix2fv(this.addr, !1, mat2array),
        copyArray(a, o)
    }
}
function setValueM3(s, e) {
    const a = this.cache
      , o = e.elements;
    if (o === void 0) {
        if (arraysEqual(a, e))
            return;
        s.uniformMatrix3fv(this.addr, !1, e),
        copyArray(a, e)
    } else {
        if (arraysEqual(a, o))
            return;
        mat3array.set(o),
        s.uniformMatrix3fv(this.addr, !1, mat3array),
        copyArray(a, o)
    }
}
function setValueM4(s, e) {
    const a = this.cache
      , o = e.elements;
    if (o === void 0) {
        if (arraysEqual(a, e))
            return;
        s.uniformMatrix4fv(this.addr, !1, e),
        copyArray(a, e)
    } else {
        if (arraysEqual(a, o))
            return;
        mat4array.set(o),
        s.uniformMatrix4fv(this.addr, !1, mat4array),
        copyArray(a, o)
    }
}
function setValueV1i(s, e) {
    const a = this.cache;
    a[0] !== e && (s.uniform1i(this.addr, e),
    a[0] = e)
}
function setValueV2i(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y),
        a[0] = e.x,
        a[1] = e.y);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform2iv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueV3i(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z),
        a[0] = e.x,
        a[1] = e.y,
        a[2] = e.z);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform3iv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueV4i(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z || a[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        a[0] = e.x,
        a[1] = e.y,
        a[2] = e.z,
        a[3] = e.w);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform4iv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueV1ui(s, e) {
    const a = this.cache;
    a[0] !== e && (s.uniform1ui(this.addr, e),
    a[0] = e)
}
function setValueV2ui(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y),
        a[0] = e.x,
        a[1] = e.y);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform2uiv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueV3ui(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z),
        a[0] = e.x,
        a[1] = e.y,
        a[2] = e.z);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform3uiv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueV4ui(s, e) {
    const a = this.cache;
    if (e.x !== void 0)
        (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z || a[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        a[0] = e.x,
        a[1] = e.y,
        a[2] = e.z,
        a[3] = e.w);
    else {
        if (arraysEqual(a, e))
            return;
        s.uniform4uiv(this.addr, e),
        copyArray(a, e)
    }
}
function setValueT1(s, e, a) {
    const o = this.cache
      , c = a.allocateTextureUnit();
    o[0] !== c && (s.uniform1i(this.addr, c),
    o[0] = c);
    let d;
    this.type === s.SAMPLER_2D_SHADOW ? (emptyShadowTexture.compareFunction = LessEqualCompare,
    d = emptyShadowTexture) : d = emptyTexture,
    a.setTexture2D(e || d, c)
}
function setValueT3D1(s, e, a) {
    const o = this.cache
      , c = a.allocateTextureUnit();
    o[0] !== c && (s.uniform1i(this.addr, c),
    o[0] = c),
    a.setTexture3D(e || empty3dTexture, c)
}
function setValueT6(s, e, a) {
    const o = this.cache
      , c = a.allocateTextureUnit();
    o[0] !== c && (s.uniform1i(this.addr, c),
    o[0] = c),
    a.setTextureCube(e || emptyCubeTexture, c)
}
function setValueT2DArray1(s, e, a) {
    const o = this.cache
      , c = a.allocateTextureUnit();
    o[0] !== c && (s.uniform1i(this.addr, c),
    o[0] = c),
    a.setTexture2DArray(e || emptyArrayTexture, c)
}
function getSingularSetter(s) {
    switch (s) {
    case 5126:
        return setValueV1f;
    case 35664:
        return setValueV2f;
    case 35665:
        return setValueV3f;
    case 35666:
        return setValueV4f;
    case 35674:
        return setValueM2;
    case 35675:
        return setValueM3;
    case 35676:
        return setValueM4;
    case 5124:
    case 35670:
        return setValueV1i;
    case 35667:
    case 35671:
        return setValueV2i;
    case 35668:
    case 35672:
        return setValueV3i;
    case 35669:
    case 35673:
        return setValueV4i;
    case 5125:
        return setValueV1ui;
    case 36294:
        return setValueV2ui;
    case 36295:
        return setValueV3ui;
    case 36296:
        return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArray1
    }
}
function setValueV1fArray(s, e) {
    s.uniform1fv(this.addr, e)
}
function setValueV2fArray(s, e) {
    const a = flatten(e, this.size, 2);
    s.uniform2fv(this.addr, a)
}
function setValueV3fArray(s, e) {
    const a = flatten(e, this.size, 3);
    s.uniform3fv(this.addr, a)
}
function setValueV4fArray(s, e) {
    const a = flatten(e, this.size, 4);
    s.uniform4fv(this.addr, a)
}
function setValueM2Array(s, e) {
    const a = flatten(e, this.size, 4);
    s.uniformMatrix2fv(this.addr, !1, a)
}
function setValueM3Array(s, e) {
    const a = flatten(e, this.size, 9);
    s.uniformMatrix3fv(this.addr, !1, a)
}
function setValueM4Array(s, e) {
    const a = flatten(e, this.size, 16);
    s.uniformMatrix4fv(this.addr, !1, a)
}
function setValueV1iArray(s, e) {
    s.uniform1iv(this.addr, e)
}
function setValueV2iArray(s, e) {
    s.uniform2iv(this.addr, e)
}
function setValueV3iArray(s, e) {
    s.uniform3iv(this.addr, e)
}
function setValueV4iArray(s, e) {
    s.uniform4iv(this.addr, e)
}
function setValueV1uiArray(s, e) {
    s.uniform1uiv(this.addr, e)
}
function setValueV2uiArray(s, e) {
    s.uniform2uiv(this.addr, e)
}
function setValueV3uiArray(s, e) {
    s.uniform3uiv(this.addr, e)
}
function setValueV4uiArray(s, e) {
    s.uniform4uiv(this.addr, e)
}
function setValueT1Array(s, e, a) {
    const o = this.cache
      , c = e.length
      , d = allocTexUnits(a, c);
    arraysEqual(o, d) || (s.uniform1iv(this.addr, d),
    copyArray(o, d));
    for (let g = 0; g !== c; ++g)
        a.setTexture2D(e[g] || emptyTexture, d[g])
}
function setValueT3DArray(s, e, a) {
    const o = this.cache
      , c = e.length
      , d = allocTexUnits(a, c);
    arraysEqual(o, d) || (s.uniform1iv(this.addr, d),
    copyArray(o, d));
    for (let g = 0; g !== c; ++g)
        a.setTexture3D(e[g] || empty3dTexture, d[g])
}
function setValueT6Array(s, e, a) {
    const o = this.cache
      , c = e.length
      , d = allocTexUnits(a, c);
    arraysEqual(o, d) || (s.uniform1iv(this.addr, d),
    copyArray(o, d));
    for (let g = 0; g !== c; ++g)
        a.setTextureCube(e[g] || emptyCubeTexture, d[g])
}
function setValueT2DArrayArray(s, e, a) {
    const o = this.cache
      , c = e.length
      , d = allocTexUnits(a, c);
    arraysEqual(o, d) || (s.uniform1iv(this.addr, d),
    copyArray(o, d));
    for (let g = 0; g !== c; ++g)
        a.setTexture2DArray(e[g] || emptyArrayTexture, d[g])
}
function getPureArraySetter(s) {
    switch (s) {
    case 5126:
        return setValueV1fArray;
    case 35664:
        return setValueV2fArray;
    case 35665:
        return setValueV3fArray;
    case 35666:
        return setValueV4fArray;
    case 35674:
        return setValueM2Array;
    case 35675:
        return setValueM3Array;
    case 35676:
        return setValueM4Array;
    case 5124:
    case 35670:
        return setValueV1iArray;
    case 35667:
    case 35671:
        return setValueV2iArray;
    case 35668:
    case 35672:
        return setValueV3iArray;
    case 35669:
    case 35673:
        return setValueV4iArray;
    case 5125:
        return setValueV1uiArray;
    case 36294:
        return setValueV2uiArray;
    case 36295:
        return setValueV3uiArray;
    case 36296:
        return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArrayArray
    }
}
class SingleUniform {
    constructor(e, a, o) {
        this.id = e,
        this.addr = o,
        this.cache = [],
        this.type = a.type,
        this.setValue = getSingularSetter(a.type)
    }
}
class PureArrayUniform {
    constructor(e, a, o) {
        this.id = e,
        this.addr = o,
        this.cache = [],
        this.type = a.type,
        this.size = a.size,
        this.setValue = getPureArraySetter(a.type)
    }
}
class StructuredUniform {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, a, o) {
        const c = this.seq;
        for (let d = 0, g = c.length; d !== g; ++d) {
            const _ = c[d];
            _.setValue(e, a[_.id], o)
        }
    }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(s, e) {
    s.seq.push(e),
    s.map[e.id] = e
}
function parseUniform(s, e, a) {
    const o = s.name
      , c = o.length;
    for (RePathPart.lastIndex = 0; ; ) {
        const d = RePathPart.exec(o)
          , g = RePathPart.lastIndex;
        let _ = d[1];
        const b = d[2] === "]"
          , j = d[3];
        if (b && (_ = _ | 0),
        j === void 0 || j === "[" && g + 2 === c) {
            addUniform(a, j === void 0 ? new SingleUniform(_,s,e) : new PureArrayUniform(_,s,e));
            break
        } else {
            let nt = a.map[_];
            nt === void 0 && (nt = new StructuredUniform(_),
            addUniform(a, nt)),
            a = nt
        }
    }
}
class WebGLUniforms {
    constructor(e, a) {
        this.seq = [],
        this.map = {};
        const o = e.getProgramParameter(a, e.ACTIVE_UNIFORMS);
        for (let c = 0; c < o; ++c) {
            const d = e.getActiveUniform(a, c)
              , g = e.getUniformLocation(a, d.name);
            parseUniform(d, g, this)
        }
    }
    setValue(e, a, o, c) {
        const d = this.map[a];
        d !== void 0 && d.setValue(e, o, c)
    }
    setOptional(e, a, o) {
        const c = a[o];
        c !== void 0 && this.setValue(e, o, c)
    }
    static upload(e, a, o, c) {
        for (let d = 0, g = a.length; d !== g; ++d) {
            const _ = a[d]
              , b = o[_.id];
            b.needsUpdate !== !1 && _.setValue(e, b.value, c)
        }
    }
    static seqWithValue(e, a) {
        const o = [];
        for (let c = 0, d = e.length; c !== d; ++c) {
            const g = e[c];
            g.id in a && o.push(g)
        }
        return o
    }
}
function WebGLShader(s, e, a) {
    const o = s.createShader(e);
    return s.shaderSource(o, a),
    s.compileShader(o),
    o
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(s, e) {
    const a = s.split(`
`)
      , o = []
      , c = Math.max(e - 6, 0)
      , d = Math.min(e + 6, a.length);
    for (let g = c; g < d; g++) {
        const _ = g + 1;
        o.push(`${_ === e ? ">" : " "} ${_}: ${a[g]}`)
    }
    return o.join(`
`)
}
function getEncodingComponents(s) {
    const e = ColorManagement.getPrimaries(ColorManagement.workingColorSpace)
      , a = ColorManagement.getPrimaries(s);
    let o;
    switch (e === a ? o = "" : e === P3Primaries && a === Rec709Primaries ? o = "LinearDisplayP3ToLinearSRGB" : e === Rec709Primaries && a === P3Primaries && (o = "LinearSRGBToLinearDisplayP3"),
    s) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
        return [o, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
        return [o, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", s),
        [o, "LinearTransferOETF"]
    }
}
function getShaderErrors(s, e, a) {
    const o = s.getShaderParameter(e, s.COMPILE_STATUS)
      , c = s.getShaderInfoLog(e).trim();
    if (o && c === "")
        return "";
    const d = /ERROR: 0:(\d+)/.exec(c);
    if (d) {
        const g = parseInt(d[1]);
        return a.toUpperCase() + `

` + c + `

` + handleSource(s.getShaderSource(e), g)
    } else
        return c
}
function getTexelEncodingFunction(s, e) {
    const a = getEncodingComponents(e);
    return `vec4 ${s}( vec4 value ) { return ${a[0]}( ${a[1]}( value ) ); }`
}
function getToneMappingFunction(s, e) {
    let a;
    switch (e) {
    case LinearToneMapping:
        a = "Linear";
        break;
    case ReinhardToneMapping:
        a = "Reinhard";
        break;
    case CineonToneMapping:
        a = "OptimizedCineon";
        break;
    case ACESFilmicToneMapping:
        a = "ACESFilmic";
        break;
    case AgXToneMapping:
        a = "AgX";
        break;
    case NeutralToneMapping:
        a = "Neutral";
        break;
    case CustomToneMapping:
        a = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        a = "Linear"
    }
    return "vec3 " + s + "( vec3 color ) { return " + a + "ToneMapping( color ); }"
}
const _v0$1 = new Vector3;
function getLuminanceFunction() {
    ColorManagement.getLuminanceCoefficients(_v0$1);
    const s = _v0$1.x.toFixed(4)
      , e = _v0$1.y.toFixed(4)
      , a = _v0$1.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${s}, ${e}, ${a} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function generateVertexExtensions(s) {
    return [s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(filterEmptyLine).join(`
`)
}
function generateDefines(s) {
    const e = [];
    for (const a in s) {
        const o = s[a];
        o !== !1 && e.push("#define " + a + " " + o)
    }
    return e.join(`
`)
}
function fetchAttributeLocations(s, e) {
    const a = {}
      , o = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
    for (let c = 0; c < o; c++) {
        const d = s.getActiveAttrib(e, c)
          , g = d.name;
        let _ = 1;
        d.type === s.FLOAT_MAT2 && (_ = 2),
        d.type === s.FLOAT_MAT3 && (_ = 3),
        d.type === s.FLOAT_MAT4 && (_ = 4),
        a[g] = {
            type: d.type,
            location: s.getAttribLocation(e, g),
            locationSize: _
        }
    }
    return a
}
function filterEmptyLine(s) {
    return s !== ""
}
function replaceLightNums(s, e) {
    const a = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, a).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function replaceClippingPlaneNums(s, e) {
    return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(s) {
    return s.replace(includePattern, includeReplacer)
}
const shaderChunkMap = new Map;
function includeReplacer(s, e) {
    let a = ShaderChunk[e];
    if (a === void 0) {
        const o = shaderChunkMap.get(e);
        if (o !== void 0)
            a = ShaderChunk[o],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, o);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return resolveIncludes(a)
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(s) {
    return s.replace(unrollLoopPattern, loopReplacer)
}
function loopReplacer(s, e, a, o) {
    let c = "";
    for (let d = parseInt(e); d < parseInt(a); d++)
        c += o.replace(/\[\s*i\s*\]/g, "[ " + d + " ]").replace(/UNROLLED_LOOP_INDEX/g, d);
    return c
}
function generatePrecision(s) {
    let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
    return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function generateShadowMapTypeDefine(s) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return s.shadowMapType === PCFShadowMap ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === PCFSoftShadowMap ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function generateEnvMapTypeDefine(s) {
    let e = "ENVMAP_TYPE_CUBE";
    if (s.envMap)
        switch (s.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case CubeUVReflectionMapping:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function generateEnvMapModeDefine(s) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (s.envMap)
        switch (s.envMapMode) {
        case CubeRefractionMapping:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function generateEnvMapBlendingDefine(s) {
    let e = "ENVMAP_BLENDING_NONE";
    if (s.envMap)
        switch (s.combine) {
        case MultiplyOperation:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case MixOperation:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case AddOperation:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function generateCubeUVSize(s) {
    const e = s.envMapCubeUVHeight;
    if (e === null)
        return null;
    const a = Math.log2(e) - 2
      , o = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, a), 7 * 16)),
        texelHeight: o,
        maxMip: a
    }
}
function WebGLProgram(s, e, a, o) {
    const c = s.getContext()
      , d = a.defines;
    let g = a.vertexShader
      , _ = a.fragmentShader;
    const b = generateShadowMapTypeDefine(a)
      , j = generateEnvMapTypeDefine(a)
      , $ = generateEnvMapModeDefine(a)
      , nt = generateEnvMapBlendingDefine(a)
      , tt = generateCubeUVSize(a)
      , rt = generateVertexExtensions(a)
      , st = generateDefines(d)
      , lt = c.createProgram();
    let ct, it, ot = a.glslVersion ? "#version " + a.glslVersion + `
` : "";
    a.isRawShaderMaterial ? (ct = ["#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, st].filter(filterEmptyLine).join(`
`),
    ct.length > 0 && (ct += `
`),
    it = ["#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, st].filter(filterEmptyLine).join(`
`),
    it.length > 0 && (it += `
`)) : (ct = [generatePrecision(a), "#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, st, a.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", a.batching ? "#define USE_BATCHING" : "", a.batchingColor ? "#define USE_BATCHING_COLOR" : "", a.instancing ? "#define USE_INSTANCING" : "", a.instancingColor ? "#define USE_INSTANCING_COLOR" : "", a.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + $ : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", a.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", a.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.anisotropy ? "#define USE_ANISOTROPY" : "", a.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", a.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", a.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", a.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", a.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", a.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", a.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.alphaHash ? "#define USE_ALPHAHASH" : "", a.transmission ? "#define USE_TRANSMISSION" : "", a.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", a.thicknessMap ? "#define USE_THICKNESSMAP" : "", a.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", a.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", a.mapUv ? "#define MAP_UV " + a.mapUv : "", a.alphaMapUv ? "#define ALPHAMAP_UV " + a.alphaMapUv : "", a.lightMapUv ? "#define LIGHTMAP_UV " + a.lightMapUv : "", a.aoMapUv ? "#define AOMAP_UV " + a.aoMapUv : "", a.emissiveMapUv ? "#define EMISSIVEMAP_UV " + a.emissiveMapUv : "", a.bumpMapUv ? "#define BUMPMAP_UV " + a.bumpMapUv : "", a.normalMapUv ? "#define NORMALMAP_UV " + a.normalMapUv : "", a.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + a.displacementMapUv : "", a.metalnessMapUv ? "#define METALNESSMAP_UV " + a.metalnessMapUv : "", a.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + a.roughnessMapUv : "", a.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + a.anisotropyMapUv : "", a.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + a.clearcoatMapUv : "", a.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + a.clearcoatNormalMapUv : "", a.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + a.clearcoatRoughnessMapUv : "", a.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + a.iridescenceMapUv : "", a.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + a.iridescenceThicknessMapUv : "", a.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + a.sheenColorMapUv : "", a.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + a.sheenRoughnessMapUv : "", a.specularMapUv ? "#define SPECULARMAP_UV " + a.specularMapUv : "", a.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + a.specularColorMapUv : "", a.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + a.specularIntensityMapUv : "", a.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + a.transmissionMapUv : "", a.thicknessMapUv ? "#define THICKNESSMAP_UV " + a.thicknessMapUv : "", a.vertexTangents && a.flatShading === !1 ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", a.vertexUv1s ? "#define USE_UV1" : "", a.vertexUv2s ? "#define USE_UV2" : "", a.vertexUv3s ? "#define USE_UV3" : "", a.pointsUvs ? "#define USE_POINTS_UV" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && a.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", a.morphColors ? "#define USE_MORPHCOLORS" : "", a.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + a.morphTextureStride : "", a.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + a.morphTargetsCount : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + b : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(filterEmptyLine).join(`
`),
    it = [generatePrecision(a), "#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, st, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "", a.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + j : "", a.envMap ? "#define " + $ : "", a.envMap ? "#define " + nt : "", tt ? "#define CUBEUV_TEXEL_WIDTH " + tt.texelWidth : "", tt ? "#define CUBEUV_TEXEL_HEIGHT " + tt.texelHeight : "", tt ? "#define CUBEUV_MAX_MIP " + tt.maxMip + ".0" : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", a.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.anisotropy ? "#define USE_ANISOTROPY" : "", a.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", a.clearcoat ? "#define USE_CLEARCOAT" : "", a.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", a.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", a.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", a.dispersion ? "#define USE_DISPERSION" : "", a.iridescence ? "#define USE_IRIDESCENCE" : "", a.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", a.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", a.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.alphaTest ? "#define USE_ALPHATEST" : "", a.alphaHash ? "#define USE_ALPHAHASH" : "", a.sheen ? "#define USE_SHEEN" : "", a.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", a.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", a.transmission ? "#define USE_TRANSMISSION" : "", a.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", a.thicknessMap ? "#define USE_THICKNESSMAP" : "", a.vertexTangents && a.flatShading === !1 ? "#define USE_TANGENT" : "", a.vertexColors || a.instancingColor || a.batchingColor ? "#define USE_COLOR" : "", a.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", a.vertexUv1s ? "#define USE_UV1" : "", a.vertexUv2s ? "#define USE_UV2" : "", a.vertexUv3s ? "#define USE_UV3" : "", a.pointsUvs ? "#define USE_POINTS_UV" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + b : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", a.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", a.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", a.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", a.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.opaque ? "#define OPAQUE" : "", ShaderChunk.colorspace_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", a.outputColorSpace), getLuminanceFunction(), a.useDepthPacking ? "#define DEPTH_PACKING " + a.depthPacking : "", `
`].filter(filterEmptyLine).join(`
`)),
    g = resolveIncludes(g),
    g = replaceLightNums(g, a),
    g = replaceClippingPlaneNums(g, a),
    _ = resolveIncludes(_),
    _ = replaceLightNums(_, a),
    _ = replaceClippingPlaneNums(_, a),
    g = unrollLoops(g),
    _ = unrollLoops(_),
    a.isRawShaderMaterial !== !0 && (ot = `#version 300 es
`,
    ct = [rt, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + ct,
    it = ["#define varying in", a.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", a.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + it);
    const at = ot + ct + g
      , ht = ot + it + _
      , pt = WebGLShader(c, c.VERTEX_SHADER, at)
      , dt = WebGLShader(c, c.FRAGMENT_SHADER, ht);
    c.attachShader(lt, pt),
    c.attachShader(lt, dt),
    a.index0AttributeName !== void 0 ? c.bindAttribLocation(lt, 0, a.index0AttributeName) : a.morphTargets === !0 && c.bindAttribLocation(lt, 0, "position"),
    c.linkProgram(lt);
    function yt(bt) {
        if (s.debug.checkShaderErrors) {
            const Rt = c.getProgramInfoLog(lt).trim()
              , Ft = c.getShaderInfoLog(pt).trim()
              , Bt = c.getShaderInfoLog(dt).trim();
            let Dt = !0
              , Mt = !0;
            if (c.getProgramParameter(lt, c.LINK_STATUS) === !1)
                if (Dt = !1,
                typeof s.debug.onShaderError == "function")
                    s.debug.onShaderError(c, lt, pt, dt);
                else {
                    const Tt = getShaderErrors(c, pt, "vertex")
                      , mt = getShaderErrors(c, dt, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + c.getError() + " - VALIDATE_STATUS " + c.getProgramParameter(lt, c.VALIDATE_STATUS) + `

Material Name: ` + bt.name + `
Material Type: ` + bt.type + `

Program Info Log: ` + Rt + `
` + Tt + `
` + mt)
                }
            else
                Rt !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Rt) : (Ft === "" || Bt === "") && (Mt = !1);
            Mt && (bt.diagnostics = {
                runnable: Dt,
                programLog: Rt,
                vertexShader: {
                    log: Ft,
                    prefix: ct
                },
                fragmentShader: {
                    log: Bt,
                    prefix: it
                }
            })
        }
        c.deleteShader(pt),
        c.deleteShader(dt),
        vt = new WebGLUniforms(c,lt),
        xt = fetchAttributeLocations(c, lt)
    }
    let vt;
    this.getUniforms = function() {
        return vt === void 0 && yt(this),
        vt
    }
    ;
    let xt;
    this.getAttributes = function() {
        return xt === void 0 && yt(this),
        xt
    }
    ;
    let _t = a.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return _t === !1 && (_t = c.getProgramParameter(lt, COMPLETION_STATUS_KHR)),
        _t
    }
    ,
    this.destroy = function() {
        o.releaseStatesOfProgram(this),
        c.deleteProgram(lt),
        this.program = void 0
    }
    ,
    this.type = a.shaderType,
    this.name = a.shaderName,
    this.id = programIdCount++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = lt,
    this.vertexShader = pt,
    this.fragmentShader = dt,
    this
}
let _id$1 = 0;
class WebGLShaderCache {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const a = e.vertexShader
          , o = e.fragmentShader
          , c = this._getShaderStage(a)
          , d = this._getShaderStage(o)
          , g = this._getShaderCacheForMaterial(e);
        return g.has(c) === !1 && (g.add(c),
        c.usedTimes++),
        g.has(d) === !1 && (g.add(d),
        d.usedTimes++),
        this
    }
    remove(e) {
        const a = this.materialCache.get(e);
        for (const o of a)
            o.usedTimes--,
            o.usedTimes === 0 && this.shaderCache.delete(o.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const a = this.materialCache;
        let o = a.get(e);
        return o === void 0 && (o = new Set,
        a.set(e, o)),
        o
    }
    _getShaderStage(e) {
        const a = this.shaderCache;
        let o = a.get(e);
        return o === void 0 && (o = new WebGLShaderStage(e),
        a.set(e, o)),
        o
    }
}
class WebGLShaderStage {
    constructor(e) {
        this.id = _id$1++,
        this.code = e,
        this.usedTimes = 0
    }
}
function WebGLPrograms(s, e, a, o, c, d, g) {
    const _ = new Layers
      , b = new WebGLShaderCache
      , j = new Set
      , $ = []
      , nt = c.logarithmicDepthBuffer
      , tt = c.vertexTextures;
    let rt = c.precision;
    const st = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function lt(xt) {
        return j.add(xt),
        xt === 0 ? "uv" : `uv${xt}`
    }
    function ct(xt, _t, bt, Rt, Ft) {
        const Bt = Rt.fog
          , Dt = Ft.geometry
          , Mt = xt.isMeshStandardMaterial ? Rt.environment : null
          , Tt = (xt.isMeshStandardMaterial ? a : e).get(xt.envMap || Mt)
          , mt = Tt && Tt.mapping === CubeUVReflectionMapping ? Tt.image.height : null
          , St = st[xt.type];
        xt.precision !== null && (rt = c.getMaxPrecision(xt.precision),
        rt !== xt.precision && console.warn("THREE.WebGLProgram.getParameters:", xt.precision, "not supported, using", rt, "instead."));
        const wt = Dt.morphAttributes.position || Dt.morphAttributes.normal || Dt.morphAttributes.color
          , Ct = wt !== void 0 ? wt.length : 0;
        let Ht = 0;
        Dt.morphAttributes.position !== void 0 && (Ht = 1),
        Dt.morphAttributes.normal !== void 0 && (Ht = 2),
        Dt.morphAttributes.color !== void 0 && (Ht = 3);
        let en, Ot, Yt, rn;
        if (St) {
            const Jn = ShaderLib[St];
            en = Jn.vertexShader,
            Ot = Jn.fragmentShader
        } else
            en = xt.vertexShader,
            Ot = xt.fragmentShader,
            b.update(xt),
            Yt = b.getVertexShaderID(xt),
            rn = b.getFragmentShaderID(xt);
        const Xt = s.getRenderTarget()
          , An = Ft.isInstancedMesh === !0
          , Ln = Ft.isBatchedMesh === !0
          , _n = !!xt.map
          , yn = !!xt.matcap
          , Pt = !!Tt
          , Qt = !!xt.aoMap
          , jt = !!xt.lightMap
          , fn = !!xt.bumpMap
          , tn = !!xt.normalMap
          , bn = !!xt.displacementMap
          , gn = !!xt.emissiveMap
          , vn = !!xt.metalnessMap
          , Lt = !!xt.roughnessMap
          , At = xt.anisotropy > 0
          , $t = xt.clearcoat > 0
          , on = xt.dispersion > 0
          , sn = xt.iridescence > 0
          , cn = xt.sheen > 0
          , Pn = xt.transmission > 0
          , dn = At && !!xt.anisotropyMap
          , Tn = $t && !!xt.clearcoatMap
          , jn = $t && !!xt.clearcoatNormalMap
          , pn = $t && !!xt.clearcoatRoughnessMap
          , kn = sn && !!xt.iridescenceMap
          , er = sn && !!xt.iridescenceThicknessMap
          , $n = cn && !!xt.sheenColorMap
          , Dn = cn && !!xt.sheenRoughnessMap
          , Nt = !!xt.specularMap
          , ln = !!xt.specularColorMap
          , Cn = !!xt.specularIntensityMap
          , Vt = Pn && !!xt.transmissionMap
          , hn = Pn && !!xt.thicknessMap
          , an = !!xt.gradientMap
          , un = !!xt.alphaMap
          , En = xt.alphaTest > 0
          , Hn = !!xt.alphaHash
          , Yn = !!xt.extensions;
        let tr = NoToneMapping;
        xt.toneMapped && (Xt === null || Xt.isXRRenderTarget === !0) && (tr = s.toneMapping);
        const hr = {
            shaderID: St,
            shaderType: xt.type,
            shaderName: xt.name,
            vertexShader: en,
            fragmentShader: Ot,
            defines: xt.defines,
            customVertexShaderID: Yt,
            customFragmentShaderID: rn,
            isRawShaderMaterial: xt.isRawShaderMaterial === !0,
            glslVersion: xt.glslVersion,
            precision: rt,
            batching: Ln,
            batchingColor: Ln && Ft._colorsTexture !== null,
            instancing: An,
            instancingColor: An && Ft.instanceColor !== null,
            instancingMorph: An && Ft.morphTexture !== null,
            supportsVertexTextures: tt,
            outputColorSpace: Xt === null ? s.outputColorSpace : Xt.isXRRenderTarget === !0 ? Xt.texture.colorSpace : LinearSRGBColorSpace,
            alphaToCoverage: !!xt.alphaToCoverage,
            map: _n,
            matcap: yn,
            envMap: Pt,
            envMapMode: Pt && Tt.mapping,
            envMapCubeUVHeight: mt,
            aoMap: Qt,
            lightMap: jt,
            bumpMap: fn,
            normalMap: tn,
            displacementMap: tt && bn,
            emissiveMap: gn,
            normalMapObjectSpace: tn && xt.normalMapType === ObjectSpaceNormalMap,
            normalMapTangentSpace: tn && xt.normalMapType === TangentSpaceNormalMap,
            metalnessMap: vn,
            roughnessMap: Lt,
            anisotropy: At,
            anisotropyMap: dn,
            clearcoat: $t,
            clearcoatMap: Tn,
            clearcoatNormalMap: jn,
            clearcoatRoughnessMap: pn,
            dispersion: on,
            iridescence: sn,
            iridescenceMap: kn,
            iridescenceThicknessMap: er,
            sheen: cn,
            sheenColorMap: $n,
            sheenRoughnessMap: Dn,
            specularMap: Nt,
            specularColorMap: ln,
            specularIntensityMap: Cn,
            transmission: Pn,
            transmissionMap: Vt,
            thicknessMap: hn,
            gradientMap: an,
            opaque: xt.transparent === !1 && xt.blending === NormalBlending && xt.alphaToCoverage === !1,
            alphaMap: un,
            alphaTest: En,
            alphaHash: Hn,
            combine: xt.combine,
            mapUv: _n && lt(xt.map.channel),
            aoMapUv: Qt && lt(xt.aoMap.channel),
            lightMapUv: jt && lt(xt.lightMap.channel),
            bumpMapUv: fn && lt(xt.bumpMap.channel),
            normalMapUv: tn && lt(xt.normalMap.channel),
            displacementMapUv: bn && lt(xt.displacementMap.channel),
            emissiveMapUv: gn && lt(xt.emissiveMap.channel),
            metalnessMapUv: vn && lt(xt.metalnessMap.channel),
            roughnessMapUv: Lt && lt(xt.roughnessMap.channel),
            anisotropyMapUv: dn && lt(xt.anisotropyMap.channel),
            clearcoatMapUv: Tn && lt(xt.clearcoatMap.channel),
            clearcoatNormalMapUv: jn && lt(xt.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: pn && lt(xt.clearcoatRoughnessMap.channel),
            iridescenceMapUv: kn && lt(xt.iridescenceMap.channel),
            iridescenceThicknessMapUv: er && lt(xt.iridescenceThicknessMap.channel),
            sheenColorMapUv: $n && lt(xt.sheenColorMap.channel),
            sheenRoughnessMapUv: Dn && lt(xt.sheenRoughnessMap.channel),
            specularMapUv: Nt && lt(xt.specularMap.channel),
            specularColorMapUv: ln && lt(xt.specularColorMap.channel),
            specularIntensityMapUv: Cn && lt(xt.specularIntensityMap.channel),
            transmissionMapUv: Vt && lt(xt.transmissionMap.channel),
            thicknessMapUv: hn && lt(xt.thicknessMap.channel),
            alphaMapUv: un && lt(xt.alphaMap.channel),
            vertexTangents: !!Dt.attributes.tangent && (tn || At),
            vertexColors: xt.vertexColors,
            vertexAlphas: xt.vertexColors === !0 && !!Dt.attributes.color && Dt.attributes.color.itemSize === 4,
            pointsUvs: Ft.isPoints === !0 && !!Dt.attributes.uv && (_n || un),
            fog: !!Bt,
            useFog: xt.fog === !0,
            fogExp2: !!Bt && Bt.isFogExp2,
            flatShading: xt.flatShading === !0,
            sizeAttenuation: xt.sizeAttenuation === !0,
            logarithmicDepthBuffer: nt,
            skinning: Ft.isSkinnedMesh === !0,
            morphTargets: Dt.morphAttributes.position !== void 0,
            morphNormals: Dt.morphAttributes.normal !== void 0,
            morphColors: Dt.morphAttributes.color !== void 0,
            morphTargetsCount: Ct,
            morphTextureStride: Ht,
            numDirLights: _t.directional.length,
            numPointLights: _t.point.length,
            numSpotLights: _t.spot.length,
            numSpotLightMaps: _t.spotLightMap.length,
            numRectAreaLights: _t.rectArea.length,
            numHemiLights: _t.hemi.length,
            numDirLightShadows: _t.directionalShadowMap.length,
            numPointLightShadows: _t.pointShadowMap.length,
            numSpotLightShadows: _t.spotShadowMap.length,
            numSpotLightShadowsWithMaps: _t.numSpotLightShadowsWithMaps,
            numLightProbes: _t.numLightProbes,
            numClippingPlanes: g.numPlanes,
            numClipIntersection: g.numIntersection,
            dithering: xt.dithering,
            shadowMapEnabled: s.shadowMap.enabled && bt.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: tr,
            decodeVideoTexture: _n && xt.map.isVideoTexture === !0 && ColorManagement.getTransfer(xt.map.colorSpace) === SRGBTransfer,
            premultipliedAlpha: xt.premultipliedAlpha,
            doubleSided: xt.side === DoubleSide,
            flipSided: xt.side === BackSide,
            useDepthPacking: xt.depthPacking >= 0,
            depthPacking: xt.depthPacking || 0,
            index0AttributeName: xt.index0AttributeName,
            extensionClipCullDistance: Yn && xt.extensions.clipCullDistance === !0 && o.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Yn && xt.extensions.multiDraw === !0 || Ln) && o.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: o.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: xt.customProgramCacheKey()
        };
        return hr.vertexUv1s = j.has(1),
        hr.vertexUv2s = j.has(2),
        hr.vertexUv3s = j.has(3),
        j.clear(),
        hr
    }
    function it(xt) {
        const _t = [];
        if (xt.shaderID ? _t.push(xt.shaderID) : (_t.push(xt.customVertexShaderID),
        _t.push(xt.customFragmentShaderID)),
        xt.defines !== void 0)
            for (const bt in xt.defines)
                _t.push(bt),
                _t.push(xt.defines[bt]);
        return xt.isRawShaderMaterial === !1 && (ot(_t, xt),
        at(_t, xt),
        _t.push(s.outputColorSpace)),
        _t.push(xt.customProgramCacheKey),
        _t.join()
    }
    function ot(xt, _t) {
        xt.push(_t.precision),
        xt.push(_t.outputColorSpace),
        xt.push(_t.envMapMode),
        xt.push(_t.envMapCubeUVHeight),
        xt.push(_t.mapUv),
        xt.push(_t.alphaMapUv),
        xt.push(_t.lightMapUv),
        xt.push(_t.aoMapUv),
        xt.push(_t.bumpMapUv),
        xt.push(_t.normalMapUv),
        xt.push(_t.displacementMapUv),
        xt.push(_t.emissiveMapUv),
        xt.push(_t.metalnessMapUv),
        xt.push(_t.roughnessMapUv),
        xt.push(_t.anisotropyMapUv),
        xt.push(_t.clearcoatMapUv),
        xt.push(_t.clearcoatNormalMapUv),
        xt.push(_t.clearcoatRoughnessMapUv),
        xt.push(_t.iridescenceMapUv),
        xt.push(_t.iridescenceThicknessMapUv),
        xt.push(_t.sheenColorMapUv),
        xt.push(_t.sheenRoughnessMapUv),
        xt.push(_t.specularMapUv),
        xt.push(_t.specularColorMapUv),
        xt.push(_t.specularIntensityMapUv),
        xt.push(_t.transmissionMapUv),
        xt.push(_t.thicknessMapUv),
        xt.push(_t.combine),
        xt.push(_t.fogExp2),
        xt.push(_t.sizeAttenuation),
        xt.push(_t.morphTargetsCount),
        xt.push(_t.morphAttributeCount),
        xt.push(_t.numDirLights),
        xt.push(_t.numPointLights),
        xt.push(_t.numSpotLights),
        xt.push(_t.numSpotLightMaps),
        xt.push(_t.numHemiLights),
        xt.push(_t.numRectAreaLights),
        xt.push(_t.numDirLightShadows),
        xt.push(_t.numPointLightShadows),
        xt.push(_t.numSpotLightShadows),
        xt.push(_t.numSpotLightShadowsWithMaps),
        xt.push(_t.numLightProbes),
        xt.push(_t.shadowMapType),
        xt.push(_t.toneMapping),
        xt.push(_t.numClippingPlanes),
        xt.push(_t.numClipIntersection),
        xt.push(_t.depthPacking)
    }
    function at(xt, _t) {
        _.disableAll(),
        _t.supportsVertexTextures && _.enable(0),
        _t.instancing && _.enable(1),
        _t.instancingColor && _.enable(2),
        _t.instancingMorph && _.enable(3),
        _t.matcap && _.enable(4),
        _t.envMap && _.enable(5),
        _t.normalMapObjectSpace && _.enable(6),
        _t.normalMapTangentSpace && _.enable(7),
        _t.clearcoat && _.enable(8),
        _t.iridescence && _.enable(9),
        _t.alphaTest && _.enable(10),
        _t.vertexColors && _.enable(11),
        _t.vertexAlphas && _.enable(12),
        _t.vertexUv1s && _.enable(13),
        _t.vertexUv2s && _.enable(14),
        _t.vertexUv3s && _.enable(15),
        _t.vertexTangents && _.enable(16),
        _t.anisotropy && _.enable(17),
        _t.alphaHash && _.enable(18),
        _t.batching && _.enable(19),
        _t.dispersion && _.enable(20),
        _t.batchingColor && _.enable(21),
        xt.push(_.mask),
        _.disableAll(),
        _t.fog && _.enable(0),
        _t.useFog && _.enable(1),
        _t.flatShading && _.enable(2),
        _t.logarithmicDepthBuffer && _.enable(3),
        _t.skinning && _.enable(4),
        _t.morphTargets && _.enable(5),
        _t.morphNormals && _.enable(6),
        _t.morphColors && _.enable(7),
        _t.premultipliedAlpha && _.enable(8),
        _t.shadowMapEnabled && _.enable(9),
        _t.doubleSided && _.enable(10),
        _t.flipSided && _.enable(11),
        _t.useDepthPacking && _.enable(12),
        _t.dithering && _.enable(13),
        _t.transmission && _.enable(14),
        _t.sheen && _.enable(15),
        _t.opaque && _.enable(16),
        _t.pointsUvs && _.enable(17),
        _t.decodeVideoTexture && _.enable(18),
        _t.alphaToCoverage && _.enable(19),
        xt.push(_.mask)
    }
    function ht(xt) {
        const _t = st[xt.type];
        let bt;
        if (_t) {
            const Rt = ShaderLib[_t];
            bt = UniformsUtils.clone(Rt.uniforms)
        } else
            bt = xt.uniforms;
        return bt
    }
    function pt(xt, _t) {
        let bt;
        for (let Rt = 0, Ft = $.length; Rt < Ft; Rt++) {
            const Bt = $[Rt];
            if (Bt.cacheKey === _t) {
                bt = Bt,
                ++bt.usedTimes;
                break
            }
        }
        return bt === void 0 && (bt = new WebGLProgram(s,_t,xt,d),
        $.push(bt)),
        bt
    }
    function dt(xt) {
        if (--xt.usedTimes === 0) {
            const _t = $.indexOf(xt);
            $[_t] = $[$.length - 1],
            $.pop(),
            xt.destroy()
        }
    }
    function yt(xt) {
        b.remove(xt)
    }
    function vt() {
        b.dispose()
    }
    return {
        getParameters: ct,
        getProgramCacheKey: it,
        getUniforms: ht,
        acquireProgram: pt,
        releaseProgram: dt,
        releaseShaderCache: yt,
        programs: $,
        dispose: vt
    }
}
function WebGLProperties() {
    let s = new WeakMap;
    function e(d) {
        let g = s.get(d);
        return g === void 0 && (g = {},
        s.set(d, g)),
        g
    }
    function a(d) {
        s.delete(d)
    }
    function o(d, g, _) {
        s.get(d)[g] = _
    }
    function c() {
        s = new WeakMap
    }
    return {
        get: e,
        remove: a,
        update: o,
        dispose: c
    }
}
function painterSortStable(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id
}
function reversePainterSortStable(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id
}
function WebGLRenderList() {
    const s = [];
    let e = 0;
    const a = []
      , o = []
      , c = [];
    function d() {
        e = 0,
        a.length = 0,
        o.length = 0,
        c.length = 0
    }
    function g(nt, tt, rt, st, lt, ct) {
        let it = s[e];
        return it === void 0 ? (it = {
            id: nt.id,
            object: nt,
            geometry: tt,
            material: rt,
            groupOrder: st,
            renderOrder: nt.renderOrder,
            z: lt,
            group: ct
        },
        s[e] = it) : (it.id = nt.id,
        it.object = nt,
        it.geometry = tt,
        it.material = rt,
        it.groupOrder = st,
        it.renderOrder = nt.renderOrder,
        it.z = lt,
        it.group = ct),
        e++,
        it
    }
    function _(nt, tt, rt, st, lt, ct) {
        const it = g(nt, tt, rt, st, lt, ct);
        rt.transmission > 0 ? o.push(it) : rt.transparent === !0 ? c.push(it) : a.push(it)
    }
    function b(nt, tt, rt, st, lt, ct) {
        const it = g(nt, tt, rt, st, lt, ct);
        rt.transmission > 0 ? o.unshift(it) : rt.transparent === !0 ? c.unshift(it) : a.unshift(it)
    }
    function j(nt, tt) {
        a.length > 1 && a.sort(nt || painterSortStable),
        o.length > 1 && o.sort(tt || reversePainterSortStable),
        c.length > 1 && c.sort(tt || reversePainterSortStable)
    }
    function $() {
        for (let nt = e, tt = s.length; nt < tt; nt++) {
            const rt = s[nt];
            if (rt.id === null)
                break;
            rt.id = null,
            rt.object = null,
            rt.geometry = null,
            rt.material = null,
            rt.group = null
        }
    }
    return {
        opaque: a,
        transmissive: o,
        transparent: c,
        init: d,
        push: _,
        unshift: b,
        finish: $,
        sort: j
    }
}
function WebGLRenderLists() {
    let s = new WeakMap;
    function e(o, c) {
        const d = s.get(o);
        let g;
        return d === void 0 ? (g = new WebGLRenderList,
        s.set(o, [g])) : c >= d.length ? (g = new WebGLRenderList,
        d.push(g)) : g = d[c],
        g
    }
    function a() {
        s = new WeakMap
    }
    return {
        get: e,
        dispose: a
    }
}
function UniformsCache() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let a;
            switch (e.type) {
            case "DirectionalLight":
                a = {
                    direction: new Vector3,
                    color: new Color
                };
                break;
            case "SpotLight":
                a = {
                    position: new Vector3,
                    direction: new Vector3,
                    color: new Color,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                a = {
                    position: new Vector3,
                    color: new Color,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                a = {
                    direction: new Vector3,
                    skyColor: new Color,
                    groundColor: new Color
                };
                break;
            case "RectAreaLight":
                a = {
                    color: new Color,
                    position: new Vector3,
                    halfWidth: new Vector3,
                    halfHeight: new Vector3
                };
                break
            }
            return s[e.id] = a,
            a
        }
    }
}
function ShadowUniformsCache() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let a;
            switch (e.type) {
            case "DirectionalLight":
                a = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2
                };
                break;
            case "SpotLight":
                a = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2
                };
                break;
            case "PointLight":
                a = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return s[e.id] = a,
            a
        }
    }
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(s, e) {
    return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0)
}
function WebGLLights(s) {
    const e = new UniformsCache
      , a = ShadowUniformsCache()
      , o = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let j = 0; j < 9; j++)
        o.probe.push(new Vector3);
    const c = new Vector3
      , d = new Matrix4
      , g = new Matrix4;
    function _(j) {
        let $ = 0
          , nt = 0
          , tt = 0;
        for (let xt = 0; xt < 9; xt++)
            o.probe[xt].set(0, 0, 0);
        let rt = 0
          , st = 0
          , lt = 0
          , ct = 0
          , it = 0
          , ot = 0
          , at = 0
          , ht = 0
          , pt = 0
          , dt = 0
          , yt = 0;
        j.sort(shadowCastingAndTexturingLightsFirst);
        for (let xt = 0, _t = j.length; xt < _t; xt++) {
            const bt = j[xt]
              , Rt = bt.color
              , Ft = bt.intensity
              , Bt = bt.distance
              , Dt = bt.shadow && bt.shadow.map ? bt.shadow.map.texture : null;
            if (bt.isAmbientLight)
                $ += Rt.r * Ft,
                nt += Rt.g * Ft,
                tt += Rt.b * Ft;
            else if (bt.isLightProbe) {
                for (let Mt = 0; Mt < 9; Mt++)
                    o.probe[Mt].addScaledVector(bt.sh.coefficients[Mt], Ft);
                yt++
            } else if (bt.isDirectionalLight) {
                const Mt = e.get(bt);
                if (Mt.color.copy(bt.color).multiplyScalar(bt.intensity),
                bt.castShadow) {
                    const Tt = bt.shadow
                      , mt = a.get(bt);
                    mt.shadowIntensity = Tt.intensity,
                    mt.shadowBias = Tt.bias,
                    mt.shadowNormalBias = Tt.normalBias,
                    mt.shadowRadius = Tt.radius,
                    mt.shadowMapSize = Tt.mapSize,
                    o.directionalShadow[rt] = mt,
                    o.directionalShadowMap[rt] = Dt,
                    o.directionalShadowMatrix[rt] = bt.shadow.matrix,
                    ot++
                }
                o.directional[rt] = Mt,
                rt++
            } else if (bt.isSpotLight) {
                const Mt = e.get(bt);
                Mt.position.setFromMatrixPosition(bt.matrixWorld),
                Mt.color.copy(Rt).multiplyScalar(Ft),
                Mt.distance = Bt,
                Mt.coneCos = Math.cos(bt.angle),
                Mt.penumbraCos = Math.cos(bt.angle * (1 - bt.penumbra)),
                Mt.decay = bt.decay,
                o.spot[lt] = Mt;
                const Tt = bt.shadow;
                if (bt.map && (o.spotLightMap[pt] = bt.map,
                pt++,
                Tt.updateMatrices(bt),
                bt.castShadow && dt++),
                o.spotLightMatrix[lt] = Tt.matrix,
                bt.castShadow) {
                    const mt = a.get(bt);
                    mt.shadowIntensity = Tt.intensity,
                    mt.shadowBias = Tt.bias,
                    mt.shadowNormalBias = Tt.normalBias,
                    mt.shadowRadius = Tt.radius,
                    mt.shadowMapSize = Tt.mapSize,
                    o.spotShadow[lt] = mt,
                    o.spotShadowMap[lt] = Dt,
                    ht++
                }
                lt++
            } else if (bt.isRectAreaLight) {
                const Mt = e.get(bt);
                Mt.color.copy(Rt).multiplyScalar(Ft),
                Mt.halfWidth.set(bt.width * .5, 0, 0),
                Mt.halfHeight.set(0, bt.height * .5, 0),
                o.rectArea[ct] = Mt,
                ct++
            } else if (bt.isPointLight) {
                const Mt = e.get(bt);
                if (Mt.color.copy(bt.color).multiplyScalar(bt.intensity),
                Mt.distance = bt.distance,
                Mt.decay = bt.decay,
                bt.castShadow) {
                    const Tt = bt.shadow
                      , mt = a.get(bt);
                    mt.shadowIntensity = Tt.intensity,
                    mt.shadowBias = Tt.bias,
                    mt.shadowNormalBias = Tt.normalBias,
                    mt.shadowRadius = Tt.radius,
                    mt.shadowMapSize = Tt.mapSize,
                    mt.shadowCameraNear = Tt.camera.near,
                    mt.shadowCameraFar = Tt.camera.far,
                    o.pointShadow[st] = mt,
                    o.pointShadowMap[st] = Dt,
                    o.pointShadowMatrix[st] = bt.shadow.matrix,
                    at++
                }
                o.point[st] = Mt,
                st++
            } else if (bt.isHemisphereLight) {
                const Mt = e.get(bt);
                Mt.skyColor.copy(bt.color).multiplyScalar(Ft),
                Mt.groundColor.copy(bt.groundColor).multiplyScalar(Ft),
                o.hemi[it] = Mt,
                it++
            }
        }
        ct > 0 && (s.has("OES_texture_float_linear") === !0 ? (o.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1,
        o.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : (o.rectAreaLTC1 = UniformsLib.LTC_HALF_1,
        o.rectAreaLTC2 = UniformsLib.LTC_HALF_2)),
        o.ambient[0] = $,
        o.ambient[1] = nt,
        o.ambient[2] = tt;
        const vt = o.hash;
        (vt.directionalLength !== rt || vt.pointLength !== st || vt.spotLength !== lt || vt.rectAreaLength !== ct || vt.hemiLength !== it || vt.numDirectionalShadows !== ot || vt.numPointShadows !== at || vt.numSpotShadows !== ht || vt.numSpotMaps !== pt || vt.numLightProbes !== yt) && (o.directional.length = rt,
        o.spot.length = lt,
        o.rectArea.length = ct,
        o.point.length = st,
        o.hemi.length = it,
        o.directionalShadow.length = ot,
        o.directionalShadowMap.length = ot,
        o.pointShadow.length = at,
        o.pointShadowMap.length = at,
        o.spotShadow.length = ht,
        o.spotShadowMap.length = ht,
        o.directionalShadowMatrix.length = ot,
        o.pointShadowMatrix.length = at,
        o.spotLightMatrix.length = ht + pt - dt,
        o.spotLightMap.length = pt,
        o.numSpotLightShadowsWithMaps = dt,
        o.numLightProbes = yt,
        vt.directionalLength = rt,
        vt.pointLength = st,
        vt.spotLength = lt,
        vt.rectAreaLength = ct,
        vt.hemiLength = it,
        vt.numDirectionalShadows = ot,
        vt.numPointShadows = at,
        vt.numSpotShadows = ht,
        vt.numSpotMaps = pt,
        vt.numLightProbes = yt,
        o.version = nextVersion++)
    }
    function b(j, $) {
        let nt = 0
          , tt = 0
          , rt = 0
          , st = 0
          , lt = 0;
        const ct = $.matrixWorldInverse;
        for (let it = 0, ot = j.length; it < ot; it++) {
            const at = j[it];
            if (at.isDirectionalLight) {
                const ht = o.directional[nt];
                ht.direction.setFromMatrixPosition(at.matrixWorld),
                c.setFromMatrixPosition(at.target.matrixWorld),
                ht.direction.sub(c),
                ht.direction.transformDirection(ct),
                nt++
            } else if (at.isSpotLight) {
                const ht = o.spot[rt];
                ht.position.setFromMatrixPosition(at.matrixWorld),
                ht.position.applyMatrix4(ct),
                ht.direction.setFromMatrixPosition(at.matrixWorld),
                c.setFromMatrixPosition(at.target.matrixWorld),
                ht.direction.sub(c),
                ht.direction.transformDirection(ct),
                rt++
            } else if (at.isRectAreaLight) {
                const ht = o.rectArea[st];
                ht.position.setFromMatrixPosition(at.matrixWorld),
                ht.position.applyMatrix4(ct),
                g.identity(),
                d.copy(at.matrixWorld),
                d.premultiply(ct),
                g.extractRotation(d),
                ht.halfWidth.set(at.width * .5, 0, 0),
                ht.halfHeight.set(0, at.height * .5, 0),
                ht.halfWidth.applyMatrix4(g),
                ht.halfHeight.applyMatrix4(g),
                st++
            } else if (at.isPointLight) {
                const ht = o.point[tt];
                ht.position.setFromMatrixPosition(at.matrixWorld),
                ht.position.applyMatrix4(ct),
                tt++
            } else if (at.isHemisphereLight) {
                const ht = o.hemi[lt];
                ht.direction.setFromMatrixPosition(at.matrixWorld),
                ht.direction.transformDirection(ct),
                lt++
            }
        }
    }
    return {
        setup: _,
        setupView: b,
        state: o
    }
}
function WebGLRenderState(s) {
    const e = new WebGLLights(s)
      , a = []
      , o = [];
    function c($) {
        j.camera = $,
        a.length = 0,
        o.length = 0
    }
    function d($) {
        a.push($)
    }
    function g($) {
        o.push($)
    }
    function _() {
        e.setup(a)
    }
    function b($) {
        e.setupView(a, $)
    }
    const j = {
        lightsArray: a,
        shadowsArray: o,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: c,
        state: j,
        setupLights: _,
        setupLightsView: b,
        pushLight: d,
        pushShadow: g
    }
}
function WebGLRenderStates(s) {
    let e = new WeakMap;
    function a(c, d=0) {
        const g = e.get(c);
        let _;
        return g === void 0 ? (_ = new WebGLRenderState(s),
        e.set(c, [_])) : d >= g.length ? (_ = new WebGLRenderState(s),
        g.push(_)) : _ = g[d],
        _
    }
    function o() {
        e = new WeakMap
    }
    return {
        get: a,
        dispose: o
    }
}
class MeshDepthMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = BasicDepthPacking,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class MeshDistanceMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WebGLShadowMap(s, e, a) {
    let o = new Frustum;
    const c = new Vector2
      , d = new Vector2
      , g = new Vector4
      , _ = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
    })
      , b = new MeshDistanceMaterial
      , j = {}
      , $ = a.maxTextureSize
      , nt = {
        [FrontSide]: BackSide,
        [BackSide]: FrontSide,
        [DoubleSide]: DoubleSide
    }
      , tt = new ShaderMaterial({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vertex,
        fragmentShader: fragment
    })
      , rt = tt.clone();
    rt.defines.HORIZONTAL_PASS = 1;
    const st = new BufferGeometry;
    st.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const lt = new Mesh(st,tt)
      , ct = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = PCFShadowMap;
    let it = this.type;
    this.render = function(dt, yt, vt) {
        if (ct.enabled === !1 || ct.autoUpdate === !1 && ct.needsUpdate === !1 || dt.length === 0)
            return;
        const xt = s.getRenderTarget()
          , _t = s.getActiveCubeFace()
          , bt = s.getActiveMipmapLevel()
          , Rt = s.state;
        Rt.setBlending(NoBlending),
        Rt.buffers.color.setClear(1, 1, 1, 1),
        Rt.buffers.depth.setTest(!0),
        Rt.setScissorTest(!1);
        const Ft = it !== VSMShadowMap && this.type === VSMShadowMap
          , Bt = it === VSMShadowMap && this.type !== VSMShadowMap;
        for (let Dt = 0, Mt = dt.length; Dt < Mt; Dt++) {
            const Tt = dt[Dt]
              , mt = Tt.shadow;
            if (mt === void 0) {
                console.warn("THREE.WebGLShadowMap:", Tt, "has no shadow.");
                continue
            }
            if (mt.autoUpdate === !1 && mt.needsUpdate === !1)
                continue;
            c.copy(mt.mapSize);
            const St = mt.getFrameExtents();
            if (c.multiply(St),
            d.copy(mt.mapSize),
            (c.x > $ || c.y > $) && (c.x > $ && (d.x = Math.floor($ / St.x),
            c.x = d.x * St.x,
            mt.mapSize.x = d.x),
            c.y > $ && (d.y = Math.floor($ / St.y),
            c.y = d.y * St.y,
            mt.mapSize.y = d.y)),
            mt.map === null || Ft === !0 || Bt === !0) {
                const Ct = this.type !== VSMShadowMap ? {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter
                } : {};
                mt.map !== null && mt.map.dispose(),
                mt.map = new WebGLRenderTarget(c.x,c.y,Ct),
                mt.map.texture.name = Tt.name + ".shadowMap",
                mt.camera.updateProjectionMatrix()
            }
            s.setRenderTarget(mt.map),
            s.clear();
            const wt = mt.getViewportCount();
            for (let Ct = 0; Ct < wt; Ct++) {
                const Ht = mt.getViewport(Ct);
                g.set(d.x * Ht.x, d.y * Ht.y, d.x * Ht.z, d.y * Ht.w),
                Rt.viewport(g),
                mt.updateMatrices(Tt, Ct),
                o = mt.getFrustum(),
                ht(yt, vt, mt.camera, Tt, this.type)
            }
            mt.isPointLightShadow !== !0 && this.type === VSMShadowMap && ot(mt, vt),
            mt.needsUpdate = !1
        }
        it = this.type,
        ct.needsUpdate = !1,
        s.setRenderTarget(xt, _t, bt)
    }
    ;
    function ot(dt, yt) {
        const vt = e.update(lt);
        tt.defines.VSM_SAMPLES !== dt.blurSamples && (tt.defines.VSM_SAMPLES = dt.blurSamples,
        rt.defines.VSM_SAMPLES = dt.blurSamples,
        tt.needsUpdate = !0,
        rt.needsUpdate = !0),
        dt.mapPass === null && (dt.mapPass = new WebGLRenderTarget(c.x,c.y)),
        tt.uniforms.shadow_pass.value = dt.map.texture,
        tt.uniforms.resolution.value = dt.mapSize,
        tt.uniforms.radius.value = dt.radius,
        s.setRenderTarget(dt.mapPass),
        s.clear(),
        s.renderBufferDirect(yt, null, vt, tt, lt, null),
        rt.uniforms.shadow_pass.value = dt.mapPass.texture,
        rt.uniforms.resolution.value = dt.mapSize,
        rt.uniforms.radius.value = dt.radius,
        s.setRenderTarget(dt.map),
        s.clear(),
        s.renderBufferDirect(yt, null, vt, rt, lt, null)
    }
    function at(dt, yt, vt, xt) {
        let _t = null;
        const bt = vt.isPointLight === !0 ? dt.customDistanceMaterial : dt.customDepthMaterial;
        if (bt !== void 0)
            _t = bt;
        else if (_t = vt.isPointLight === !0 ? b : _,
        s.localClippingEnabled && yt.clipShadows === !0 && Array.isArray(yt.clippingPlanes) && yt.clippingPlanes.length !== 0 || yt.displacementMap && yt.displacementScale !== 0 || yt.alphaMap && yt.alphaTest > 0 || yt.map && yt.alphaTest > 0) {
            const Rt = _t.uuid
              , Ft = yt.uuid;
            let Bt = j[Rt];
            Bt === void 0 && (Bt = {},
            j[Rt] = Bt);
            let Dt = Bt[Ft];
            Dt === void 0 && (Dt = _t.clone(),
            Bt[Ft] = Dt,
            yt.addEventListener("dispose", pt)),
            _t = Dt
        }
        if (_t.visible = yt.visible,
        _t.wireframe = yt.wireframe,
        xt === VSMShadowMap ? _t.side = yt.shadowSide !== null ? yt.shadowSide : yt.side : _t.side = yt.shadowSide !== null ? yt.shadowSide : nt[yt.side],
        _t.alphaMap = yt.alphaMap,
        _t.alphaTest = yt.alphaTest,
        _t.map = yt.map,
        _t.clipShadows = yt.clipShadows,
        _t.clippingPlanes = yt.clippingPlanes,
        _t.clipIntersection = yt.clipIntersection,
        _t.displacementMap = yt.displacementMap,
        _t.displacementScale = yt.displacementScale,
        _t.displacementBias = yt.displacementBias,
        _t.wireframeLinewidth = yt.wireframeLinewidth,
        _t.linewidth = yt.linewidth,
        vt.isPointLight === !0 && _t.isMeshDistanceMaterial === !0) {
            const Rt = s.properties.get(_t);
            Rt.light = vt
        }
        return _t
    }
    function ht(dt, yt, vt, xt, _t) {
        if (dt.visible === !1)
            return;
        if (dt.layers.test(yt.layers) && (dt.isMesh || dt.isLine || dt.isPoints) && (dt.castShadow || dt.receiveShadow && _t === VSMShadowMap) && (!dt.frustumCulled || o.intersectsObject(dt))) {
            dt.modelViewMatrix.multiplyMatrices(vt.matrixWorldInverse, dt.matrixWorld);
            const Ft = e.update(dt)
              , Bt = dt.material;
            if (Array.isArray(Bt)) {
                const Dt = Ft.groups;
                for (let Mt = 0, Tt = Dt.length; Mt < Tt; Mt++) {
                    const mt = Dt[Mt]
                      , St = Bt[mt.materialIndex];
                    if (St && St.visible) {
                        const wt = at(dt, St, xt, _t);
                        dt.onBeforeShadow(s, dt, yt, vt, Ft, wt, mt),
                        s.renderBufferDirect(vt, null, Ft, wt, dt, mt),
                        dt.onAfterShadow(s, dt, yt, vt, Ft, wt, mt)
                    }
                }
            } else if (Bt.visible) {
                const Dt = at(dt, Bt, xt, _t);
                dt.onBeforeShadow(s, dt, yt, vt, Ft, Dt, null),
                s.renderBufferDirect(vt, null, Ft, Dt, dt, null),
                dt.onAfterShadow(s, dt, yt, vt, Ft, Dt, null)
            }
        }
        const Rt = dt.children;
        for (let Ft = 0, Bt = Rt.length; Ft < Bt; Ft++)
            ht(Rt[Ft], yt, vt, xt, _t)
    }
    function pt(dt) {
        dt.target.removeEventListener("dispose", pt);
        for (const vt in j) {
            const xt = j[vt]
              , _t = dt.target.uuid;
            _t in xt && (xt[_t].dispose(),
            delete xt[_t])
        }
    }
}
function WebGLState(s) {
    function e() {
        let Vt = !1;
        const hn = new Vector4;
        let an = null;
        const un = new Vector4(0,0,0,0);
        return {
            setMask: function(En) {
                an !== En && !Vt && (s.colorMask(En, En, En, En),
                an = En)
            },
            setLocked: function(En) {
                Vt = En
            },
            setClear: function(En, Hn, Yn, tr, hr) {
                hr === !0 && (En *= tr,
                Hn *= tr,
                Yn *= tr),
                hn.set(En, Hn, Yn, tr),
                un.equals(hn) === !1 && (s.clearColor(En, Hn, Yn, tr),
                un.copy(hn))
            },
            reset: function() {
                Vt = !1,
                an = null,
                un.set(-1, 0, 0, 0)
            }
        }
    }
    function a() {
        let Vt = !1
          , hn = null
          , an = null
          , un = null;
        return {
            setTest: function(En) {
                En ? rn(s.DEPTH_TEST) : Xt(s.DEPTH_TEST)
            },
            setMask: function(En) {
                hn !== En && !Vt && (s.depthMask(En),
                hn = En)
            },
            setFunc: function(En) {
                if (an !== En) {
                    switch (En) {
                    case NeverDepth:
                        s.depthFunc(s.NEVER);
                        break;
                    case AlwaysDepth:
                        s.depthFunc(s.ALWAYS);
                        break;
                    case LessDepth:
                        s.depthFunc(s.LESS);
                        break;
                    case LessEqualDepth:
                        s.depthFunc(s.LEQUAL);
                        break;
                    case EqualDepth:
                        s.depthFunc(s.EQUAL);
                        break;
                    case GreaterEqualDepth:
                        s.depthFunc(s.GEQUAL);
                        break;
                    case GreaterDepth:
                        s.depthFunc(s.GREATER);
                        break;
                    case NotEqualDepth:
                        s.depthFunc(s.NOTEQUAL);
                        break;
                    default:
                        s.depthFunc(s.LEQUAL)
                    }
                    an = En
                }
            },
            setLocked: function(En) {
                Vt = En
            },
            setClear: function(En) {
                un !== En && (s.clearDepth(En),
                un = En)
            },
            reset: function() {
                Vt = !1,
                hn = null,
                an = null,
                un = null
            }
        }
    }
    function o() {
        let Vt = !1
          , hn = null
          , an = null
          , un = null
          , En = null
          , Hn = null
          , Yn = null
          , tr = null
          , hr = null;
        return {
            setTest: function(Jn) {
                Vt || (Jn ? rn(s.STENCIL_TEST) : Xt(s.STENCIL_TEST))
            },
            setMask: function(Jn) {
                hn !== Jn && !Vt && (s.stencilMask(Jn),
                hn = Jn)
            },
            setFunc: function(Jn, Mr, br) {
                (an !== Jn || un !== Mr || En !== br) && (s.stencilFunc(Jn, Mr, br),
                an = Jn,
                un = Mr,
                En = br)
            },
            setOp: function(Jn, Mr, br) {
                (Hn !== Jn || Yn !== Mr || tr !== br) && (s.stencilOp(Jn, Mr, br),
                Hn = Jn,
                Yn = Mr,
                tr = br)
            },
            setLocked: function(Jn) {
                Vt = Jn
            },
            setClear: function(Jn) {
                hr !== Jn && (s.clearStencil(Jn),
                hr = Jn)
            },
            reset: function() {
                Vt = !1,
                hn = null,
                an = null,
                un = null,
                En = null,
                Hn = null,
                Yn = null,
                tr = null,
                hr = null
            }
        }
    }
    const c = new e
      , d = new a
      , g = new o
      , _ = new WeakMap
      , b = new WeakMap;
    let j = {}
      , $ = {}
      , nt = new WeakMap
      , tt = []
      , rt = null
      , st = !1
      , lt = null
      , ct = null
      , it = null
      , ot = null
      , at = null
      , ht = null
      , pt = null
      , dt = new Color(0,0,0)
      , yt = 0
      , vt = !1
      , xt = null
      , _t = null
      , bt = null
      , Rt = null
      , Ft = null;
    const Bt = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let Dt = !1
      , Mt = 0;
    const Tt = s.getParameter(s.VERSION);
    Tt.indexOf("WebGL") !== -1 ? (Mt = parseFloat(/^WebGL (\d)/.exec(Tt)[1]),
    Dt = Mt >= 1) : Tt.indexOf("OpenGL ES") !== -1 && (Mt = parseFloat(/^OpenGL ES (\d)/.exec(Tt)[1]),
    Dt = Mt >= 2);
    let mt = null
      , St = {};
    const wt = s.getParameter(s.SCISSOR_BOX)
      , Ct = s.getParameter(s.VIEWPORT)
      , Ht = new Vector4().fromArray(wt)
      , en = new Vector4().fromArray(Ct);
    function Ot(Vt, hn, an, un) {
        const En = new Uint8Array(4)
          , Hn = s.createTexture();
        s.bindTexture(Vt, Hn),
        s.texParameteri(Vt, s.TEXTURE_MIN_FILTER, s.NEAREST),
        s.texParameteri(Vt, s.TEXTURE_MAG_FILTER, s.NEAREST);
        for (let Yn = 0; Yn < an; Yn++)
            Vt === s.TEXTURE_3D || Vt === s.TEXTURE_2D_ARRAY ? s.texImage3D(hn, 0, s.RGBA, 1, 1, un, 0, s.RGBA, s.UNSIGNED_BYTE, En) : s.texImage2D(hn + Yn, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, En);
        return Hn
    }
    const Yt = {};
    Yt[s.TEXTURE_2D] = Ot(s.TEXTURE_2D, s.TEXTURE_2D, 1),
    Yt[s.TEXTURE_CUBE_MAP] = Ot(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    Yt[s.TEXTURE_2D_ARRAY] = Ot(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1),
    Yt[s.TEXTURE_3D] = Ot(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1),
    c.setClear(0, 0, 0, 1),
    d.setClear(1),
    g.setClear(0),
    rn(s.DEPTH_TEST),
    d.setFunc(LessEqualDepth),
    fn(!1),
    tn(CullFaceBack),
    rn(s.CULL_FACE),
    Qt(NoBlending);
    function rn(Vt) {
        j[Vt] !== !0 && (s.enable(Vt),
        j[Vt] = !0)
    }
    function Xt(Vt) {
        j[Vt] !== !1 && (s.disable(Vt),
        j[Vt] = !1)
    }
    function An(Vt, hn) {
        return $[Vt] !== hn ? (s.bindFramebuffer(Vt, hn),
        $[Vt] = hn,
        Vt === s.DRAW_FRAMEBUFFER && ($[s.FRAMEBUFFER] = hn),
        Vt === s.FRAMEBUFFER && ($[s.DRAW_FRAMEBUFFER] = hn),
        !0) : !1
    }
    function Ln(Vt, hn) {
        let an = tt
          , un = !1;
        if (Vt) {
            an = nt.get(hn),
            an === void 0 && (an = [],
            nt.set(hn, an));
            const En = Vt.textures;
            if (an.length !== En.length || an[0] !== s.COLOR_ATTACHMENT0) {
                for (let Hn = 0, Yn = En.length; Hn < Yn; Hn++)
                    an[Hn] = s.COLOR_ATTACHMENT0 + Hn;
                an.length = En.length,
                un = !0
            }
        } else
            an[0] !== s.BACK && (an[0] = s.BACK,
            un = !0);
        un && s.drawBuffers(an)
    }
    function _n(Vt) {
        return rt !== Vt ? (s.useProgram(Vt),
        rt = Vt,
        !0) : !1
    }
    const yn = {
        [AddEquation]: s.FUNC_ADD,
        [SubtractEquation]: s.FUNC_SUBTRACT,
        [ReverseSubtractEquation]: s.FUNC_REVERSE_SUBTRACT
    };
    yn[MinEquation] = s.MIN,
    yn[MaxEquation] = s.MAX;
    const Pt = {
        [ZeroFactor]: s.ZERO,
        [OneFactor]: s.ONE,
        [SrcColorFactor]: s.SRC_COLOR,
        [SrcAlphaFactor]: s.SRC_ALPHA,
        [SrcAlphaSaturateFactor]: s.SRC_ALPHA_SATURATE,
        [DstColorFactor]: s.DST_COLOR,
        [DstAlphaFactor]: s.DST_ALPHA,
        [OneMinusSrcColorFactor]: s.ONE_MINUS_SRC_COLOR,
        [OneMinusSrcAlphaFactor]: s.ONE_MINUS_SRC_ALPHA,
        [OneMinusDstColorFactor]: s.ONE_MINUS_DST_COLOR,
        [OneMinusDstAlphaFactor]: s.ONE_MINUS_DST_ALPHA,
        [ConstantColorFactor]: s.CONSTANT_COLOR,
        [OneMinusConstantColorFactor]: s.ONE_MINUS_CONSTANT_COLOR,
        [ConstantAlphaFactor]: s.CONSTANT_ALPHA,
        [OneMinusConstantAlphaFactor]: s.ONE_MINUS_CONSTANT_ALPHA
    };
    function Qt(Vt, hn, an, un, En, Hn, Yn, tr, hr, Jn) {
        if (Vt === NoBlending) {
            st === !0 && (Xt(s.BLEND),
            st = !1);
            return
        }
        if (st === !1 && (rn(s.BLEND),
        st = !0),
        Vt !== CustomBlending) {
            if (Vt !== lt || Jn !== vt) {
                if ((ct !== AddEquation || at !== AddEquation) && (s.blendEquation(s.FUNC_ADD),
                ct = AddEquation,
                at = AddEquation),
                Jn)
                    switch (Vt) {
                    case NormalBlending:
                        s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        s.blendFunc(s.ONE, s.ONE);
                        break;
                    case SubtractiveBlending:
                        s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                        break;
                    case MultiplyBlending:
                        s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Vt);
                        break
                    }
                else
                    switch (Vt) {
                    case NormalBlending:
                        s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        s.blendFunc(s.SRC_ALPHA, s.ONE);
                        break;
                    case SubtractiveBlending:
                        s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                        break;
                    case MultiplyBlending:
                        s.blendFunc(s.ZERO, s.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Vt);
                        break
                    }
                it = null,
                ot = null,
                ht = null,
                pt = null,
                dt.set(0, 0, 0),
                yt = 0,
                lt = Vt,
                vt = Jn
            }
            return
        }
        En = En || hn,
        Hn = Hn || an,
        Yn = Yn || un,
        (hn !== ct || En !== at) && (s.blendEquationSeparate(yn[hn], yn[En]),
        ct = hn,
        at = En),
        (an !== it || un !== ot || Hn !== ht || Yn !== pt) && (s.blendFuncSeparate(Pt[an], Pt[un], Pt[Hn], Pt[Yn]),
        it = an,
        ot = un,
        ht = Hn,
        pt = Yn),
        (tr.equals(dt) === !1 || hr !== yt) && (s.blendColor(tr.r, tr.g, tr.b, hr),
        dt.copy(tr),
        yt = hr),
        lt = Vt,
        vt = !1
    }
    function jt(Vt, hn) {
        Vt.side === DoubleSide ? Xt(s.CULL_FACE) : rn(s.CULL_FACE);
        let an = Vt.side === BackSide;
        hn && (an = !an),
        fn(an),
        Vt.blending === NormalBlending && Vt.transparent === !1 ? Qt(NoBlending) : Qt(Vt.blending, Vt.blendEquation, Vt.blendSrc, Vt.blendDst, Vt.blendEquationAlpha, Vt.blendSrcAlpha, Vt.blendDstAlpha, Vt.blendColor, Vt.blendAlpha, Vt.premultipliedAlpha),
        d.setFunc(Vt.depthFunc),
        d.setTest(Vt.depthTest),
        d.setMask(Vt.depthWrite),
        c.setMask(Vt.colorWrite);
        const un = Vt.stencilWrite;
        g.setTest(un),
        un && (g.setMask(Vt.stencilWriteMask),
        g.setFunc(Vt.stencilFunc, Vt.stencilRef, Vt.stencilFuncMask),
        g.setOp(Vt.stencilFail, Vt.stencilZFail, Vt.stencilZPass)),
        gn(Vt.polygonOffset, Vt.polygonOffsetFactor, Vt.polygonOffsetUnits),
        Vt.alphaToCoverage === !0 ? rn(s.SAMPLE_ALPHA_TO_COVERAGE) : Xt(s.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function fn(Vt) {
        xt !== Vt && (Vt ? s.frontFace(s.CW) : s.frontFace(s.CCW),
        xt = Vt)
    }
    function tn(Vt) {
        Vt !== CullFaceNone ? (rn(s.CULL_FACE),
        Vt !== _t && (Vt === CullFaceBack ? s.cullFace(s.BACK) : Vt === CullFaceFront ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Xt(s.CULL_FACE),
        _t = Vt
    }
    function bn(Vt) {
        Vt !== bt && (Dt && s.lineWidth(Vt),
        bt = Vt)
    }
    function gn(Vt, hn, an) {
        Vt ? (rn(s.POLYGON_OFFSET_FILL),
        (Rt !== hn || Ft !== an) && (s.polygonOffset(hn, an),
        Rt = hn,
        Ft = an)) : Xt(s.POLYGON_OFFSET_FILL)
    }
    function vn(Vt) {
        Vt ? rn(s.SCISSOR_TEST) : Xt(s.SCISSOR_TEST)
    }
    function Lt(Vt) {
        Vt === void 0 && (Vt = s.TEXTURE0 + Bt - 1),
        mt !== Vt && (s.activeTexture(Vt),
        mt = Vt)
    }
    function At(Vt, hn, an) {
        an === void 0 && (mt === null ? an = s.TEXTURE0 + Bt - 1 : an = mt);
        let un = St[an];
        un === void 0 && (un = {
            type: void 0,
            texture: void 0
        },
        St[an] = un),
        (un.type !== Vt || un.texture !== hn) && (mt !== an && (s.activeTexture(an),
        mt = an),
        s.bindTexture(Vt, hn || Yt[Vt]),
        un.type = Vt,
        un.texture = hn)
    }
    function $t() {
        const Vt = St[mt];
        Vt !== void 0 && Vt.type !== void 0 && (s.bindTexture(Vt.type, null),
        Vt.type = void 0,
        Vt.texture = void 0)
    }
    function on() {
        try {
            s.compressedTexImage2D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function sn() {
        try {
            s.compressedTexImage3D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function cn() {
        try {
            s.texSubImage2D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function Pn() {
        try {
            s.texSubImage3D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function dn() {
        try {
            s.compressedTexSubImage2D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function Tn() {
        try {
            s.compressedTexSubImage3D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function jn() {
        try {
            s.texStorage2D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function pn() {
        try {
            s.texStorage3D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function kn() {
        try {
            s.texImage2D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function er() {
        try {
            s.texImage3D.apply(s, arguments)
        } catch (Vt) {
            console.error("THREE.WebGLState:", Vt)
        }
    }
    function $n(Vt) {
        Ht.equals(Vt) === !1 && (s.scissor(Vt.x, Vt.y, Vt.z, Vt.w),
        Ht.copy(Vt))
    }
    function Dn(Vt) {
        en.equals(Vt) === !1 && (s.viewport(Vt.x, Vt.y, Vt.z, Vt.w),
        en.copy(Vt))
    }
    function Nt(Vt, hn) {
        let an = b.get(hn);
        an === void 0 && (an = new WeakMap,
        b.set(hn, an));
        let un = an.get(Vt);
        un === void 0 && (un = s.getUniformBlockIndex(hn, Vt.name),
        an.set(Vt, un))
    }
    function ln(Vt, hn) {
        const un = b.get(hn).get(Vt);
        _.get(hn) !== un && (s.uniformBlockBinding(hn, un, Vt.__bindingPointIndex),
        _.set(hn, un))
    }
    function Cn() {
        s.disable(s.BLEND),
        s.disable(s.CULL_FACE),
        s.disable(s.DEPTH_TEST),
        s.disable(s.POLYGON_OFFSET_FILL),
        s.disable(s.SCISSOR_TEST),
        s.disable(s.STENCIL_TEST),
        s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
        s.blendEquation(s.FUNC_ADD),
        s.blendFunc(s.ONE, s.ZERO),
        s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
        s.blendColor(0, 0, 0, 0),
        s.colorMask(!0, !0, !0, !0),
        s.clearColor(0, 0, 0, 0),
        s.depthMask(!0),
        s.depthFunc(s.LESS),
        s.clearDepth(1),
        s.stencilMask(4294967295),
        s.stencilFunc(s.ALWAYS, 0, 4294967295),
        s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
        s.clearStencil(0),
        s.cullFace(s.BACK),
        s.frontFace(s.CCW),
        s.polygonOffset(0, 0),
        s.activeTexture(s.TEXTURE0),
        s.bindFramebuffer(s.FRAMEBUFFER, null),
        s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
        s.bindFramebuffer(s.READ_FRAMEBUFFER, null),
        s.useProgram(null),
        s.lineWidth(1),
        s.scissor(0, 0, s.canvas.width, s.canvas.height),
        s.viewport(0, 0, s.canvas.width, s.canvas.height),
        j = {},
        mt = null,
        St = {},
        $ = {},
        nt = new WeakMap,
        tt = [],
        rt = null,
        st = !1,
        lt = null,
        ct = null,
        it = null,
        ot = null,
        at = null,
        ht = null,
        pt = null,
        dt = new Color(0,0,0),
        yt = 0,
        vt = !1,
        xt = null,
        _t = null,
        bt = null,
        Rt = null,
        Ft = null,
        Ht.set(0, 0, s.canvas.width, s.canvas.height),
        en.set(0, 0, s.canvas.width, s.canvas.height),
        c.reset(),
        d.reset(),
        g.reset()
    }
    return {
        buffers: {
            color: c,
            depth: d,
            stencil: g
        },
        enable: rn,
        disable: Xt,
        bindFramebuffer: An,
        drawBuffers: Ln,
        useProgram: _n,
        setBlending: Qt,
        setMaterial: jt,
        setFlipSided: fn,
        setCullFace: tn,
        setLineWidth: bn,
        setPolygonOffset: gn,
        setScissorTest: vn,
        activeTexture: Lt,
        bindTexture: At,
        unbindTexture: $t,
        compressedTexImage2D: on,
        compressedTexImage3D: sn,
        texImage2D: kn,
        texImage3D: er,
        updateUBOMapping: Nt,
        uniformBlockBinding: ln,
        texStorage2D: jn,
        texStorage3D: pn,
        texSubImage2D: cn,
        texSubImage3D: Pn,
        compressedTexSubImage2D: dn,
        compressedTexSubImage3D: Tn,
        scissor: $n,
        viewport: Dn,
        reset: Cn
    }
}
function contain(s, e) {
    const a = s.image && s.image.width ? s.image.width / s.image.height : 1;
    return a > e ? (s.repeat.x = 1,
    s.repeat.y = a / e,
    s.offset.x = 0,
    s.offset.y = (1 - s.repeat.y) / 2) : (s.repeat.x = e / a,
    s.repeat.y = 1,
    s.offset.x = (1 - s.repeat.x) / 2,
    s.offset.y = 0),
    s
}
function cover(s, e) {
    const a = s.image && s.image.width ? s.image.width / s.image.height : 1;
    return a > e ? (s.repeat.x = e / a,
    s.repeat.y = 1,
    s.offset.x = (1 - s.repeat.x) / 2,
    s.offset.y = 0) : (s.repeat.x = 1,
    s.repeat.y = a / e,
    s.offset.x = 0,
    s.offset.y = (1 - s.repeat.y) / 2),
    s
}
function fill(s) {
    return s.repeat.x = 1,
    s.repeat.y = 1,
    s.offset.x = 0,
    s.offset.y = 0,
    s
}
function getByteLength(s, e, a, o) {
    const c = getTextureTypeByteLength(o);
    switch (a) {
    case AlphaFormat:
        return s * e;
    case LuminanceFormat:
        return s * e;
    case LuminanceAlphaFormat:
        return s * e * 2;
    case RedFormat:
        return s * e / c.components * c.byteLength;
    case RedIntegerFormat:
        return s * e / c.components * c.byteLength;
    case RGFormat:
        return s * e * 2 / c.components * c.byteLength;
    case RGIntegerFormat:
        return s * e * 2 / c.components * c.byteLength;
    case RGBFormat:
        return s * e * 3 / c.components * c.byteLength;
    case RGBAFormat:
        return s * e * 4 / c.components * c.byteLength;
    case RGBAIntegerFormat:
        return s * e * 4 / c.components * c.byteLength;
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
        return Math.max(s, 16) * Math.max(e, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
        return Math.max(s, 8) * Math.max(e, 8) / 2;
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_4x4_Format:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
        return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
        return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
        return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
        return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
        return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
        return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
        return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
        return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
        return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
        return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
        return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
        return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
        return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${a} format.`)
}
function getTextureTypeByteLength(s) {
    switch (s) {
    case UnsignedByteType:
    case ByteType:
        return {
            byteLength: 1,
            components: 1
        };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
        return {
            byteLength: 2,
            components: 1
        };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
        return {
            byteLength: 2,
            components: 4
        };
    case UnsignedIntType:
    case IntType:
    case FloatType:
        return {
            byteLength: 4,
            components: 1
        };
    case UnsignedInt5999Type:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${s}.`)
}
const TextureUtils = {
    contain,
    cover,
    fill,
    getByteLength
};
function WebGLTextures(s, e, a, o, c, d, g) {
    const _ = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , b = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , j = new Vector2
      , $ = new WeakMap;
    let nt;
    const tt = new WeakMap;
    let rt = !1;
    try {
        rt = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function st(Lt, At) {
        return rt ? new OffscreenCanvas(Lt,At) : createElementNS("canvas")
    }
    function lt(Lt, At, $t) {
        let on = 1;
        const sn = vn(Lt);
        if ((sn.width > $t || sn.height > $t) && (on = $t / Math.max(sn.width, sn.height)),
        on < 1)
            if (typeof HTMLImageElement < "u" && Lt instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Lt instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Lt instanceof ImageBitmap || typeof VideoFrame < "u" && Lt instanceof VideoFrame) {
                const cn = Math.floor(on * sn.width)
                  , Pn = Math.floor(on * sn.height);
                nt === void 0 && (nt = st(cn, Pn));
                const dn = At ? st(cn, Pn) : nt;
                return dn.width = cn,
                dn.height = Pn,
                dn.getContext("2d").drawImage(Lt, 0, 0, cn, Pn),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + sn.width + "x" + sn.height + ") to (" + cn + "x" + Pn + ")."),
                dn
            } else
                return "data"in Lt && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + sn.width + "x" + sn.height + ")."),
                Lt;
        return Lt
    }
    function ct(Lt) {
        return Lt.generateMipmaps && Lt.minFilter !== NearestFilter && Lt.minFilter !== LinearFilter
    }
    function it(Lt) {
        s.generateMipmap(Lt)
    }
    function ot(Lt, At, $t, on, sn=!1) {
        if (Lt !== null) {
            if (s[Lt] !== void 0)
                return s[Lt];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Lt + "'")
        }
        let cn = At;
        if (At === s.RED && ($t === s.FLOAT && (cn = s.R32F),
        $t === s.HALF_FLOAT && (cn = s.R16F),
        $t === s.UNSIGNED_BYTE && (cn = s.R8)),
        At === s.RED_INTEGER && ($t === s.UNSIGNED_BYTE && (cn = s.R8UI),
        $t === s.UNSIGNED_SHORT && (cn = s.R16UI),
        $t === s.UNSIGNED_INT && (cn = s.R32UI),
        $t === s.BYTE && (cn = s.R8I),
        $t === s.SHORT && (cn = s.R16I),
        $t === s.INT && (cn = s.R32I)),
        At === s.RG && ($t === s.FLOAT && (cn = s.RG32F),
        $t === s.HALF_FLOAT && (cn = s.RG16F),
        $t === s.UNSIGNED_BYTE && (cn = s.RG8)),
        At === s.RG_INTEGER && ($t === s.UNSIGNED_BYTE && (cn = s.RG8UI),
        $t === s.UNSIGNED_SHORT && (cn = s.RG16UI),
        $t === s.UNSIGNED_INT && (cn = s.RG32UI),
        $t === s.BYTE && (cn = s.RG8I),
        $t === s.SHORT && (cn = s.RG16I),
        $t === s.INT && (cn = s.RG32I)),
        At === s.RGB && $t === s.UNSIGNED_INT_5_9_9_9_REV && (cn = s.RGB9_E5),
        At === s.RGBA) {
            const Pn = sn ? LinearTransfer : ColorManagement.getTransfer(on);
            $t === s.FLOAT && (cn = s.RGBA32F),
            $t === s.HALF_FLOAT && (cn = s.RGBA16F),
            $t === s.UNSIGNED_BYTE && (cn = Pn === SRGBTransfer ? s.SRGB8_ALPHA8 : s.RGBA8),
            $t === s.UNSIGNED_SHORT_4_4_4_4 && (cn = s.RGBA4),
            $t === s.UNSIGNED_SHORT_5_5_5_1 && (cn = s.RGB5_A1)
        }
        return (cn === s.R16F || cn === s.R32F || cn === s.RG16F || cn === s.RG32F || cn === s.RGBA16F || cn === s.RGBA32F) && e.get("EXT_color_buffer_float"),
        cn
    }
    function at(Lt, At) {
        let $t;
        return Lt ? At === null || At === UnsignedIntType || At === UnsignedInt248Type ? $t = s.DEPTH24_STENCIL8 : At === FloatType ? $t = s.DEPTH32F_STENCIL8 : At === UnsignedShortType && ($t = s.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : At === null || At === UnsignedIntType || At === UnsignedInt248Type ? $t = s.DEPTH_COMPONENT24 : At === FloatType ? $t = s.DEPTH_COMPONENT32F : At === UnsignedShortType && ($t = s.DEPTH_COMPONENT16),
        $t
    }
    function ht(Lt, At) {
        return ct(Lt) === !0 || Lt.isFramebufferTexture && Lt.minFilter !== NearestFilter && Lt.minFilter !== LinearFilter ? Math.log2(Math.max(At.width, At.height)) + 1 : Lt.mipmaps !== void 0 && Lt.mipmaps.length > 0 ? Lt.mipmaps.length : Lt.isCompressedTexture && Array.isArray(Lt.image) ? At.mipmaps.length : 1
    }
    function pt(Lt) {
        const At = Lt.target;
        At.removeEventListener("dispose", pt),
        yt(At),
        At.isVideoTexture && $.delete(At)
    }
    function dt(Lt) {
        const At = Lt.target;
        At.removeEventListener("dispose", dt),
        xt(At)
    }
    function yt(Lt) {
        const At = o.get(Lt);
        if (At.__webglInit === void 0)
            return;
        const $t = Lt.source
          , on = tt.get($t);
        if (on) {
            const sn = on[At.__cacheKey];
            sn.usedTimes--,
            sn.usedTimes === 0 && vt(Lt),
            Object.keys(on).length === 0 && tt.delete($t)
        }
        o.remove(Lt)
    }
    function vt(Lt) {
        const At = o.get(Lt);
        s.deleteTexture(At.__webglTexture);
        const $t = Lt.source
          , on = tt.get($t);
        delete on[At.__cacheKey],
        g.memory.textures--
    }
    function xt(Lt) {
        const At = o.get(Lt);
        if (Lt.depthTexture && Lt.depthTexture.dispose(),
        Lt.isWebGLCubeRenderTarget)
            for (let on = 0; on < 6; on++) {
                if (Array.isArray(At.__webglFramebuffer[on]))
                    for (let sn = 0; sn < At.__webglFramebuffer[on].length; sn++)
                        s.deleteFramebuffer(At.__webglFramebuffer[on][sn]);
                else
                    s.deleteFramebuffer(At.__webglFramebuffer[on]);
                At.__webglDepthbuffer && s.deleteRenderbuffer(At.__webglDepthbuffer[on])
            }
        else {
            if (Array.isArray(At.__webglFramebuffer))
                for (let on = 0; on < At.__webglFramebuffer.length; on++)
                    s.deleteFramebuffer(At.__webglFramebuffer[on]);
            else
                s.deleteFramebuffer(At.__webglFramebuffer);
            if (At.__webglDepthbuffer && s.deleteRenderbuffer(At.__webglDepthbuffer),
            At.__webglMultisampledFramebuffer && s.deleteFramebuffer(At.__webglMultisampledFramebuffer),
            At.__webglColorRenderbuffer)
                for (let on = 0; on < At.__webglColorRenderbuffer.length; on++)
                    At.__webglColorRenderbuffer[on] && s.deleteRenderbuffer(At.__webglColorRenderbuffer[on]);
            At.__webglDepthRenderbuffer && s.deleteRenderbuffer(At.__webglDepthRenderbuffer)
        }
        const $t = Lt.textures;
        for (let on = 0, sn = $t.length; on < sn; on++) {
            const cn = o.get($t[on]);
            cn.__webglTexture && (s.deleteTexture(cn.__webglTexture),
            g.memory.textures--),
            o.remove($t[on])
        }
        o.remove(Lt)
    }
    let _t = 0;
    function bt() {
        _t = 0
    }
    function Rt() {
        const Lt = _t;
        return Lt >= c.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Lt + " texture units while this GPU supports only " + c.maxTextures),
        _t += 1,
        Lt
    }
    function Ft(Lt) {
        const At = [];
        return At.push(Lt.wrapS),
        At.push(Lt.wrapT),
        At.push(Lt.wrapR || 0),
        At.push(Lt.magFilter),
        At.push(Lt.minFilter),
        At.push(Lt.anisotropy),
        At.push(Lt.internalFormat),
        At.push(Lt.format),
        At.push(Lt.type),
        At.push(Lt.generateMipmaps),
        At.push(Lt.premultiplyAlpha),
        At.push(Lt.flipY),
        At.push(Lt.unpackAlignment),
        At.push(Lt.colorSpace),
        At.join()
    }
    function Bt(Lt, At) {
        const $t = o.get(Lt);
        if (Lt.isVideoTexture && bn(Lt),
        Lt.isRenderTargetTexture === !1 && Lt.version > 0 && $t.__version !== Lt.version) {
            const on = Lt.image;
            if (on === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (on.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                en($t, Lt, At);
                return
            }
        }
        a.bindTexture(s.TEXTURE_2D, $t.__webglTexture, s.TEXTURE0 + At)
    }
    function Dt(Lt, At) {
        const $t = o.get(Lt);
        if (Lt.version > 0 && $t.__version !== Lt.version) {
            en($t, Lt, At);
            return
        }
        a.bindTexture(s.TEXTURE_2D_ARRAY, $t.__webglTexture, s.TEXTURE0 + At)
    }
    function Mt(Lt, At) {
        const $t = o.get(Lt);
        if (Lt.version > 0 && $t.__version !== Lt.version) {
            en($t, Lt, At);
            return
        }
        a.bindTexture(s.TEXTURE_3D, $t.__webglTexture, s.TEXTURE0 + At)
    }
    function Tt(Lt, At) {
        const $t = o.get(Lt);
        if (Lt.version > 0 && $t.__version !== Lt.version) {
            Ot($t, Lt, At);
            return
        }
        a.bindTexture(s.TEXTURE_CUBE_MAP, $t.__webglTexture, s.TEXTURE0 + At)
    }
    const mt = {
        [RepeatWrapping]: s.REPEAT,
        [ClampToEdgeWrapping]: s.CLAMP_TO_EDGE,
        [MirroredRepeatWrapping]: s.MIRRORED_REPEAT
    }
      , St = {
        [NearestFilter]: s.NEAREST,
        [NearestMipmapNearestFilter]: s.NEAREST_MIPMAP_NEAREST,
        [NearestMipmapLinearFilter]: s.NEAREST_MIPMAP_LINEAR,
        [LinearFilter]: s.LINEAR,
        [LinearMipmapNearestFilter]: s.LINEAR_MIPMAP_NEAREST,
        [LinearMipmapLinearFilter]: s.LINEAR_MIPMAP_LINEAR
    }
      , wt = {
        [NeverCompare]: s.NEVER,
        [AlwaysCompare]: s.ALWAYS,
        [LessCompare]: s.LESS,
        [LessEqualCompare]: s.LEQUAL,
        [EqualCompare]: s.EQUAL,
        [GreaterEqualCompare]: s.GEQUAL,
        [GreaterCompare]: s.GREATER,
        [NotEqualCompare]: s.NOTEQUAL
    };
    function Ct(Lt, At) {
        if (At.type === FloatType && e.has("OES_texture_float_linear") === !1 && (At.magFilter === LinearFilter || At.magFilter === LinearMipmapNearestFilter || At.magFilter === NearestMipmapLinearFilter || At.magFilter === LinearMipmapLinearFilter || At.minFilter === LinearFilter || At.minFilter === LinearMipmapNearestFilter || At.minFilter === NearestMipmapLinearFilter || At.minFilter === LinearMipmapLinearFilter) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        s.texParameteri(Lt, s.TEXTURE_WRAP_S, mt[At.wrapS]),
        s.texParameteri(Lt, s.TEXTURE_WRAP_T, mt[At.wrapT]),
        (Lt === s.TEXTURE_3D || Lt === s.TEXTURE_2D_ARRAY) && s.texParameteri(Lt, s.TEXTURE_WRAP_R, mt[At.wrapR]),
        s.texParameteri(Lt, s.TEXTURE_MAG_FILTER, St[At.magFilter]),
        s.texParameteri(Lt, s.TEXTURE_MIN_FILTER, St[At.minFilter]),
        At.compareFunction && (s.texParameteri(Lt, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(Lt, s.TEXTURE_COMPARE_FUNC, wt[At.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (At.magFilter === NearestFilter || At.minFilter !== NearestMipmapLinearFilter && At.minFilter !== LinearMipmapLinearFilter || At.type === FloatType && e.has("OES_texture_float_linear") === !1)
                return;
            if (At.anisotropy > 1 || o.get(At).__currentAnisotropy) {
                const $t = e.get("EXT_texture_filter_anisotropic");
                s.texParameterf(Lt, $t.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(At.anisotropy, c.getMaxAnisotropy())),
                o.get(At).__currentAnisotropy = At.anisotropy
            }
        }
    }
    function Ht(Lt, At) {
        let $t = !1;
        Lt.__webglInit === void 0 && (Lt.__webglInit = !0,
        At.addEventListener("dispose", pt));
        const on = At.source;
        let sn = tt.get(on);
        sn === void 0 && (sn = {},
        tt.set(on, sn));
        const cn = Ft(At);
        if (cn !== Lt.__cacheKey) {
            sn[cn] === void 0 && (sn[cn] = {
                texture: s.createTexture(),
                usedTimes: 0
            },
            g.memory.textures++,
            $t = !0),
            sn[cn].usedTimes++;
            const Pn = sn[Lt.__cacheKey];
            Pn !== void 0 && (sn[Lt.__cacheKey].usedTimes--,
            Pn.usedTimes === 0 && vt(At)),
            Lt.__cacheKey = cn,
            Lt.__webglTexture = sn[cn].texture
        }
        return $t
    }
    function en(Lt, At, $t) {
        let on = s.TEXTURE_2D;
        (At.isDataArrayTexture || At.isCompressedArrayTexture) && (on = s.TEXTURE_2D_ARRAY),
        At.isData3DTexture && (on = s.TEXTURE_3D);
        const sn = Ht(Lt, At)
          , cn = At.source;
        a.bindTexture(on, Lt.__webglTexture, s.TEXTURE0 + $t);
        const Pn = o.get(cn);
        if (cn.version !== Pn.__version || sn === !0) {
            a.activeTexture(s.TEXTURE0 + $t);
            const dn = ColorManagement.getPrimaries(ColorManagement.workingColorSpace)
              , Tn = At.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(At.colorSpace)
              , jn = At.colorSpace === NoColorSpace || dn === Tn ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, At.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, At.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, At.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, jn);
            let pn = lt(At.image, !1, c.maxTextureSize);
            pn = gn(At, pn);
            const kn = d.convert(At.format, At.colorSpace)
              , er = d.convert(At.type);
            let $n = ot(At.internalFormat, kn, er, At.colorSpace, At.isVideoTexture);
            Ct(on, At);
            let Dn;
            const Nt = At.mipmaps
              , ln = At.isVideoTexture !== !0
              , Cn = Pn.__version === void 0 || sn === !0
              , Vt = cn.dataReady
              , hn = ht(At, pn);
            if (At.isDepthTexture)
                $n = at(At.format === DepthStencilFormat, At.type),
                Cn && (ln ? a.texStorage2D(s.TEXTURE_2D, 1, $n, pn.width, pn.height) : a.texImage2D(s.TEXTURE_2D, 0, $n, pn.width, pn.height, 0, kn, er, null));
            else if (At.isDataTexture)
                if (Nt.length > 0) {
                    ln && Cn && a.texStorage2D(s.TEXTURE_2D, hn, $n, Nt[0].width, Nt[0].height);
                    for (let an = 0, un = Nt.length; an < un; an++)
                        Dn = Nt[an],
                        ln ? Vt && a.texSubImage2D(s.TEXTURE_2D, an, 0, 0, Dn.width, Dn.height, kn, er, Dn.data) : a.texImage2D(s.TEXTURE_2D, an, $n, Dn.width, Dn.height, 0, kn, er, Dn.data);
                    At.generateMipmaps = !1
                } else
                    ln ? (Cn && a.texStorage2D(s.TEXTURE_2D, hn, $n, pn.width, pn.height),
                    Vt && a.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, pn.width, pn.height, kn, er, pn.data)) : a.texImage2D(s.TEXTURE_2D, 0, $n, pn.width, pn.height, 0, kn, er, pn.data);
            else if (At.isCompressedTexture)
                if (At.isCompressedArrayTexture) {
                    ln && Cn && a.texStorage3D(s.TEXTURE_2D_ARRAY, hn, $n, Nt[0].width, Nt[0].height, pn.depth);
                    for (let an = 0, un = Nt.length; an < un; an++)
                        if (Dn = Nt[an],
                        At.format !== RGBAFormat)
                            if (kn !== null)
                                if (ln) {
                                    if (Vt)
                                        if (At.layerUpdates.size > 0) {
                                            const En = getByteLength(Dn.width, Dn.height, At.format, At.type);
                                            for (const Hn of At.layerUpdates) {
                                                const Yn = Dn.data.subarray(Hn * En / Dn.data.BYTES_PER_ELEMENT, (Hn + 1) * En / Dn.data.BYTES_PER_ELEMENT);
                                                a.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, an, 0, 0, Hn, Dn.width, Dn.height, 1, kn, Yn, 0, 0)
                                            }
                                            At.clearLayerUpdates()
                                        } else
                                            a.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, an, 0, 0, 0, Dn.width, Dn.height, pn.depth, kn, Dn.data, 0, 0)
                                } else
                                    a.compressedTexImage3D(s.TEXTURE_2D_ARRAY, an, $n, Dn.width, Dn.height, pn.depth, 0, Dn.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            ln ? Vt && a.texSubImage3D(s.TEXTURE_2D_ARRAY, an, 0, 0, 0, Dn.width, Dn.height, pn.depth, kn, er, Dn.data) : a.texImage3D(s.TEXTURE_2D_ARRAY, an, $n, Dn.width, Dn.height, pn.depth, 0, kn, er, Dn.data)
                } else {
                    ln && Cn && a.texStorage2D(s.TEXTURE_2D, hn, $n, Nt[0].width, Nt[0].height);
                    for (let an = 0, un = Nt.length; an < un; an++)
                        Dn = Nt[an],
                        At.format !== RGBAFormat ? kn !== null ? ln ? Vt && a.compressedTexSubImage2D(s.TEXTURE_2D, an, 0, 0, Dn.width, Dn.height, kn, Dn.data) : a.compressedTexImage2D(s.TEXTURE_2D, an, $n, Dn.width, Dn.height, 0, Dn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ln ? Vt && a.texSubImage2D(s.TEXTURE_2D, an, 0, 0, Dn.width, Dn.height, kn, er, Dn.data) : a.texImage2D(s.TEXTURE_2D, an, $n, Dn.width, Dn.height, 0, kn, er, Dn.data)
                }
            else if (At.isDataArrayTexture)
                if (ln) {
                    if (Cn && a.texStorage3D(s.TEXTURE_2D_ARRAY, hn, $n, pn.width, pn.height, pn.depth),
                    Vt)
                        if (At.layerUpdates.size > 0) {
                            const an = getByteLength(pn.width, pn.height, At.format, At.type);
                            for (const un of At.layerUpdates) {
                                const En = pn.data.subarray(un * an / pn.data.BYTES_PER_ELEMENT, (un + 1) * an / pn.data.BYTES_PER_ELEMENT);
                                a.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, un, pn.width, pn.height, 1, kn, er, En)
                            }
                            At.clearLayerUpdates()
                        } else
                            a.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, pn.width, pn.height, pn.depth, kn, er, pn.data)
                } else
                    a.texImage3D(s.TEXTURE_2D_ARRAY, 0, $n, pn.width, pn.height, pn.depth, 0, kn, er, pn.data);
            else if (At.isData3DTexture)
                ln ? (Cn && a.texStorage3D(s.TEXTURE_3D, hn, $n, pn.width, pn.height, pn.depth),
                Vt && a.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, pn.width, pn.height, pn.depth, kn, er, pn.data)) : a.texImage3D(s.TEXTURE_3D, 0, $n, pn.width, pn.height, pn.depth, 0, kn, er, pn.data);
            else if (At.isFramebufferTexture) {
                if (Cn)
                    if (ln)
                        a.texStorage2D(s.TEXTURE_2D, hn, $n, pn.width, pn.height);
                    else {
                        let an = pn.width
                          , un = pn.height;
                        for (let En = 0; En < hn; En++)
                            a.texImage2D(s.TEXTURE_2D, En, $n, an, un, 0, kn, er, null),
                            an >>= 1,
                            un >>= 1
                    }
            } else if (Nt.length > 0) {
                if (ln && Cn) {
                    const an = vn(Nt[0]);
                    a.texStorage2D(s.TEXTURE_2D, hn, $n, an.width, an.height)
                }
                for (let an = 0, un = Nt.length; an < un; an++)
                    Dn = Nt[an],
                    ln ? Vt && a.texSubImage2D(s.TEXTURE_2D, an, 0, 0, kn, er, Dn) : a.texImage2D(s.TEXTURE_2D, an, $n, kn, er, Dn);
                At.generateMipmaps = !1
            } else if (ln) {
                if (Cn) {
                    const an = vn(pn);
                    a.texStorage2D(s.TEXTURE_2D, hn, $n, an.width, an.height)
                }
                Vt && a.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, kn, er, pn)
            } else
                a.texImage2D(s.TEXTURE_2D, 0, $n, kn, er, pn);
            ct(At) && it(on),
            Pn.__version = cn.version,
            At.onUpdate && At.onUpdate(At)
        }
        Lt.__version = At.version
    }
    function Ot(Lt, At, $t) {
        if (At.image.length !== 6)
            return;
        const on = Ht(Lt, At)
          , sn = At.source;
        a.bindTexture(s.TEXTURE_CUBE_MAP, Lt.__webglTexture, s.TEXTURE0 + $t);
        const cn = o.get(sn);
        if (sn.version !== cn.__version || on === !0) {
            a.activeTexture(s.TEXTURE0 + $t);
            const Pn = ColorManagement.getPrimaries(ColorManagement.workingColorSpace)
              , dn = At.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(At.colorSpace)
              , Tn = At.colorSpace === NoColorSpace || Pn === dn ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, At.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, At.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, At.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Tn);
            const jn = At.isCompressedTexture || At.image[0].isCompressedTexture
              , pn = At.image[0] && At.image[0].isDataTexture
              , kn = [];
            for (let un = 0; un < 6; un++)
                !jn && !pn ? kn[un] = lt(At.image[un], !0, c.maxCubemapSize) : kn[un] = pn ? At.image[un].image : At.image[un],
                kn[un] = gn(At, kn[un]);
            const er = kn[0]
              , $n = d.convert(At.format, At.colorSpace)
              , Dn = d.convert(At.type)
              , Nt = ot(At.internalFormat, $n, Dn, At.colorSpace)
              , ln = At.isVideoTexture !== !0
              , Cn = cn.__version === void 0 || on === !0
              , Vt = sn.dataReady;
            let hn = ht(At, er);
            Ct(s.TEXTURE_CUBE_MAP, At);
            let an;
            if (jn) {
                ln && Cn && a.texStorage2D(s.TEXTURE_CUBE_MAP, hn, Nt, er.width, er.height);
                for (let un = 0; un < 6; un++) {
                    an = kn[un].mipmaps;
                    for (let En = 0; En < an.length; En++) {
                        const Hn = an[En];
                        At.format !== RGBAFormat ? $n !== null ? ln ? Vt && a.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En, 0, 0, Hn.width, Hn.height, $n, Hn.data) : a.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En, Nt, Hn.width, Hn.height, 0, Hn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ln ? Vt && a.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En, 0, 0, Hn.width, Hn.height, $n, Dn, Hn.data) : a.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En, Nt, Hn.width, Hn.height, 0, $n, Dn, Hn.data)
                    }
                }
            } else {
                if (an = At.mipmaps,
                ln && Cn) {
                    an.length > 0 && hn++;
                    const un = vn(kn[0]);
                    a.texStorage2D(s.TEXTURE_CUBE_MAP, hn, Nt, un.width, un.height)
                }
                for (let un = 0; un < 6; un++)
                    if (pn) {
                        ln ? Vt && a.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, 0, 0, 0, kn[un].width, kn[un].height, $n, Dn, kn[un].data) : a.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, 0, Nt, kn[un].width, kn[un].height, 0, $n, Dn, kn[un].data);
                        for (let En = 0; En < an.length; En++) {
                            const Yn = an[En].image[un].image;
                            ln ? Vt && a.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En + 1, 0, 0, Yn.width, Yn.height, $n, Dn, Yn.data) : a.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En + 1, Nt, Yn.width, Yn.height, 0, $n, Dn, Yn.data)
                        }
                    } else {
                        ln ? Vt && a.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, 0, 0, 0, $n, Dn, kn[un]) : a.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, 0, Nt, $n, Dn, kn[un]);
                        for (let En = 0; En < an.length; En++) {
                            const Hn = an[En];
                            ln ? Vt && a.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En + 1, 0, 0, $n, Dn, Hn.image[un]) : a.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + un, En + 1, Nt, $n, Dn, Hn.image[un])
                        }
                    }
            }
            ct(At) && it(s.TEXTURE_CUBE_MAP),
            cn.__version = sn.version,
            At.onUpdate && At.onUpdate(At)
        }
        Lt.__version = At.version
    }
    function Yt(Lt, At, $t, on, sn, cn) {
        const Pn = d.convert($t.format, $t.colorSpace)
          , dn = d.convert($t.type)
          , Tn = ot($t.internalFormat, Pn, dn, $t.colorSpace);
        if (!o.get(At).__hasExternalTextures) {
            const pn = Math.max(1, At.width >> cn)
              , kn = Math.max(1, At.height >> cn);
            sn === s.TEXTURE_3D || sn === s.TEXTURE_2D_ARRAY ? a.texImage3D(sn, cn, Tn, pn, kn, At.depth, 0, Pn, dn, null) : a.texImage2D(sn, cn, Tn, pn, kn, 0, Pn, dn, null)
        }
        a.bindFramebuffer(s.FRAMEBUFFER, Lt),
        tn(At) ? _.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, on, sn, o.get($t).__webglTexture, 0, fn(At)) : (sn === s.TEXTURE_2D || sn >= s.TEXTURE_CUBE_MAP_POSITIVE_X && sn <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, on, sn, o.get($t).__webglTexture, cn),
        a.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function rn(Lt, At, $t) {
        if (s.bindRenderbuffer(s.RENDERBUFFER, Lt),
        At.depthBuffer) {
            const on = At.depthTexture
              , sn = on && on.isDepthTexture ? on.type : null
              , cn = at(At.stencilBuffer, sn)
              , Pn = At.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
              , dn = fn(At);
            tn(At) ? _.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, dn, cn, At.width, At.height) : $t ? s.renderbufferStorageMultisample(s.RENDERBUFFER, dn, cn, At.width, At.height) : s.renderbufferStorage(s.RENDERBUFFER, cn, At.width, At.height),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, Pn, s.RENDERBUFFER, Lt)
        } else {
            const on = At.textures;
            for (let sn = 0; sn < on.length; sn++) {
                const cn = on[sn]
                  , Pn = d.convert(cn.format, cn.colorSpace)
                  , dn = d.convert(cn.type)
                  , Tn = ot(cn.internalFormat, Pn, dn, cn.colorSpace)
                  , jn = fn(At);
                $t && tn(At) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, jn, Tn, At.width, At.height) : tn(At) ? _.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, jn, Tn, At.width, At.height) : s.renderbufferStorage(s.RENDERBUFFER, Tn, At.width, At.height)
            }
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null)
    }
    function Xt(Lt, At) {
        if (At && At.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (a.bindFramebuffer(s.FRAMEBUFFER, Lt),
        !(At.depthTexture && At.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!o.get(At.depthTexture).__webglTexture || At.depthTexture.image.width !== At.width || At.depthTexture.image.height !== At.height) && (At.depthTexture.image.width = At.width,
        At.depthTexture.image.height = At.height,
        At.depthTexture.needsUpdate = !0),
        Bt(At.depthTexture, 0);
        const on = o.get(At.depthTexture).__webglTexture
          , sn = fn(At);
        if (At.depthTexture.format === DepthFormat)
            tn(At) ? _.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, on, 0, sn) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, on, 0);
        else if (At.depthTexture.format === DepthStencilFormat)
            tn(At) ? _.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, on, 0, sn) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, on, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function An(Lt) {
        const At = o.get(Lt)
          , $t = Lt.isWebGLCubeRenderTarget === !0;
        if (Lt.depthTexture && !At.__autoAllocateDepthBuffer) {
            if ($t)
                throw new Error("target.depthTexture not supported in Cube render targets");
            Xt(At.__webglFramebuffer, Lt)
        } else if ($t) {
            At.__webglDepthbuffer = [];
            for (let on = 0; on < 6; on++)
                a.bindFramebuffer(s.FRAMEBUFFER, At.__webglFramebuffer[on]),
                At.__webglDepthbuffer[on] = s.createRenderbuffer(),
                rn(At.__webglDepthbuffer[on], Lt, !1)
        } else
            a.bindFramebuffer(s.FRAMEBUFFER, At.__webglFramebuffer),
            At.__webglDepthbuffer = s.createRenderbuffer(),
            rn(At.__webglDepthbuffer, Lt, !1);
        a.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function Ln(Lt, At, $t) {
        const on = o.get(Lt);
        At !== void 0 && Yt(on.__webglFramebuffer, Lt, Lt.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0),
        $t !== void 0 && An(Lt)
    }
    function _n(Lt) {
        const At = Lt.texture
          , $t = o.get(Lt)
          , on = o.get(At);
        Lt.addEventListener("dispose", dt);
        const sn = Lt.textures
          , cn = Lt.isWebGLCubeRenderTarget === !0
          , Pn = sn.length > 1;
        if (Pn || (on.__webglTexture === void 0 && (on.__webglTexture = s.createTexture()),
        on.__version = At.version,
        g.memory.textures++),
        cn) {
            $t.__webglFramebuffer = [];
            for (let dn = 0; dn < 6; dn++)
                if (At.mipmaps && At.mipmaps.length > 0) {
                    $t.__webglFramebuffer[dn] = [];
                    for (let Tn = 0; Tn < At.mipmaps.length; Tn++)
                        $t.__webglFramebuffer[dn][Tn] = s.createFramebuffer()
                } else
                    $t.__webglFramebuffer[dn] = s.createFramebuffer()
        } else {
            if (At.mipmaps && At.mipmaps.length > 0) {
                $t.__webglFramebuffer = [];
                for (let dn = 0; dn < At.mipmaps.length; dn++)
                    $t.__webglFramebuffer[dn] = s.createFramebuffer()
            } else
                $t.__webglFramebuffer = s.createFramebuffer();
            if (Pn)
                for (let dn = 0, Tn = sn.length; dn < Tn; dn++) {
                    const jn = o.get(sn[dn]);
                    jn.__webglTexture === void 0 && (jn.__webglTexture = s.createTexture(),
                    g.memory.textures++)
                }
            if (Lt.samples > 0 && tn(Lt) === !1) {
                $t.__webglMultisampledFramebuffer = s.createFramebuffer(),
                $t.__webglColorRenderbuffer = [],
                a.bindFramebuffer(s.FRAMEBUFFER, $t.__webglMultisampledFramebuffer);
                for (let dn = 0; dn < sn.length; dn++) {
                    const Tn = sn[dn];
                    $t.__webglColorRenderbuffer[dn] = s.createRenderbuffer(),
                    s.bindRenderbuffer(s.RENDERBUFFER, $t.__webglColorRenderbuffer[dn]);
                    const jn = d.convert(Tn.format, Tn.colorSpace)
                      , pn = d.convert(Tn.type)
                      , kn = ot(Tn.internalFormat, jn, pn, Tn.colorSpace, Lt.isXRRenderTarget === !0)
                      , er = fn(Lt);
                    s.renderbufferStorageMultisample(s.RENDERBUFFER, er, kn, Lt.width, Lt.height),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + dn, s.RENDERBUFFER, $t.__webglColorRenderbuffer[dn])
                }
                s.bindRenderbuffer(s.RENDERBUFFER, null),
                Lt.depthBuffer && ($t.__webglDepthRenderbuffer = s.createRenderbuffer(),
                rn($t.__webglDepthRenderbuffer, Lt, !0)),
                a.bindFramebuffer(s.FRAMEBUFFER, null)
            }
        }
        if (cn) {
            a.bindTexture(s.TEXTURE_CUBE_MAP, on.__webglTexture),
            Ct(s.TEXTURE_CUBE_MAP, At);
            for (let dn = 0; dn < 6; dn++)
                if (At.mipmaps && At.mipmaps.length > 0)
                    for (let Tn = 0; Tn < At.mipmaps.length; Tn++)
                        Yt($t.__webglFramebuffer[dn][Tn], Lt, At, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + dn, Tn);
                else
                    Yt($t.__webglFramebuffer[dn], Lt, At, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + dn, 0);
            ct(At) && it(s.TEXTURE_CUBE_MAP),
            a.unbindTexture()
        } else if (Pn) {
            for (let dn = 0, Tn = sn.length; dn < Tn; dn++) {
                const jn = sn[dn]
                  , pn = o.get(jn);
                a.bindTexture(s.TEXTURE_2D, pn.__webglTexture),
                Ct(s.TEXTURE_2D, jn),
                Yt($t.__webglFramebuffer, Lt, jn, s.COLOR_ATTACHMENT0 + dn, s.TEXTURE_2D, 0),
                ct(jn) && it(s.TEXTURE_2D)
            }
            a.unbindTexture()
        } else {
            let dn = s.TEXTURE_2D;
            if ((Lt.isWebGL3DRenderTarget || Lt.isWebGLArrayRenderTarget) && (dn = Lt.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY),
            a.bindTexture(dn, on.__webglTexture),
            Ct(dn, At),
            At.mipmaps && At.mipmaps.length > 0)
                for (let Tn = 0; Tn < At.mipmaps.length; Tn++)
                    Yt($t.__webglFramebuffer[Tn], Lt, At, s.COLOR_ATTACHMENT0, dn, Tn);
            else
                Yt($t.__webglFramebuffer, Lt, At, s.COLOR_ATTACHMENT0, dn, 0);
            ct(At) && it(dn),
            a.unbindTexture()
        }
        Lt.depthBuffer && An(Lt)
    }
    function yn(Lt) {
        const At = Lt.textures;
        for (let $t = 0, on = At.length; $t < on; $t++) {
            const sn = At[$t];
            if (ct(sn)) {
                const cn = Lt.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D
                  , Pn = o.get(sn).__webglTexture;
                a.bindTexture(cn, Pn),
                it(cn),
                a.unbindTexture()
            }
        }
    }
    const Pt = []
      , Qt = [];
    function jt(Lt) {
        if (Lt.samples > 0) {
            if (tn(Lt) === !1) {
                const At = Lt.textures
                  , $t = Lt.width
                  , on = Lt.height;
                let sn = s.COLOR_BUFFER_BIT;
                const cn = Lt.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
                  , Pn = o.get(Lt)
                  , dn = At.length > 1;
                if (dn)
                    for (let Tn = 0; Tn < At.length; Tn++)
                        a.bindFramebuffer(s.FRAMEBUFFER, Pn.__webglMultisampledFramebuffer),
                        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Tn, s.RENDERBUFFER, null),
                        a.bindFramebuffer(s.FRAMEBUFFER, Pn.__webglFramebuffer),
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Tn, s.TEXTURE_2D, null, 0);
                a.bindFramebuffer(s.READ_FRAMEBUFFER, Pn.__webglMultisampledFramebuffer),
                a.bindFramebuffer(s.DRAW_FRAMEBUFFER, Pn.__webglFramebuffer);
                for (let Tn = 0; Tn < At.length; Tn++) {
                    if (Lt.resolveDepthBuffer && (Lt.depthBuffer && (sn |= s.DEPTH_BUFFER_BIT),
                    Lt.stencilBuffer && Lt.resolveStencilBuffer && (sn |= s.STENCIL_BUFFER_BIT)),
                    dn) {
                        s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Pn.__webglColorRenderbuffer[Tn]);
                        const jn = o.get(At[Tn]).__webglTexture;
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, jn, 0)
                    }
                    s.blitFramebuffer(0, 0, $t, on, 0, 0, $t, on, sn, s.NEAREST),
                    b === !0 && (Pt.length = 0,
                    Qt.length = 0,
                    Pt.push(s.COLOR_ATTACHMENT0 + Tn),
                    Lt.depthBuffer && Lt.resolveDepthBuffer === !1 && (Pt.push(cn),
                    Qt.push(cn),
                    s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, Qt)),
                    s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Pt))
                }
                if (a.bindFramebuffer(s.READ_FRAMEBUFFER, null),
                a.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
                dn)
                    for (let Tn = 0; Tn < At.length; Tn++) {
                        a.bindFramebuffer(s.FRAMEBUFFER, Pn.__webglMultisampledFramebuffer),
                        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Tn, s.RENDERBUFFER, Pn.__webglColorRenderbuffer[Tn]);
                        const jn = o.get(At[Tn]).__webglTexture;
                        a.bindFramebuffer(s.FRAMEBUFFER, Pn.__webglFramebuffer),
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Tn, s.TEXTURE_2D, jn, 0)
                    }
                a.bindFramebuffer(s.DRAW_FRAMEBUFFER, Pn.__webglMultisampledFramebuffer)
            } else if (Lt.depthBuffer && Lt.resolveDepthBuffer === !1 && b) {
                const At = Lt.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
                s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [At])
            }
        }
    }
    function fn(Lt) {
        return Math.min(c.maxSamples, Lt.samples)
    }
    function tn(Lt) {
        const At = o.get(Lt);
        return Lt.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && At.__useRenderToTexture !== !1
    }
    function bn(Lt) {
        const At = g.render.frame;
        $.get(Lt) !== At && ($.set(Lt, At),
        Lt.update())
    }
    function gn(Lt, At) {
        const $t = Lt.colorSpace
          , on = Lt.format
          , sn = Lt.type;
        return Lt.isCompressedTexture === !0 || Lt.isVideoTexture === !0 || $t !== LinearSRGBColorSpace && $t !== NoColorSpace && (ColorManagement.getTransfer($t) === SRGBTransfer ? (on !== RGBAFormat || sn !== UnsignedByteType) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", $t)),
        At
    }
    function vn(Lt) {
        return typeof HTMLImageElement < "u" && Lt instanceof HTMLImageElement ? (j.width = Lt.naturalWidth || Lt.width,
        j.height = Lt.naturalHeight || Lt.height) : typeof VideoFrame < "u" && Lt instanceof VideoFrame ? (j.width = Lt.displayWidth,
        j.height = Lt.displayHeight) : (j.width = Lt.width,
        j.height = Lt.height),
        j
    }
    this.allocateTextureUnit = Rt,
    this.resetTextureUnits = bt,
    this.setTexture2D = Bt,
    this.setTexture2DArray = Dt,
    this.setTexture3D = Mt,
    this.setTextureCube = Tt,
    this.rebindTextures = Ln,
    this.setupRenderTarget = _n,
    this.updateRenderTargetMipmap = yn,
    this.updateMultisampleRenderTarget = jt,
    this.setupDepthRenderbuffer = An,
    this.setupFrameBufferTexture = Yt,
    this.useMultisampledRTT = tn
}
function WebGLUtils(s, e) {
    function a(o, c=NoColorSpace) {
        let d;
        const g = ColorManagement.getTransfer(c);
        if (o === UnsignedByteType)
            return s.UNSIGNED_BYTE;
        if (o === UnsignedShort4444Type)
            return s.UNSIGNED_SHORT_4_4_4_4;
        if (o === UnsignedShort5551Type)
            return s.UNSIGNED_SHORT_5_5_5_1;
        if (o === UnsignedInt5999Type)
            return s.UNSIGNED_INT_5_9_9_9_REV;
        if (o === ByteType)
            return s.BYTE;
        if (o === ShortType)
            return s.SHORT;
        if (o === UnsignedShortType)
            return s.UNSIGNED_SHORT;
        if (o === IntType)
            return s.INT;
        if (o === UnsignedIntType)
            return s.UNSIGNED_INT;
        if (o === FloatType)
            return s.FLOAT;
        if (o === HalfFloatType)
            return s.HALF_FLOAT;
        if (o === AlphaFormat)
            return s.ALPHA;
        if (o === RGBFormat)
            return s.RGB;
        if (o === RGBAFormat)
            return s.RGBA;
        if (o === LuminanceFormat)
            return s.LUMINANCE;
        if (o === LuminanceAlphaFormat)
            return s.LUMINANCE_ALPHA;
        if (o === DepthFormat)
            return s.DEPTH_COMPONENT;
        if (o === DepthStencilFormat)
            return s.DEPTH_STENCIL;
        if (o === RedFormat)
            return s.RED;
        if (o === RedIntegerFormat)
            return s.RED_INTEGER;
        if (o === RGFormat)
            return s.RG;
        if (o === RGIntegerFormat)
            return s.RG_INTEGER;
        if (o === RGBAIntegerFormat)
            return s.RGBA_INTEGER;
        if (o === RGB_S3TC_DXT1_Format || o === RGBA_S3TC_DXT1_Format || o === RGBA_S3TC_DXT3_Format || o === RGBA_S3TC_DXT5_Format)
            if (g === SRGBTransfer)
                if (d = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                d !== null) {
                    if (o === RGB_S3TC_DXT1_Format)
                        return d.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (o === RGBA_S3TC_DXT1_Format)
                        return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (o === RGBA_S3TC_DXT3_Format)
                        return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (o === RGBA_S3TC_DXT5_Format)
                        return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (d = e.get("WEBGL_compressed_texture_s3tc"),
            d !== null) {
                if (o === RGB_S3TC_DXT1_Format)
                    return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (o === RGBA_S3TC_DXT1_Format)
                    return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (o === RGBA_S3TC_DXT3_Format)
                    return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (o === RGBA_S3TC_DXT5_Format)
                    return d.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (o === RGB_PVRTC_4BPPV1_Format || o === RGB_PVRTC_2BPPV1_Format || o === RGBA_PVRTC_4BPPV1_Format || o === RGBA_PVRTC_2BPPV1_Format)
            if (d = e.get("WEBGL_compressed_texture_pvrtc"),
            d !== null) {
                if (o === RGB_PVRTC_4BPPV1_Format)
                    return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (o === RGB_PVRTC_2BPPV1_Format)
                    return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (o === RGBA_PVRTC_4BPPV1_Format)
                    return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (o === RGBA_PVRTC_2BPPV1_Format)
                    return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (o === RGB_ETC1_Format || o === RGB_ETC2_Format || o === RGBA_ETC2_EAC_Format)
            if (d = e.get("WEBGL_compressed_texture_etc"),
            d !== null) {
                if (o === RGB_ETC1_Format || o === RGB_ETC2_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ETC2 : d.COMPRESSED_RGB8_ETC2;
                if (o === RGBA_ETC2_EAC_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : d.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (o === RGBA_ASTC_4x4_Format || o === RGBA_ASTC_5x4_Format || o === RGBA_ASTC_5x5_Format || o === RGBA_ASTC_6x5_Format || o === RGBA_ASTC_6x6_Format || o === RGBA_ASTC_8x5_Format || o === RGBA_ASTC_8x6_Format || o === RGBA_ASTC_8x8_Format || o === RGBA_ASTC_10x5_Format || o === RGBA_ASTC_10x6_Format || o === RGBA_ASTC_10x8_Format || o === RGBA_ASTC_10x10_Format || o === RGBA_ASTC_12x10_Format || o === RGBA_ASTC_12x12_Format)
            if (d = e.get("WEBGL_compressed_texture_astc"),
            d !== null) {
                if (o === RGBA_ASTC_4x4_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : d.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (o === RGBA_ASTC_5x4_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : d.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (o === RGBA_ASTC_5x5_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : d.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (o === RGBA_ASTC_6x5_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : d.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (o === RGBA_ASTC_6x6_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : d.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (o === RGBA_ASTC_8x5_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : d.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (o === RGBA_ASTC_8x6_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : d.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (o === RGBA_ASTC_8x8_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : d.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (o === RGBA_ASTC_10x5_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : d.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (o === RGBA_ASTC_10x6_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : d.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (o === RGBA_ASTC_10x8_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : d.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (o === RGBA_ASTC_10x10_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : d.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (o === RGBA_ASTC_12x10_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : d.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (o === RGBA_ASTC_12x12_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : d.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (o === RGBA_BPTC_Format || o === RGB_BPTC_SIGNED_Format || o === RGB_BPTC_UNSIGNED_Format)
            if (d = e.get("EXT_texture_compression_bptc"),
            d !== null) {
                if (o === RGBA_BPTC_Format)
                    return g === SRGBTransfer ? d.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : d.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (o === RGB_BPTC_SIGNED_Format)
                    return d.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (o === RGB_BPTC_UNSIGNED_Format)
                    return d.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (o === RED_RGTC1_Format || o === SIGNED_RED_RGTC1_Format || o === RED_GREEN_RGTC2_Format || o === SIGNED_RED_GREEN_RGTC2_Format)
            if (d = e.get("EXT_texture_compression_rgtc"),
            d !== null) {
                if (o === RGBA_BPTC_Format)
                    return d.COMPRESSED_RED_RGTC1_EXT;
                if (o === SIGNED_RED_RGTC1_Format)
                    return d.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (o === RED_GREEN_RGTC2_Format)
                    return d.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (o === SIGNED_RED_GREEN_RGTC2_Format)
                    return d.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return o === UnsignedInt248Type ? s.UNSIGNED_INT_24_8 : s[o] !== void 0 ? s[o] : null
    }
    return {
        convert: a
    }
}
class ArrayCamera extends PerspectiveCamera {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Group extends Object3D {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const _moveEvent = {
    type: "move"
};
class WebXRController {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Group,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Group,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new Vector3,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new Vector3),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Group,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new Vector3,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new Vector3),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const a = this._hand;
            if (a)
                for (const o of e.hand.values())
                    this._getHandJoint(a, o)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, a, o) {
        let c = null
          , d = null
          , g = null;
        const _ = this._targetRay
          , b = this._grip
          , j = this._hand;
        if (e && a.session.visibilityState !== "visible-blurred") {
            if (j && e.hand) {
                g = !0;
                for (const lt of e.hand.values()) {
                    const ct = a.getJointPose(lt, o)
                      , it = this._getHandJoint(j, lt);
                    ct !== null && (it.matrix.fromArray(ct.transform.matrix),
                    it.matrix.decompose(it.position, it.rotation, it.scale),
                    it.matrixWorldNeedsUpdate = !0,
                    it.jointRadius = ct.radius),
                    it.visible = ct !== null
                }
                const $ = j.joints["index-finger-tip"]
                  , nt = j.joints["thumb-tip"]
                  , tt = $.position.distanceTo(nt.position)
                  , rt = .02
                  , st = .005;
                j.inputState.pinching && tt > rt + st ? (j.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !j.inputState.pinching && tt <= rt - st && (j.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                b !== null && e.gripSpace && (d = a.getPose(e.gripSpace, o),
                d !== null && (b.matrix.fromArray(d.transform.matrix),
                b.matrix.decompose(b.position, b.rotation, b.scale),
                b.matrixWorldNeedsUpdate = !0,
                d.linearVelocity ? (b.hasLinearVelocity = !0,
                b.linearVelocity.copy(d.linearVelocity)) : b.hasLinearVelocity = !1,
                d.angularVelocity ? (b.hasAngularVelocity = !0,
                b.angularVelocity.copy(d.angularVelocity)) : b.hasAngularVelocity = !1));
            _ !== null && (c = a.getPose(e.targetRaySpace, o),
            c === null && d !== null && (c = d),
            c !== null && (_.matrix.fromArray(c.transform.matrix),
            _.matrix.decompose(_.position, _.rotation, _.scale),
            _.matrixWorldNeedsUpdate = !0,
            c.linearVelocity ? (_.hasLinearVelocity = !0,
            _.linearVelocity.copy(c.linearVelocity)) : _.hasLinearVelocity = !1,
            c.angularVelocity ? (_.hasAngularVelocity = !0,
            _.angularVelocity.copy(c.angularVelocity)) : _.hasAngularVelocity = !1,
            this.dispatchEvent(_moveEvent)))
        }
        return _ !== null && (_.visible = c !== null),
        b !== null && (b.visible = d !== null),
        j !== null && (j.visible = g !== null),
        this
    }
    _getHandJoint(e, a) {
        if (e.joints[a.jointName] === void 0) {
            const o = new Group;
            o.matrixAutoUpdate = !1,
            o.visible = !1,
            e.joints[a.jointName] = o,
            e.add(o)
        }
        return e.joints[a.jointName]
    }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, a, o) {
        if (this.texture === null) {
            const c = new Texture
              , d = e.properties.get(c);
            d.__webglTexture = a.texture,
            (a.depthNear != o.depthNear || a.depthFar != o.depthFar) && (this.depthNear = a.depthNear,
            this.depthFar = a.depthFar),
            this.texture = c
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const a = e.cameras[0].viewport
              , o = new ShaderMaterial({
                vertexShader: _occlusion_vertex,
                fragmentShader: _occlusion_fragment,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: a.z
                    },
                    depthHeight: {
                        value: a.w
                    }
                }
            });
            this.mesh = new Mesh(new PlaneGeometry(20,20),o)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class WebXRManager extends EventDispatcher {
    constructor(e, a) {
        super();
        const o = this;
        let c = null
          , d = 1
          , g = null
          , _ = "local-floor"
          , b = 1
          , j = null
          , $ = null
          , nt = null
          , tt = null
          , rt = null
          , st = null;
        const lt = new WebXRDepthSensing
          , ct = a.getContextAttributes();
        let it = null
          , ot = null;
        const at = []
          , ht = []
          , pt = new Vector2;
        let dt = null;
        const yt = new PerspectiveCamera;
        yt.layers.enable(1),
        yt.viewport = new Vector4;
        const vt = new PerspectiveCamera;
        vt.layers.enable(2),
        vt.viewport = new Vector4;
        const xt = [yt, vt]
          , _t = new ArrayCamera;
        _t.layers.enable(1),
        _t.layers.enable(2);
        let bt = null
          , Rt = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(Ot) {
            let Yt = at[Ot];
            return Yt === void 0 && (Yt = new WebXRController,
            at[Ot] = Yt),
            Yt.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(Ot) {
            let Yt = at[Ot];
            return Yt === void 0 && (Yt = new WebXRController,
            at[Ot] = Yt),
            Yt.getGripSpace()
        }
        ,
        this.getHand = function(Ot) {
            let Yt = at[Ot];
            return Yt === void 0 && (Yt = new WebXRController,
            at[Ot] = Yt),
            Yt.getHandSpace()
        }
        ;
        function Ft(Ot) {
            const Yt = ht.indexOf(Ot.inputSource);
            if (Yt === -1)
                return;
            const rn = at[Yt];
            rn !== void 0 && (rn.update(Ot.inputSource, Ot.frame, j || g),
            rn.dispatchEvent({
                type: Ot.type,
                data: Ot.inputSource
            }))
        }
        function Bt() {
            c.removeEventListener("select", Ft),
            c.removeEventListener("selectstart", Ft),
            c.removeEventListener("selectend", Ft),
            c.removeEventListener("squeeze", Ft),
            c.removeEventListener("squeezestart", Ft),
            c.removeEventListener("squeezeend", Ft),
            c.removeEventListener("end", Bt),
            c.removeEventListener("inputsourceschange", Dt);
            for (let Ot = 0; Ot < at.length; Ot++) {
                const Yt = ht[Ot];
                Yt !== null && (ht[Ot] = null,
                at[Ot].disconnect(Yt))
            }
            bt = null,
            Rt = null,
            lt.reset(),
            e.setRenderTarget(it),
            rt = null,
            tt = null,
            nt = null,
            c = null,
            ot = null,
            en.stop(),
            o.isPresenting = !1,
            e.setPixelRatio(dt),
            e.setSize(pt.width, pt.height, !1),
            o.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(Ot) {
            d = Ot,
            o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(Ot) {
            _ = Ot,
            o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return j || g
        }
        ,
        this.setReferenceSpace = function(Ot) {
            j = Ot
        }
        ,
        this.getBaseLayer = function() {
            return tt !== null ? tt : rt
        }
        ,
        this.getBinding = function() {
            return nt
        }
        ,
        this.getFrame = function() {
            return st
        }
        ,
        this.getSession = function() {
            return c
        }
        ,
        this.setSession = async function(Ot) {
            if (c = Ot,
            c !== null) {
                if (it = e.getRenderTarget(),
                c.addEventListener("select", Ft),
                c.addEventListener("selectstart", Ft),
                c.addEventListener("selectend", Ft),
                c.addEventListener("squeeze", Ft),
                c.addEventListener("squeezestart", Ft),
                c.addEventListener("squeezeend", Ft),
                c.addEventListener("end", Bt),
                c.addEventListener("inputsourceschange", Dt),
                ct.xrCompatible !== !0 && await a.makeXRCompatible(),
                dt = e.getPixelRatio(),
                e.getSize(pt),
                c.renderState.layers === void 0) {
                    const Yt = {
                        antialias: ct.antialias,
                        alpha: !0,
                        depth: ct.depth,
                        stencil: ct.stencil,
                        framebufferScaleFactor: d
                    };
                    rt = new XRWebGLLayer(c,a,Yt),
                    c.updateRenderState({
                        baseLayer: rt
                    }),
                    e.setPixelRatio(1),
                    e.setSize(rt.framebufferWidth, rt.framebufferHeight, !1),
                    ot = new WebGLRenderTarget(rt.framebufferWidth,rt.framebufferHeight,{
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: ct.stencil
                    })
                } else {
                    let Yt = null
                      , rn = null
                      , Xt = null;
                    ct.depth && (Xt = ct.stencil ? a.DEPTH24_STENCIL8 : a.DEPTH_COMPONENT24,
                    Yt = ct.stencil ? DepthStencilFormat : DepthFormat,
                    rn = ct.stencil ? UnsignedInt248Type : UnsignedIntType);
                    const An = {
                        colorFormat: a.RGBA8,
                        depthFormat: Xt,
                        scaleFactor: d
                    };
                    nt = new XRWebGLBinding(c,a),
                    tt = nt.createProjectionLayer(An),
                    c.updateRenderState({
                        layers: [tt]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(tt.textureWidth, tt.textureHeight, !1),
                    ot = new WebGLRenderTarget(tt.textureWidth,tt.textureHeight,{
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        depthTexture: new DepthTexture(tt.textureWidth,tt.textureHeight,rn,void 0,void 0,void 0,void 0,void 0,void 0,Yt),
                        stencilBuffer: ct.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: ct.antialias ? 4 : 0,
                        resolveDepthBuffer: tt.ignoreDepthValues === !1
                    })
                }
                ot.isXRRenderTarget = !0,
                this.setFoveation(b),
                j = null,
                g = await c.requestReferenceSpace(_),
                en.setContext(c),
                en.start(),
                o.isPresenting = !0,
                o.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (c !== null)
                return c.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return lt.getDepthTexture()
        }
        ;
        function Dt(Ot) {
            for (let Yt = 0; Yt < Ot.removed.length; Yt++) {
                const rn = Ot.removed[Yt]
                  , Xt = ht.indexOf(rn);
                Xt >= 0 && (ht[Xt] = null,
                at[Xt].disconnect(rn))
            }
            for (let Yt = 0; Yt < Ot.added.length; Yt++) {
                const rn = Ot.added[Yt];
                let Xt = ht.indexOf(rn);
                if (Xt === -1) {
                    for (let Ln = 0; Ln < at.length; Ln++)
                        if (Ln >= ht.length) {
                            ht.push(rn),
                            Xt = Ln;
                            break
                        } else if (ht[Ln] === null) {
                            ht[Ln] = rn,
                            Xt = Ln;
                            break
                        }
                    if (Xt === -1)
                        break
                }
                const An = at[Xt];
                An && An.connect(rn)
            }
        }
        const Mt = new Vector3
          , Tt = new Vector3;
        function mt(Ot, Yt, rn) {
            Mt.setFromMatrixPosition(Yt.matrixWorld),
            Tt.setFromMatrixPosition(rn.matrixWorld);
            const Xt = Mt.distanceTo(Tt)
              , An = Yt.projectionMatrix.elements
              , Ln = rn.projectionMatrix.elements
              , _n = An[14] / (An[10] - 1)
              , yn = An[14] / (An[10] + 1)
              , Pt = (An[9] + 1) / An[5]
              , Qt = (An[9] - 1) / An[5]
              , jt = (An[8] - 1) / An[0]
              , fn = (Ln[8] + 1) / Ln[0]
              , tn = _n * jt
              , bn = _n * fn
              , gn = Xt / (-jt + fn)
              , vn = gn * -jt;
            Yt.matrixWorld.decompose(Ot.position, Ot.quaternion, Ot.scale),
            Ot.translateX(vn),
            Ot.translateZ(gn),
            Ot.matrixWorld.compose(Ot.position, Ot.quaternion, Ot.scale),
            Ot.matrixWorldInverse.copy(Ot.matrixWorld).invert();
            const Lt = _n + gn
              , At = yn + gn
              , $t = tn - vn
              , on = bn + (Xt - vn)
              , sn = Pt * yn / At * Lt
              , cn = Qt * yn / At * Lt;
            Ot.projectionMatrix.makePerspective($t, on, sn, cn, Lt, At),
            Ot.projectionMatrixInverse.copy(Ot.projectionMatrix).invert()
        }
        function St(Ot, Yt) {
            Yt === null ? Ot.matrixWorld.copy(Ot.matrix) : Ot.matrixWorld.multiplyMatrices(Yt.matrixWorld, Ot.matrix),
            Ot.matrixWorldInverse.copy(Ot.matrixWorld).invert()
        }
        this.updateCamera = function(Ot) {
            if (c === null)
                return;
            lt.texture !== null && (Ot.near = lt.depthNear,
            Ot.far = lt.depthFar),
            _t.near = vt.near = yt.near = Ot.near,
            _t.far = vt.far = yt.far = Ot.far,
            (bt !== _t.near || Rt !== _t.far) && (c.updateRenderState({
                depthNear: _t.near,
                depthFar: _t.far
            }),
            bt = _t.near,
            Rt = _t.far,
            yt.near = bt,
            yt.far = Rt,
            vt.near = bt,
            vt.far = Rt,
            yt.updateProjectionMatrix(),
            vt.updateProjectionMatrix(),
            Ot.updateProjectionMatrix());
            const Yt = Ot.parent
              , rn = _t.cameras;
            St(_t, Yt);
            for (let Xt = 0; Xt < rn.length; Xt++)
                St(rn[Xt], Yt);
            rn.length === 2 ? mt(_t, yt, vt) : _t.projectionMatrix.copy(yt.projectionMatrix),
            wt(Ot, _t, Yt)
        }
        ;
        function wt(Ot, Yt, rn) {
            rn === null ? Ot.matrix.copy(Yt.matrixWorld) : (Ot.matrix.copy(rn.matrixWorld),
            Ot.matrix.invert(),
            Ot.matrix.multiply(Yt.matrixWorld)),
            Ot.matrix.decompose(Ot.position, Ot.quaternion, Ot.scale),
            Ot.updateMatrixWorld(!0),
            Ot.projectionMatrix.copy(Yt.projectionMatrix),
            Ot.projectionMatrixInverse.copy(Yt.projectionMatrixInverse),
            Ot.isPerspectiveCamera && (Ot.fov = RAD2DEG * 2 * Math.atan(1 / Ot.projectionMatrix.elements[5]),
            Ot.zoom = 1)
        }
        this.getCamera = function() {
            return _t
        }
        ,
        this.getFoveation = function() {
            if (!(tt === null && rt === null))
                return b
        }
        ,
        this.setFoveation = function(Ot) {
            b = Ot,
            tt !== null && (tt.fixedFoveation = Ot),
            rt !== null && rt.fixedFoveation !== void 0 && (rt.fixedFoveation = Ot)
        }
        ,
        this.hasDepthSensing = function() {
            return lt.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return lt.getMesh(_t)
        }
        ;
        let Ct = null;
        function Ht(Ot, Yt) {
            if ($ = Yt.getViewerPose(j || g),
            st = Yt,
            $ !== null) {
                const rn = $.views;
                rt !== null && (e.setRenderTargetFramebuffer(ot, rt.framebuffer),
                e.setRenderTarget(ot));
                let Xt = !1;
                rn.length !== _t.cameras.length && (_t.cameras.length = 0,
                Xt = !0);
                for (let Ln = 0; Ln < rn.length; Ln++) {
                    const _n = rn[Ln];
                    let yn = null;
                    if (rt !== null)
                        yn = rt.getViewport(_n);
                    else {
                        const Qt = nt.getViewSubImage(tt, _n);
                        yn = Qt.viewport,
                        Ln === 0 && (e.setRenderTargetTextures(ot, Qt.colorTexture, tt.ignoreDepthValues ? void 0 : Qt.depthStencilTexture),
                        e.setRenderTarget(ot))
                    }
                    let Pt = xt[Ln];
                    Pt === void 0 && (Pt = new PerspectiveCamera,
                    Pt.layers.enable(Ln),
                    Pt.viewport = new Vector4,
                    xt[Ln] = Pt),
                    Pt.matrix.fromArray(_n.transform.matrix),
                    Pt.matrix.decompose(Pt.position, Pt.quaternion, Pt.scale),
                    Pt.projectionMatrix.fromArray(_n.projectionMatrix),
                    Pt.projectionMatrixInverse.copy(Pt.projectionMatrix).invert(),
                    Pt.viewport.set(yn.x, yn.y, yn.width, yn.height),
                    Ln === 0 && (_t.matrix.copy(Pt.matrix),
                    _t.matrix.decompose(_t.position, _t.quaternion, _t.scale)),
                    Xt === !0 && _t.cameras.push(Pt)
                }
                const An = c.enabledFeatures;
                if (An && An.includes("depth-sensing")) {
                    const Ln = nt.getDepthInformation(rn[0]);
                    Ln && Ln.isValid && Ln.texture && lt.init(e, Ln, c.renderState)
                }
            }
            for (let rn = 0; rn < at.length; rn++) {
                const Xt = ht[rn]
                  , An = at[rn];
                Xt !== null && An !== void 0 && An.update(Xt, Yt, j || g)
            }
            Ct && Ct(Ot, Yt),
            Yt.detectedPlanes && o.dispatchEvent({
                type: "planesdetected",
                data: Yt
            }),
            st = null
        }
        const en = new WebGLAnimation;
        en.setAnimationLoop(Ht),
        this.setAnimationLoop = function(Ot) {
            Ct = Ot
        }
        ,
        this.dispose = function() {}
    }
}
const _e1 = new Euler
  , _m1 = new Matrix4;
function WebGLMaterials(s, e) {
    function a(ct, it) {
        ct.matrixAutoUpdate === !0 && ct.updateMatrix(),
        it.value.copy(ct.matrix)
    }
    function o(ct, it) {
        it.color.getRGB(ct.fogColor.value, getUnlitUniformColorSpace(s)),
        it.isFog ? (ct.fogNear.value = it.near,
        ct.fogFar.value = it.far) : it.isFogExp2 && (ct.fogDensity.value = it.density)
    }
    function c(ct, it, ot, at, ht) {
        it.isMeshBasicMaterial || it.isMeshLambertMaterial ? d(ct, it) : it.isMeshToonMaterial ? (d(ct, it),
        nt(ct, it)) : it.isMeshPhongMaterial ? (d(ct, it),
        $(ct, it)) : it.isMeshStandardMaterial ? (d(ct, it),
        tt(ct, it),
        it.isMeshPhysicalMaterial && rt(ct, it, ht)) : it.isMeshMatcapMaterial ? (d(ct, it),
        st(ct, it)) : it.isMeshDepthMaterial ? d(ct, it) : it.isMeshDistanceMaterial ? (d(ct, it),
        lt(ct, it)) : it.isMeshNormalMaterial ? d(ct, it) : it.isLineBasicMaterial ? (g(ct, it),
        it.isLineDashedMaterial && _(ct, it)) : it.isPointsMaterial ? b(ct, it, ot, at) : it.isSpriteMaterial ? j(ct, it) : it.isShadowMaterial ? (ct.color.value.copy(it.color),
        ct.opacity.value = it.opacity) : it.isShaderMaterial && (it.uniformsNeedUpdate = !1)
    }
    function d(ct, it) {
        ct.opacity.value = it.opacity,
        it.color && ct.diffuse.value.copy(it.color),
        it.emissive && ct.emissive.value.copy(it.emissive).multiplyScalar(it.emissiveIntensity),
        it.map && (ct.map.value = it.map,
        a(it.map, ct.mapTransform)),
        it.alphaMap && (ct.alphaMap.value = it.alphaMap,
        a(it.alphaMap, ct.alphaMapTransform)),
        it.bumpMap && (ct.bumpMap.value = it.bumpMap,
        a(it.bumpMap, ct.bumpMapTransform),
        ct.bumpScale.value = it.bumpScale,
        it.side === BackSide && (ct.bumpScale.value *= -1)),
        it.normalMap && (ct.normalMap.value = it.normalMap,
        a(it.normalMap, ct.normalMapTransform),
        ct.normalScale.value.copy(it.normalScale),
        it.side === BackSide && ct.normalScale.value.negate()),
        it.displacementMap && (ct.displacementMap.value = it.displacementMap,
        a(it.displacementMap, ct.displacementMapTransform),
        ct.displacementScale.value = it.displacementScale,
        ct.displacementBias.value = it.displacementBias),
        it.emissiveMap && (ct.emissiveMap.value = it.emissiveMap,
        a(it.emissiveMap, ct.emissiveMapTransform)),
        it.specularMap && (ct.specularMap.value = it.specularMap,
        a(it.specularMap, ct.specularMapTransform)),
        it.alphaTest > 0 && (ct.alphaTest.value = it.alphaTest);
        const ot = e.get(it)
          , at = ot.envMap
          , ht = ot.envMapRotation;
        at && (ct.envMap.value = at,
        _e1.copy(ht),
        _e1.x *= -1,
        _e1.y *= -1,
        _e1.z *= -1,
        at.isCubeTexture && at.isRenderTargetTexture === !1 && (_e1.y *= -1,
        _e1.z *= -1),
        ct.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),
        ct.flipEnvMap.value = at.isCubeTexture && at.isRenderTargetTexture === !1 ? -1 : 1,
        ct.reflectivity.value = it.reflectivity,
        ct.ior.value = it.ior,
        ct.refractionRatio.value = it.refractionRatio),
        it.lightMap && (ct.lightMap.value = it.lightMap,
        ct.lightMapIntensity.value = it.lightMapIntensity,
        a(it.lightMap, ct.lightMapTransform)),
        it.aoMap && (ct.aoMap.value = it.aoMap,
        ct.aoMapIntensity.value = it.aoMapIntensity,
        a(it.aoMap, ct.aoMapTransform))
    }
    function g(ct, it) {
        ct.diffuse.value.copy(it.color),
        ct.opacity.value = it.opacity,
        it.map && (ct.map.value = it.map,
        a(it.map, ct.mapTransform))
    }
    function _(ct, it) {
        ct.dashSize.value = it.dashSize,
        ct.totalSize.value = it.dashSize + it.gapSize,
        ct.scale.value = it.scale
    }
    function b(ct, it, ot, at) {
        ct.diffuse.value.copy(it.color),
        ct.opacity.value = it.opacity,
        ct.size.value = it.size * ot,
        ct.scale.value = at * .5,
        it.map && (ct.map.value = it.map,
        a(it.map, ct.uvTransform)),
        it.alphaMap && (ct.alphaMap.value = it.alphaMap,
        a(it.alphaMap, ct.alphaMapTransform)),
        it.alphaTest > 0 && (ct.alphaTest.value = it.alphaTest)
    }
    function j(ct, it) {
        ct.diffuse.value.copy(it.color),
        ct.opacity.value = it.opacity,
        ct.rotation.value = it.rotation,
        it.map && (ct.map.value = it.map,
        a(it.map, ct.mapTransform)),
        it.alphaMap && (ct.alphaMap.value = it.alphaMap,
        a(it.alphaMap, ct.alphaMapTransform)),
        it.alphaTest > 0 && (ct.alphaTest.value = it.alphaTest)
    }
    function $(ct, it) {
        ct.specular.value.copy(it.specular),
        ct.shininess.value = Math.max(it.shininess, 1e-4)
    }
    function nt(ct, it) {
        it.gradientMap && (ct.gradientMap.value = it.gradientMap)
    }
    function tt(ct, it) {
        ct.metalness.value = it.metalness,
        it.metalnessMap && (ct.metalnessMap.value = it.metalnessMap,
        a(it.metalnessMap, ct.metalnessMapTransform)),
        ct.roughness.value = it.roughness,
        it.roughnessMap && (ct.roughnessMap.value = it.roughnessMap,
        a(it.roughnessMap, ct.roughnessMapTransform)),
        it.envMap && (ct.envMapIntensity.value = it.envMapIntensity)
    }
    function rt(ct, it, ot) {
        ct.ior.value = it.ior,
        it.sheen > 0 && (ct.sheenColor.value.copy(it.sheenColor).multiplyScalar(it.sheen),
        ct.sheenRoughness.value = it.sheenRoughness,
        it.sheenColorMap && (ct.sheenColorMap.value = it.sheenColorMap,
        a(it.sheenColorMap, ct.sheenColorMapTransform)),
        it.sheenRoughnessMap && (ct.sheenRoughnessMap.value = it.sheenRoughnessMap,
        a(it.sheenRoughnessMap, ct.sheenRoughnessMapTransform))),
        it.clearcoat > 0 && (ct.clearcoat.value = it.clearcoat,
        ct.clearcoatRoughness.value = it.clearcoatRoughness,
        it.clearcoatMap && (ct.clearcoatMap.value = it.clearcoatMap,
        a(it.clearcoatMap, ct.clearcoatMapTransform)),
        it.clearcoatRoughnessMap && (ct.clearcoatRoughnessMap.value = it.clearcoatRoughnessMap,
        a(it.clearcoatRoughnessMap, ct.clearcoatRoughnessMapTransform)),
        it.clearcoatNormalMap && (ct.clearcoatNormalMap.value = it.clearcoatNormalMap,
        a(it.clearcoatNormalMap, ct.clearcoatNormalMapTransform),
        ct.clearcoatNormalScale.value.copy(it.clearcoatNormalScale),
        it.side === BackSide && ct.clearcoatNormalScale.value.negate())),
        it.dispersion > 0 && (ct.dispersion.value = it.dispersion),
        it.iridescence > 0 && (ct.iridescence.value = it.iridescence,
        ct.iridescenceIOR.value = it.iridescenceIOR,
        ct.iridescenceThicknessMinimum.value = it.iridescenceThicknessRange[0],
        ct.iridescenceThicknessMaximum.value = it.iridescenceThicknessRange[1],
        it.iridescenceMap && (ct.iridescenceMap.value = it.iridescenceMap,
        a(it.iridescenceMap, ct.iridescenceMapTransform)),
        it.iridescenceThicknessMap && (ct.iridescenceThicknessMap.value = it.iridescenceThicknessMap,
        a(it.iridescenceThicknessMap, ct.iridescenceThicknessMapTransform))),
        it.transmission > 0 && (ct.transmission.value = it.transmission,
        ct.transmissionSamplerMap.value = ot.texture,
        ct.transmissionSamplerSize.value.set(ot.width, ot.height),
        it.transmissionMap && (ct.transmissionMap.value = it.transmissionMap,
        a(it.transmissionMap, ct.transmissionMapTransform)),
        ct.thickness.value = it.thickness,
        it.thicknessMap && (ct.thicknessMap.value = it.thicknessMap,
        a(it.thicknessMap, ct.thicknessMapTransform)),
        ct.attenuationDistance.value = it.attenuationDistance,
        ct.attenuationColor.value.copy(it.attenuationColor)),
        it.anisotropy > 0 && (ct.anisotropyVector.value.set(it.anisotropy * Math.cos(it.anisotropyRotation), it.anisotropy * Math.sin(it.anisotropyRotation)),
        it.anisotropyMap && (ct.anisotropyMap.value = it.anisotropyMap,
        a(it.anisotropyMap, ct.anisotropyMapTransform))),
        ct.specularIntensity.value = it.specularIntensity,
        ct.specularColor.value.copy(it.specularColor),
        it.specularColorMap && (ct.specularColorMap.value = it.specularColorMap,
        a(it.specularColorMap, ct.specularColorMapTransform)),
        it.specularIntensityMap && (ct.specularIntensityMap.value = it.specularIntensityMap,
        a(it.specularIntensityMap, ct.specularIntensityMapTransform))
    }
    function st(ct, it) {
        it.matcap && (ct.matcap.value = it.matcap)
    }
    function lt(ct, it) {
        const ot = e.get(it).light;
        ct.referencePosition.value.setFromMatrixPosition(ot.matrixWorld),
        ct.nearDistance.value = ot.shadow.camera.near,
        ct.farDistance.value = ot.shadow.camera.far
    }
    return {
        refreshFogUniforms: o,
        refreshMaterialUniforms: c
    }
}
function WebGLUniformsGroups(s, e, a, o) {
    let c = {}
      , d = {}
      , g = [];
    const _ = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
    function b(ot, at) {
        const ht = at.program;
        o.uniformBlockBinding(ot, ht)
    }
    function j(ot, at) {
        let ht = c[ot.id];
        ht === void 0 && (st(ot),
        ht = $(ot),
        c[ot.id] = ht,
        ot.addEventListener("dispose", ct));
        const pt = at.program;
        o.updateUBOMapping(ot, pt);
        const dt = e.render.frame;
        d[ot.id] !== dt && (tt(ot),
        d[ot.id] = dt)
    }
    function $(ot) {
        const at = nt();
        ot.__bindingPointIndex = at;
        const ht = s.createBuffer()
          , pt = ot.__size
          , dt = ot.usage;
        return s.bindBuffer(s.UNIFORM_BUFFER, ht),
        s.bufferData(s.UNIFORM_BUFFER, pt, dt),
        s.bindBuffer(s.UNIFORM_BUFFER, null),
        s.bindBufferBase(s.UNIFORM_BUFFER, at, ht),
        ht
    }
    function nt() {
        for (let ot = 0; ot < _; ot++)
            if (g.indexOf(ot) === -1)
                return g.push(ot),
                ot;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function tt(ot) {
        const at = c[ot.id]
          , ht = ot.uniforms
          , pt = ot.__cache;
        s.bindBuffer(s.UNIFORM_BUFFER, at);
        for (let dt = 0, yt = ht.length; dt < yt; dt++) {
            const vt = Array.isArray(ht[dt]) ? ht[dt] : [ht[dt]];
            for (let xt = 0, _t = vt.length; xt < _t; xt++) {
                const bt = vt[xt];
                if (rt(bt, dt, xt, pt) === !0) {
                    const Rt = bt.__offset
                      , Ft = Array.isArray(bt.value) ? bt.value : [bt.value];
                    let Bt = 0;
                    for (let Dt = 0; Dt < Ft.length; Dt++) {
                        const Mt = Ft[Dt]
                          , Tt = lt(Mt);
                        typeof Mt == "number" || typeof Mt == "boolean" ? (bt.__data[0] = Mt,
                        s.bufferSubData(s.UNIFORM_BUFFER, Rt + Bt, bt.__data)) : Mt.isMatrix3 ? (bt.__data[0] = Mt.elements[0],
                        bt.__data[1] = Mt.elements[1],
                        bt.__data[2] = Mt.elements[2],
                        bt.__data[3] = 0,
                        bt.__data[4] = Mt.elements[3],
                        bt.__data[5] = Mt.elements[4],
                        bt.__data[6] = Mt.elements[5],
                        bt.__data[7] = 0,
                        bt.__data[8] = Mt.elements[6],
                        bt.__data[9] = Mt.elements[7],
                        bt.__data[10] = Mt.elements[8],
                        bt.__data[11] = 0) : (Mt.toArray(bt.__data, Bt),
                        Bt += Tt.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    s.bufferSubData(s.UNIFORM_BUFFER, Rt, bt.__data)
                }
            }
        }
        s.bindBuffer(s.UNIFORM_BUFFER, null)
    }
    function rt(ot, at, ht, pt) {
        const dt = ot.value
          , yt = at + "_" + ht;
        if (pt[yt] === void 0)
            return typeof dt == "number" || typeof dt == "boolean" ? pt[yt] = dt : pt[yt] = dt.clone(),
            !0;
        {
            const vt = pt[yt];
            if (typeof dt == "number" || typeof dt == "boolean") {
                if (vt !== dt)
                    return pt[yt] = dt,
                    !0
            } else if (vt.equals(dt) === !1)
                return vt.copy(dt),
                !0
        }
        return !1
    }
    function st(ot) {
        const at = ot.uniforms;
        let ht = 0;
        const pt = 16;
        for (let yt = 0, vt = at.length; yt < vt; yt++) {
            const xt = Array.isArray(at[yt]) ? at[yt] : [at[yt]];
            for (let _t = 0, bt = xt.length; _t < bt; _t++) {
                const Rt = xt[_t]
                  , Ft = Array.isArray(Rt.value) ? Rt.value : [Rt.value];
                for (let Bt = 0, Dt = Ft.length; Bt < Dt; Bt++) {
                    const Mt = Ft[Bt]
                      , Tt = lt(Mt)
                      , mt = ht % pt
                      , St = mt % Tt.boundary
                      , wt = mt + St;
                    ht += St,
                    wt !== 0 && pt - wt < Tt.storage && (ht += pt - wt),
                    Rt.__data = new Float32Array(Tt.storage / Float32Array.BYTES_PER_ELEMENT),
                    Rt.__offset = ht,
                    ht += Tt.storage
                }
            }
        }
        const dt = ht % pt;
        return dt > 0 && (ht += pt - dt),
        ot.__size = ht,
        ot.__cache = {},
        this
    }
    function lt(ot) {
        const at = {
            boundary: 0,
            storage: 0
        };
        return typeof ot == "number" || typeof ot == "boolean" ? (at.boundary = 4,
        at.storage = 4) : ot.isVector2 ? (at.boundary = 8,
        at.storage = 8) : ot.isVector3 || ot.isColor ? (at.boundary = 16,
        at.storage = 12) : ot.isVector4 ? (at.boundary = 16,
        at.storage = 16) : ot.isMatrix3 ? (at.boundary = 48,
        at.storage = 48) : ot.isMatrix4 ? (at.boundary = 64,
        at.storage = 64) : ot.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", ot),
        at
    }
    function ct(ot) {
        const at = ot.target;
        at.removeEventListener("dispose", ct);
        const ht = g.indexOf(at.__bindingPointIndex);
        g.splice(ht, 1),
        s.deleteBuffer(c[at.id]),
        delete c[at.id],
        delete d[at.id]
    }
    function it() {
        for (const ot in c)
            s.deleteBuffer(c[ot]);
        g = [],
        c = {},
        d = {}
    }
    return {
        bind: b,
        update: j,
        dispose: it
    }
}
class WebGLRenderer {
    constructor(e={}) {
        const {canvas: a=createCanvasElement(), context: o=null, depth: c=!0, stencil: d=!1, alpha: g=!1, antialias: _=!1, premultipliedAlpha: b=!0, preserveDrawingBuffer: j=!1, powerPreference: $="default", failIfMajorPerformanceCaveat: nt=!1} = e;
        this.isWebGLRenderer = !0;
        let tt;
        if (o !== null) {
            if (typeof WebGLRenderingContext < "u" && o instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            tt = o.getContextAttributes().alpha
        } else
            tt = g;
        const rt = new Uint32Array(4)
          , st = new Int32Array(4);
        let lt = null
          , ct = null;
        const it = []
          , ot = [];
        this.domElement = a,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = SRGBColorSpace,
        this.toneMapping = NoToneMapping,
        this.toneMappingExposure = 1;
        const at = this;
        let ht = !1
          , pt = 0
          , dt = 0
          , yt = null
          , vt = -1
          , xt = null;
        const _t = new Vector4
          , bt = new Vector4;
        let Rt = null;
        const Ft = new Color(0);
        let Bt = 0
          , Dt = a.width
          , Mt = a.height
          , Tt = 1
          , mt = null
          , St = null;
        const wt = new Vector4(0,0,Dt,Mt)
          , Ct = new Vector4(0,0,Dt,Mt);
        let Ht = !1;
        const en = new Frustum;
        let Ot = !1
          , Yt = !1;
        const rn = new Matrix4
          , Xt = new Vector3
          , An = new Vector4
          , Ln = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let _n = !1;
        function yn() {
            return yt === null ? Tt : 1
        }
        let Pt = o;
        function Qt(kt, zt) {
            return a.getContext(kt, zt)
        }
        try {
            const kt = {
                alpha: !0,
                depth: c,
                stencil: d,
                antialias: _,
                premultipliedAlpha: b,
                preserveDrawingBuffer: j,
                powerPreference: $,
                failIfMajorPerformanceCaveat: nt
            };
            if ("setAttribute"in a && a.setAttribute("data-engine", `three.js r${REVISION}`),
            a.addEventListener("webglcontextlost", an, !1),
            a.addEventListener("webglcontextrestored", un, !1),
            a.addEventListener("webglcontextcreationerror", En, !1),
            Pt === null) {
                const zt = "webgl2";
                if (Pt = Qt(zt, kt),
                Pt === null)
                    throw Qt(zt) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (kt) {
            throw console.error("THREE.WebGLRenderer: " + kt.message),
            kt
        }
        let jt, fn, tn, bn, gn, vn, Lt, At, $t, on, sn, cn, Pn, dn, Tn, jn, pn, kn, er, $n, Dn, Nt, ln, Cn;
        function Vt() {
            jt = new WebGLExtensions(Pt),
            jt.init(),
            Nt = new WebGLUtils(Pt,jt),
            fn = new WebGLCapabilities(Pt,jt,e,Nt),
            tn = new WebGLState(Pt),
            bn = new WebGLInfo(Pt),
            gn = new WebGLProperties,
            vn = new WebGLTextures(Pt,jt,tn,gn,fn,Nt,bn),
            Lt = new WebGLCubeMaps(at),
            At = new WebGLCubeUVMaps(at),
            $t = new WebGLAttributes(Pt),
            ln = new WebGLBindingStates(Pt,$t),
            on = new WebGLGeometries(Pt,$t,bn,ln),
            sn = new WebGLObjects(Pt,on,$t,bn),
            er = new WebGLMorphtargets(Pt,fn,vn),
            jn = new WebGLClipping(gn),
            cn = new WebGLPrograms(at,Lt,At,jt,fn,ln,jn),
            Pn = new WebGLMaterials(at,gn),
            dn = new WebGLRenderLists,
            Tn = new WebGLRenderStates(jt),
            kn = new WebGLBackground(at,Lt,At,tn,sn,tt,b),
            pn = new WebGLShadowMap(at,sn,fn),
            Cn = new WebGLUniformsGroups(Pt,bn,fn,tn),
            $n = new WebGLBufferRenderer(Pt,jt,bn),
            Dn = new WebGLIndexedBufferRenderer(Pt,jt,bn),
            bn.programs = cn.programs,
            at.capabilities = fn,
            at.extensions = jt,
            at.properties = gn,
            at.renderLists = dn,
            at.shadowMap = pn,
            at.state = tn,
            at.info = bn
        }
        Vt();
        const hn = new WebXRManager(at,Pt);
        this.xr = hn,
        this.getContext = function() {
            return Pt
        }
        ,
        this.getContextAttributes = function() {
            return Pt.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const kt = jt.get("WEBGL_lose_context");
            kt && kt.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const kt = jt.get("WEBGL_lose_context");
            kt && kt.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return Tt
        }
        ,
        this.setPixelRatio = function(kt) {
            kt !== void 0 && (Tt = kt,
            this.setSize(Dt, Mt, !1))
        }
        ,
        this.getSize = function(kt) {
            return kt.set(Dt, Mt)
        }
        ,
        this.setSize = function(kt, zt, Kt=!0) {
            if (hn.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            Dt = kt,
            Mt = zt,
            a.width = Math.floor(kt * Tt),
            a.height = Math.floor(zt * Tt),
            Kt === !0 && (a.style.width = kt + "px",
            a.style.height = zt + "px"),
            this.setViewport(0, 0, kt, zt)
        }
        ,
        this.getDrawingBufferSize = function(kt) {
            return kt.set(Dt * Tt, Mt * Tt).floor()
        }
        ,
        this.setDrawingBufferSize = function(kt, zt, Kt) {
            Dt = kt,
            Mt = zt,
            Tt = Kt,
            a.width = Math.floor(kt * Kt),
            a.height = Math.floor(zt * Kt),
            this.setViewport(0, 0, kt, zt)
        }
        ,
        this.getCurrentViewport = function(kt) {
            return kt.copy(_t)
        }
        ,
        this.getViewport = function(kt) {
            return kt.copy(wt)
        }
        ,
        this.setViewport = function(kt, zt, Kt, Zt) {
            kt.isVector4 ? wt.set(kt.x, kt.y, kt.z, kt.w) : wt.set(kt, zt, Kt, Zt),
            tn.viewport(_t.copy(wt).multiplyScalar(Tt).round())
        }
        ,
        this.getScissor = function(kt) {
            return kt.copy(Ct)
        }
        ,
        this.setScissor = function(kt, zt, Kt, Zt) {
            kt.isVector4 ? Ct.set(kt.x, kt.y, kt.z, kt.w) : Ct.set(kt, zt, Kt, Zt),
            tn.scissor(bt.copy(Ct).multiplyScalar(Tt).round())
        }
        ,
        this.getScissorTest = function() {
            return Ht
        }
        ,
        this.setScissorTest = function(kt) {
            tn.setScissorTest(Ht = kt)
        }
        ,
        this.setOpaqueSort = function(kt) {
            mt = kt
        }
        ,
        this.setTransparentSort = function(kt) {
            St = kt
        }
        ,
        this.getClearColor = function(kt) {
            return kt.copy(kn.getClearColor())
        }
        ,
        this.setClearColor = function() {
            kn.setClearColor.apply(kn, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return kn.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            kn.setClearAlpha.apply(kn, arguments)
        }
        ,
        this.clear = function(kt=!0, zt=!0, Kt=!0) {
            let Zt = 0;
            if (kt) {
                let Wt = !1;
                if (yt !== null) {
                    const Sn = yt.texture.format;
                    Wt = Sn === RGBAIntegerFormat || Sn === RGIntegerFormat || Sn === RedIntegerFormat
                }
                if (Wt) {
                    const Sn = yt.texture.type
                      , In = Sn === UnsignedByteType || Sn === UnsignedIntType || Sn === UnsignedShortType || Sn === UnsignedInt248Type || Sn === UnsignedShort4444Type || Sn === UnsignedShort5551Type
                      , Vn = kn.getClearColor()
                      , Bn = kn.getClearAlpha()
                      , Gn = Vn.r
                      , Xn = Vn.g
                      , zn = Vn.b;
                    In ? (rt[0] = Gn,
                    rt[1] = Xn,
                    rt[2] = zn,
                    rt[3] = Bn,
                    Pt.clearBufferuiv(Pt.COLOR, 0, rt)) : (st[0] = Gn,
                    st[1] = Xn,
                    st[2] = zn,
                    st[3] = Bn,
                    Pt.clearBufferiv(Pt.COLOR, 0, st))
                } else
                    Zt |= Pt.COLOR_BUFFER_BIT
            }
            zt && (Zt |= Pt.DEPTH_BUFFER_BIT),
            Kt && (Zt |= Pt.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            Pt.clear(Zt)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            a.removeEventListener("webglcontextlost", an, !1),
            a.removeEventListener("webglcontextrestored", un, !1),
            a.removeEventListener("webglcontextcreationerror", En, !1),
            dn.dispose(),
            Tn.dispose(),
            gn.dispose(),
            Lt.dispose(),
            At.dispose(),
            sn.dispose(),
            ln.dispose(),
            Cn.dispose(),
            cn.dispose(),
            hn.dispose(),
            hn.removeEventListener("sessionstart", br),
            hn.removeEventListener("sessionend", go),
            hs.stop()
        }
        ;
        function an(kt) {
            kt.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            ht = !0
        }
        function un() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            ht = !1;
            const kt = bn.autoReset
              , zt = pn.enabled
              , Kt = pn.autoUpdate
              , Zt = pn.needsUpdate
              , Wt = pn.type;
            Vt(),
            bn.autoReset = kt,
            pn.enabled = zt,
            pn.autoUpdate = Kt,
            pn.needsUpdate = Zt,
            pn.type = Wt
        }
        function En(kt) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", kt.statusMessage)
        }
        function Hn(kt) {
            const zt = kt.target;
            zt.removeEventListener("dispose", Hn),
            Yn(zt)
        }
        function Yn(kt) {
            tr(kt),
            gn.remove(kt)
        }
        function tr(kt) {
            const zt = gn.get(kt).programs;
            zt !== void 0 && (zt.forEach(function(Kt) {
                cn.releaseProgram(Kt)
            }),
            kt.isShaderMaterial && cn.releaseShaderCache(kt))
        }
        this.renderBufferDirect = function(kt, zt, Kt, Zt, Wt, Sn) {
            zt === null && (zt = Ln);
            const In = Wt.isMesh && Wt.matrixWorld.determinant() < 0
              , Vn = Ll(kt, zt, Kt, Zt, Wt);
            tn.setMaterial(Zt, In);
            let Bn = Kt.index
              , Gn = 1;
            if (Zt.wireframe === !0) {
                if (Bn = on.getWireframeAttribute(Kt),
                Bn === void 0)
                    return;
                Gn = 2
            }
            const Xn = Kt.drawRange
              , zn = Kt.attributes.position;
            let nr = Xn.start * Gn
              , lr = (Xn.start + Xn.count) * Gn;
            Sn !== null && (nr = Math.max(nr, Sn.start * Gn),
            lr = Math.min(lr, (Sn.start + Sn.count) * Gn)),
            Bn !== null ? (nr = Math.max(nr, 0),
            lr = Math.min(lr, Bn.count)) : zn != null && (nr = Math.max(nr, 0),
            lr = Math.min(lr, zn.count));
            const ar = lr - nr;
            if (ar < 0 || ar === 1 / 0)
                return;
            ln.setup(Wt, Zt, Vn, Kt, Bn);
            let gr, Un = $n;
            if (Bn !== null && (gr = $t.get(Bn),
            Un = Dn,
            Un.setIndex(gr)),
            Wt.isMesh)
                Zt.wireframe === !0 ? (tn.setLineWidth(Zt.wireframeLinewidth * yn()),
                Un.setMode(Pt.LINES)) : Un.setMode(Pt.TRIANGLES);
            else if (Wt.isLine) {
                let Mn = Zt.linewidth;
                Mn === void 0 && (Mn = 1),
                tn.setLineWidth(Mn * yn()),
                Wt.isLineSegments ? Un.setMode(Pt.LINES) : Wt.isLineLoop ? Un.setMode(Pt.LINE_LOOP) : Un.setMode(Pt.LINE_STRIP)
            } else
                Wt.isPoints ? Un.setMode(Pt.POINTS) : Wt.isSprite && Un.setMode(Pt.TRIANGLES);
            if (Wt.isBatchedMesh)
                if (Wt._multiDrawInstances !== null)
                    Un.renderMultiDrawInstances(Wt._multiDrawStarts, Wt._multiDrawCounts, Wt._multiDrawCount, Wt._multiDrawInstances);
                else if (jt.get("WEBGL_multi_draw"))
                    Un.renderMultiDraw(Wt._multiDrawStarts, Wt._multiDrawCounts, Wt._multiDrawCount);
                else {
                    const Mn = Wt._multiDrawStarts
                      , cr = Wt._multiDrawCounts
                      , qn = Wt._multiDrawCount
                      , ur = Bn ? $t.get(Bn).bytesPerElement : 1
                      , Vr = gn.get(Zt).currentProgram.getUniforms();
                    for (let xr = 0; xr < qn; xr++)
                        Vr.setValue(Pt, "_gl_DrawID", xr),
                        Un.render(Mn[xr] / ur, cr[xr])
                }
            else if (Wt.isInstancedMesh)
                Un.renderInstances(nr, ar, Wt.count);
            else if (Kt.isInstancedBufferGeometry) {
                const Mn = Kt._maxInstanceCount !== void 0 ? Kt._maxInstanceCount : 1 / 0
                  , cr = Math.min(Kt.instanceCount, Mn);
                Un.renderInstances(nr, ar, cr)
            } else
                Un.render(nr, ar)
        }
        ;
        function hr(kt, zt, Kt) {
            kt.transparent === !0 && kt.side === DoubleSide && kt.forceSinglePass === !1 ? (kt.side = BackSide,
            kt.needsUpdate = !0,
            Ns(kt, zt, Kt),
            kt.side = FrontSide,
            kt.needsUpdate = !0,
            Ns(kt, zt, Kt),
            kt.side = DoubleSide) : Ns(kt, zt, Kt)
        }
        this.compile = function(kt, zt, Kt=null) {
            Kt === null && (Kt = kt),
            ct = Tn.get(Kt),
            ct.init(zt),
            ot.push(ct),
            Kt.traverseVisible(function(Wt) {
                Wt.isLight && Wt.layers.test(zt.layers) && (ct.pushLight(Wt),
                Wt.castShadow && ct.pushShadow(Wt))
            }),
            kt !== Kt && kt.traverseVisible(function(Wt) {
                Wt.isLight && Wt.layers.test(zt.layers) && (ct.pushLight(Wt),
                Wt.castShadow && ct.pushShadow(Wt))
            }),
            ct.setupLights();
            const Zt = new Set;
            return kt.traverse(function(Wt) {
                const Sn = Wt.material;
                if (Sn)
                    if (Array.isArray(Sn))
                        for (let In = 0; In < Sn.length; In++) {
                            const Vn = Sn[In];
                            hr(Vn, Kt, Wt),
                            Zt.add(Vn)
                        }
                    else
                        hr(Sn, Kt, Wt),
                        Zt.add(Sn)
            }),
            ot.pop(),
            ct = null,
            Zt
        }
        ,
        this.compileAsync = function(kt, zt, Kt=null) {
            const Zt = this.compile(kt, zt, Kt);
            return new Promise(Wt => {
                function Sn() {
                    if (Zt.forEach(function(In) {
                        gn.get(In).currentProgram.isReady() && Zt.delete(In)
                    }),
                    Zt.size === 0) {
                        Wt(kt);
                        return
                    }
                    setTimeout(Sn, 10)
                }
                jt.get("KHR_parallel_shader_compile") !== null ? Sn() : setTimeout(Sn, 10)
            }
            )
        }
        ;
        let Jn = null;
        function Mr(kt) {
            Jn && Jn(kt)
        }
        function br() {
            hs.stop()
        }
        function go() {
            hs.start()
        }
        const hs = new WebGLAnimation;
        hs.setAnimationLoop(Mr),
        typeof self < "u" && hs.setContext(self),
        this.setAnimationLoop = function(kt) {
            Jn = kt,
            hn.setAnimationLoop(kt),
            kt === null ? hs.stop() : hs.start()
        }
        ,
        hn.addEventListener("sessionstart", br),
        hn.addEventListener("sessionend", go),
        this.render = function(kt, zt) {
            if (zt !== void 0 && zt.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (ht === !0)
                return;
            if (kt.matrixWorldAutoUpdate === !0 && kt.updateMatrixWorld(),
            zt.parent === null && zt.matrixWorldAutoUpdate === !0 && zt.updateMatrixWorld(),
            hn.enabled === !0 && hn.isPresenting === !0 && (hn.cameraAutoUpdate === !0 && hn.updateCamera(zt),
            zt = hn.getCamera()),
            kt.isScene === !0 && kt.onBeforeRender(at, kt, zt, yt),
            ct = Tn.get(kt, ot.length),
            ct.init(zt),
            ot.push(ct),
            rn.multiplyMatrices(zt.projectionMatrix, zt.matrixWorldInverse),
            en.setFromProjectionMatrix(rn),
            Yt = this.localClippingEnabled,
            Ot = jn.init(this.clippingPlanes, Yt),
            lt = dn.get(kt, it.length),
            lt.init(),
            it.push(lt),
            hn.enabled === !0 && hn.isPresenting === !0) {
                const Sn = at.xr.getDepthSensingMesh();
                Sn !== null && Js(Sn, zt, -1 / 0, at.sortObjects)
            }
            Js(kt, zt, 0, at.sortObjects),
            lt.finish(),
            at.sortObjects === !0 && lt.sort(mt, St),
            _n = hn.enabled === !1 || hn.isPresenting === !1 || hn.hasDepthSensing() === !1,
            _n && kn.addToRenderList(lt, kt),
            this.info.render.frame++,
            Ot === !0 && jn.beginShadows();
            const Kt = ct.state.shadowsArray;
            pn.render(Kt, kt, zt),
            Ot === !0 && jn.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const Zt = lt.opaque
              , Wt = lt.transmissive;
            if (ct.setupLights(),
            zt.isArrayCamera) {
                const Sn = zt.cameras;
                if (Wt.length > 0)
                    for (let In = 0, Vn = Sn.length; In < Vn; In++) {
                        const Bn = Sn[In];
                        Bs(Zt, Wt, kt, Bn)
                    }
                _n && kn.render(kt);
                for (let In = 0, Vn = Sn.length; In < Vn; In++) {
                    const Bn = Sn[In];
                    na(lt, kt, Bn, Bn.viewport)
                }
            } else
                Wt.length > 0 && Bs(Zt, Wt, kt, zt),
                _n && kn.render(kt),
                na(lt, kt, zt);
            yt !== null && (vn.updateMultisampleRenderTarget(yt),
            vn.updateRenderTargetMipmap(yt)),
            kt.isScene === !0 && kt.onAfterRender(at, kt, zt),
            ln.resetDefaultState(),
            vt = -1,
            xt = null,
            ot.pop(),
            ot.length > 0 ? (ct = ot[ot.length - 1],
            Ot === !0 && jn.setGlobalState(at.clippingPlanes, ct.state.camera)) : ct = null,
            it.pop(),
            it.length > 0 ? lt = it[it.length - 1] : lt = null
        }
        ;
        function Js(kt, zt, Kt, Zt) {
            if (kt.visible === !1)
                return;
            if (kt.layers.test(zt.layers)) {
                if (kt.isGroup)
                    Kt = kt.renderOrder;
                else if (kt.isLOD)
                    kt.autoUpdate === !0 && kt.update(zt);
                else if (kt.isLight)
                    ct.pushLight(kt),
                    kt.castShadow && ct.pushShadow(kt);
                else if (kt.isSprite) {
                    if (!kt.frustumCulled || en.intersectsSprite(kt)) {
                        Zt && An.setFromMatrixPosition(kt.matrixWorld).applyMatrix4(rn);
                        const In = sn.update(kt)
                          , Vn = kt.material;
                        Vn.visible && lt.push(kt, In, Vn, Kt, An.z, null)
                    }
                } else if ((kt.isMesh || kt.isLine || kt.isPoints) && (!kt.frustumCulled || en.intersectsObject(kt))) {
                    const In = sn.update(kt)
                      , Vn = kt.material;
                    if (Zt && (kt.boundingSphere !== void 0 ? (kt.boundingSphere === null && kt.computeBoundingSphere(),
                    An.copy(kt.boundingSphere.center)) : (In.boundingSphere === null && In.computeBoundingSphere(),
                    An.copy(In.boundingSphere.center)),
                    An.applyMatrix4(kt.matrixWorld).applyMatrix4(rn)),
                    Array.isArray(Vn)) {
                        const Bn = In.groups;
                        for (let Gn = 0, Xn = Bn.length; Gn < Xn; Gn++) {
                            const zn = Bn[Gn]
                              , nr = Vn[zn.materialIndex];
                            nr && nr.visible && lt.push(kt, In, nr, Kt, An.z, zn)
                        }
                    } else
                        Vn.visible && lt.push(kt, In, Vn, Kt, An.z, null)
                }
            }
            const Sn = kt.children;
            for (let In = 0, Vn = Sn.length; In < Vn; In++)
                Js(Sn[In], zt, Kt, Zt)
        }
        function na(kt, zt, Kt, Zt) {
            const Wt = kt.opaque
              , Sn = kt.transmissive
              , In = kt.transparent;
            ct.setupLightsView(Kt),
            Ot === !0 && jn.setGlobalState(at.clippingPlanes, Kt),
            Zt && tn.viewport(_t.copy(Zt)),
            Wt.length > 0 && Vs(Wt, zt, Kt),
            Sn.length > 0 && Vs(Sn, zt, Kt),
            In.length > 0 && Vs(In, zt, Kt),
            tn.buffers.depth.setTest(!0),
            tn.buffers.depth.setMask(!0),
            tn.buffers.color.setMask(!0),
            tn.setPolygonOffset(!1)
        }
        function Bs(kt, zt, Kt, Zt) {
            if ((Kt.isScene === !0 ? Kt.overrideMaterial : null) !== null)
                return;
            ct.state.transmissionRenderTarget[Zt.id] === void 0 && (ct.state.transmissionRenderTarget[Zt.id] = new WebGLRenderTarget(1,1,{
                generateMipmaps: !0,
                type: jt.has("EXT_color_buffer_half_float") || jt.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
                minFilter: LinearMipmapLinearFilter,
                samples: 4,
                stencilBuffer: d,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: ColorManagement.workingColorSpace
            }));
            const Sn = ct.state.transmissionRenderTarget[Zt.id]
              , In = Zt.viewport || _t;
            Sn.setSize(In.z, In.w);
            const Vn = at.getRenderTarget();
            at.setRenderTarget(Sn),
            at.getClearColor(Ft),
            Bt = at.getClearAlpha(),
            Bt < 1 && at.setClearColor(16777215, .5),
            at.clear(),
            _n && kn.render(Kt);
            const Bn = at.toneMapping;
            at.toneMapping = NoToneMapping;
            const Gn = Zt.viewport;
            if (Zt.viewport !== void 0 && (Zt.viewport = void 0),
            ct.setupLightsView(Zt),
            Ot === !0 && jn.setGlobalState(at.clippingPlanes, Zt),
            Vs(kt, Kt, Zt),
            vn.updateMultisampleRenderTarget(Sn),
            vn.updateRenderTargetMipmap(Sn),
            jt.has("WEBGL_multisampled_render_to_texture") === !1) {
                let Xn = !1;
                for (let zn = 0, nr = zt.length; zn < nr; zn++) {
                    const lr = zt[zn]
                      , ar = lr.object
                      , gr = lr.geometry
                      , Un = lr.material
                      , Mn = lr.group;
                    if (Un.side === DoubleSide && ar.layers.test(Zt.layers)) {
                        const cr = Un.side;
                        Un.side = BackSide,
                        Un.needsUpdate = !0,
                        vs(ar, Kt, Zt, gr, Un, Mn),
                        Un.side = cr,
                        Un.needsUpdate = !0,
                        Xn = !0
                    }
                }
                Xn === !0 && (vn.updateMultisampleRenderTarget(Sn),
                vn.updateRenderTargetMipmap(Sn))
            }
            at.setRenderTarget(Vn),
            at.setClearColor(Ft, Bt),
            Gn !== void 0 && (Zt.viewport = Gn),
            at.toneMapping = Bn
        }
        function Vs(kt, zt, Kt) {
            const Zt = zt.isScene === !0 ? zt.overrideMaterial : null;
            for (let Wt = 0, Sn = kt.length; Wt < Sn; Wt++) {
                const In = kt[Wt]
                  , Vn = In.object
                  , Bn = In.geometry
                  , Gn = Zt === null ? In.material : Zt
                  , Xn = In.group;
                Vn.layers.test(Kt.layers) && vs(Vn, zt, Kt, Bn, Gn, Xn)
            }
        }
        function vs(kt, zt, Kt, Zt, Wt, Sn) {
            kt.onBeforeRender(at, zt, Kt, Zt, Wt, Sn),
            kt.modelViewMatrix.multiplyMatrices(Kt.matrixWorldInverse, kt.matrixWorld),
            kt.normalMatrix.getNormalMatrix(kt.modelViewMatrix),
            Wt.transparent === !0 && Wt.side === DoubleSide && Wt.forceSinglePass === !1 ? (Wt.side = BackSide,
            Wt.needsUpdate = !0,
            at.renderBufferDirect(Kt, zt, Zt, Wt, kt, Sn),
            Wt.side = FrontSide,
            Wt.needsUpdate = !0,
            at.renderBufferDirect(Kt, zt, Zt, Wt, kt, Sn),
            Wt.side = DoubleSide) : at.renderBufferDirect(Kt, zt, Zt, Wt, kt, Sn),
            kt.onAfterRender(at, zt, Kt, Zt, Wt, Sn)
        }
        function Ns(kt, zt, Kt) {
            zt.isScene !== !0 && (zt = Ln);
            const Zt = gn.get(kt)
              , Wt = ct.state.lights
              , Sn = ct.state.shadowsArray
              , In = Wt.state.version
              , Vn = cn.getParameters(kt, Wt.state, Sn, zt, Kt)
              , Bn = cn.getProgramCacheKey(Vn);
            let Gn = Zt.programs;
            Zt.environment = kt.isMeshStandardMaterial ? zt.environment : null,
            Zt.fog = zt.fog,
            Zt.envMap = (kt.isMeshStandardMaterial ? At : Lt).get(kt.envMap || Zt.environment),
            Zt.envMapRotation = Zt.environment !== null && kt.envMap === null ? zt.environmentRotation : kt.envMapRotation,
            Gn === void 0 && (kt.addEventListener("dispose", Hn),
            Gn = new Map,
            Zt.programs = Gn);
            let Xn = Gn.get(Bn);
            if (Xn !== void 0) {
                if (Zt.currentProgram === Xn && Zt.lightsStateVersion === In)
                    return vo(kt, Vn),
                    Xn
            } else
                Vn.uniforms = cn.getUniforms(kt),
                kt.onBeforeCompile(Vn, at),
                Xn = cn.acquireProgram(Vn, Bn),
                Gn.set(Bn, Xn),
                Zt.uniforms = Vn.uniforms;
            const zn = Zt.uniforms;
            return (!kt.isShaderMaterial && !kt.isRawShaderMaterial || kt.clipping === !0) && (zn.clippingPlanes = jn.uniform),
            vo(kt, Vn),
            Zt.needsLights = Dl(kt),
            Zt.lightsStateVersion = In,
            Zt.needsLights && (zn.ambientLightColor.value = Wt.state.ambient,
            zn.lightProbe.value = Wt.state.probe,
            zn.directionalLights.value = Wt.state.directional,
            zn.directionalLightShadows.value = Wt.state.directionalShadow,
            zn.spotLights.value = Wt.state.spot,
            zn.spotLightShadows.value = Wt.state.spotShadow,
            zn.rectAreaLights.value = Wt.state.rectArea,
            zn.ltc_1.value = Wt.state.rectAreaLTC1,
            zn.ltc_2.value = Wt.state.rectAreaLTC2,
            zn.pointLights.value = Wt.state.point,
            zn.pointLightShadows.value = Wt.state.pointShadow,
            zn.hemisphereLights.value = Wt.state.hemi,
            zn.directionalShadowMap.value = Wt.state.directionalShadowMap,
            zn.directionalShadowMatrix.value = Wt.state.directionalShadowMatrix,
            zn.spotShadowMap.value = Wt.state.spotShadowMap,
            zn.spotLightMatrix.value = Wt.state.spotLightMatrix,
            zn.spotLightMap.value = Wt.state.spotLightMap,
            zn.pointShadowMap.value = Wt.state.pointShadowMap,
            zn.pointShadowMatrix.value = Wt.state.pointShadowMatrix),
            Zt.currentProgram = Xn,
            Zt.uniformsList = null,
            Xn
        }
        function yo(kt) {
            if (kt.uniformsList === null) {
                const zt = kt.currentProgram.getUniforms();
                kt.uniformsList = WebGLUniforms.seqWithValue(zt.seq, kt.uniforms)
            }
            return kt.uniformsList
        }
        function vo(kt, zt) {
            const Kt = gn.get(kt);
            Kt.outputColorSpace = zt.outputColorSpace,
            Kt.batching = zt.batching,
            Kt.batchingColor = zt.batchingColor,
            Kt.instancing = zt.instancing,
            Kt.instancingColor = zt.instancingColor,
            Kt.instancingMorph = zt.instancingMorph,
            Kt.skinning = zt.skinning,
            Kt.morphTargets = zt.morphTargets,
            Kt.morphNormals = zt.morphNormals,
            Kt.morphColors = zt.morphColors,
            Kt.morphTargetsCount = zt.morphTargetsCount,
            Kt.numClippingPlanes = zt.numClippingPlanes,
            Kt.numIntersection = zt.numClipIntersection,
            Kt.vertexAlphas = zt.vertexAlphas,
            Kt.vertexTangents = zt.vertexTangents,
            Kt.toneMapping = zt.toneMapping
        }
        function Ll(kt, zt, Kt, Zt, Wt) {
            zt.isScene !== !0 && (zt = Ln),
            vn.resetTextureUnits();
            const Sn = zt.fog
              , In = Zt.isMeshStandardMaterial ? zt.environment : null
              , Vn = yt === null ? at.outputColorSpace : yt.isXRRenderTarget === !0 ? yt.texture.colorSpace : LinearSRGBColorSpace
              , Bn = (Zt.isMeshStandardMaterial ? At : Lt).get(Zt.envMap || In)
              , Gn = Zt.vertexColors === !0 && !!Kt.attributes.color && Kt.attributes.color.itemSize === 4
              , Xn = !!Kt.attributes.tangent && (!!Zt.normalMap || Zt.anisotropy > 0)
              , zn = !!Kt.morphAttributes.position
              , nr = !!Kt.morphAttributes.normal
              , lr = !!Kt.morphAttributes.color;
            let ar = NoToneMapping;
            Zt.toneMapped && (yt === null || yt.isXRRenderTarget === !0) && (ar = at.toneMapping);
            const gr = Kt.morphAttributes.position || Kt.morphAttributes.normal || Kt.morphAttributes.color
              , Un = gr !== void 0 ? gr.length : 0
              , Mn = gn.get(Zt)
              , cr = ct.state.lights;
            if (Ot === !0 && (Yt === !0 || kt !== xt)) {
                const Pr = kt === xt && Zt.id === vt;
                jn.setState(Zt, kt, Pr)
            }
            let qn = !1;
            Zt.version === Mn.__version ? (Mn.needsLights && Mn.lightsStateVersion !== cr.state.version || Mn.outputColorSpace !== Vn || Wt.isBatchedMesh && Mn.batching === !1 || !Wt.isBatchedMesh && Mn.batching === !0 || Wt.isBatchedMesh && Mn.batchingColor === !0 && Wt.colorTexture === null || Wt.isBatchedMesh && Mn.batchingColor === !1 && Wt.colorTexture !== null || Wt.isInstancedMesh && Mn.instancing === !1 || !Wt.isInstancedMesh && Mn.instancing === !0 || Wt.isSkinnedMesh && Mn.skinning === !1 || !Wt.isSkinnedMesh && Mn.skinning === !0 || Wt.isInstancedMesh && Mn.instancingColor === !0 && Wt.instanceColor === null || Wt.isInstancedMesh && Mn.instancingColor === !1 && Wt.instanceColor !== null || Wt.isInstancedMesh && Mn.instancingMorph === !0 && Wt.morphTexture === null || Wt.isInstancedMesh && Mn.instancingMorph === !1 && Wt.morphTexture !== null || Mn.envMap !== Bn || Zt.fog === !0 && Mn.fog !== Sn || Mn.numClippingPlanes !== void 0 && (Mn.numClippingPlanes !== jn.numPlanes || Mn.numIntersection !== jn.numIntersection) || Mn.vertexAlphas !== Gn || Mn.vertexTangents !== Xn || Mn.morphTargets !== zn || Mn.morphNormals !== nr || Mn.morphColors !== lr || Mn.toneMapping !== ar || Mn.morphTargetsCount !== Un) && (qn = !0) : (qn = !0,
            Mn.__version = Zt.version);
            let ur = Mn.currentProgram;
            qn === !0 && (ur = Ns(Zt, zt, Wt));
            let Vr = !1
              , xr = !1
              , Ar = !1;
            const dr = ur.getUniforms()
              , es = Mn.uniforms;
            if (tn.useProgram(ur.program) && (Vr = !0,
            xr = !0,
            Ar = !0),
            Zt.id !== vt && (vt = Zt.id,
            xr = !0),
            Vr || xt !== kt) {
                dr.setValue(Pt, "projectionMatrix", kt.projectionMatrix),
                dr.setValue(Pt, "viewMatrix", kt.matrixWorldInverse);
                const Pr = dr.map.cameraPosition;
                Pr !== void 0 && Pr.setValue(Pt, Xt.setFromMatrixPosition(kt.matrixWorld)),
                fn.logarithmicDepthBuffer && dr.setValue(Pt, "logDepthBufFC", 2 / (Math.log(kt.far + 1) / Math.LN2)),
                (Zt.isMeshPhongMaterial || Zt.isMeshToonMaterial || Zt.isMeshLambertMaterial || Zt.isMeshBasicMaterial || Zt.isMeshStandardMaterial || Zt.isShaderMaterial) && dr.setValue(Pt, "isOrthographic", kt.isOrthographicCamera === !0),
                xt !== kt && (xt = kt,
                xr = !0,
                Ar = !0)
            }
            if (Wt.isSkinnedMesh) {
                dr.setOptional(Pt, Wt, "bindMatrix"),
                dr.setOptional(Pt, Wt, "bindMatrixInverse");
                const Pr = Wt.skeleton;
                Pr && (Pr.boneTexture === null && Pr.computeBoneTexture(),
                dr.setValue(Pt, "boneTexture", Pr.boneTexture, vn))
            }
            Wt.isBatchedMesh && (dr.setOptional(Pt, Wt, "batchingTexture"),
            dr.setValue(Pt, "batchingTexture", Wt._matricesTexture, vn),
            dr.setOptional(Pt, Wt, "batchingIdTexture"),
            dr.setValue(Pt, "batchingIdTexture", Wt._indirectTexture, vn),
            dr.setOptional(Pt, Wt, "batchingColorTexture"),
            Wt._colorsTexture !== null && dr.setValue(Pt, "batchingColorTexture", Wt._colorsTexture, vn));
            const Os = Kt.morphAttributes;
            if ((Os.position !== void 0 || Os.normal !== void 0 || Os.color !== void 0) && er.update(Wt, Kt, ur),
            (xr || Mn.receiveShadow !== Wt.receiveShadow) && (Mn.receiveShadow = Wt.receiveShadow,
            dr.setValue(Pt, "receiveShadow", Wt.receiveShadow)),
            Zt.isMeshGouraudMaterial && Zt.envMap !== null && (es.envMap.value = Bn,
            es.flipEnvMap.value = Bn.isCubeTexture && Bn.isRenderTargetTexture === !1 ? -1 : 1),
            Zt.isMeshStandardMaterial && Zt.envMap === null && zt.environment !== null && (es.envMapIntensity.value = zt.environmentIntensity),
            xr && (dr.setValue(Pt, "toneMappingExposure", at.toneMappingExposure),
            Mn.needsLights && Il(es, Ar),
            Sn && Zt.fog === !0 && Pn.refreshFogUniforms(es, Sn),
            Pn.refreshMaterialUniforms(es, Zt, Tt, Mt, ct.state.transmissionRenderTarget[kt.id]),
            WebGLUniforms.upload(Pt, yo(Mn), es, vn)),
            Zt.isShaderMaterial && Zt.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(Pt, yo(Mn), es, vn),
            Zt.uniformsNeedUpdate = !1),
            Zt.isSpriteMaterial && dr.setValue(Pt, "center", Wt.center),
            dr.setValue(Pt, "modelViewMatrix", Wt.modelViewMatrix),
            dr.setValue(Pt, "normalMatrix", Wt.normalMatrix),
            dr.setValue(Pt, "modelMatrix", Wt.matrixWorld),
            Zt.isShaderMaterial || Zt.isRawShaderMaterial) {
                const Pr = Zt.uniformsGroups;
                for (let Us = 0, zr = Pr.length; Us < zr; Us++) {
                    const xo = Pr[Us];
                    Cn.update(xo, ur),
                    Cn.bind(xo, ur)
                }
            }
            return ur
        }
        function Il(kt, zt) {
            kt.ambientLightColor.needsUpdate = zt,
            kt.lightProbe.needsUpdate = zt,
            kt.directionalLights.needsUpdate = zt,
            kt.directionalLightShadows.needsUpdate = zt,
            kt.pointLights.needsUpdate = zt,
            kt.pointLightShadows.needsUpdate = zt,
            kt.spotLights.needsUpdate = zt,
            kt.spotLightShadows.needsUpdate = zt,
            kt.rectAreaLights.needsUpdate = zt,
            kt.hemisphereLights.needsUpdate = zt
        }
        function Dl(kt) {
            return kt.isMeshLambertMaterial || kt.isMeshToonMaterial || kt.isMeshPhongMaterial || kt.isMeshStandardMaterial || kt.isShadowMaterial || kt.isShaderMaterial && kt.lights === !0
        }
        this.getActiveCubeFace = function() {
            return pt
        }
        ,
        this.getActiveMipmapLevel = function() {
            return dt
        }
        ,
        this.getRenderTarget = function() {
            return yt
        }
        ,
        this.setRenderTargetTextures = function(kt, zt, Kt) {
            gn.get(kt.texture).__webglTexture = zt,
            gn.get(kt.depthTexture).__webglTexture = Kt;
            const Zt = gn.get(kt);
            Zt.__hasExternalTextures = !0,
            Zt.__autoAllocateDepthBuffer = Kt === void 0,
            Zt.__autoAllocateDepthBuffer || jt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            Zt.__useRenderToTexture = !1)
        }
        ,
        this.setRenderTargetFramebuffer = function(kt, zt) {
            const Kt = gn.get(kt);
            Kt.__webglFramebuffer = zt,
            Kt.__useDefaultFramebuffer = zt === void 0
        }
        ,
        this.setRenderTarget = function(kt, zt=0, Kt=0) {
            yt = kt,
            pt = zt,
            dt = Kt;
            let Zt = !0
              , Wt = null
              , Sn = !1
              , In = !1;
            if (kt) {
                const Bn = gn.get(kt);
                Bn.__useDefaultFramebuffer !== void 0 ? (tn.bindFramebuffer(Pt.FRAMEBUFFER, null),
                Zt = !1) : Bn.__webglFramebuffer === void 0 ? vn.setupRenderTarget(kt) : Bn.__hasExternalTextures && vn.rebindTextures(kt, gn.get(kt.texture).__webglTexture, gn.get(kt.depthTexture).__webglTexture);
                const Gn = kt.texture;
                (Gn.isData3DTexture || Gn.isDataArrayTexture || Gn.isCompressedArrayTexture) && (In = !0);
                const Xn = gn.get(kt).__webglFramebuffer;
                kt.isWebGLCubeRenderTarget ? (Array.isArray(Xn[zt]) ? Wt = Xn[zt][Kt] : Wt = Xn[zt],
                Sn = !0) : kt.samples > 0 && vn.useMultisampledRTT(kt) === !1 ? Wt = gn.get(kt).__webglMultisampledFramebuffer : Array.isArray(Xn) ? Wt = Xn[Kt] : Wt = Xn,
                _t.copy(kt.viewport),
                bt.copy(kt.scissor),
                Rt = kt.scissorTest
            } else
                _t.copy(wt).multiplyScalar(Tt).floor(),
                bt.copy(Ct).multiplyScalar(Tt).floor(),
                Rt = Ht;
            if (tn.bindFramebuffer(Pt.FRAMEBUFFER, Wt) && Zt && tn.drawBuffers(kt, Wt),
            tn.viewport(_t),
            tn.scissor(bt),
            tn.setScissorTest(Rt),
            Sn) {
                const Bn = gn.get(kt.texture);
                Pt.framebufferTexture2D(Pt.FRAMEBUFFER, Pt.COLOR_ATTACHMENT0, Pt.TEXTURE_CUBE_MAP_POSITIVE_X + zt, Bn.__webglTexture, Kt)
            } else if (In) {
                const Bn = gn.get(kt.texture)
                  , Gn = zt || 0;
                Pt.framebufferTextureLayer(Pt.FRAMEBUFFER, Pt.COLOR_ATTACHMENT0, Bn.__webglTexture, Kt || 0, Gn)
            }
            vt = -1
        }
        ,
        this.readRenderTargetPixels = function(kt, zt, Kt, Zt, Wt, Sn, In) {
            if (!(kt && kt.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Vn = gn.get(kt).__webglFramebuffer;
            if (kt.isWebGLCubeRenderTarget && In !== void 0 && (Vn = Vn[In]),
            Vn) {
                tn.bindFramebuffer(Pt.FRAMEBUFFER, Vn);
                try {
                    const Bn = kt.texture
                      , Gn = Bn.format
                      , Xn = Bn.type;
                    if (!fn.textureFormatReadable(Gn)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!fn.textureTypeReadable(Xn)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    zt >= 0 && zt <= kt.width - Zt && Kt >= 0 && Kt <= kt.height - Wt && Pt.readPixels(zt, Kt, Zt, Wt, Nt.convert(Gn), Nt.convert(Xn), Sn)
                } finally {
                    const Bn = yt !== null ? gn.get(yt).__webglFramebuffer : null;
                    tn.bindFramebuffer(Pt.FRAMEBUFFER, Bn)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(kt, zt, Kt, Zt, Wt, Sn, In) {
            if (!(kt && kt.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Vn = gn.get(kt).__webglFramebuffer;
            if (kt.isWebGLCubeRenderTarget && In !== void 0 && (Vn = Vn[In]),
            Vn) {
                tn.bindFramebuffer(Pt.FRAMEBUFFER, Vn);
                try {
                    const Bn = kt.texture
                      , Gn = Bn.format
                      , Xn = Bn.type;
                    if (!fn.textureFormatReadable(Gn))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!fn.textureTypeReadable(Xn))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    if (zt >= 0 && zt <= kt.width - Zt && Kt >= 0 && Kt <= kt.height - Wt) {
                        const zn = Pt.createBuffer();
                        Pt.bindBuffer(Pt.PIXEL_PACK_BUFFER, zn),
                        Pt.bufferData(Pt.PIXEL_PACK_BUFFER, Sn.byteLength, Pt.STREAM_READ),
                        Pt.readPixels(zt, Kt, Zt, Wt, Nt.convert(Gn), Nt.convert(Xn), 0),
                        Pt.flush();
                        const nr = Pt.fenceSync(Pt.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        await probeAsync(Pt, nr, 4);
                        try {
                            Pt.bindBuffer(Pt.PIXEL_PACK_BUFFER, zn),
                            Pt.getBufferSubData(Pt.PIXEL_PACK_BUFFER, 0, Sn)
                        } finally {
                            Pt.deleteBuffer(zn),
                            Pt.deleteSync(nr)
                        }
                        return Sn
                    }
                } finally {
                    const Bn = yt !== null ? gn.get(yt).__webglFramebuffer : null;
                    tn.bindFramebuffer(Pt.FRAMEBUFFER, Bn)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(kt, zt=null, Kt=0) {
            kt.isTexture !== !0 && (warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
            zt = arguments[0] || null,
            kt = arguments[1]);
            const Zt = Math.pow(2, -Kt)
              , Wt = Math.floor(kt.image.width * Zt)
              , Sn = Math.floor(kt.image.height * Zt)
              , In = zt !== null ? zt.x : 0
              , Vn = zt !== null ? zt.y : 0;
            vn.setTexture2D(kt, 0),
            Pt.copyTexSubImage2D(Pt.TEXTURE_2D, Kt, 0, 0, In, Vn, Wt, Sn),
            tn.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(kt, zt, Kt=null, Zt=null, Wt=0) {
            kt.isTexture !== !0 && (warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed."),
            Zt = arguments[0] || null,
            kt = arguments[1],
            zt = arguments[2],
            Wt = arguments[3] || 0,
            Kt = null);
            let Sn, In, Vn, Bn, Gn, Xn;
            Kt !== null ? (Sn = Kt.max.x - Kt.min.x,
            In = Kt.max.y - Kt.min.y,
            Vn = Kt.min.x,
            Bn = Kt.min.y) : (Sn = kt.image.width,
            In = kt.image.height,
            Vn = 0,
            Bn = 0),
            Zt !== null ? (Gn = Zt.x,
            Xn = Zt.y) : (Gn = 0,
            Xn = 0);
            const zn = Nt.convert(zt.format)
              , nr = Nt.convert(zt.type);
            vn.setTexture2D(zt, 0),
            Pt.pixelStorei(Pt.UNPACK_FLIP_Y_WEBGL, zt.flipY),
            Pt.pixelStorei(Pt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, zt.premultiplyAlpha),
            Pt.pixelStorei(Pt.UNPACK_ALIGNMENT, zt.unpackAlignment);
            const lr = Pt.getParameter(Pt.UNPACK_ROW_LENGTH)
              , ar = Pt.getParameter(Pt.UNPACK_IMAGE_HEIGHT)
              , gr = Pt.getParameter(Pt.UNPACK_SKIP_PIXELS)
              , Un = Pt.getParameter(Pt.UNPACK_SKIP_ROWS)
              , Mn = Pt.getParameter(Pt.UNPACK_SKIP_IMAGES)
              , cr = kt.isCompressedTexture ? kt.mipmaps[Wt] : kt.image;
            Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, cr.width),
            Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, cr.height),
            Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, Vn),
            Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, Bn),
            kt.isDataTexture ? Pt.texSubImage2D(Pt.TEXTURE_2D, Wt, Gn, Xn, Sn, In, zn, nr, cr.data) : kt.isCompressedTexture ? Pt.compressedTexSubImage2D(Pt.TEXTURE_2D, Wt, Gn, Xn, cr.width, cr.height, zn, cr.data) : Pt.texSubImage2D(Pt.TEXTURE_2D, Wt, Gn, Xn, Sn, In, zn, nr, cr),
            Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, lr),
            Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, ar),
            Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, gr),
            Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, Un),
            Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES, Mn),
            Wt === 0 && zt.generateMipmaps && Pt.generateMipmap(Pt.TEXTURE_2D),
            tn.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(kt, zt, Kt=null, Zt=null, Wt=0) {
            kt.isTexture !== !0 && (warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
            Kt = arguments[0] || null,
            Zt = arguments[1] || null,
            kt = arguments[2],
            zt = arguments[3],
            Wt = arguments[4] || 0);
            let Sn, In, Vn, Bn, Gn, Xn, zn, nr, lr;
            const ar = kt.isCompressedTexture ? kt.mipmaps[Wt] : kt.image;
            Kt !== null ? (Sn = Kt.max.x - Kt.min.x,
            In = Kt.max.y - Kt.min.y,
            Vn = Kt.max.z - Kt.min.z,
            Bn = Kt.min.x,
            Gn = Kt.min.y,
            Xn = Kt.min.z) : (Sn = ar.width,
            In = ar.height,
            Vn = ar.depth,
            Bn = 0,
            Gn = 0,
            Xn = 0),
            Zt !== null ? (zn = Zt.x,
            nr = Zt.y,
            lr = Zt.z) : (zn = 0,
            nr = 0,
            lr = 0);
            const gr = Nt.convert(zt.format)
              , Un = Nt.convert(zt.type);
            let Mn;
            if (zt.isData3DTexture)
                vn.setTexture3D(zt, 0),
                Mn = Pt.TEXTURE_3D;
            else if (zt.isDataArrayTexture || zt.isCompressedArrayTexture)
                vn.setTexture2DArray(zt, 0),
                Mn = Pt.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            Pt.pixelStorei(Pt.UNPACK_FLIP_Y_WEBGL, zt.flipY),
            Pt.pixelStorei(Pt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, zt.premultiplyAlpha),
            Pt.pixelStorei(Pt.UNPACK_ALIGNMENT, zt.unpackAlignment);
            const cr = Pt.getParameter(Pt.UNPACK_ROW_LENGTH)
              , qn = Pt.getParameter(Pt.UNPACK_IMAGE_HEIGHT)
              , ur = Pt.getParameter(Pt.UNPACK_SKIP_PIXELS)
              , Vr = Pt.getParameter(Pt.UNPACK_SKIP_ROWS)
              , xr = Pt.getParameter(Pt.UNPACK_SKIP_IMAGES);
            Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, ar.width),
            Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, ar.height),
            Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, Bn),
            Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, Gn),
            Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES, Xn),
            kt.isDataTexture || kt.isData3DTexture ? Pt.texSubImage3D(Mn, Wt, zn, nr, lr, Sn, In, Vn, gr, Un, ar.data) : zt.isCompressedArrayTexture ? Pt.compressedTexSubImage3D(Mn, Wt, zn, nr, lr, Sn, In, Vn, gr, ar.data) : Pt.texSubImage3D(Mn, Wt, zn, nr, lr, Sn, In, Vn, gr, Un, ar),
            Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, cr),
            Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, qn),
            Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, ur),
            Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, Vr),
            Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES, xr),
            Wt === 0 && zt.generateMipmaps && Pt.generateMipmap(Mn),
            tn.unbindTexture()
        }
        ,
        this.initRenderTarget = function(kt) {
            gn.get(kt).__webglFramebuffer === void 0 && vn.setupRenderTarget(kt)
        }
        ,
        this.initTexture = function(kt) {
            kt.isCubeTexture ? vn.setTextureCube(kt, 0) : kt.isData3DTexture ? vn.setTexture3D(kt, 0) : kt.isDataArrayTexture || kt.isCompressedArrayTexture ? vn.setTexture2DArray(kt, 0) : vn.setTexture2D(kt, 0),
            tn.unbindTexture()
        }
        ,
        this.resetState = function() {
            pt = 0,
            dt = 0,
            yt = null,
            tn.reset(),
            ln.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return WebGLCoordinateSystem
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const a = this.getContext();
        a.drawingBufferColorSpace = e === DisplayP3ColorSpace ? "display-p3" : "srgb",
        a.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb"
    }
}
class FogExp2 {
    constructor(e, a=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new Color(e),
        this.density = a
    }
    clone() {
        return new FogExp2(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class Fog {
    constructor(e, a=1, o=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Color(e),
        this.near = a,
        this.far = o
    }
    clone() {
        return new Fog(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class Scene extends Object3D {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Euler,
        this.environmentIntensity = 1,
        this.environmentRotation = new Euler,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, a) {
        return super.copy(e, a),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return this.fog !== null && (a.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (a.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (a.object.backgroundIntensity = this.backgroundIntensity),
        a.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (a.object.environmentIntensity = this.environmentIntensity),
        a.object.environmentRotation = this.environmentRotation.toArray(),
        a
    }
}
class InterleavedBuffer {
    constructor(e, a) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = a,
        this.count = e !== void 0 ? e.length / a : 0,
        this.usage = StaticDrawUsage,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = generateUUID()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return warnOnce("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, a) {
        this.updateRanges.push({
            start: e,
            count: a
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, a, o) {
        e *= this.stride,
        o *= a.stride;
        for (let c = 0, d = this.stride; c < d; c++)
            this.array[e + c] = a.array[o + c];
        return this
    }
    set(e, a=0) {
        return this.array.set(e, a),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const a = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , o = new this.constructor(a,this.stride);
        return o.setUsage(this.usage),
        o
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const _vector$6 = new Vector3;
class InterleavedBufferAttribute {
    constructor(e, a, o, c=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = a,
        this.offset = o,
        this.normalized = c
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let a = 0, o = this.data.count; a < o; a++)
            _vector$6.fromBufferAttribute(this, a),
            _vector$6.applyMatrix4(e),
            this.setXYZ(a, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let a = 0, o = this.count; a < o; a++)
            _vector$6.fromBufferAttribute(this, a),
            _vector$6.applyNormalMatrix(e),
            this.setXYZ(a, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    transformDirection(e) {
        for (let a = 0, o = this.count; a < o; a++)
            _vector$6.fromBufferAttribute(this, a),
            _vector$6.transformDirection(e),
            this.setXYZ(a, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    getComponent(e, a) {
        let o = this.array[e * this.data.stride + this.offset + a];
        return this.normalized && (o = denormalize(o, this.array)),
        o
    }
    setComponent(e, a, o) {
        return this.normalized && (o = normalize(o, this.array)),
        this.data.array[e * this.data.stride + this.offset + a] = o,
        this
    }
    setX(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.data.array[e * this.data.stride + this.offset] = a,
        this
    }
    setY(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = a,
        this
    }
    setZ(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = a,
        this
    }
    setW(e, a) {
        return this.normalized && (a = normalize(a, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = a,
        this
    }
    getX(e) {
        let a = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    getY(e) {
        let a = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    getZ(e) {
        let a = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    getW(e) {
        let a = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (a = denormalize(a, this.array)),
        a
    }
    setXY(e, a, o) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array)),
        this.data.array[e + 0] = a,
        this.data.array[e + 1] = o,
        this
    }
    setXYZ(e, a, o, c) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array),
        c = normalize(c, this.array)),
        this.data.array[e + 0] = a,
        this.data.array[e + 1] = o,
        this.data.array[e + 2] = c,
        this
    }
    setXYZW(e, a, o, c, d) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (a = normalize(a, this.array),
        o = normalize(o, this.array),
        c = normalize(c, this.array),
        d = normalize(d, this.array)),
        this.data.array[e + 0] = a,
        this.data.array[e + 1] = o,
        this.data.array[e + 2] = c,
        this.data.array[e + 3] = d,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const a = [];
            for (let o = 0; o < this.count; o++) {
                const c = o * this.data.stride + this.offset;
                for (let d = 0; d < this.itemSize; d++)
                    a.push(this.data.array[c + d])
            }
            return new BufferAttribute(new this.array.constructor(a),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const a = [];
            for (let o = 0; o < this.count; o++) {
                const c = o * this.data.stride + this.offset;
                for (let d = 0; d < this.itemSize; d++)
                    a.push(this.data.array[c + d])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: a,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class SpriteMaterial extends Material {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let _geometry;
const _intersectPoint = new Vector3
  , _worldScale = new Vector3
  , _mvPosition = new Vector3
  , _alignedPosition = new Vector2
  , _rotatedPosition = new Vector2
  , _viewWorldMatrix = new Matrix4
  , _vA = new Vector3
  , _vB = new Vector3
  , _vC = new Vector3
  , _uvA = new Vector2
  , _uvB = new Vector2
  , _uvC = new Vector2;
class Sprite extends Object3D {
    constructor(e=new SpriteMaterial) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        _geometry === void 0) {
            _geometry = new BufferGeometry;
            const a = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , o = new InterleavedBuffer(a,5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]),
            _geometry.setAttribute("position", new InterleavedBufferAttribute(o,3,0,!1)),
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(o,2,3,!1))
        }
        this.geometry = _geometry,
        this.material = e,
        this.center = new Vector2(.5,.5)
    }
    raycast(e, a) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        _worldScale.setFromMatrixScale(this.matrixWorld),
        _viewWorldMatrix.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _worldScale.multiplyScalar(-_mvPosition.z);
        const o = this.material.rotation;
        let c, d;
        o !== 0 && (d = Math.cos(o),
        c = Math.sin(o));
        const g = this.center;
        transformVertex(_vA.set(-.5, -.5, 0), _mvPosition, g, _worldScale, c, d),
        transformVertex(_vB.set(.5, -.5, 0), _mvPosition, g, _worldScale, c, d),
        transformVertex(_vC.set(.5, .5, 0), _mvPosition, g, _worldScale, c, d),
        _uvA.set(0, 0),
        _uvB.set(1, 0),
        _uvC.set(1, 1);
        let _ = e.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
        if (_ === null && (transformVertex(_vB.set(-.5, .5, 0), _mvPosition, g, _worldScale, c, d),
        _uvB.set(0, 1),
        _ = e.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint),
        _ === null))
            return;
        const b = e.ray.origin.distanceTo(_intersectPoint);
        b < e.near || b > e.far || a.push({
            distance: b,
            point: _intersectPoint.clone(),
            uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2),
            face: null,
            object: this
        })
    }
    copy(e, a) {
        return super.copy(e, a),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function transformVertex(s, e, a, o, c, d) {
    _alignedPosition.subVectors(s, a).addScalar(.5).multiply(o),
    c !== void 0 ? (_rotatedPosition.x = d * _alignedPosition.x - c * _alignedPosition.y,
    _rotatedPosition.y = c * _alignedPosition.x + d * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition),
    s.copy(e),
    s.x += _rotatedPosition.x,
    s.y += _rotatedPosition.y,
    s.applyMatrix4(_viewWorldMatrix)
}
const _v1$2 = new Vector3
  , _v2$1 = new Vector3;
class LOD extends Object3D {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const a = e.levels;
        for (let o = 0, c = a.length; o < c; o++) {
            const d = a[o];
            this.addLevel(d.object.clone(), d.distance, d.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, a=0, o=0) {
        a = Math.abs(a);
        const c = this.levels;
        let d;
        for (d = 0; d < c.length && !(a < c[d].distance); d++)
            ;
        return c.splice(d, 0, {
            distance: a,
            hysteresis: o,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const a = this.levels;
        if (a.length > 0) {
            let o, c;
            for (o = 1,
            c = a.length; o < c; o++) {
                let d = a[o].distance;
                if (a[o].object.visible && (d -= d * a[o].hysteresis),
                e < d)
                    break
            }
            return a[o - 1].object
        }
        return null
    }
    raycast(e, a) {
        if (this.levels.length > 0) {
            _v1$2.setFromMatrixPosition(this.matrixWorld);
            const c = e.ray.origin.distanceTo(_v1$2);
            this.getObjectForDistance(c).raycast(e, a)
        }
    }
    update(e) {
        const a = this.levels;
        if (a.length > 1) {
            _v1$2.setFromMatrixPosition(e.matrixWorld),
            _v2$1.setFromMatrixPosition(this.matrixWorld);
            const o = _v1$2.distanceTo(_v2$1) / e.zoom;
            a[0].object.visible = !0;
            let c, d;
            for (c = 1,
            d = a.length; c < d; c++) {
                let g = a[c].distance;
                if (a[c].object.visible && (g -= g * a[c].hysteresis),
                o >= g)
                    a[c - 1].object.visible = !1,
                    a[c].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = c - 1; c < d; c++)
                a[c].object.visible = !1
        }
    }
    toJSON(e) {
        const a = super.toJSON(e);
        this.autoUpdate === !1 && (a.object.autoUpdate = !1),
        a.object.levels = [];
        const o = this.levels;
        for (let c = 0, d = o.length; c < d; c++) {
            const g = o[c];
            a.object.levels.push({
                object: g.object.uuid,
                distance: g.distance,
                hysteresis: g.hysteresis
            })
        }
        return a
    }
}
const _basePosition = new Vector3
  , _skinIndex = new Vector4
  , _skinWeight = new Vector4
  , _vector3 = new Vector3
  , _matrix4 = new Matrix4
  , _vertex = new Vector3
  , _sphere$4 = new Sphere
  , _inverseMatrix$2 = new Matrix4
  , _ray$2 = new Ray;
class SkinnedMesh extends Mesh {
    constructor(e, a) {
        super(e, a),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = AttachedBindMode,
        this.bindMatrix = new Matrix4,
        this.bindMatrixInverse = new Matrix4,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Box3),
        this.boundingBox.makeEmpty();
        const a = e.getAttribute("position");
        for (let o = 0; o < a.count; o++)
            this.getVertexPosition(o, _vertex),
            this.boundingBox.expandByPoint(_vertex)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new Sphere),
        this.boundingSphere.makeEmpty();
        const a = e.getAttribute("position");
        for (let o = 0; o < a.count; o++)
            this.getVertexPosition(o, _vertex),
            this.boundingSphere.expandByPoint(_vertex)
    }
    copy(e, a) {
        return super.copy(e, a),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, a) {
        const o = this.material
          , c = this.matrixWorld;
        o !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        _sphere$4.copy(this.boundingSphere),
        _sphere$4.applyMatrix4(c),
        e.ray.intersectsSphere(_sphere$4) !== !1 && (_inverseMatrix$2.copy(c).invert(),
        _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),
        !(this.boundingBox !== null && _ray$2.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, a, _ray$2)))
    }
    getVertexPosition(e, a) {
        return super.getVertexPosition(e, a),
        this.applyBoneTransform(e, a),
        a
    }
    bind(e, a) {
        this.skeleton = e,
        a === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        a = this.matrixWorld),
        this.bindMatrix.copy(a),
        this.bindMatrixInverse.copy(a).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Vector4
          , a = this.geometry.attributes.skinWeight;
        for (let o = 0, c = a.count; o < c; o++) {
            e.fromBufferAttribute(a, o);
            const d = 1 / e.manhattanLength();
            d !== 1 / 0 ? e.multiplyScalar(d) : e.set(1, 0, 0, 0),
            a.setXYZW(o, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === DetachedBindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, a) {
        const o = this.skeleton
          , c = this.geometry;
        _skinIndex.fromBufferAttribute(c.attributes.skinIndex, e),
        _skinWeight.fromBufferAttribute(c.attributes.skinWeight, e),
        _basePosition.copy(a).applyMatrix4(this.bindMatrix),
        a.set(0, 0, 0);
        for (let d = 0; d < 4; d++) {
            const g = _skinWeight.getComponent(d);
            if (g !== 0) {
                const _ = _skinIndex.getComponent(d);
                _matrix4.multiplyMatrices(o.bones[_].matrixWorld, o.boneInverses[_]),
                a.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), g)
            }
        }
        return a.applyMatrix4(this.bindMatrixInverse)
    }
}
class Bone extends Object3D {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class DataTexture extends Texture {
    constructor(e=null, a=1, o=1, c, d, g, _, b, j=NearestFilter, $=NearestFilter, nt, tt) {
        super(null, g, _, b, j, $, c, d, nt, tt),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: a,
            height: o
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const _offsetMatrix = new Matrix4
  , _identityMatrix$1 = new Matrix4;
class Skeleton {
    constructor(e=[], a=[]) {
        this.uuid = generateUUID(),
        this.bones = e.slice(0),
        this.boneInverses = a,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , a = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        a.length === 0)
            this.calculateInverses();
        else if (e.length !== a.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let o = 0, c = this.bones.length; o < c; o++)
                this.boneInverses.push(new Matrix4)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, a = this.bones.length; e < a; e++) {
            const o = new Matrix4;
            this.bones[e] && o.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(o)
        }
    }
    pose() {
        for (let e = 0, a = this.bones.length; e < a; e++) {
            const o = this.bones[e];
            o && o.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, a = this.bones.length; e < a; e++) {
            const o = this.bones[e];
            o && (o.parent && o.parent.isBone ? (o.matrix.copy(o.parent.matrixWorld).invert(),
            o.matrix.multiply(o.matrixWorld)) : o.matrix.copy(o.matrixWorld),
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        }
    }
    update() {
        const e = this.bones
          , a = this.boneInverses
          , o = this.boneMatrices
          , c = this.boneTexture;
        for (let d = 0, g = e.length; d < g; d++) {
            const _ = e[d] ? e[d].matrixWorld : _identityMatrix$1;
            _offsetMatrix.multiplyMatrices(_, a[d]),
            _offsetMatrix.toArray(o, d * 16)
        }
        c !== null && (c.needsUpdate = !0)
    }
    clone() {
        return new Skeleton(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const a = new Float32Array(e * e * 4);
        a.set(this.boneMatrices);
        const o = new DataTexture(a,e,e,RGBAFormat,FloatType);
        return o.needsUpdate = !0,
        this.boneMatrices = a,
        this.boneTexture = o,
        this
    }
    getBoneByName(e) {
        for (let a = 0, o = this.bones.length; a < o; a++) {
            const c = this.bones[a];
            if (c.name === e)
                return c
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, a) {
        this.uuid = e.uuid;
        for (let o = 0, c = e.bones.length; o < c; o++) {
            const d = e.bones[o];
            let g = a[d];
            g === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", d),
            g = new Bone),
            this.bones.push(g),
            this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[o]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const a = this.bones
          , o = this.boneInverses;
        for (let c = 0, d = a.length; c < d; c++) {
            const g = a[c];
            e.bones.push(g.uuid);
            const _ = o[c];
            e.boneInverses.push(_.toArray())
        }
        return e
    }
}
class InstancedBufferAttribute extends BufferAttribute {
    constructor(e, a, o, c=1) {
        super(e, a, o),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = c
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const _instanceLocalMatrix = new Matrix4
  , _instanceWorldMatrix = new Matrix4
  , _instanceIntersects = []
  , _box3 = new Box3
  , _identity = new Matrix4
  , _mesh$1 = new Mesh
  , _sphere$3 = new Sphere;
class InstancedMesh extends Mesh {
    constructor(e, a, o) {
        super(e, a),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(o * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = o,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let c = 0; c < o; c++)
            this.setMatrixAt(c, _identity)
    }
    computeBoundingBox() {
        const e = this.geometry
          , a = this.count;
        this.boundingBox === null && (this.boundingBox = new Box3),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let o = 0; o < a; o++)
            this.getMatrixAt(o, _instanceLocalMatrix),
            _box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix),
            this.boundingBox.union(_box3)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , a = this.count;
        this.boundingSphere === null && (this.boundingSphere = new Sphere),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let o = 0; o < a; o++)
            this.getMatrixAt(o, _instanceLocalMatrix),
            _sphere$3.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix),
            this.boundingSphere.union(_sphere$3)
    }
    copy(e, a) {
        return super.copy(e, a),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, a) {
        a.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, a) {
        a.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, a) {
        const o = a.morphTargetInfluences
          , c = this.morphTexture.source.data.data
          , d = o.length + 1
          , g = e * d + 1;
        for (let _ = 0; _ < o.length; _++)
            o[_] = c[g + _]
    }
    raycast(e, a) {
        const o = this.matrixWorld
          , c = this.count;
        if (_mesh$1.geometry = this.geometry,
        _mesh$1.material = this.material,
        _mesh$1.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        _sphere$3.copy(this.boundingSphere),
        _sphere$3.applyMatrix4(o),
        e.ray.intersectsSphere(_sphere$3) !== !1))
            for (let d = 0; d < c; d++) {
                this.getMatrixAt(d, _instanceLocalMatrix),
                _instanceWorldMatrix.multiplyMatrices(o, _instanceLocalMatrix),
                _mesh$1.matrixWorld = _instanceWorldMatrix,
                _mesh$1.raycast(e, _instanceIntersects);
                for (let g = 0, _ = _instanceIntersects.length; g < _; g++) {
                    const b = _instanceIntersects[g];
                    b.instanceId = d,
                    b.object = this,
                    a.push(b)
                }
                _instanceIntersects.length = 0
            }
    }
    setColorAt(e, a) {
        this.instanceColor === null && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
        a.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, a) {
        a.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, a) {
        const o = a.morphTargetInfluences
          , c = o.length + 1;
        this.morphTexture === null && (this.morphTexture = new DataTexture(new Float32Array(c * this.count),c,this.count,RedFormat,FloatType));
        const d = this.morphTexture.source.data.data;
        let g = 0;
        for (let j = 0; j < o.length; j++)
            g += o[j];
        const _ = this.geometry.morphTargetsRelative ? 1 : 1 - g
          , b = c * e;
        d[b] = _,
        d.set(o, b + 1)
    }
    updateMorphTargets() {}
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this.morphTexture !== null && (this.morphTexture.dispose(),
        this.morphTexture = null),
        this
    }
}
function sortOpaque(s, e) {
    return s.z - e.z
}
function sortTransparent(s, e) {
    return e.z - s.z
}
class MultiDrawRenderList {
    constructor() {
        this.index = 0,
        this.pool = [],
        this.list = []
    }
    push(e, a, o) {
        const c = this.pool
          , d = this.list;
        this.index >= c.length && c.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
        });
        const g = c[this.index];
        d.push(g),
        this.index++,
        g.start = e.start,
        g.count = e.count,
        g.z = a,
        g.index = o
    }
    reset() {
        this.list.length = 0,
        this.index = 0
    }
}
const _matrix$1 = new Matrix4
  , _invMatrixWorld = new Matrix4
  , _identityMatrix = new Matrix4
  , _whiteColor = new Color(1,1,1)
  , _projScreenMatrix$2 = new Matrix4
  , _frustum = new Frustum
  , _box$1 = new Box3
  , _sphere$2 = new Sphere
  , _vector$5 = new Vector3
  , _forward = new Vector3
  , _temp = new Vector3
  , _renderList = new MultiDrawRenderList
  , _mesh = new Mesh
  , _batchIntersects = [];
function copyAttributeData(s, e, a=0) {
    const o = e.itemSize;
    if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
        const c = s.count;
        for (let d = 0; d < c; d++)
            for (let g = 0; g < o; g++)
                e.setComponent(d + a, g, s.getComponent(d, g))
    } else
        e.array.set(s.array, a * o);
    e.needsUpdate = !0
}
class BatchedMesh extends Mesh {
    get maxInstanceCount() {
        return this._maxInstanceCount
    }
    constructor(e, a, o=a * 2, c) {
        super(new BufferGeometry, c),
        this.isBatchedMesh = !0,
        this.perObjectFrustumCulled = !0,
        this.sortObjects = !0,
        this.boundingBox = null,
        this.boundingSphere = null,
        this.customSort = null,
        this._drawInfo = [],
        this._drawRanges = [],
        this._reservedRanges = [],
        this._bounds = [],
        this._maxInstanceCount = e,
        this._maxVertexCount = a,
        this._maxIndexCount = o,
        this._geometryInitialized = !1,
        this._geometryCount = 0,
        this._multiDrawCounts = new Int32Array(e),
        this._multiDrawStarts = new Int32Array(e),
        this._multiDrawCount = 0,
        this._multiDrawInstances = null,
        this._visibilityChanged = !0,
        this._matricesTexture = null,
        this._indirectTexture = null,
        this._colorsTexture = null,
        this._initMatricesTexture(),
        this._initIndirectTexture()
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxInstanceCount * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const a = new Float32Array(e * e * 4)
          , o = new DataTexture(a,e,e,RGBAFormat,FloatType);
        this._matricesTexture = o
    }
    _initIndirectTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const a = new Uint32Array(e * e)
          , o = new DataTexture(a,e,e,RedIntegerFormat,UnsignedIntType);
        this._indirectTexture = o
    }
    _initColorsTexture() {
        let e = Math.sqrt(this._maxIndexCount);
        e = Math.ceil(e);
        const a = new Float32Array(e * e * 4).fill(1)
          , o = new DataTexture(a,e,e,RGBAFormat,FloatType);
        o.colorSpace = ColorManagement.workingColorSpace,
        this._colorsTexture = o
    }
    _initializeGeometry(e) {
        const a = this.geometry
          , o = this._maxVertexCount
          , c = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const d in e.attributes) {
                const g = e.getAttribute(d)
                  , {array: _, itemSize: b, normalized: j} = g
                  , $ = new _.constructor(o * b)
                  , nt = new BufferAttribute($,b,j);
                a.setAttribute(d, nt)
            }
            if (e.getIndex() !== null) {
                const d = o > 65535 ? new Uint32Array(c) : new Uint16Array(c);
                a.setIndex(new BufferAttribute(d,1))
            }
            this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        const a = this.geometry;
        if (!!e.getIndex() != !!a.getIndex())
            throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const o in a.attributes) {
            if (!e.hasAttribute(o))
                throw new Error(`BatchedMesh: Added geometry missing "${o}". All geometries must have consistent attributes.`);
            const c = e.getAttribute(o)
              , d = a.getAttribute(o);
            if (c.itemSize !== d.itemSize || c.normalized !== d.normalized)
                throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    setCustomSort(e) {
        return this.customSort = e,
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Box3);
        const e = this._geometryCount
          , a = this.boundingBox
          , o = this._drawInfo;
        a.makeEmpty();
        for (let c = 0; c < e; c++) {
            if (o[c].active === !1)
                continue;
            const d = o[c].geometryIndex;
            this.getMatrixAt(c, _matrix$1),
            this.getBoundingBoxAt(d, _box$1).applyMatrix4(_matrix$1),
            a.union(_box$1)
        }
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Sphere);
        const e = this.boundingSphere
          , a = this._drawInfo;
        e.makeEmpty();
        for (let o = 0, c = a.length; o < c; o++) {
            if (a[o].active === !1)
                continue;
            const d = a[o].geometryIndex;
            this.getMatrixAt(o, _matrix$1),
            this.getBoundingSphereAt(d, _sphere$2).applyMatrix4(_matrix$1),
            e.union(_sphere$2)
        }
    }
    addInstance(e) {
        if (this._drawInfo.length >= this._maxInstanceCount)
            throw new Error("BatchedMesh: Maximum item count reached.");
        this._drawInfo.push({
            visible: !0,
            active: !0,
            geometryIndex: e
        });
        const a = this._drawInfo.length - 1
          , o = this._matricesTexture
          , c = o.image.data;
        _identityMatrix.toArray(c, a * 16),
        o.needsUpdate = !0;
        const d = this._colorsTexture;
        return d && (_whiteColor.toArray(d.image.data, a * 4),
        d.needsUpdate = !0),
        a
    }
    addGeometry(e, a=-1, o=-1) {
        if (this._initializeGeometry(e),
        this._validateGeometry(e),
        this._drawInfo.length >= this._maxInstanceCount)
            throw new Error("BatchedMesh: Maximum item count reached.");
        const c = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1
        };
        let d = null;
        const g = this._reservedRanges
          , _ = this._drawRanges
          , b = this._bounds;
        this._geometryCount !== 0 && (d = g[g.length - 1]),
        a === -1 ? c.vertexCount = e.getAttribute("position").count : c.vertexCount = a,
        d === null ? c.vertexStart = 0 : c.vertexStart = d.vertexStart + d.vertexCount;
        const j = e.getIndex()
          , $ = j !== null;
        if ($ && (o === -1 ? c.indexCount = j.count : c.indexCount = o,
        d === null ? c.indexStart = 0 : c.indexStart = d.indexStart + d.indexCount),
        c.indexStart !== -1 && c.indexStart + c.indexCount > this._maxIndexCount || c.vertexStart + c.vertexCount > this._maxVertexCount)
            throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        const nt = this._geometryCount;
        return this._geometryCount++,
        g.push(c),
        _.push({
            start: $ ? c.indexStart : c.vertexStart,
            count: -1
        }),
        b.push({
            boxInitialized: !1,
            box: new Box3,
            sphereInitialized: !1,
            sphere: new Sphere
        }),
        this.setGeometryAt(nt, e),
        nt
    }
    setGeometryAt(e, a) {
        if (e >= this._geometryCount)
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(a);
        const o = this.geometry
          , c = o.getIndex() !== null
          , d = o.getIndex()
          , g = a.getIndex()
          , _ = this._reservedRanges[e];
        if (c && g.count > _.indexCount || a.attributes.position.count > _.vertexCount)
            throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        const b = _.vertexStart
          , j = _.vertexCount;
        for (const rt in o.attributes) {
            const st = a.getAttribute(rt)
              , lt = o.getAttribute(rt);
            copyAttributeData(st, lt, b);
            const ct = st.itemSize;
            for (let it = st.count, ot = j; it < ot; it++) {
                const at = b + it;
                for (let ht = 0; ht < ct; ht++)
                    lt.setComponent(at, ht, 0)
            }
            lt.needsUpdate = !0,
            lt.addUpdateRange(b * ct, j * ct)
        }
        if (c) {
            const rt = _.indexStart;
            for (let st = 0; st < g.count; st++)
                d.setX(rt + st, b + g.getX(st));
            for (let st = g.count, lt = _.indexCount; st < lt; st++)
                d.setX(rt + st, b);
            d.needsUpdate = !0,
            d.addUpdateRange(rt, _.indexCount)
        }
        const $ = this._bounds[e];
        a.boundingBox !== null ? ($.box.copy(a.boundingBox),
        $.boxInitialized = !0) : $.boxInitialized = !1,
        a.boundingSphere !== null ? ($.sphere.copy(a.boundingSphere),
        $.sphereInitialized = !0) : $.sphereInitialized = !1;
        const nt = this._drawRanges[e]
          , tt = a.getAttribute("position");
        return nt.count = c ? g.count : tt.count,
        this._visibilityChanged = !0,
        e
    }
    getBoundingBoxAt(e, a) {
        if (e >= this._geometryCount)
            return null;
        const o = this._bounds[e]
          , c = o.box
          , d = this.geometry;
        if (o.boxInitialized === !1) {
            c.makeEmpty();
            const g = d.index
              , _ = d.attributes.position
              , b = this._drawRanges[e];
            for (let j = b.start, $ = b.start + b.count; j < $; j++) {
                let nt = j;
                g && (nt = g.getX(nt)),
                c.expandByPoint(_vector$5.fromBufferAttribute(_, nt))
            }
            o.boxInitialized = !0
        }
        return a.copy(c),
        a
    }
    getBoundingSphereAt(e, a) {
        if (e >= this._geometryCount)
            return null;
        const o = this._bounds[e]
          , c = o.sphere
          , d = this.geometry;
        if (o.sphereInitialized === !1) {
            c.makeEmpty(),
            this.getBoundingBoxAt(e, _box$1),
            _box$1.getCenter(c.center);
            const g = d.index
              , _ = d.attributes.position
              , b = this._drawRanges[e];
            let j = 0;
            for (let $ = b.start, nt = b.start + b.count; $ < nt; $++) {
                let tt = $;
                g && (tt = g.getX(tt)),
                _vector$5.fromBufferAttribute(_, tt),
                j = Math.max(j, c.center.distanceToSquared(_vector$5))
            }
            c.radius = Math.sqrt(j),
            o.sphereInitialized = !0
        }
        return a.copy(c),
        a
    }
    setMatrixAt(e, a) {
        const o = this._drawInfo
          , c = this._matricesTexture
          , d = this._matricesTexture.image.data;
        return e >= o.length || o[e].active === !1 ? this : (a.toArray(d, e * 16),
        c.needsUpdate = !0,
        this)
    }
    getMatrixAt(e, a) {
        const o = this._drawInfo
          , c = this._matricesTexture.image.data;
        return e >= o.length || o[e].active === !1 ? null : a.fromArray(c, e * 16)
    }
    setColorAt(e, a) {
        this._colorsTexture === null && this._initColorsTexture();
        const o = this._colorsTexture
          , c = this._colorsTexture.image.data
          , d = this._drawInfo;
        return e >= d.length || d[e].active === !1 ? this : (a.toArray(c, e * 4),
        o.needsUpdate = !0,
        this)
    }
    getColorAt(e, a) {
        const o = this._colorsTexture.image.data
          , c = this._drawInfo;
        return e >= c.length || c[e].active === !1 ? null : a.fromArray(o, e * 4)
    }
    setVisibleAt(e, a) {
        const o = this._drawInfo;
        return e >= o.length || o[e].active === !1 || o[e].visible === a ? this : (o[e].visible = a,
        this._visibilityChanged = !0,
        this)
    }
    getVisibleAt(e) {
        const a = this._drawInfo;
        return e >= a.length || a[e].active === !1 ? !1 : a[e].visible
    }
    raycast(e, a) {
        const o = this._drawInfo
          , c = this._drawRanges
          , d = this.matrixWorld
          , g = this.geometry;
        _mesh.material = this.material,
        _mesh.geometry.index = g.index,
        _mesh.geometry.attributes = g.attributes,
        _mesh.geometry.boundingBox === null && (_mesh.geometry.boundingBox = new Box3),
        _mesh.geometry.boundingSphere === null && (_mesh.geometry.boundingSphere = new Sphere);
        for (let _ = 0, b = o.length; _ < b; _++) {
            if (!o[_].visible || !o[_].active)
                continue;
            const j = o[_].geometryIndex
              , $ = c[j];
            _mesh.geometry.setDrawRange($.start, $.count),
            this.getMatrixAt(_, _mesh.matrixWorld).premultiply(d),
            this.getBoundingBoxAt(j, _mesh.geometry.boundingBox),
            this.getBoundingSphereAt(j, _mesh.geometry.boundingSphere),
            _mesh.raycast(e, _batchIntersects);
            for (let nt = 0, tt = _batchIntersects.length; nt < tt; nt++) {
                const rt = _batchIntersects[nt];
                rt.object = this,
                rt.batchId = _,
                a.push(rt)
            }
            _batchIntersects.length = 0
        }
        _mesh.material = null,
        _mesh.geometry.index = null,
        _mesh.geometry.attributes = {},
        _mesh.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e),
        this.geometry = e.geometry.clone(),
        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
        this.sortObjects = e.sortObjects,
        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
        this._drawRanges = e._drawRanges.map(a => ({
            ...a
        })),
        this._reservedRanges = e._reservedRanges.map(a => ({
            ...a
        })),
        this._drawInfo = e._drawInfo.map(a => ({
            ...a
        })),
        this._bounds = e._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            box: a.box.clone(),
            sphereInitialized: a.sphereInitialized,
            sphere: a.sphere.clone()
        })),
        this._maxInstanceCount = e._maxInstanceCount,
        this._maxVertexCount = e._maxVertexCount,
        this._maxIndexCount = e._maxIndexCount,
        this._geometryInitialized = e._geometryInitialized,
        this._geometryCount = e._geometryCount,
        this._multiDrawCounts = e._multiDrawCounts.slice(),
        this._multiDrawStarts = e._multiDrawStarts.slice(),
        this._matricesTexture = e._matricesTexture.clone(),
        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
        this
    }
    dispose() {
        return this.geometry.dispose(),
        this._matricesTexture.dispose(),
        this._matricesTexture = null,
        this._indirectTexture.dispose(),
        this._indirectTexture = null,
        this._colorsTexture !== null && (this._colorsTexture.dispose(),
        this._colorsTexture = null),
        this
    }
    onBeforeRender(e, a, o, c, d) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
            return;
        const g = c.getIndex()
          , _ = g === null ? 1 : g.array.BYTES_PER_ELEMENT
          , b = this._drawInfo
          , j = this._multiDrawStarts
          , $ = this._multiDrawCounts
          , nt = this._drawRanges
          , tt = this.perObjectFrustumCulled
          , rt = this._indirectTexture
          , st = rt.image.data;
        tt && (_projScreenMatrix$2.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse).multiply(this.matrixWorld),
        _frustum.setFromProjectionMatrix(_projScreenMatrix$2, e.coordinateSystem));
        let lt = 0;
        if (this.sortObjects) {
            _invMatrixWorld.copy(this.matrixWorld).invert(),
            _vector$5.setFromMatrixPosition(o.matrixWorld).applyMatrix4(_invMatrixWorld),
            _forward.set(0, 0, -1).transformDirection(o.matrixWorld).transformDirection(_invMatrixWorld);
            for (let ot = 0, at = b.length; ot < at; ot++)
                if (b[ot].visible && b[ot].active) {
                    const ht = b[ot].geometryIndex;
                    this.getMatrixAt(ot, _matrix$1),
                    this.getBoundingSphereAt(ht, _sphere$2).applyMatrix4(_matrix$1);
                    let pt = !1;
                    if (tt && (pt = !_frustum.intersectsSphere(_sphere$2)),
                    !pt) {
                        const dt = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
                        _renderList.push(nt[ht], dt, ot)
                    }
                }
            const ct = _renderList.list
              , it = this.customSort;
            it === null ? ct.sort(d.transparent ? sortTransparent : sortOpaque) : it.call(this, ct, o);
            for (let ot = 0, at = ct.length; ot < at; ot++) {
                const ht = ct[ot];
                j[lt] = ht.start * _,
                $[lt] = ht.count,
                st[lt] = ht.index,
                lt++
            }
            _renderList.reset()
        } else
            for (let ct = 0, it = b.length; ct < it; ct++)
                if (b[ct].visible && b[ct].active) {
                    const ot = b[ct].geometryIndex;
                    let at = !1;
                    if (tt && (this.getMatrixAt(ct, _matrix$1),
                    this.getBoundingSphereAt(ot, _sphere$2).applyMatrix4(_matrix$1),
                    at = !_frustum.intersectsSphere(_sphere$2)),
                    !at) {
                        const ht = nt[ot];
                        j[lt] = ht.start * _,
                        $[lt] = ht.count,
                        st[lt] = ct,
                        lt++
                    }
                }
        rt.needsUpdate = !0,
        this._multiDrawCount = lt,
        this._visibilityChanged = !1
    }
    onBeforeShadow(e, a, o, c, d, g) {
        this.onBeforeRender(e, null, c, d, g)
    }
}
class LineBasicMaterial extends Material {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const _vStart = new Vector3
  , _vEnd = new Vector3
  , _inverseMatrix$1 = new Matrix4
  , _ray$1 = new Ray
  , _sphere$1 = new Sphere
  , _intersectPointOnRay = new Vector3
  , _intersectPointOnSegment = new Vector3;
class Line extends Object3D {
    constructor(e=new BufferGeometry, a=new LineBasicMaterial) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = a,
        this.updateMorphTargets()
    }
    copy(e, a) {
        return super.copy(e, a),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const a = e.attributes.position
              , o = [0];
            for (let c = 1, d = a.count; c < d; c++)
                _vStart.fromBufferAttribute(a, c - 1),
                _vEnd.fromBufferAttribute(a, c),
                o[c] = o[c - 1],
                o[c] += _vStart.distanceTo(_vEnd);
            e.setAttribute("lineDistance", new Float32BufferAttribute(o,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, a) {
        const o = this.geometry
          , c = this.matrixWorld
          , d = e.params.Line.threshold
          , g = o.drawRange;
        if (o.boundingSphere === null && o.computeBoundingSphere(),
        _sphere$1.copy(o.boundingSphere),
        _sphere$1.applyMatrix4(c),
        _sphere$1.radius += d,
        e.ray.intersectsSphere(_sphere$1) === !1)
            return;
        _inverseMatrix$1.copy(c).invert(),
        _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
        const _ = d / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , b = _ * _
          , j = this.isLineSegments ? 2 : 1
          , $ = o.index
          , tt = o.attributes.position;
        if ($ !== null) {
            const rt = Math.max(0, g.start)
              , st = Math.min($.count, g.start + g.count);
            for (let lt = rt, ct = st - 1; lt < ct; lt += j) {
                const it = $.getX(lt)
                  , ot = $.getX(lt + 1)
                  , at = checkIntersection(this, e, _ray$1, b, it, ot);
                at && a.push(at)
            }
            if (this.isLineLoop) {
                const lt = $.getX(st - 1)
                  , ct = $.getX(rt)
                  , it = checkIntersection(this, e, _ray$1, b, lt, ct);
                it && a.push(it)
            }
        } else {
            const rt = Math.max(0, g.start)
              , st = Math.min(tt.count, g.start + g.count);
            for (let lt = rt, ct = st - 1; lt < ct; lt += j) {
                const it = checkIntersection(this, e, _ray$1, b, lt, lt + 1);
                it && a.push(it)
            }
            if (this.isLineLoop) {
                const lt = checkIntersection(this, e, _ray$1, b, st - 1, rt);
                lt && a.push(lt)
            }
        }
    }
    updateMorphTargets() {
        const a = this.geometry.morphAttributes
          , o = Object.keys(a);
        if (o.length > 0) {
            const c = a[o[0]];
            if (c !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let d = 0, g = c.length; d < g; d++) {
                    const _ = c[d].name || String(d);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[_] = d
                }
            }
        }
    }
}
function checkIntersection(s, e, a, o, c, d) {
    const g = s.geometry.attributes.position;
    if (_vStart.fromBufferAttribute(g, c),
    _vEnd.fromBufferAttribute(g, d),
    a.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment) > o)
        return;
    _intersectPointOnRay.applyMatrix4(s.matrixWorld);
    const b = e.ray.origin.distanceTo(_intersectPointOnRay);
    if (!(b < e.near || b > e.far))
        return {
            distance: b,
            point: _intersectPointOnSegment.clone().applyMatrix4(s.matrixWorld),
            index: c,
            face: null,
            faceIndex: null,
            object: s
        }
}
const _start = new Vector3
  , _end = new Vector3;
class LineSegments extends Line {
    constructor(e, a) {
        super(e, a),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const a = e.attributes.position
              , o = [];
            for (let c = 0, d = a.count; c < d; c += 2)
                _start.fromBufferAttribute(a, c),
                _end.fromBufferAttribute(a, c + 1),
                o[c] = c === 0 ? 0 : o[c - 1],
                o[c + 1] = o[c] + _start.distanceTo(_end);
            e.setAttribute("lineDistance", new Float32BufferAttribute(o,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class LineLoop extends Line {
    constructor(e, a) {
        super(e, a),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class PointsMaterial extends Material {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const _inverseMatrix = new Matrix4
  , _ray$4 = new Ray
  , _sphere = new Sphere
  , _position$2 = new Vector3;
let Points$1 = class extends Object3D {
    constructor(e=new BufferGeometry, a=new PointsMaterial) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = a,
        this.updateMorphTargets()
    }
    copy(e, a) {
        return super.copy(e, a),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, a) {
        const o = this.geometry
          , c = this.matrixWorld
          , d = e.params.Points.threshold
          , g = o.drawRange;
        if (o.boundingSphere === null && o.computeBoundingSphere(),
        _sphere.copy(o.boundingSphere),
        _sphere.applyMatrix4(c),
        _sphere.radius += d,
        e.ray.intersectsSphere(_sphere) === !1)
            return;
        _inverseMatrix.copy(c).invert(),
        _ray$4.copy(e.ray).applyMatrix4(_inverseMatrix);
        const _ = d / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , b = _ * _
          , j = o.index
          , nt = o.attributes.position;
        if (j !== null) {
            const tt = Math.max(0, g.start)
              , rt = Math.min(j.count, g.start + g.count);
            for (let st = tt, lt = rt; st < lt; st++) {
                const ct = j.getX(st);
                _position$2.fromBufferAttribute(nt, ct),
                testPoint(_position$2, ct, b, c, e, a, this)
            }
        } else {
            const tt = Math.max(0, g.start)
              , rt = Math.min(nt.count, g.start + g.count);
            for (let st = tt, lt = rt; st < lt; st++)
                _position$2.fromBufferAttribute(nt, st),
                testPoint(_position$2, st, b, c, e, a, this)
        }
    }
    updateMorphTargets() {
        const a = this.geometry.morphAttributes
          , o = Object.keys(a);
        if (o.length > 0) {
            const c = a[o[0]];
            if (c !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let d = 0, g = c.length; d < g; d++) {
                    const _ = c[d].name || String(d);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[_] = d
                }
            }
        }
    }
}
;
function testPoint(s, e, a, o, c, d, g) {
    const _ = _ray$4.distanceSqToPoint(s);
    if (_ < a) {
        const b = new Vector3;
        _ray$4.closestPointToPoint(s, b),
        b.applyMatrix4(o);
        const j = c.ray.origin.distanceTo(b);
        if (j < c.near || j > c.far)
            return;
        d.push({
            distance: j,
            distanceToRay: Math.sqrt(_),
            point: b,
            index: e,
            face: null,
            object: g
        })
    }
}
class VideoTexture extends Texture {
    constructor(e, a, o, c, d, g, _, b, j) {
        super(e, a, o, c, d, g, _, b, j),
        this.isVideoTexture = !0,
        this.minFilter = g !== void 0 ? g : LinearFilter,
        this.magFilter = d !== void 0 ? d : LinearFilter,
        this.generateMipmaps = !1;
        const $ = this;
        function nt() {
            $.needsUpdate = !0,
            e.requestVideoFrameCallback(nt)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(nt)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class FramebufferTexture extends Texture {
    constructor(e, a) {
        super({
            width: e,
            height: a
        }),
        this.isFramebufferTexture = !0,
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class CompressedTexture extends Texture {
    constructor(e, a, o, c, d, g, _, b, j, $, nt, tt) {
        super(null, g, _, b, j, $, c, d, nt, tt),
        this.isCompressedTexture = !0,
        this.image = {
            width: a,
            height: o
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class CompressedArrayTexture extends CompressedTexture {
    constructor(e, a, o, c, d, g) {
        super(e, a, o, d, g),
        this.isCompressedArrayTexture = !0,
        this.image.depth = c,
        this.wrapR = ClampToEdgeWrapping,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class CompressedCubeTexture extends CompressedTexture {
    constructor(e, a, o) {
        super(void 0, e[0].width, e[0].height, a, o, CubeReflectionMapping),
        this.isCompressedCubeTexture = !0,
        this.isCubeTexture = !0,
        this.image = e
    }
}
class CanvasTexture extends Texture {
    constructor(e, a, o, c, d, g, _, b, j) {
        super(e, a, o, c, d, g, _, b, j),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class Curve {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, a) {
        const o = this.getUtoTmapping(e);
        return this.getPoint(o, a)
    }
    getPoints(e=5) {
        const a = [];
        for (let o = 0; o <= e; o++)
            a.push(this.getPoint(o / e));
        return a
    }
    getSpacedPoints(e=5) {
        const a = [];
        for (let o = 0; o <= e; o++)
            a.push(this.getPointAt(o / e));
        return a
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const a = [];
        let o, c = this.getPoint(0), d = 0;
        a.push(0);
        for (let g = 1; g <= e; g++)
            o = this.getPoint(g / e),
            d += o.distanceTo(c),
            a.push(d),
            c = o;
        return this.cacheArcLengths = a,
        a
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, a) {
        const o = this.getLengths();
        let c = 0;
        const d = o.length;
        let g;
        a ? g = a : g = e * o[d - 1];
        let _ = 0, b = d - 1, j;
        for (; _ <= b; )
            if (c = Math.floor(_ + (b - _) / 2),
            j = o[c] - g,
            j < 0)
                _ = c + 1;
            else if (j > 0)
                b = c - 1;
            else {
                b = c;
                break
            }
        if (c = b,
        o[c] === g)
            return c / (d - 1);
        const $ = o[c]
          , tt = o[c + 1] - $
          , rt = (g - $) / tt;
        return (c + rt) / (d - 1)
    }
    getTangent(e, a) {
        let c = e - 1e-4
          , d = e + 1e-4;
        c < 0 && (c = 0),
        d > 1 && (d = 1);
        const g = this.getPoint(c)
          , _ = this.getPoint(d)
          , b = a || (g.isVector2 ? new Vector2 : new Vector3);
        return b.copy(_).sub(g).normalize(),
        b
    }
    getTangentAt(e, a) {
        const o = this.getUtoTmapping(e);
        return this.getTangent(o, a)
    }
    computeFrenetFrames(e, a) {
        const o = new Vector3
          , c = []
          , d = []
          , g = []
          , _ = new Vector3
          , b = new Matrix4;
        for (let rt = 0; rt <= e; rt++) {
            const st = rt / e;
            c[rt] = this.getTangentAt(st, new Vector3)
        }
        d[0] = new Vector3,
        g[0] = new Vector3;
        let j = Number.MAX_VALUE;
        const $ = Math.abs(c[0].x)
          , nt = Math.abs(c[0].y)
          , tt = Math.abs(c[0].z);
        $ <= j && (j = $,
        o.set(1, 0, 0)),
        nt <= j && (j = nt,
        o.set(0, 1, 0)),
        tt <= j && o.set(0, 0, 1),
        _.crossVectors(c[0], o).normalize(),
        d[0].crossVectors(c[0], _),
        g[0].crossVectors(c[0], d[0]);
        for (let rt = 1; rt <= e; rt++) {
            if (d[rt] = d[rt - 1].clone(),
            g[rt] = g[rt - 1].clone(),
            _.crossVectors(c[rt - 1], c[rt]),
            _.length() > Number.EPSILON) {
                _.normalize();
                const st = Math.acos(clamp(c[rt - 1].dot(c[rt]), -1, 1));
                d[rt].applyMatrix4(b.makeRotationAxis(_, st))
            }
            g[rt].crossVectors(c[rt], d[rt])
        }
        if (a === !0) {
            let rt = Math.acos(clamp(d[0].dot(d[e]), -1, 1));
            rt /= e,
            c[0].dot(_.crossVectors(d[0], d[e])) > 0 && (rt = -rt);
            for (let st = 1; st <= e; st++)
                d[st].applyMatrix4(b.makeRotationAxis(c[st], rt * st)),
                g[st].crossVectors(c[st], d[st])
        }
        return {
            tangents: c,
            normals: d,
            binormals: g
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class EllipseCurve extends Curve {
    constructor(e=0, a=0, o=1, c=1, d=0, g=Math.PI * 2, _=!1, b=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = a,
        this.xRadius = o,
        this.yRadius = c,
        this.aStartAngle = d,
        this.aEndAngle = g,
        this.aClockwise = _,
        this.aRotation = b
    }
    getPoint(e, a=new Vector2) {
        const o = a
          , c = Math.PI * 2;
        let d = this.aEndAngle - this.aStartAngle;
        const g = Math.abs(d) < Number.EPSILON;
        for (; d < 0; )
            d += c;
        for (; d > c; )
            d -= c;
        d < Number.EPSILON && (g ? d = 0 : d = c),
        this.aClockwise === !0 && !g && (d === c ? d = -c : d = d - c);
        const _ = this.aStartAngle + e * d;
        let b = this.aX + this.xRadius * Math.cos(_)
          , j = this.aY + this.yRadius * Math.sin(_);
        if (this.aRotation !== 0) {
            const $ = Math.cos(this.aRotation)
              , nt = Math.sin(this.aRotation)
              , tt = b - this.aX
              , rt = j - this.aY;
            b = tt * $ - rt * nt + this.aX,
            j = tt * nt + rt * $ + this.aY
        }
        return o.set(b, j)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class ArcCurve extends EllipseCurve {
    constructor(e, a, o, c, d, g) {
        super(e, a, o, o, c, d, g),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function CubicPoly() {
    let s = 0
      , e = 0
      , a = 0
      , o = 0;
    function c(d, g, _, b) {
        s = d,
        e = _,
        a = -3 * d + 3 * g - 2 * _ - b,
        o = 2 * d - 2 * g + _ + b
    }
    return {
        initCatmullRom: function(d, g, _, b, j) {
            c(g, _, j * (_ - d), j * (b - g))
        },
        initNonuniformCatmullRom: function(d, g, _, b, j, $, nt) {
            let tt = (g - d) / j - (_ - d) / (j + $) + (_ - g) / $
              , rt = (_ - g) / $ - (b - g) / ($ + nt) + (b - _) / nt;
            tt *= $,
            rt *= $,
            c(g, _, tt, rt)
        },
        calc: function(d) {
            const g = d * d
              , _ = g * d;
            return s + e * d + a * g + o * _
        }
    }
}
const tmp = new Vector3
  , px = new CubicPoly
  , py = new CubicPoly
  , pz = new CubicPoly;
class CatmullRomCurve3 extends Curve {
    constructor(e=[], a=!1, o="centripetal", c=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = a,
        this.curveType = o,
        this.tension = c
    }
    getPoint(e, a=new Vector3) {
        const o = a
          , c = this.points
          , d = c.length
          , g = (d - (this.closed ? 0 : 1)) * e;
        let _ = Math.floor(g)
          , b = g - _;
        this.closed ? _ += _ > 0 ? 0 : (Math.floor(Math.abs(_) / d) + 1) * d : b === 0 && _ === d - 1 && (_ = d - 2,
        b = 1);
        let j, $;
        this.closed || _ > 0 ? j = c[(_ - 1) % d] : (tmp.subVectors(c[0], c[1]).add(c[0]),
        j = tmp);
        const nt = c[_ % d]
          , tt = c[(_ + 1) % d];
        if (this.closed || _ + 2 < d ? $ = c[(_ + 2) % d] : (tmp.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]),
        $ = tmp),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const rt = this.curveType === "chordal" ? .5 : .25;
            let st = Math.pow(j.distanceToSquared(nt), rt)
              , lt = Math.pow(nt.distanceToSquared(tt), rt)
              , ct = Math.pow(tt.distanceToSquared($), rt);
            lt < 1e-4 && (lt = 1),
            st < 1e-4 && (st = lt),
            ct < 1e-4 && (ct = lt),
            px.initNonuniformCatmullRom(j.x, nt.x, tt.x, $.x, st, lt, ct),
            py.initNonuniformCatmullRom(j.y, nt.y, tt.y, $.y, st, lt, ct),
            pz.initNonuniformCatmullRom(j.z, nt.z, tt.z, $.z, st, lt, ct)
        } else
            this.curveType === "catmullrom" && (px.initCatmullRom(j.x, nt.x, tt.x, $.x, this.tension),
            py.initCatmullRom(j.y, nt.y, tt.y, $.y, this.tension),
            pz.initCatmullRom(j.z, nt.z, tt.z, $.z, this.tension));
        return o.set(px.calc(b), py.calc(b), pz.calc(b)),
        o
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let a = 0, o = e.points.length; a < o; a++) {
            const c = e.points[a];
            this.points.push(c.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let a = 0, o = this.points.length; a < o; a++) {
            const c = this.points[a];
            e.points.push(c.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let a = 0, o = e.points.length; a < o; a++) {
            const c = e.points[a];
            this.points.push(new Vector3().fromArray(c))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function CatmullRom(s, e, a, o, c) {
    const d = (o - e) * .5
      , g = (c - a) * .5
      , _ = s * s
      , b = s * _;
    return (2 * a - 2 * o + d + g) * b + (-3 * a + 3 * o - 2 * d - g) * _ + d * s + a
}
function QuadraticBezierP0(s, e) {
    const a = 1 - s;
    return a * a * e
}
function QuadraticBezierP1(s, e) {
    return 2 * (1 - s) * s * e
}
function QuadraticBezierP2(s, e) {
    return s * s * e
}
function QuadraticBezier(s, e, a, o) {
    return QuadraticBezierP0(s, e) + QuadraticBezierP1(s, a) + QuadraticBezierP2(s, o)
}
function CubicBezierP0(s, e) {
    const a = 1 - s;
    return a * a * a * e
}
function CubicBezierP1(s, e) {
    const a = 1 - s;
    return 3 * a * a * s * e
}
function CubicBezierP2(s, e) {
    return 3 * (1 - s) * s * s * e
}
function CubicBezierP3(s, e) {
    return s * s * s * e
}
function CubicBezier(s, e, a, o, c) {
    return CubicBezierP0(s, e) + CubicBezierP1(s, a) + CubicBezierP2(s, o) + CubicBezierP3(s, c)
}
class CubicBezierCurve extends Curve {
    constructor(e=new Vector2, a=new Vector2, o=new Vector2, c=new Vector2) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = a,
        this.v2 = o,
        this.v3 = c
    }
    getPoint(e, a=new Vector2) {
        const o = a
          , c = this.v0
          , d = this.v1
          , g = this.v2
          , _ = this.v3;
        return o.set(CubicBezier(e, c.x, d.x, g.x, _.x), CubicBezier(e, c.y, d.y, g.y, _.y)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class CubicBezierCurve3 extends Curve {
    constructor(e=new Vector3, a=new Vector3, o=new Vector3, c=new Vector3) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = a,
        this.v2 = o,
        this.v3 = c
    }
    getPoint(e, a=new Vector3) {
        const o = a
          , c = this.v0
          , d = this.v1
          , g = this.v2
          , _ = this.v3;
        return o.set(CubicBezier(e, c.x, d.x, g.x, _.x), CubicBezier(e, c.y, d.y, g.y, _.y), CubicBezier(e, c.z, d.z, g.z, _.z)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class LineCurve extends Curve {
    constructor(e=new Vector2, a=new Vector2) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = a
    }
    getPoint(e, a=new Vector2) {
        const o = a;
        return e === 1 ? o.copy(this.v2) : (o.copy(this.v2).sub(this.v1),
        o.multiplyScalar(e).add(this.v1)),
        o
    }
    getPointAt(e, a) {
        return this.getPoint(e, a)
    }
    getTangent(e, a=new Vector2) {
        return a.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, a) {
        return this.getTangent(e, a)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class LineCurve3 extends Curve {
    constructor(e=new Vector3, a=new Vector3) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = a
    }
    getPoint(e, a=new Vector3) {
        const o = a;
        return e === 1 ? o.copy(this.v2) : (o.copy(this.v2).sub(this.v1),
        o.multiplyScalar(e).add(this.v1)),
        o
    }
    getPointAt(e, a) {
        return this.getPoint(e, a)
    }
    getTangent(e, a=new Vector3) {
        return a.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, a) {
        return this.getTangent(e, a)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class QuadraticBezierCurve extends Curve {
    constructor(e=new Vector2, a=new Vector2, o=new Vector2) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = a,
        this.v2 = o
    }
    getPoint(e, a=new Vector2) {
        const o = a
          , c = this.v0
          , d = this.v1
          , g = this.v2;
        return o.set(QuadraticBezier(e, c.x, d.x, g.x), QuadraticBezier(e, c.y, d.y, g.y)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class QuadraticBezierCurve3 extends Curve {
    constructor(e=new Vector3, a=new Vector3, o=new Vector3) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = a,
        this.v2 = o
    }
    getPoint(e, a=new Vector3) {
        const o = a
          , c = this.v0
          , d = this.v1
          , g = this.v2;
        return o.set(QuadraticBezier(e, c.x, d.x, g.x), QuadraticBezier(e, c.y, d.y, g.y), QuadraticBezier(e, c.z, d.z, g.z)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class SplineCurve extends Curve {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, a=new Vector2) {
        const o = a
          , c = this.points
          , d = (c.length - 1) * e
          , g = Math.floor(d)
          , _ = d - g
          , b = c[g === 0 ? g : g - 1]
          , j = c[g]
          , $ = c[g > c.length - 2 ? c.length - 1 : g + 1]
          , nt = c[g > c.length - 3 ? c.length - 1 : g + 2];
        return o.set(CatmullRom(_, b.x, j.x, $.x, nt.x), CatmullRom(_, b.y, j.y, $.y, nt.y)),
        o
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let a = 0, o = e.points.length; a < o; a++) {
            const c = e.points[a];
            this.points.push(c.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let a = 0, o = this.points.length; a < o; a++) {
            const c = this.points[a];
            e.points.push(c.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let a = 0, o = e.points.length; a < o; a++) {
            const c = e.points[a];
            this.points.push(new Vector2().fromArray(c))
        }
        return this
    }
}
var Curves = Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
});
class CurvePath extends Curve {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , a = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(a)) {
            const o = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new Curves[o](a,e))
        }
        return this
    }
    getPoint(e, a) {
        const o = e * this.getLength()
          , c = this.getCurveLengths();
        let d = 0;
        for (; d < c.length; ) {
            if (c[d] >= o) {
                const g = c[d] - o
                  , _ = this.curves[d]
                  , b = _.getLength()
                  , j = b === 0 ? 0 : 1 - g / b;
                return _.getPointAt(j, a)
            }
            d++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let a = 0;
        for (let o = 0, c = this.curves.length; o < c; o++)
            a += this.curves[o].getLength(),
            e.push(a);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const a = [];
        for (let o = 0; o <= e; o++)
            a.push(this.getPoint(o / e));
        return this.autoClose && a.push(a[0]),
        a
    }
    getPoints(e=12) {
        const a = [];
        let o;
        for (let c = 0, d = this.curves; c < d.length; c++) {
            const g = d[c]
              , _ = g.isEllipseCurve ? e * 2 : g.isLineCurve || g.isLineCurve3 ? 1 : g.isSplineCurve ? e * g.points.length : e
              , b = g.getPoints(_);
            for (let j = 0; j < b.length; j++) {
                const $ = b[j];
                o && o.equals($) || (a.push($),
                o = $)
            }
        }
        return this.autoClose && a.length > 1 && !a[a.length - 1].equals(a[0]) && a.push(a[0]),
        a
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let a = 0, o = e.curves.length; a < o; a++) {
            const c = e.curves[a];
            this.curves.push(c.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let a = 0, o = this.curves.length; a < o; a++) {
            const c = this.curves[a];
            e.curves.push(c.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let a = 0, o = e.curves.length; a < o; a++) {
            const c = e.curves[a];
            this.curves.push(new Curves[c.type]().fromJSON(c))
        }
        return this
    }
}
class Path extends CurvePath {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new Vector2,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let a = 1, o = e.length; a < o; a++)
            this.lineTo(e[a].x, e[a].y);
        return this
    }
    moveTo(e, a) {
        return this.currentPoint.set(e, a),
        this
    }
    lineTo(e, a) {
        const o = new LineCurve(this.currentPoint.clone(),new Vector2(e,a));
        return this.curves.push(o),
        this.currentPoint.set(e, a),
        this
    }
    quadraticCurveTo(e, a, o, c) {
        const d = new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,a),new Vector2(o,c));
        return this.curves.push(d),
        this.currentPoint.set(o, c),
        this
    }
    bezierCurveTo(e, a, o, c, d, g) {
        const _ = new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,a),new Vector2(o,c),new Vector2(d,g));
        return this.curves.push(_),
        this.currentPoint.set(d, g),
        this
    }
    splineThru(e) {
        const a = [this.currentPoint.clone()].concat(e)
          , o = new SplineCurve(a);
        return this.curves.push(o),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, a, o, c, d, g) {
        const _ = this.currentPoint.x
          , b = this.currentPoint.y;
        return this.absarc(e + _, a + b, o, c, d, g),
        this
    }
    absarc(e, a, o, c, d, g) {
        return this.absellipse(e, a, o, o, c, d, g),
        this
    }
    ellipse(e, a, o, c, d, g, _, b) {
        const j = this.currentPoint.x
          , $ = this.currentPoint.y;
        return this.absellipse(e + j, a + $, o, c, d, g, _, b),
        this
    }
    absellipse(e, a, o, c, d, g, _, b) {
        const j = new EllipseCurve(e,a,o,c,d,g,_,b);
        if (this.curves.length > 0) {
            const nt = j.getPoint(0);
            nt.equals(this.currentPoint) || this.lineTo(nt.x, nt.y)
        }
        this.curves.push(j);
        const $ = j.getPoint(1);
        return this.currentPoint.copy($),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class LatheGeometry extends BufferGeometry {
    constructor(e=[new Vector2(0,-.5), new Vector2(.5,0), new Vector2(0,.5)], a=12, o=0, c=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: a,
            phiStart: o,
            phiLength: c
        },
        a = Math.floor(a),
        c = clamp(c, 0, Math.PI * 2);
        const d = []
          , g = []
          , _ = []
          , b = []
          , j = []
          , $ = 1 / a
          , nt = new Vector3
          , tt = new Vector2
          , rt = new Vector3
          , st = new Vector3
          , lt = new Vector3;
        let ct = 0
          , it = 0;
        for (let ot = 0; ot <= e.length - 1; ot++)
            switch (ot) {
            case 0:
                ct = e[ot + 1].x - e[ot].x,
                it = e[ot + 1].y - e[ot].y,
                rt.x = it * 1,
                rt.y = -ct,
                rt.z = it * 0,
                lt.copy(rt),
                rt.normalize(),
                b.push(rt.x, rt.y, rt.z);
                break;
            case e.length - 1:
                b.push(lt.x, lt.y, lt.z);
                break;
            default:
                ct = e[ot + 1].x - e[ot].x,
                it = e[ot + 1].y - e[ot].y,
                rt.x = it * 1,
                rt.y = -ct,
                rt.z = it * 0,
                st.copy(rt),
                rt.x += lt.x,
                rt.y += lt.y,
                rt.z += lt.z,
                rt.normalize(),
                b.push(rt.x, rt.y, rt.z),
                lt.copy(st)
            }
        for (let ot = 0; ot <= a; ot++) {
            const at = o + ot * $ * c
              , ht = Math.sin(at)
              , pt = Math.cos(at);
            for (let dt = 0; dt <= e.length - 1; dt++) {
                nt.x = e[dt].x * ht,
                nt.y = e[dt].y,
                nt.z = e[dt].x * pt,
                g.push(nt.x, nt.y, nt.z),
                tt.x = ot / a,
                tt.y = dt / (e.length - 1),
                _.push(tt.x, tt.y);
                const yt = b[3 * dt + 0] * ht
                  , vt = b[3 * dt + 1]
                  , xt = b[3 * dt + 0] * pt;
                j.push(yt, vt, xt)
            }
        }
        for (let ot = 0; ot < a; ot++)
            for (let at = 0; at < e.length - 1; at++) {
                const ht = at + ot * e.length
                  , pt = ht
                  , dt = ht + e.length
                  , yt = ht + e.length + 1
                  , vt = ht + 1;
                d.push(pt, dt, vt),
                d.push(yt, vt, dt)
            }
        this.setIndex(d),
        this.setAttribute("position", new Float32BufferAttribute(g,3)),
        this.setAttribute("uv", new Float32BufferAttribute(_,2)),
        this.setAttribute("normal", new Float32BufferAttribute(j,3))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new LatheGeometry(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class CapsuleGeometry extends LatheGeometry {
    constructor(e=1, a=1, o=4, c=8) {
        const d = new Path;
        d.absarc(0, -a / 2, e, Math.PI * 1.5, 0),
        d.absarc(0, a / 2, e, 0, Math.PI * .5),
        super(d.getPoints(o), c),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            length: a,
            capSegments: o,
            radialSegments: c
        }
    }
    static fromJSON(e) {
        return new CapsuleGeometry(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class CircleGeometry extends BufferGeometry {
    constructor(e=1, a=32, o=0, c=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: a,
            thetaStart: o,
            thetaLength: c
        },
        a = Math.max(3, a);
        const d = []
          , g = []
          , _ = []
          , b = []
          , j = new Vector3
          , $ = new Vector2;
        g.push(0, 0, 0),
        _.push(0, 0, 1),
        b.push(.5, .5);
        for (let nt = 0, tt = 3; nt <= a; nt++,
        tt += 3) {
            const rt = o + nt / a * c;
            j.x = e * Math.cos(rt),
            j.y = e * Math.sin(rt),
            g.push(j.x, j.y, j.z),
            _.push(0, 0, 1),
            $.x = (g[tt] / e + 1) / 2,
            $.y = (g[tt + 1] / e + 1) / 2,
            b.push($.x, $.y)
        }
        for (let nt = 1; nt <= a; nt++)
            d.push(nt, nt + 1, 0);
        this.setIndex(d),
        this.setAttribute("position", new Float32BufferAttribute(g,3)),
        this.setAttribute("normal", new Float32BufferAttribute(_,3)),
        this.setAttribute("uv", new Float32BufferAttribute(b,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new CircleGeometry(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class CylinderGeometry extends BufferGeometry {
    constructor(e=1, a=1, o=1, c=32, d=1, g=!1, _=0, b=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: a,
            height: o,
            radialSegments: c,
            heightSegments: d,
            openEnded: g,
            thetaStart: _,
            thetaLength: b
        };
        const j = this;
        c = Math.floor(c),
        d = Math.floor(d);
        const $ = []
          , nt = []
          , tt = []
          , rt = [];
        let st = 0;
        const lt = []
          , ct = o / 2;
        let it = 0;
        ot(),
        g === !1 && (e > 0 && at(!0),
        a > 0 && at(!1)),
        this.setIndex($),
        this.setAttribute("position", new Float32BufferAttribute(nt,3)),
        this.setAttribute("normal", new Float32BufferAttribute(tt,3)),
        this.setAttribute("uv", new Float32BufferAttribute(rt,2));
        function ot() {
            const ht = new Vector3
              , pt = new Vector3;
            let dt = 0;
            const yt = (a - e) / o;
            for (let vt = 0; vt <= d; vt++) {
                const xt = []
                  , _t = vt / d
                  , bt = _t * (a - e) + e;
                for (let Rt = 0; Rt <= c; Rt++) {
                    const Ft = Rt / c
                      , Bt = Ft * b + _
                      , Dt = Math.sin(Bt)
                      , Mt = Math.cos(Bt);
                    pt.x = bt * Dt,
                    pt.y = -_t * o + ct,
                    pt.z = bt * Mt,
                    nt.push(pt.x, pt.y, pt.z),
                    ht.set(Dt, yt, Mt).normalize(),
                    tt.push(ht.x, ht.y, ht.z),
                    rt.push(Ft, 1 - _t),
                    xt.push(st++)
                }
                lt.push(xt)
            }
            for (let vt = 0; vt < c; vt++)
                for (let xt = 0; xt < d; xt++) {
                    const _t = lt[xt][vt]
                      , bt = lt[xt + 1][vt]
                      , Rt = lt[xt + 1][vt + 1]
                      , Ft = lt[xt][vt + 1];
                    $.push(_t, bt, Ft),
                    $.push(bt, Rt, Ft),
                    dt += 6
                }
            j.addGroup(it, dt, 0),
            it += dt
        }
        function at(ht) {
            const pt = st
              , dt = new Vector2
              , yt = new Vector3;
            let vt = 0;
            const xt = ht === !0 ? e : a
              , _t = ht === !0 ? 1 : -1;
            for (let Rt = 1; Rt <= c; Rt++)
                nt.push(0, ct * _t, 0),
                tt.push(0, _t, 0),
                rt.push(.5, .5),
                st++;
            const bt = st;
            for (let Rt = 0; Rt <= c; Rt++) {
                const Bt = Rt / c * b + _
                  , Dt = Math.cos(Bt)
                  , Mt = Math.sin(Bt);
                yt.x = xt * Mt,
                yt.y = ct * _t,
                yt.z = xt * Dt,
                nt.push(yt.x, yt.y, yt.z),
                tt.push(0, _t, 0),
                dt.x = Dt * .5 + .5,
                dt.y = Mt * .5 * _t + .5,
                rt.push(dt.x, dt.y),
                st++
            }
            for (let Rt = 0; Rt < c; Rt++) {
                const Ft = pt + Rt
                  , Bt = bt + Rt;
                ht === !0 ? $.push(Bt, Bt + 1, Ft) : $.push(Bt + 1, Bt, Ft),
                vt += 3
            }
            j.addGroup(it, vt, ht === !0 ? 1 : 2),
            it += vt
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new CylinderGeometry(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class ConeGeometry extends CylinderGeometry {
    constructor(e=1, a=1, o=32, c=1, d=!1, g=0, _=Math.PI * 2) {
        super(0, e, a, o, c, d, g, _),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: a,
            radialSegments: o,
            heightSegments: c,
            openEnded: d,
            thetaStart: g,
            thetaLength: _
        }
    }
    static fromJSON(e) {
        return new ConeGeometry(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class PolyhedronGeometry extends BufferGeometry {
    constructor(e=[], a=[], o=1, c=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: a,
            radius: o,
            detail: c
        };
        const d = []
          , g = [];
        _(c),
        j(o),
        $(),
        this.setAttribute("position", new Float32BufferAttribute(d,3)),
        this.setAttribute("normal", new Float32BufferAttribute(d.slice(),3)),
        this.setAttribute("uv", new Float32BufferAttribute(g,2)),
        c === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function _(ot) {
            const at = new Vector3
              , ht = new Vector3
              , pt = new Vector3;
            for (let dt = 0; dt < a.length; dt += 3)
                rt(a[dt + 0], at),
                rt(a[dt + 1], ht),
                rt(a[dt + 2], pt),
                b(at, ht, pt, ot)
        }
        function b(ot, at, ht, pt) {
            const dt = pt + 1
              , yt = [];
            for (let vt = 0; vt <= dt; vt++) {
                yt[vt] = [];
                const xt = ot.clone().lerp(ht, vt / dt)
                  , _t = at.clone().lerp(ht, vt / dt)
                  , bt = dt - vt;
                for (let Rt = 0; Rt <= bt; Rt++)
                    Rt === 0 && vt === dt ? yt[vt][Rt] = xt : yt[vt][Rt] = xt.clone().lerp(_t, Rt / bt)
            }
            for (let vt = 0; vt < dt; vt++)
                for (let xt = 0; xt < 2 * (dt - vt) - 1; xt++) {
                    const _t = Math.floor(xt / 2);
                    xt % 2 === 0 ? (tt(yt[vt][_t + 1]),
                    tt(yt[vt + 1][_t]),
                    tt(yt[vt][_t])) : (tt(yt[vt][_t + 1]),
                    tt(yt[vt + 1][_t + 1]),
                    tt(yt[vt + 1][_t]))
                }
        }
        function j(ot) {
            const at = new Vector3;
            for (let ht = 0; ht < d.length; ht += 3)
                at.x = d[ht + 0],
                at.y = d[ht + 1],
                at.z = d[ht + 2],
                at.normalize().multiplyScalar(ot),
                d[ht + 0] = at.x,
                d[ht + 1] = at.y,
                d[ht + 2] = at.z
        }
        function $() {
            const ot = new Vector3;
            for (let at = 0; at < d.length; at += 3) {
                ot.x = d[at + 0],
                ot.y = d[at + 1],
                ot.z = d[at + 2];
                const ht = ct(ot) / 2 / Math.PI + .5
                  , pt = it(ot) / Math.PI + .5;
                g.push(ht, 1 - pt)
            }
            st(),
            nt()
        }
        function nt() {
            for (let ot = 0; ot < g.length; ot += 6) {
                const at = g[ot + 0]
                  , ht = g[ot + 2]
                  , pt = g[ot + 4]
                  , dt = Math.max(at, ht, pt)
                  , yt = Math.min(at, ht, pt);
                dt > .9 && yt < .1 && (at < .2 && (g[ot + 0] += 1),
                ht < .2 && (g[ot + 2] += 1),
                pt < .2 && (g[ot + 4] += 1))
            }
        }
        function tt(ot) {
            d.push(ot.x, ot.y, ot.z)
        }
        function rt(ot, at) {
            const ht = ot * 3;
            at.x = e[ht + 0],
            at.y = e[ht + 1],
            at.z = e[ht + 2]
        }
        function st() {
            const ot = new Vector3
              , at = new Vector3
              , ht = new Vector3
              , pt = new Vector3
              , dt = new Vector2
              , yt = new Vector2
              , vt = new Vector2;
            for (let xt = 0, _t = 0; xt < d.length; xt += 9,
            _t += 6) {
                ot.set(d[xt + 0], d[xt + 1], d[xt + 2]),
                at.set(d[xt + 3], d[xt + 4], d[xt + 5]),
                ht.set(d[xt + 6], d[xt + 7], d[xt + 8]),
                dt.set(g[_t + 0], g[_t + 1]),
                yt.set(g[_t + 2], g[_t + 3]),
                vt.set(g[_t + 4], g[_t + 5]),
                pt.copy(ot).add(at).add(ht).divideScalar(3);
                const bt = ct(pt);
                lt(dt, _t + 0, ot, bt),
                lt(yt, _t + 2, at, bt),
                lt(vt, _t + 4, ht, bt)
            }
        }
        function lt(ot, at, ht, pt) {
            pt < 0 && ot.x === 1 && (g[at] = ot.x - 1),
            ht.x === 0 && ht.z === 0 && (g[at] = pt / 2 / Math.PI + .5)
        }
        function ct(ot) {
            return Math.atan2(ot.z, -ot.x)
        }
        function it(ot) {
            return Math.atan2(-ot.y, Math.sqrt(ot.x * ot.x + ot.z * ot.z))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new PolyhedronGeometry(e.vertices,e.indices,e.radius,e.details)
    }
}
class DodecahedronGeometry extends PolyhedronGeometry {
    constructor(e=1, a=0) {
        const o = (1 + Math.sqrt(5)) / 2
          , c = 1 / o
          , d = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -c, -o, 0, -c, o, 0, c, -o, 0, c, o, -c, -o, 0, -c, o, 0, c, -o, 0, c, o, 0, -o, 0, -c, o, 0, -c, -o, 0, c, o, 0, c]
          , g = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(d, g, e, a),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: a
        }
    }
    static fromJSON(e) {
        return new DodecahedronGeometry(e.radius,e.detail)
    }
}
const _v0 = new Vector3
  , _v1$1 = new Vector3
  , _normal = new Vector3
  , _triangle = new Triangle;
class EdgesGeometry extends BufferGeometry {
    constructor(e=null, a=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: a
        },
        e !== null) {
            const c = Math.pow(10, 4)
              , d = Math.cos(DEG2RAD * a)
              , g = e.getIndex()
              , _ = e.getAttribute("position")
              , b = g ? g.count : _.count
              , j = [0, 0, 0]
              , $ = ["a", "b", "c"]
              , nt = new Array(3)
              , tt = {}
              , rt = [];
            for (let st = 0; st < b; st += 3) {
                g ? (j[0] = g.getX(st),
                j[1] = g.getX(st + 1),
                j[2] = g.getX(st + 2)) : (j[0] = st,
                j[1] = st + 1,
                j[2] = st + 2);
                const {a: lt, b: ct, c: it} = _triangle;
                if (lt.fromBufferAttribute(_, j[0]),
                ct.fromBufferAttribute(_, j[1]),
                it.fromBufferAttribute(_, j[2]),
                _triangle.getNormal(_normal),
                nt[0] = `${Math.round(lt.x * c)},${Math.round(lt.y * c)},${Math.round(lt.z * c)}`,
                nt[1] = `${Math.round(ct.x * c)},${Math.round(ct.y * c)},${Math.round(ct.z * c)}`,
                nt[2] = `${Math.round(it.x * c)},${Math.round(it.y * c)},${Math.round(it.z * c)}`,
                !(nt[0] === nt[1] || nt[1] === nt[2] || nt[2] === nt[0]))
                    for (let ot = 0; ot < 3; ot++) {
                        const at = (ot + 1) % 3
                          , ht = nt[ot]
                          , pt = nt[at]
                          , dt = _triangle[$[ot]]
                          , yt = _triangle[$[at]]
                          , vt = `${ht}_${pt}`
                          , xt = `${pt}_${ht}`;
                        xt in tt && tt[xt] ? (_normal.dot(tt[xt].normal) <= d && (rt.push(dt.x, dt.y, dt.z),
                        rt.push(yt.x, yt.y, yt.z)),
                        tt[xt] = null) : vt in tt || (tt[vt] = {
                            index0: j[ot],
                            index1: j[at],
                            normal: _normal.clone()
                        })
                    }
            }
            for (const st in tt)
                if (tt[st]) {
                    const {index0: lt, index1: ct} = tt[st];
                    _v0.fromBufferAttribute(_, lt),
                    _v1$1.fromBufferAttribute(_, ct),
                    rt.push(_v0.x, _v0.y, _v0.z),
                    rt.push(_v1$1.x, _v1$1.y, _v1$1.z)
                }
            this.setAttribute("position", new Float32BufferAttribute(rt,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
class Shape extends Path {
    constructor(e) {
        super(e),
        this.uuid = generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const a = [];
        for (let o = 0, c = this.holes.length; o < c; o++)
            a[o] = this.holes[o].getPoints(e);
        return a
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let a = 0, o = e.holes.length; a < o; a++) {
            const c = e.holes[a];
            this.holes.push(c.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let a = 0, o = this.holes.length; a < o; a++) {
            const c = this.holes[a];
            e.holes.push(c.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let a = 0, o = e.holes.length; a < o; a++) {
            const c = e.holes[a];
            this.holes.push(new Path().fromJSON(c))
        }
        return this
    }
}
const Earcut = {
    triangulate: function(s, e, a=2) {
        const o = e && e.length
          , c = o ? e[0] * a : s.length;
        let d = linkedList(s, 0, c, a, !0);
        const g = [];
        if (!d || d.next === d.prev)
            return g;
        let _, b, j, $, nt, tt, rt;
        if (o && (d = eliminateHoles(s, e, d, a)),
        s.length > 80 * a) {
            _ = j = s[0],
            b = $ = s[1];
            for (let st = a; st < c; st += a)
                nt = s[st],
                tt = s[st + 1],
                nt < _ && (_ = nt),
                tt < b && (b = tt),
                nt > j && (j = nt),
                tt > $ && ($ = tt);
            rt = Math.max(j - _, $ - b),
            rt = rt !== 0 ? 32767 / rt : 0
        }
        return earcutLinked(d, g, a, _, b, rt, 0),
        g
    }
};
function linkedList(s, e, a, o, c) {
    let d, g;
    if (c === signedArea(s, e, a, o) > 0)
        for (d = e; d < a; d += o)
            g = insertNode(d, s[d], s[d + 1], g);
    else
        for (d = a - o; d >= e; d -= o)
            g = insertNode(d, s[d], s[d + 1], g);
    return g && equals(g, g.next) && (removeNode(g),
    g = g.next),
    g
}
function filterPoints(s, e) {
    if (!s)
        return s;
    e || (e = s);
    let a = s, o;
    do
        if (o = !1,
        !a.steiner && (equals(a, a.next) || area(a.prev, a, a.next) === 0)) {
            if (removeNode(a),
            a = e = a.prev,
            a === a.next)
                break;
            o = !0
        } else
            a = a.next;
    while (o || a !== e);
    return e
}
function earcutLinked(s, e, a, o, c, d, g) {
    if (!s)
        return;
    !g && d && indexCurve(s, o, c, d);
    let _ = s, b, j;
    for (; s.prev !== s.next; ) {
        if (b = s.prev,
        j = s.next,
        d ? isEarHashed(s, o, c, d) : isEar(s)) {
            e.push(b.i / a | 0),
            e.push(s.i / a | 0),
            e.push(j.i / a | 0),
            removeNode(s),
            s = j.next,
            _ = j.next;
            continue
        }
        if (s = j,
        s === _) {
            g ? g === 1 ? (s = cureLocalIntersections(filterPoints(s), e, a),
            earcutLinked(s, e, a, o, c, d, 2)) : g === 2 && splitEarcut(s, e, a, o, c, d) : earcutLinked(filterPoints(s), e, a, o, c, d, 1);
            break
        }
    }
}
function isEar(s) {
    const e = s.prev
      , a = s
      , o = s.next;
    if (area(e, a, o) >= 0)
        return !1;
    const c = e.x
      , d = a.x
      , g = o.x
      , _ = e.y
      , b = a.y
      , j = o.y
      , $ = c < d ? c < g ? c : g : d < g ? d : g
      , nt = _ < b ? _ < j ? _ : j : b < j ? b : j
      , tt = c > d ? c > g ? c : g : d > g ? d : g
      , rt = _ > b ? _ > j ? _ : j : b > j ? b : j;
    let st = o.next;
    for (; st !== e; ) {
        if (st.x >= $ && st.x <= tt && st.y >= nt && st.y <= rt && pointInTriangle(c, _, d, b, g, j, st.x, st.y) && area(st.prev, st, st.next) >= 0)
            return !1;
        st = st.next
    }
    return !0
}
function isEarHashed(s, e, a, o) {
    const c = s.prev
      , d = s
      , g = s.next;
    if (area(c, d, g) >= 0)
        return !1;
    const _ = c.x
      , b = d.x
      , j = g.x
      , $ = c.y
      , nt = d.y
      , tt = g.y
      , rt = _ < b ? _ < j ? _ : j : b < j ? b : j
      , st = $ < nt ? $ < tt ? $ : tt : nt < tt ? nt : tt
      , lt = _ > b ? _ > j ? _ : j : b > j ? b : j
      , ct = $ > nt ? $ > tt ? $ : tt : nt > tt ? nt : tt
      , it = zOrder(rt, st, e, a, o)
      , ot = zOrder(lt, ct, e, a, o);
    let at = s.prevZ
      , ht = s.nextZ;
    for (; at && at.z >= it && ht && ht.z <= ot; ) {
        if (at.x >= rt && at.x <= lt && at.y >= st && at.y <= ct && at !== c && at !== g && pointInTriangle(_, $, b, nt, j, tt, at.x, at.y) && area(at.prev, at, at.next) >= 0 || (at = at.prevZ,
        ht.x >= rt && ht.x <= lt && ht.y >= st && ht.y <= ct && ht !== c && ht !== g && pointInTriangle(_, $, b, nt, j, tt, ht.x, ht.y) && area(ht.prev, ht, ht.next) >= 0))
            return !1;
        ht = ht.nextZ
    }
    for (; at && at.z >= it; ) {
        if (at.x >= rt && at.x <= lt && at.y >= st && at.y <= ct && at !== c && at !== g && pointInTriangle(_, $, b, nt, j, tt, at.x, at.y) && area(at.prev, at, at.next) >= 0)
            return !1;
        at = at.prevZ
    }
    for (; ht && ht.z <= ot; ) {
        if (ht.x >= rt && ht.x <= lt && ht.y >= st && ht.y <= ct && ht !== c && ht !== g && pointInTriangle(_, $, b, nt, j, tt, ht.x, ht.y) && area(ht.prev, ht, ht.next) >= 0)
            return !1;
        ht = ht.nextZ
    }
    return !0
}
function cureLocalIntersections(s, e, a) {
    let o = s;
    do {
        const c = o.prev
          , d = o.next.next;
        !equals(c, d) && intersects(c, o, o.next, d) && locallyInside(c, d) && locallyInside(d, c) && (e.push(c.i / a | 0),
        e.push(o.i / a | 0),
        e.push(d.i / a | 0),
        removeNode(o),
        removeNode(o.next),
        o = s = d),
        o = o.next
    } while (o !== s);
    return filterPoints(o)
}
function splitEarcut(s, e, a, o, c, d) {
    let g = s;
    do {
        let _ = g.next.next;
        for (; _ !== g.prev; ) {
            if (g.i !== _.i && isValidDiagonal(g, _)) {
                let b = splitPolygon(g, _);
                g = filterPoints(g, g.next),
                b = filterPoints(b, b.next),
                earcutLinked(g, e, a, o, c, d, 0),
                earcutLinked(b, e, a, o, c, d, 0);
                return
            }
            _ = _.next
        }
        g = g.next
    } while (g !== s)
}
function eliminateHoles(s, e, a, o) {
    const c = [];
    let d, g, _, b, j;
    for (d = 0,
    g = e.length; d < g; d++)
        _ = e[d] * o,
        b = d < g - 1 ? e[d + 1] * o : s.length,
        j = linkedList(s, _, b, o, !1),
        j === j.next && (j.steiner = !0),
        c.push(getLeftmost(j));
    for (c.sort(compareX),
    d = 0; d < c.length; d++)
        a = eliminateHole(c[d], a);
    return a
}
function compareX(s, e) {
    return s.x - e.x
}
function eliminateHole(s, e) {
    const a = findHoleBridge(s, e);
    if (!a)
        return e;
    const o = splitPolygon(a, s);
    return filterPoints(o, o.next),
    filterPoints(a, a.next)
}
function findHoleBridge(s, e) {
    let a = e, o = -1 / 0, c;
    const d = s.x
      , g = s.y;
    do {
        if (g <= a.y && g >= a.next.y && a.next.y !== a.y) {
            const tt = a.x + (g - a.y) * (a.next.x - a.x) / (a.next.y - a.y);
            if (tt <= d && tt > o && (o = tt,
            c = a.x < a.next.x ? a : a.next,
            tt === d))
                return c
        }
        a = a.next
    } while (a !== e);
    if (!c)
        return null;
    const _ = c
      , b = c.x
      , j = c.y;
    let $ = 1 / 0, nt;
    a = c;
    do
        d >= a.x && a.x >= b && d !== a.x && pointInTriangle(g < j ? d : o, g, b, j, g < j ? o : d, g, a.x, a.y) && (nt = Math.abs(g - a.y) / (d - a.x),
        locallyInside(a, s) && (nt < $ || nt === $ && (a.x > c.x || a.x === c.x && sectorContainsSector(c, a))) && (c = a,
        $ = nt)),
        a = a.next;
    while (a !== _);
    return c
}
function sectorContainsSector(s, e) {
    return area(s.prev, s, e.prev) < 0 && area(e.next, s, s.next) < 0
}
function indexCurve(s, e, a, o) {
    let c = s;
    do
        c.z === 0 && (c.z = zOrder(c.x, c.y, e, a, o)),
        c.prevZ = c.prev,
        c.nextZ = c.next,
        c = c.next;
    while (c !== s);
    c.prevZ.nextZ = null,
    c.prevZ = null,
    sortLinked(c)
}
function sortLinked(s) {
    let e, a, o, c, d, g, _, b, j = 1;
    do {
        for (a = s,
        s = null,
        d = null,
        g = 0; a; ) {
            for (g++,
            o = a,
            _ = 0,
            e = 0; e < j && (_++,
            o = o.nextZ,
            !!o); e++)
                ;
            for (b = j; _ > 0 || b > 0 && o; )
                _ !== 0 && (b === 0 || !o || a.z <= o.z) ? (c = a,
                a = a.nextZ,
                _--) : (c = o,
                o = o.nextZ,
                b--),
                d ? d.nextZ = c : s = c,
                c.prevZ = d,
                d = c;
            a = o
        }
        d.nextZ = null,
        j *= 2
    } while (g > 1);
    return s
}
function zOrder(s, e, a, o, c) {
    return s = (s - a) * c | 0,
    e = (e - o) * c | 0,
    s = (s | s << 8) & 16711935,
    s = (s | s << 4) & 252645135,
    s = (s | s << 2) & 858993459,
    s = (s | s << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    s | e << 1
}
function getLeftmost(s) {
    let e = s
      , a = s;
    do
        (e.x < a.x || e.x === a.x && e.y < a.y) && (a = e),
        e = e.next;
    while (e !== s);
    return a
}
function pointInTriangle(s, e, a, o, c, d, g, _) {
    return (c - g) * (e - _) >= (s - g) * (d - _) && (s - g) * (o - _) >= (a - g) * (e - _) && (a - g) * (d - _) >= (c - g) * (o - _)
}
function isValidDiagonal(s, e) {
    return s.next.i !== e.i && s.prev.i !== e.i && !intersectsPolygon(s, e) && (locallyInside(s, e) && locallyInside(e, s) && middleInside(s, e) && (area(s.prev, s, e.prev) || area(s, e.prev, e)) || equals(s, e) && area(s.prev, s, s.next) > 0 && area(e.prev, e, e.next) > 0)
}
function area(s, e, a) {
    return (e.y - s.y) * (a.x - e.x) - (e.x - s.x) * (a.y - e.y)
}
function equals(s, e) {
    return s.x === e.x && s.y === e.y
}
function intersects(s, e, a, o) {
    const c = sign(area(s, e, a))
      , d = sign(area(s, e, o))
      , g = sign(area(a, o, s))
      , _ = sign(area(a, o, e));
    return !!(c !== d && g !== _ || c === 0 && onSegment(s, a, e) || d === 0 && onSegment(s, o, e) || g === 0 && onSegment(a, s, o) || _ === 0 && onSegment(a, e, o))
}
function onSegment(s, e, a) {
    return e.x <= Math.max(s.x, a.x) && e.x >= Math.min(s.x, a.x) && e.y <= Math.max(s.y, a.y) && e.y >= Math.min(s.y, a.y)
}
function sign(s) {
    return s > 0 ? 1 : s < 0 ? -1 : 0
}
function intersectsPolygon(s, e) {
    let a = s;
    do {
        if (a.i !== s.i && a.next.i !== s.i && a.i !== e.i && a.next.i !== e.i && intersects(a, a.next, s, e))
            return !0;
        a = a.next
    } while (a !== s);
    return !1
}
function locallyInside(s, e) {
    return area(s.prev, s, s.next) < 0 ? area(s, e, s.next) >= 0 && area(s, s.prev, e) >= 0 : area(s, e, s.prev) < 0 || area(s, s.next, e) < 0
}
function middleInside(s, e) {
    let a = s
      , o = !1;
    const c = (s.x + e.x) / 2
      , d = (s.y + e.y) / 2;
    do
        a.y > d != a.next.y > d && a.next.y !== a.y && c < (a.next.x - a.x) * (d - a.y) / (a.next.y - a.y) + a.x && (o = !o),
        a = a.next;
    while (a !== s);
    return o
}
function splitPolygon(s, e) {
    const a = new Node(s.i,s.x,s.y)
      , o = new Node(e.i,e.x,e.y)
      , c = s.next
      , d = e.prev;
    return s.next = e,
    e.prev = s,
    a.next = c,
    c.prev = a,
    o.next = a,
    a.prev = o,
    d.next = o,
    o.prev = d,
    o
}
function insertNode(s, e, a, o) {
    const c = new Node(s,e,a);
    return o ? (c.next = o.next,
    c.prev = o,
    o.next.prev = c,
    o.next = c) : (c.prev = c,
    c.next = c),
    c
}
function removeNode(s) {
    s.next.prev = s.prev,
    s.prev.next = s.next,
    s.prevZ && (s.prevZ.nextZ = s.nextZ),
    s.nextZ && (s.nextZ.prevZ = s.prevZ)
}
function Node(s, e, a) {
    this.i = s,
    this.x = e,
    this.y = a,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function signedArea(s, e, a, o) {
    let c = 0;
    for (let d = e, g = a - o; d < a; d += o)
        c += (s[g] - s[d]) * (s[d + 1] + s[g + 1]),
        g = d;
    return c
}
class ShapeUtils {
    static area(e) {
        const a = e.length;
        let o = 0;
        for (let c = a - 1, d = 0; d < a; c = d++)
            o += e[c].x * e[d].y - e[d].x * e[c].y;
        return o * .5
    }
    static isClockWise(e) {
        return ShapeUtils.area(e) < 0
    }
    static triangulateShape(e, a) {
        const o = []
          , c = []
          , d = [];
        removeDupEndPts(e),
        addContour(o, e);
        let g = e.length;
        a.forEach(removeDupEndPts);
        for (let b = 0; b < a.length; b++)
            c.push(g),
            g += a[b].length,
            addContour(o, a[b]);
        const _ = Earcut.triangulate(o, c);
        for (let b = 0; b < _.length; b += 3)
            d.push(_.slice(b, b + 3));
        return d
    }
}
function removeDupEndPts(s) {
    const e = s.length;
    e > 2 && s[e - 1].equals(s[0]) && s.pop()
}
function addContour(s, e) {
    for (let a = 0; a < e.length; a++)
        s.push(e[a].x),
        s.push(e[a].y)
}
class ExtrudeGeometry extends BufferGeometry {
    constructor(e=new Shape([new Vector2(.5,.5), new Vector2(-.5,.5), new Vector2(-.5,-.5), new Vector2(.5,-.5)]), a={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: a
        },
        e = Array.isArray(e) ? e : [e];
        const o = this
          , c = []
          , d = [];
        for (let _ = 0, b = e.length; _ < b; _++) {
            const j = e[_];
            g(j)
        }
        this.setAttribute("position", new Float32BufferAttribute(c,3)),
        this.setAttribute("uv", new Float32BufferAttribute(d,2)),
        this.computeVertexNormals();
        function g(_) {
            const b = []
              , j = a.curveSegments !== void 0 ? a.curveSegments : 12
              , $ = a.steps !== void 0 ? a.steps : 1
              , nt = a.depth !== void 0 ? a.depth : 1;
            let tt = a.bevelEnabled !== void 0 ? a.bevelEnabled : !0
              , rt = a.bevelThickness !== void 0 ? a.bevelThickness : .2
              , st = a.bevelSize !== void 0 ? a.bevelSize : rt - .1
              , lt = a.bevelOffset !== void 0 ? a.bevelOffset : 0
              , ct = a.bevelSegments !== void 0 ? a.bevelSegments : 3;
            const it = a.extrudePath
              , ot = a.UVGenerator !== void 0 ? a.UVGenerator : WorldUVGenerator;
            let at, ht = !1, pt, dt, yt, vt;
            it && (at = it.getSpacedPoints($),
            ht = !0,
            tt = !1,
            pt = it.computeFrenetFrames($, !1),
            dt = new Vector3,
            yt = new Vector3,
            vt = new Vector3),
            tt || (ct = 0,
            rt = 0,
            st = 0,
            lt = 0);
            const xt = _.extractPoints(j);
            let _t = xt.shape;
            const bt = xt.holes;
            if (!ShapeUtils.isClockWise(_t)) {
                _t = _t.reverse();
                for (let Pt = 0, Qt = bt.length; Pt < Qt; Pt++) {
                    const jt = bt[Pt];
                    ShapeUtils.isClockWise(jt) && (bt[Pt] = jt.reverse())
                }
            }
            const Ft = ShapeUtils.triangulateShape(_t, bt)
              , Bt = _t;
            for (let Pt = 0, Qt = bt.length; Pt < Qt; Pt++) {
                const jt = bt[Pt];
                _t = _t.concat(jt)
            }
            function Dt(Pt, Qt, jt) {
                return Qt || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                Pt.clone().addScaledVector(Qt, jt)
            }
            const Mt = _t.length
              , Tt = Ft.length;
            function mt(Pt, Qt, jt) {
                let fn, tn, bn;
                const gn = Pt.x - Qt.x
                  , vn = Pt.y - Qt.y
                  , Lt = jt.x - Pt.x
                  , At = jt.y - Pt.y
                  , $t = gn * gn + vn * vn
                  , on = gn * At - vn * Lt;
                if (Math.abs(on) > Number.EPSILON) {
                    const sn = Math.sqrt($t)
                      , cn = Math.sqrt(Lt * Lt + At * At)
                      , Pn = Qt.x - vn / sn
                      , dn = Qt.y + gn / sn
                      , Tn = jt.x - At / cn
                      , jn = jt.y + Lt / cn
                      , pn = ((Tn - Pn) * At - (jn - dn) * Lt) / (gn * At - vn * Lt);
                    fn = Pn + gn * pn - Pt.x,
                    tn = dn + vn * pn - Pt.y;
                    const kn = fn * fn + tn * tn;
                    if (kn <= 2)
                        return new Vector2(fn,tn);
                    bn = Math.sqrt(kn / 2)
                } else {
                    let sn = !1;
                    gn > Number.EPSILON ? Lt > Number.EPSILON && (sn = !0) : gn < -Number.EPSILON ? Lt < -Number.EPSILON && (sn = !0) : Math.sign(vn) === Math.sign(At) && (sn = !0),
                    sn ? (fn = -vn,
                    tn = gn,
                    bn = Math.sqrt($t)) : (fn = gn,
                    tn = vn,
                    bn = Math.sqrt($t / 2))
                }
                return new Vector2(fn / bn,tn / bn)
            }
            const St = [];
            for (let Pt = 0, Qt = Bt.length, jt = Qt - 1, fn = Pt + 1; Pt < Qt; Pt++,
            jt++,
            fn++)
                jt === Qt && (jt = 0),
                fn === Qt && (fn = 0),
                St[Pt] = mt(Bt[Pt], Bt[jt], Bt[fn]);
            const wt = [];
            let Ct, Ht = St.concat();
            for (let Pt = 0, Qt = bt.length; Pt < Qt; Pt++) {
                const jt = bt[Pt];
                Ct = [];
                for (let fn = 0, tn = jt.length, bn = tn - 1, gn = fn + 1; fn < tn; fn++,
                bn++,
                gn++)
                    bn === tn && (bn = 0),
                    gn === tn && (gn = 0),
                    Ct[fn] = mt(jt[fn], jt[bn], jt[gn]);
                wt.push(Ct),
                Ht = Ht.concat(Ct)
            }
            for (let Pt = 0; Pt < ct; Pt++) {
                const Qt = Pt / ct
                  , jt = rt * Math.cos(Qt * Math.PI / 2)
                  , fn = st * Math.sin(Qt * Math.PI / 2) + lt;
                for (let tn = 0, bn = Bt.length; tn < bn; tn++) {
                    const gn = Dt(Bt[tn], St[tn], fn);
                    Xt(gn.x, gn.y, -jt)
                }
                for (let tn = 0, bn = bt.length; tn < bn; tn++) {
                    const gn = bt[tn];
                    Ct = wt[tn];
                    for (let vn = 0, Lt = gn.length; vn < Lt; vn++) {
                        const At = Dt(gn[vn], Ct[vn], fn);
                        Xt(At.x, At.y, -jt)
                    }
                }
            }
            const en = st + lt;
            for (let Pt = 0; Pt < Mt; Pt++) {
                const Qt = tt ? Dt(_t[Pt], Ht[Pt], en) : _t[Pt];
                ht ? (yt.copy(pt.normals[0]).multiplyScalar(Qt.x),
                dt.copy(pt.binormals[0]).multiplyScalar(Qt.y),
                vt.copy(at[0]).add(yt).add(dt),
                Xt(vt.x, vt.y, vt.z)) : Xt(Qt.x, Qt.y, 0)
            }
            for (let Pt = 1; Pt <= $; Pt++)
                for (let Qt = 0; Qt < Mt; Qt++) {
                    const jt = tt ? Dt(_t[Qt], Ht[Qt], en) : _t[Qt];
                    ht ? (yt.copy(pt.normals[Pt]).multiplyScalar(jt.x),
                    dt.copy(pt.binormals[Pt]).multiplyScalar(jt.y),
                    vt.copy(at[Pt]).add(yt).add(dt),
                    Xt(vt.x, vt.y, vt.z)) : Xt(jt.x, jt.y, nt / $ * Pt)
                }
            for (let Pt = ct - 1; Pt >= 0; Pt--) {
                const Qt = Pt / ct
                  , jt = rt * Math.cos(Qt * Math.PI / 2)
                  , fn = st * Math.sin(Qt * Math.PI / 2) + lt;
                for (let tn = 0, bn = Bt.length; tn < bn; tn++) {
                    const gn = Dt(Bt[tn], St[tn], fn);
                    Xt(gn.x, gn.y, nt + jt)
                }
                for (let tn = 0, bn = bt.length; tn < bn; tn++) {
                    const gn = bt[tn];
                    Ct = wt[tn];
                    for (let vn = 0, Lt = gn.length; vn < Lt; vn++) {
                        const At = Dt(gn[vn], Ct[vn], fn);
                        ht ? Xt(At.x, At.y + at[$ - 1].y, at[$ - 1].x + jt) : Xt(At.x, At.y, nt + jt)
                    }
                }
            }
            Ot(),
            Yt();
            function Ot() {
                const Pt = c.length / 3;
                if (tt) {
                    let Qt = 0
                      , jt = Mt * Qt;
                    for (let fn = 0; fn < Tt; fn++) {
                        const tn = Ft[fn];
                        An(tn[2] + jt, tn[1] + jt, tn[0] + jt)
                    }
                    Qt = $ + ct * 2,
                    jt = Mt * Qt;
                    for (let fn = 0; fn < Tt; fn++) {
                        const tn = Ft[fn];
                        An(tn[0] + jt, tn[1] + jt, tn[2] + jt)
                    }
                } else {
                    for (let Qt = 0; Qt < Tt; Qt++) {
                        const jt = Ft[Qt];
                        An(jt[2], jt[1], jt[0])
                    }
                    for (let Qt = 0; Qt < Tt; Qt++) {
                        const jt = Ft[Qt];
                        An(jt[0] + Mt * $, jt[1] + Mt * $, jt[2] + Mt * $)
                    }
                }
                o.addGroup(Pt, c.length / 3 - Pt, 0)
            }
            function Yt() {
                const Pt = c.length / 3;
                let Qt = 0;
                rn(Bt, Qt),
                Qt += Bt.length;
                for (let jt = 0, fn = bt.length; jt < fn; jt++) {
                    const tn = bt[jt];
                    rn(tn, Qt),
                    Qt += tn.length
                }
                o.addGroup(Pt, c.length / 3 - Pt, 1)
            }
            function rn(Pt, Qt) {
                let jt = Pt.length;
                for (; --jt >= 0; ) {
                    const fn = jt;
                    let tn = jt - 1;
                    tn < 0 && (tn = Pt.length - 1);
                    for (let bn = 0, gn = $ + ct * 2; bn < gn; bn++) {
                        const vn = Mt * bn
                          , Lt = Mt * (bn + 1)
                          , At = Qt + fn + vn
                          , $t = Qt + tn + vn
                          , on = Qt + tn + Lt
                          , sn = Qt + fn + Lt;
                        Ln(At, $t, on, sn)
                    }
                }
            }
            function Xt(Pt, Qt, jt) {
                b.push(Pt),
                b.push(Qt),
                b.push(jt)
            }
            function An(Pt, Qt, jt) {
                _n(Pt),
                _n(Qt),
                _n(jt);
                const fn = c.length / 3
                  , tn = ot.generateTopUV(o, c, fn - 3, fn - 2, fn - 1);
                yn(tn[0]),
                yn(tn[1]),
                yn(tn[2])
            }
            function Ln(Pt, Qt, jt, fn) {
                _n(Pt),
                _n(Qt),
                _n(fn),
                _n(Qt),
                _n(jt),
                _n(fn);
                const tn = c.length / 3
                  , bn = ot.generateSideWallUV(o, c, tn - 6, tn - 3, tn - 2, tn - 1);
                yn(bn[0]),
                yn(bn[1]),
                yn(bn[3]),
                yn(bn[1]),
                yn(bn[2]),
                yn(bn[3])
            }
            function _n(Pt) {
                c.push(b[Pt * 3 + 0]),
                c.push(b[Pt * 3 + 1]),
                c.push(b[Pt * 3 + 2])
            }
            function yn(Pt) {
                d.push(Pt.x),
                d.push(Pt.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , a = this.parameters.shapes
          , o = this.parameters.options;
        return toJSON$1(a, o, e)
    }
    static fromJSON(e, a) {
        const o = [];
        for (let d = 0, g = e.shapes.length; d < g; d++) {
            const _ = a[e.shapes[d]];
            o.push(_)
        }
        const c = e.options.extrudePath;
        return c !== void 0 && (e.options.extrudePath = new Curves[c.type]().fromJSON(c)),
        new ExtrudeGeometry(o,e.options)
    }
}
const WorldUVGenerator = {
    generateTopUV: function(s, e, a, o, c) {
        const d = e[a * 3]
          , g = e[a * 3 + 1]
          , _ = e[o * 3]
          , b = e[o * 3 + 1]
          , j = e[c * 3]
          , $ = e[c * 3 + 1];
        return [new Vector2(d,g), new Vector2(_,b), new Vector2(j,$)]
    },
    generateSideWallUV: function(s, e, a, o, c, d) {
        const g = e[a * 3]
          , _ = e[a * 3 + 1]
          , b = e[a * 3 + 2]
          , j = e[o * 3]
          , $ = e[o * 3 + 1]
          , nt = e[o * 3 + 2]
          , tt = e[c * 3]
          , rt = e[c * 3 + 1]
          , st = e[c * 3 + 2]
          , lt = e[d * 3]
          , ct = e[d * 3 + 1]
          , it = e[d * 3 + 2];
        return Math.abs(_ - $) < Math.abs(g - j) ? [new Vector2(g,1 - b), new Vector2(j,1 - nt), new Vector2(tt,1 - st), new Vector2(lt,1 - it)] : [new Vector2(_,1 - b), new Vector2($,1 - nt), new Vector2(rt,1 - st), new Vector2(ct,1 - it)]
    }
};
function toJSON$1(s, e, a) {
    if (a.shapes = [],
    Array.isArray(s))
        for (let o = 0, c = s.length; o < c; o++) {
            const d = s[o];
            a.shapes.push(d.uuid)
        }
    else
        a.shapes.push(s.uuid);
    return a.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (a.options.extrudePath = e.extrudePath.toJSON()),
    a
}
class IcosahedronGeometry extends PolyhedronGeometry {
    constructor(e=1, a=0) {
        const o = (1 + Math.sqrt(5)) / 2
          , c = [-1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, 0, 0, -1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, o, 0, -1, o, 0, 1, -o, 0, -1, -o, 0, 1]
          , d = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(c, d, e, a),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: a
        }
    }
    static fromJSON(e) {
        return new IcosahedronGeometry(e.radius,e.detail)
    }
}
class OctahedronGeometry extends PolyhedronGeometry {
    constructor(e=1, a=0) {
        const o = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , c = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(o, c, e, a),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: a
        }
    }
    static fromJSON(e) {
        return new OctahedronGeometry(e.radius,e.detail)
    }
}
class RingGeometry extends BufferGeometry {
    constructor(e=.5, a=1, o=32, c=1, d=0, g=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: a,
            thetaSegments: o,
            phiSegments: c,
            thetaStart: d,
            thetaLength: g
        },
        o = Math.max(3, o),
        c = Math.max(1, c);
        const _ = []
          , b = []
          , j = []
          , $ = [];
        let nt = e;
        const tt = (a - e) / c
          , rt = new Vector3
          , st = new Vector2;
        for (let lt = 0; lt <= c; lt++) {
            for (let ct = 0; ct <= o; ct++) {
                const it = d + ct / o * g;
                rt.x = nt * Math.cos(it),
                rt.y = nt * Math.sin(it),
                b.push(rt.x, rt.y, rt.z),
                j.push(0, 0, 1),
                st.x = (rt.x / a + 1) / 2,
                st.y = (rt.y / a + 1) / 2,
                $.push(st.x, st.y)
            }
            nt += tt
        }
        for (let lt = 0; lt < c; lt++) {
            const ct = lt * (o + 1);
            for (let it = 0; it < o; it++) {
                const ot = it + ct
                  , at = ot
                  , ht = ot + o + 1
                  , pt = ot + o + 2
                  , dt = ot + 1;
                _.push(at, ht, dt),
                _.push(ht, pt, dt)
            }
        }
        this.setIndex(_),
        this.setAttribute("position", new Float32BufferAttribute(b,3)),
        this.setAttribute("normal", new Float32BufferAttribute(j,3)),
        this.setAttribute("uv", new Float32BufferAttribute($,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new RingGeometry(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class ShapeGeometry extends BufferGeometry {
    constructor(e=new Shape([new Vector2(0,.5), new Vector2(-.5,-.5), new Vector2(.5,-.5)]), a=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: a
        };
        const o = []
          , c = []
          , d = []
          , g = [];
        let _ = 0
          , b = 0;
        if (Array.isArray(e) === !1)
            j(e);
        else
            for (let $ = 0; $ < e.length; $++)
                j(e[$]),
                this.addGroup(_, b, $),
                _ += b,
                b = 0;
        this.setIndex(o),
        this.setAttribute("position", new Float32BufferAttribute(c,3)),
        this.setAttribute("normal", new Float32BufferAttribute(d,3)),
        this.setAttribute("uv", new Float32BufferAttribute(g,2));
        function j($) {
            const nt = c.length / 3
              , tt = $.extractPoints(a);
            let rt = tt.shape;
            const st = tt.holes;
            ShapeUtils.isClockWise(rt) === !1 && (rt = rt.reverse());
            for (let ct = 0, it = st.length; ct < it; ct++) {
                const ot = st[ct];
                ShapeUtils.isClockWise(ot) === !0 && (st[ct] = ot.reverse())
            }
            const lt = ShapeUtils.triangulateShape(rt, st);
            for (let ct = 0, it = st.length; ct < it; ct++) {
                const ot = st[ct];
                rt = rt.concat(ot)
            }
            for (let ct = 0, it = rt.length; ct < it; ct++) {
                const ot = rt[ct];
                c.push(ot.x, ot.y, 0),
                d.push(0, 0, 1),
                g.push(ot.x, ot.y)
            }
            for (let ct = 0, it = lt.length; ct < it; ct++) {
                const ot = lt[ct]
                  , at = ot[0] + nt
                  , ht = ot[1] + nt
                  , pt = ot[2] + nt;
                o.push(at, ht, pt),
                b += 3
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , a = this.parameters.shapes;
        return toJSON(a, e)
    }
    static fromJSON(e, a) {
        const o = [];
        for (let c = 0, d = e.shapes.length; c < d; c++) {
            const g = a[e.shapes[c]];
            o.push(g)
        }
        return new ShapeGeometry(o,e.curveSegments)
    }
}
function toJSON(s, e) {
    if (e.shapes = [],
    Array.isArray(s))
        for (let a = 0, o = s.length; a < o; a++) {
            const c = s[a];
            e.shapes.push(c.uuid)
        }
    else
        e.shapes.push(s.uuid);
    return e
}
class SphereGeometry extends BufferGeometry {
    constructor(e=1, a=32, o=16, c=0, d=Math.PI * 2, g=0, _=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: a,
            heightSegments: o,
            phiStart: c,
            phiLength: d,
            thetaStart: g,
            thetaLength: _
        },
        a = Math.max(3, Math.floor(a)),
        o = Math.max(2, Math.floor(o));
        const b = Math.min(g + _, Math.PI);
        let j = 0;
        const $ = []
          , nt = new Vector3
          , tt = new Vector3
          , rt = []
          , st = []
          , lt = []
          , ct = [];
        for (let it = 0; it <= o; it++) {
            const ot = []
              , at = it / o;
            let ht = 0;
            it === 0 && g === 0 ? ht = .5 / a : it === o && b === Math.PI && (ht = -.5 / a);
            for (let pt = 0; pt <= a; pt++) {
                const dt = pt / a;
                nt.x = -e * Math.cos(c + dt * d) * Math.sin(g + at * _),
                nt.y = e * Math.cos(g + at * _),
                nt.z = e * Math.sin(c + dt * d) * Math.sin(g + at * _),
                st.push(nt.x, nt.y, nt.z),
                tt.copy(nt).normalize(),
                lt.push(tt.x, tt.y, tt.z),
                ct.push(dt + ht, 1 - at),
                ot.push(j++)
            }
            $.push(ot)
        }
        for (let it = 0; it < o; it++)
            for (let ot = 0; ot < a; ot++) {
                const at = $[it][ot + 1]
                  , ht = $[it][ot]
                  , pt = $[it + 1][ot]
                  , dt = $[it + 1][ot + 1];
                (it !== 0 || g > 0) && rt.push(at, ht, dt),
                (it !== o - 1 || b < Math.PI) && rt.push(ht, pt, dt)
            }
        this.setIndex(rt),
        this.setAttribute("position", new Float32BufferAttribute(st,3)),
        this.setAttribute("normal", new Float32BufferAttribute(lt,3)),
        this.setAttribute("uv", new Float32BufferAttribute(ct,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new SphereGeometry(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class TetrahedronGeometry extends PolyhedronGeometry {
    constructor(e=1, a=0) {
        const o = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , c = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(o, c, e, a),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: a
        }
    }
    static fromJSON(e) {
        return new TetrahedronGeometry(e.radius,e.detail)
    }
}
class TorusGeometry extends BufferGeometry {
    constructor(e=1, a=.4, o=12, c=48, d=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: a,
            radialSegments: o,
            tubularSegments: c,
            arc: d
        },
        o = Math.floor(o),
        c = Math.floor(c);
        const g = []
          , _ = []
          , b = []
          , j = []
          , $ = new Vector3
          , nt = new Vector3
          , tt = new Vector3;
        for (let rt = 0; rt <= o; rt++)
            for (let st = 0; st <= c; st++) {
                const lt = st / c * d
                  , ct = rt / o * Math.PI * 2;
                nt.x = (e + a * Math.cos(ct)) * Math.cos(lt),
                nt.y = (e + a * Math.cos(ct)) * Math.sin(lt),
                nt.z = a * Math.sin(ct),
                _.push(nt.x, nt.y, nt.z),
                $.x = e * Math.cos(lt),
                $.y = e * Math.sin(lt),
                tt.subVectors(nt, $).normalize(),
                b.push(tt.x, tt.y, tt.z),
                j.push(st / c),
                j.push(rt / o)
            }
        for (let rt = 1; rt <= o; rt++)
            for (let st = 1; st <= c; st++) {
                const lt = (c + 1) * rt + st - 1
                  , ct = (c + 1) * (rt - 1) + st - 1
                  , it = (c + 1) * (rt - 1) + st
                  , ot = (c + 1) * rt + st;
                g.push(lt, ct, ot),
                g.push(ct, it, ot)
            }
        this.setIndex(g),
        this.setAttribute("position", new Float32BufferAttribute(_,3)),
        this.setAttribute("normal", new Float32BufferAttribute(b,3)),
        this.setAttribute("uv", new Float32BufferAttribute(j,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new TorusGeometry(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class TorusKnotGeometry extends BufferGeometry {
    constructor(e=1, a=.4, o=64, c=8, d=2, g=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: a,
            tubularSegments: o,
            radialSegments: c,
            p: d,
            q: g
        },
        o = Math.floor(o),
        c = Math.floor(c);
        const _ = []
          , b = []
          , j = []
          , $ = []
          , nt = new Vector3
          , tt = new Vector3
          , rt = new Vector3
          , st = new Vector3
          , lt = new Vector3
          , ct = new Vector3
          , it = new Vector3;
        for (let at = 0; at <= o; ++at) {
            const ht = at / o * d * Math.PI * 2;
            ot(ht, d, g, e, rt),
            ot(ht + .01, d, g, e, st),
            ct.subVectors(st, rt),
            it.addVectors(st, rt),
            lt.crossVectors(ct, it),
            it.crossVectors(lt, ct),
            lt.normalize(),
            it.normalize();
            for (let pt = 0; pt <= c; ++pt) {
                const dt = pt / c * Math.PI * 2
                  , yt = -a * Math.cos(dt)
                  , vt = a * Math.sin(dt);
                nt.x = rt.x + (yt * it.x + vt * lt.x),
                nt.y = rt.y + (yt * it.y + vt * lt.y),
                nt.z = rt.z + (yt * it.z + vt * lt.z),
                b.push(nt.x, nt.y, nt.z),
                tt.subVectors(nt, rt).normalize(),
                j.push(tt.x, tt.y, tt.z),
                $.push(at / o),
                $.push(pt / c)
            }
        }
        for (let at = 1; at <= o; at++)
            for (let ht = 1; ht <= c; ht++) {
                const pt = (c + 1) * (at - 1) + (ht - 1)
                  , dt = (c + 1) * at + (ht - 1)
                  , yt = (c + 1) * at + ht
                  , vt = (c + 1) * (at - 1) + ht;
                _.push(pt, dt, vt),
                _.push(dt, yt, vt)
            }
        this.setIndex(_),
        this.setAttribute("position", new Float32BufferAttribute(b,3)),
        this.setAttribute("normal", new Float32BufferAttribute(j,3)),
        this.setAttribute("uv", new Float32BufferAttribute($,2));
        function ot(at, ht, pt, dt, yt) {
            const vt = Math.cos(at)
              , xt = Math.sin(at)
              , _t = pt / ht * at
              , bt = Math.cos(_t);
            yt.x = dt * (2 + bt) * .5 * vt,
            yt.y = dt * (2 + bt) * xt * .5,
            yt.z = dt * Math.sin(_t) * .5
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new TorusKnotGeometry(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class TubeGeometry extends BufferGeometry {
    constructor(e=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)), a=64, o=1, c=8, d=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: a,
            radius: o,
            radialSegments: c,
            closed: d
        };
        const g = e.computeFrenetFrames(a, d);
        this.tangents = g.tangents,
        this.normals = g.normals,
        this.binormals = g.binormals;
        const _ = new Vector3
          , b = new Vector3
          , j = new Vector2;
        let $ = new Vector3;
        const nt = []
          , tt = []
          , rt = []
          , st = [];
        lt(),
        this.setIndex(st),
        this.setAttribute("position", new Float32BufferAttribute(nt,3)),
        this.setAttribute("normal", new Float32BufferAttribute(tt,3)),
        this.setAttribute("uv", new Float32BufferAttribute(rt,2));
        function lt() {
            for (let at = 0; at < a; at++)
                ct(at);
            ct(d === !1 ? a : 0),
            ot(),
            it()
        }
        function ct(at) {
            $ = e.getPointAt(at / a, $);
            const ht = g.normals[at]
              , pt = g.binormals[at];
            for (let dt = 0; dt <= c; dt++) {
                const yt = dt / c * Math.PI * 2
                  , vt = Math.sin(yt)
                  , xt = -Math.cos(yt);
                b.x = xt * ht.x + vt * pt.x,
                b.y = xt * ht.y + vt * pt.y,
                b.z = xt * ht.z + vt * pt.z,
                b.normalize(),
                tt.push(b.x, b.y, b.z),
                _.x = $.x + o * b.x,
                _.y = $.y + o * b.y,
                _.z = $.z + o * b.z,
                nt.push(_.x, _.y, _.z)
            }
        }
        function it() {
            for (let at = 1; at <= a; at++)
                for (let ht = 1; ht <= c; ht++) {
                    const pt = (c + 1) * (at - 1) + (ht - 1)
                      , dt = (c + 1) * at + (ht - 1)
                      , yt = (c + 1) * at + ht
                      , vt = (c + 1) * (at - 1) + ht;
                    st.push(pt, dt, vt),
                    st.push(dt, yt, vt)
                }
        }
        function ot() {
            for (let at = 0; at <= a; at++)
                for (let ht = 0; ht <= c; ht++)
                    j.x = at / a,
                    j.y = ht / c,
                    rt.push(j.x, j.y)
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new TubeGeometry(new Curves[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class WireframeGeometry extends BufferGeometry {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const a = []
              , o = new Set
              , c = new Vector3
              , d = new Vector3;
            if (e.index !== null) {
                const g = e.attributes.position
                  , _ = e.index;
                let b = e.groups;
                b.length === 0 && (b = [{
                    start: 0,
                    count: _.count,
                    materialIndex: 0
                }]);
                for (let j = 0, $ = b.length; j < $; ++j) {
                    const nt = b[j]
                      , tt = nt.start
                      , rt = nt.count;
                    for (let st = tt, lt = tt + rt; st < lt; st += 3)
                        for (let ct = 0; ct < 3; ct++) {
                            const it = _.getX(st + ct)
                              , ot = _.getX(st + (ct + 1) % 3);
                            c.fromBufferAttribute(g, it),
                            d.fromBufferAttribute(g, ot),
                            isUniqueEdge(c, d, o) === !0 && (a.push(c.x, c.y, c.z),
                            a.push(d.x, d.y, d.z))
                        }
                }
            } else {
                const g = e.attributes.position;
                for (let _ = 0, b = g.count / 3; _ < b; _++)
                    for (let j = 0; j < 3; j++) {
                        const $ = 3 * _ + j
                          , nt = 3 * _ + (j + 1) % 3;
                        c.fromBufferAttribute(g, $),
                        d.fromBufferAttribute(g, nt),
                        isUniqueEdge(c, d, o) === !0 && (a.push(c.x, c.y, c.z),
                        a.push(d.x, d.y, d.z))
                    }
            }
            this.setAttribute("position", new Float32BufferAttribute(a,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
function isUniqueEdge(s, e, a) {
    const o = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`
      , c = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
    return a.has(o) === !0 || a.has(c) === !0 ? !1 : (a.add(o),
    a.add(c),
    !0)
}
var Geometries = Object.freeze({
    __proto__: null,
    BoxGeometry,
    CapsuleGeometry,
    CircleGeometry,
    ConeGeometry,
    CylinderGeometry,
    DodecahedronGeometry,
    EdgesGeometry,
    ExtrudeGeometry,
    IcosahedronGeometry,
    LatheGeometry,
    OctahedronGeometry,
    PlaneGeometry,
    PolyhedronGeometry,
    RingGeometry,
    ShapeGeometry,
    SphereGeometry,
    TetrahedronGeometry,
    TorusGeometry,
    TorusKnotGeometry,
    TubeGeometry,
    WireframeGeometry
});
class ShadowMaterial extends Material {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new Color(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class RawShaderMaterial extends ShaderMaterial {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class MeshStandardMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Color(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Euler,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Vector2(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(a) {
                this.ior = (1 + .4 * a) / (1 - .4 * a)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Color(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Color(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Color(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.dispersion = e.dispersion,
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class MeshPhongMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Color(16777215),
        this.specular = new Color(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Euler,
        this.combine = MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class MeshToonMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class MeshNormalMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class MeshLambertMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Euler,
        this.combine = MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class MeshMatcapMaterial extends Material {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Color(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class LineDashedMaterial extends LineBasicMaterial {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function convertArray(s, e, a) {
    return !s || !a && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s)
}
function isTypedArray(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView)
}
function getKeyframeOrder(s) {
    function e(c, d) {
        return s[c] - s[d]
    }
    const a = s.length
      , o = new Array(a);
    for (let c = 0; c !== a; ++c)
        o[c] = c;
    return o.sort(e),
    o
}
function sortedArray(s, e, a) {
    const o = s.length
      , c = new s.constructor(o);
    for (let d = 0, g = 0; g !== o; ++d) {
        const _ = a[d] * e;
        for (let b = 0; b !== e; ++b)
            c[g++] = s[_ + b]
    }
    return c
}
function flattenJSON(s, e, a, o) {
    let c = 1
      , d = s[0];
    for (; d !== void 0 && d[o] === void 0; )
        d = s[c++];
    if (d === void 0)
        return;
    let g = d[o];
    if (g !== void 0)
        if (Array.isArray(g))
            do
                g = d[o],
                g !== void 0 && (e.push(d.time),
                a.push.apply(a, g)),
                d = s[c++];
            while (d !== void 0);
        else if (g.toArray !== void 0)
            do
                g = d[o],
                g !== void 0 && (e.push(d.time),
                g.toArray(a, a.length)),
                d = s[c++];
            while (d !== void 0);
        else
            do
                g = d[o],
                g !== void 0 && (e.push(d.time),
                a.push(g)),
                d = s[c++];
            while (d !== void 0)
}
function subclip(s, e, a, o, c=30) {
    const d = s.clone();
    d.name = e;
    const g = [];
    for (let b = 0; b < d.tracks.length; ++b) {
        const j = d.tracks[b]
          , $ = j.getValueSize()
          , nt = []
          , tt = [];
        for (let rt = 0; rt < j.times.length; ++rt) {
            const st = j.times[rt] * c;
            if (!(st < a || st >= o)) {
                nt.push(j.times[rt]);
                for (let lt = 0; lt < $; ++lt)
                    tt.push(j.values[rt * $ + lt])
            }
        }
        nt.length !== 0 && (j.times = convertArray(nt, j.times.constructor),
        j.values = convertArray(tt, j.values.constructor),
        g.push(j))
    }
    d.tracks = g;
    let _ = 1 / 0;
    for (let b = 0; b < d.tracks.length; ++b)
        _ > d.tracks[b].times[0] && (_ = d.tracks[b].times[0]);
    for (let b = 0; b < d.tracks.length; ++b)
        d.tracks[b].shift(-1 * _);
    return d.resetDuration(),
    d
}
function makeClipAdditive(s, e=0, a=s, o=30) {
    o <= 0 && (o = 30);
    const c = a.tracks.length
      , d = e / o;
    for (let g = 0; g < c; ++g) {
        const _ = a.tracks[g]
          , b = _.ValueTypeName;
        if (b === "bool" || b === "string")
            continue;
        const j = s.tracks.find(function(it) {
            return it.name === _.name && it.ValueTypeName === b
        });
        if (j === void 0)
            continue;
        let $ = 0;
        const nt = _.getValueSize();
        _.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && ($ = nt / 3);
        let tt = 0;
        const rt = j.getValueSize();
        j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (tt = rt / 3);
        const st = _.times.length - 1;
        let lt;
        if (d <= _.times[0]) {
            const it = $
              , ot = nt - $;
            lt = _.values.slice(it, ot)
        } else if (d >= _.times[st]) {
            const it = st * nt + $
              , ot = it + nt - $;
            lt = _.values.slice(it, ot)
        } else {
            const it = _.createInterpolant()
              , ot = $
              , at = nt - $;
            it.evaluate(d),
            lt = it.resultBuffer.slice(ot, at)
        }
        b === "quaternion" && new Quaternion().fromArray(lt).normalize().conjugate().toArray(lt);
        const ct = j.times.length;
        for (let it = 0; it < ct; ++it) {
            const ot = it * rt + tt;
            if (b === "quaternion")
                Quaternion.multiplyQuaternionsFlat(j.values, ot, lt, 0, j.values, ot);
            else {
                const at = rt - tt * 2;
                for (let ht = 0; ht < at; ++ht)
                    j.values[ot + ht] -= lt[ht]
            }
        }
    }
    return s.blendMode = AdditiveAnimationBlendMode,
    s
}
const AnimationUtils = {
    convertArray,
    isTypedArray,
    getKeyframeOrder,
    sortedArray,
    flattenJSON,
    subclip,
    makeClipAdditive
};
class Interpolant {
    constructor(e, a, o, c) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = c !== void 0 ? c : new a.constructor(o),
        this.sampleValues = a,
        this.valueSize = o,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const a = this.parameterPositions;
        let o = this._cachedIndex
          , c = a[o]
          , d = a[o - 1];
        e: {
            t: {
                let g;
                n: {
                    i: if (!(e < c)) {
                        for (let _ = o + 2; ; ) {
                            if (c === void 0) {
                                if (e < d)
                                    break i;
                                return o = a.length,
                                this._cachedIndex = o,
                                this.copySampleValue_(o - 1)
                            }
                            if (o === _)
                                break;
                            if (d = c,
                            c = a[++o],
                            e < c)
                                break t
                        }
                        g = a.length;
                        break n
                    }
                    if (!(e >= d)) {
                        const _ = a[1];
                        e < _ && (o = 2,
                        d = _);
                        for (let b = o - 2; ; ) {
                            if (d === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (o === b)
                                break;
                            if (c = d,
                            d = a[--o - 1],
                            e >= d)
                                break t
                        }
                        g = o,
                        o = 0;
                        break n
                    }
                    break e
                }
                for (; o < g; ) {
                    const _ = o + g >>> 1;
                    e < a[_] ? g = _ : o = _ + 1
                }
                if (c = a[o],
                d = a[o - 1],
                d === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (c === void 0)
                    return o = a.length,
                    this._cachedIndex = o,
                    this.copySampleValue_(o - 1)
            }
            this._cachedIndex = o,
            this.intervalChanged_(o, d, c)
        }
        return this.interpolate_(o, d, e, c)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const a = this.resultBuffer
          , o = this.sampleValues
          , c = this.valueSize
          , d = e * c;
        for (let g = 0; g !== c; ++g)
            a[g] = o[d + g];
        return a
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
    constructor(e, a, o, c) {
        super(e, a, o, c),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        }
    }
    intervalChanged_(e, a, o) {
        const c = this.parameterPositions;
        let d = e - 2
          , g = e + 1
          , _ = c[d]
          , b = c[g];
        if (_ === void 0)
            switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
                d = e,
                _ = 2 * a - o;
                break;
            case WrapAroundEnding:
                d = c.length - 2,
                _ = a + c[d] - c[d + 1];
                break;
            default:
                d = e,
                _ = o
            }
        if (b === void 0)
            switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
                g = e,
                b = 2 * o - a;
                break;
            case WrapAroundEnding:
                g = 1,
                b = o + c[1] - c[0];
                break;
            default:
                g = e - 1,
                b = a
            }
        const j = (o - a) * .5
          , $ = this.valueSize;
        this._weightPrev = j / (a - _),
        this._weightNext = j / (b - o),
        this._offsetPrev = d * $,
        this._offsetNext = g * $
    }
    interpolate_(e, a, o, c) {
        const d = this.resultBuffer
          , g = this.sampleValues
          , _ = this.valueSize
          , b = e * _
          , j = b - _
          , $ = this._offsetPrev
          , nt = this._offsetNext
          , tt = this._weightPrev
          , rt = this._weightNext
          , st = (o - a) / (c - a)
          , lt = st * st
          , ct = lt * st
          , it = -tt * ct + 2 * tt * lt - tt * st
          , ot = (1 + tt) * ct + (-1.5 - 2 * tt) * lt + (-.5 + tt) * st + 1
          , at = (-1 - rt) * ct + (1.5 + rt) * lt + .5 * st
          , ht = rt * ct - rt * lt;
        for (let pt = 0; pt !== _; ++pt)
            d[pt] = it * g[$ + pt] + ot * g[j + pt] + at * g[b + pt] + ht * g[nt + pt];
        return d
    }
}
class LinearInterpolant extends Interpolant {
    constructor(e, a, o, c) {
        super(e, a, o, c)
    }
    interpolate_(e, a, o, c) {
        const d = this.resultBuffer
          , g = this.sampleValues
          , _ = this.valueSize
          , b = e * _
          , j = b - _
          , $ = (o - a) / (c - a)
          , nt = 1 - $;
        for (let tt = 0; tt !== _; ++tt)
            d[tt] = g[j + tt] * nt + g[b + tt] * $;
        return d
    }
}
class DiscreteInterpolant extends Interpolant {
    constructor(e, a, o, c) {
        super(e, a, o, c)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class KeyframeTrack {
    constructor(e, a, o, c) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (a === void 0 || a.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = convertArray(a, this.TimeBufferType),
        this.values = convertArray(o, this.ValueBufferType),
        this.setInterpolation(c || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const a = e.constructor;
        let o;
        if (a.toJSON !== this.toJSON)
            o = a.toJSON(e);
        else {
            o = {
                name: e.name,
                times: convertArray(e.times, Array),
                values: convertArray(e.values, Array)
            };
            const c = e.getInterpolation();
            c !== e.DefaultInterpolation && (o.interpolation = c)
        }
        return o.type = e.ValueTypeName,
        o
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let a;
        switch (e) {
        case InterpolateDiscrete:
            a = this.InterpolantFactoryMethodDiscrete;
            break;
        case InterpolateLinear:
            a = this.InterpolantFactoryMethodLinear;
            break;
        case InterpolateSmooth:
            a = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (a === void 0) {
            const o = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(o);
            return console.warn("THREE.KeyframeTrack:", o),
            this
        }
        return this.createInterpolant = a,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const a = this.times;
            for (let o = 0, c = a.length; o !== c; ++o)
                a[o] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const a = this.times;
            for (let o = 0, c = a.length; o !== c; ++o)
                a[o] *= e
        }
        return this
    }
    trim(e, a) {
        const o = this.times
          , c = o.length;
        let d = 0
          , g = c - 1;
        for (; d !== c && o[d] < e; )
            ++d;
        for (; g !== -1 && o[g] > a; )
            --g;
        if (++g,
        d !== 0 || g !== c) {
            d >= g && (g = Math.max(g, 1),
            d = g - 1);
            const _ = this.getValueSize();
            this.times = o.slice(d, g),
            this.values = this.values.slice(d * _, g * _)
        }
        return this
    }
    validate() {
        let e = !0;
        const a = this.getValueSize();
        a - Math.floor(a) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const o = this.times
          , c = this.values
          , d = o.length;
        d === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let g = null;
        for (let _ = 0; _ !== d; _++) {
            const b = o[_];
            if (typeof b == "number" && isNaN(b)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, _, b),
                e = !1;
                break
            }
            if (g !== null && g > b) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, _, b, g),
                e = !1;
                break
            }
            g = b
        }
        if (c !== void 0 && isTypedArray(c))
            for (let _ = 0, b = c.length; _ !== b; ++_) {
                const j = c[_];
                if (isNaN(j)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, _, j),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , a = this.values.slice()
          , o = this.getValueSize()
          , c = this.getInterpolation() === InterpolateSmooth
          , d = e.length - 1;
        let g = 1;
        for (let _ = 1; _ < d; ++_) {
            let b = !1;
            const j = e[_]
              , $ = e[_ + 1];
            if (j !== $ && (_ !== 1 || j !== e[0]))
                if (c)
                    b = !0;
                else {
                    const nt = _ * o
                      , tt = nt - o
                      , rt = nt + o;
                    for (let st = 0; st !== o; ++st) {
                        const lt = a[nt + st];
                        if (lt !== a[tt + st] || lt !== a[rt + st]) {
                            b = !0;
                            break
                        }
                    }
                }
            if (b) {
                if (_ !== g) {
                    e[g] = e[_];
                    const nt = _ * o
                      , tt = g * o;
                    for (let rt = 0; rt !== o; ++rt)
                        a[tt + rt] = a[nt + rt]
                }
                ++g
            }
        }
        if (d > 0) {
            e[g] = e[d];
            for (let _ = d * o, b = g * o, j = 0; j !== o; ++j)
                a[b + j] = a[_ + j];
            ++g
        }
        return g !== e.length ? (this.times = e.slice(0, g),
        this.values = a.slice(0, g * o)) : (this.times = e,
        this.values = a),
        this
    }
    clone() {
        const e = this.times.slice()
          , a = this.values.slice()
          , o = this.constructor
          , c = new o(this.name,e,a);
        return c.createInterpolant = this.createInterpolant,
        c
    }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
    constructor(e, a, o) {
        super(e, a, o)
    }
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
    constructor(e, a, o, c) {
        super(e, a, o, c)
    }
    interpolate_(e, a, o, c) {
        const d = this.resultBuffer
          , g = this.sampleValues
          , _ = this.valueSize
          , b = (o - a) / (c - a);
        let j = e * _;
        for (let $ = j + _; j !== $; j += 4)
            Quaternion.slerpFlat(d, 0, g, j - _, g, j, b);
        return d
    }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
    InterpolantFactoryMethodLinear(e) {
        return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)
    }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
    constructor(e, a, o) {
        super(e, a, o)
    }
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
    constructor(e="", a=-1, o=[], c=NormalAnimationBlendMode) {
        this.name = e,
        this.tracks = o,
        this.duration = a,
        this.blendMode = c,
        this.uuid = generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const a = []
          , o = e.tracks
          , c = 1 / (e.fps || 1);
        for (let g = 0, _ = o.length; g !== _; ++g)
            a.push(parseKeyframeTrack(o[g]).scale(c));
        const d = new this(e.name,e.duration,a,e.blendMode);
        return d.uuid = e.uuid,
        d
    }
    static toJSON(e) {
        const a = []
          , o = e.tracks
          , c = {
            name: e.name,
            duration: e.duration,
            tracks: a,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let d = 0, g = o.length; d !== g; ++d)
            a.push(KeyframeTrack.toJSON(o[d]));
        return c
    }
    static CreateFromMorphTargetSequence(e, a, o, c) {
        const d = a.length
          , g = [];
        for (let _ = 0; _ < d; _++) {
            let b = []
              , j = [];
            b.push((_ + d - 1) % d, _, (_ + 1) % d),
            j.push(0, 1, 0);
            const $ = getKeyframeOrder(b);
            b = sortedArray(b, 1, $),
            j = sortedArray(j, 1, $),
            !c && b[0] === 0 && (b.push(d),
            j.push(j[0])),
            g.push(new NumberKeyframeTrack(".morphTargetInfluences[" + a[_].name + "]",b,j).scale(1 / o))
        }
        return new this(e,-1,g)
    }
    static findByName(e, a) {
        let o = e;
        if (!Array.isArray(e)) {
            const c = e;
            o = c.geometry && c.geometry.animations || c.animations
        }
        for (let c = 0; c < o.length; c++)
            if (o[c].name === a)
                return o[c];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, a, o) {
        const c = {}
          , d = /^([\w-]*?)([\d]+)$/;
        for (let _ = 0, b = e.length; _ < b; _++) {
            const j = e[_]
              , $ = j.name.match(d);
            if ($ && $.length > 1) {
                const nt = $[1];
                let tt = c[nt];
                tt || (c[nt] = tt = []),
                tt.push(j)
            }
        }
        const g = [];
        for (const _ in c)
            g.push(this.CreateFromMorphTargetSequence(_, c[_], a, o));
        return g
    }
    static parseAnimation(e, a) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const o = function(nt, tt, rt, st, lt) {
            if (rt.length !== 0) {
                const ct = []
                  , it = [];
                flattenJSON(rt, ct, it, st),
                ct.length !== 0 && lt.push(new nt(tt,ct,it))
            }
        }
          , c = []
          , d = e.name || "default"
          , g = e.fps || 30
          , _ = e.blendMode;
        let b = e.length || -1;
        const j = e.hierarchy || [];
        for (let nt = 0; nt < j.length; nt++) {
            const tt = j[nt].keys;
            if (!(!tt || tt.length === 0))
                if (tt[0].morphTargets) {
                    const rt = {};
                    let st;
                    for (st = 0; st < tt.length; st++)
                        if (tt[st].morphTargets)
                            for (let lt = 0; lt < tt[st].morphTargets.length; lt++)
                                rt[tt[st].morphTargets[lt]] = -1;
                    for (const lt in rt) {
                        const ct = []
                          , it = [];
                        for (let ot = 0; ot !== tt[st].morphTargets.length; ++ot) {
                            const at = tt[st];
                            ct.push(at.time),
                            it.push(at.morphTarget === lt ? 1 : 0)
                        }
                        c.push(new NumberKeyframeTrack(".morphTargetInfluence[" + lt + "]",ct,it))
                    }
                    b = rt.length * g
                } else {
                    const rt = ".bones[" + a[nt].name + "]";
                    o(VectorKeyframeTrack, rt + ".position", tt, "pos", c),
                    o(QuaternionKeyframeTrack, rt + ".quaternion", tt, "rot", c),
                    o(VectorKeyframeTrack, rt + ".scale", tt, "scl", c)
                }
        }
        return c.length === 0 ? null : new this(d,b,c,_)
    }
    resetDuration() {
        const e = this.tracks;
        let a = 0;
        for (let o = 0, c = e.length; o !== c; ++o) {
            const d = this.tracks[o];
            a = Math.max(a, d.times[d.times.length - 1])
        }
        return this.duration = a,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let a = 0; a < this.tracks.length; a++)
            e = e && this.tracks[a].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let a = 0; a < this.tracks.length; a++)
            e.push(this.tracks[a].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function getTrackTypeForValueTypeName(s) {
    switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return VectorKeyframeTrack;
    case "color":
        return ColorKeyframeTrack;
    case "quaternion":
        return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
        return BooleanKeyframeTrack;
    case "string":
        return StringKeyframeTrack
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s)
}
function parseKeyframeTrack(s) {
    if (s.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = getTrackTypeForValueTypeName(s.type);
    if (s.times === void 0) {
        const a = []
          , o = [];
        flattenJSON(s.keys, a, o, "value"),
        s.times = a,
        s.values = o
    }
    return e.parse !== void 0 ? e.parse(s) : new e(s.name,s.times,s.values,s.interpolation)
}
const Cache = {
    enabled: !1,
    files: {},
    add: function(s, e) {
        this.enabled !== !1 && (this.files[s] = e)
    },
    get: function(s) {
        if (this.enabled !== !1)
            return this.files[s]
    },
    remove: function(s) {
        delete this.files[s]
    },
    clear: function() {
        this.files = {}
    }
};
class LoadingManager {
    constructor(e, a, o) {
        const c = this;
        let d = !1, g = 0, _ = 0, b;
        const j = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = a,
        this.onError = o,
        this.itemStart = function($) {
            _++,
            d === !1 && c.onStart !== void 0 && c.onStart($, g, _),
            d = !0
        }
        ,
        this.itemEnd = function($) {
            g++,
            c.onProgress !== void 0 && c.onProgress($, g, _),
            g === _ && (d = !1,
            c.onLoad !== void 0 && c.onLoad())
        }
        ,
        this.itemError = function($) {
            c.onError !== void 0 && c.onError($)
        }
        ,
        this.resolveURL = function($) {
            return b ? b($) : $
        }
        ,
        this.setURLModifier = function($) {
            return b = $,
            this
        }
        ,
        this.addHandler = function($, nt) {
            return j.push($, nt),
            this
        }
        ,
        this.removeHandler = function($) {
            const nt = j.indexOf($);
            return nt !== -1 && j.splice(nt, 2),
            this
        }
        ,
        this.getHandler = function($) {
            for (let nt = 0, tt = j.length; nt < tt; nt += 2) {
                const rt = j[nt]
                  , st = j[nt + 1];
                if (rt.global && (rt.lastIndex = 0),
                rt.test($))
                    return st
            }
            return null
        }
    }
}
const DefaultLoadingManager = new LoadingManager;
let Loader$1 = class {
    constructor(e) {
        this.manager = e !== void 0 ? e : DefaultLoadingManager,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, a) {
        const o = this;
        return new Promise(function(c, d) {
            o.load(e, c, a, d)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
;
Loader$1.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
    constructor(e, a) {
        super(e),
        this.response = a
    }
}
class FileLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const d = Cache.get(e);
        if (d !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                a && a(d),
                this.manager.itemEnd(e)
            }
            , 0),
            d;
        if (loading[e] !== void 0) {
            loading[e].push({
                onLoad: a,
                onProgress: o,
                onError: c
            });
            return
        }
        loading[e] = [],
        loading[e].push({
            onLoad: a,
            onProgress: o,
            onError: c
        });
        const g = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , _ = this.mimeType
          , b = this.responseType;
        fetch(g).then(j => {
            if (j.status === 200 || j.status === 0) {
                if (j.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || j.body === void 0 || j.body.getReader === void 0)
                    return j;
                const $ = loading[e]
                  , nt = j.body.getReader()
                  , tt = j.headers.get("X-File-Size") || j.headers.get("Content-Length")
                  , rt = tt ? parseInt(tt) : 0
                  , st = rt !== 0;
                let lt = 0;
                const ct = new ReadableStream({
                    start(it) {
                        ot();
                        function ot() {
                            nt.read().then( ({done: at, value: ht}) => {
                                if (at)
                                    it.close();
                                else {
                                    lt += ht.byteLength;
                                    const pt = new ProgressEvent("progress",{
                                        lengthComputable: st,
                                        loaded: lt,
                                        total: rt
                                    });
                                    for (let dt = 0, yt = $.length; dt < yt; dt++) {
                                        const vt = $[dt];
                                        vt.onProgress && vt.onProgress(pt)
                                    }
                                    it.enqueue(ht),
                                    ot()
                                }
                            }
                            , at => {
                                it.error(at)
                            }
                            )
                        }
                    }
                });
                return new Response(ct)
            } else
                throw new HttpError(`fetch for "${j.url}" responded with ${j.status}: ${j.statusText}`,j)
        }
        ).then(j => {
            switch (b) {
            case "arraybuffer":
                return j.arrayBuffer();
            case "blob":
                return j.blob();
            case "document":
                return j.text().then($ => new DOMParser().parseFromString($, _));
            case "json":
                return j.json();
            default:
                if (_ === void 0)
                    return j.text();
                {
                    const nt = /charset="?([^;"\s]*)"?/i.exec(_)
                      , tt = nt && nt[1] ? nt[1].toLowerCase() : void 0
                      , rt = new TextDecoder(tt);
                    return j.arrayBuffer().then(st => rt.decode(st))
                }
            }
        }
        ).then(j => {
            Cache.add(e, j);
            const $ = loading[e];
            delete loading[e];
            for (let nt = 0, tt = $.length; nt < tt; nt++) {
                const rt = $[nt];
                rt.onLoad && rt.onLoad(j)
            }
        }
        ).catch(j => {
            const $ = loading[e];
            if ($ === void 0)
                throw this.manager.itemError(e),
                j;
            delete loading[e];
            for (let nt = 0, tt = $.length; nt < tt; nt++) {
                const rt = $[nt];
                rt.onError && rt.onError(j)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class AnimationLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = this
          , g = new FileLoader(this.manager);
        g.setPath(this.path),
        g.setRequestHeader(this.requestHeader),
        g.setWithCredentials(this.withCredentials),
        g.load(e, function(_) {
            try {
                a(d.parse(JSON.parse(_)))
            } catch (b) {
                c ? c(b) : console.error(b),
                d.manager.itemError(e)
            }
        }, o, c)
    }
    parse(e) {
        const a = [];
        for (let o = 0; o < e.length; o++) {
            const c = AnimationClip.parse(e[o]);
            a.push(c)
        }
        return a
    }
}
class CompressedTextureLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = this
          , g = []
          , _ = new CompressedTexture
          , b = new FileLoader(this.manager);
        b.setPath(this.path),
        b.setResponseType("arraybuffer"),
        b.setRequestHeader(this.requestHeader),
        b.setWithCredentials(d.withCredentials);
        let j = 0;
        function $(nt) {
            b.load(e[nt], function(tt) {
                const rt = d.parse(tt, !0);
                g[nt] = {
                    width: rt.width,
                    height: rt.height,
                    format: rt.format,
                    mipmaps: rt.mipmaps
                },
                j += 1,
                j === 6 && (rt.mipmapCount === 1 && (_.minFilter = LinearFilter),
                _.image = g,
                _.format = rt.format,
                _.needsUpdate = !0,
                a && a(_))
            }, o, c)
        }
        if (Array.isArray(e))
            for (let nt = 0, tt = e.length; nt < tt; ++nt)
                $(nt);
        else
            b.load(e, function(nt) {
                const tt = d.parse(nt, !0);
                if (tt.isCubemap) {
                    const rt = tt.mipmaps.length / tt.mipmapCount;
                    for (let st = 0; st < rt; st++) {
                        g[st] = {
                            mipmaps: []
                        };
                        for (let lt = 0; lt < tt.mipmapCount; lt++)
                            g[st].mipmaps.push(tt.mipmaps[st * tt.mipmapCount + lt]),
                            g[st].format = tt.format,
                            g[st].width = tt.width,
                            g[st].height = tt.height
                    }
                    _.image = g
                } else
                    _.image.width = tt.width,
                    _.image.height = tt.height,
                    _.mipmaps = tt.mipmaps;
                tt.mipmapCount === 1 && (_.minFilter = LinearFilter),
                _.format = tt.format,
                _.needsUpdate = !0,
                a && a(_)
            }, o, c);
        return _
    }
}
class ImageLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const d = this
          , g = Cache.get(e);
        if (g !== void 0)
            return d.manager.itemStart(e),
            setTimeout(function() {
                a && a(g),
                d.manager.itemEnd(e)
            }, 0),
            g;
        const _ = createElementNS("img");
        function b() {
            $(),
            Cache.add(e, this),
            a && a(this),
            d.manager.itemEnd(e)
        }
        function j(nt) {
            $(),
            c && c(nt),
            d.manager.itemError(e),
            d.manager.itemEnd(e)
        }
        function $() {
            _.removeEventListener("load", b, !1),
            _.removeEventListener("error", j, !1)
        }
        return _.addEventListener("load", b, !1),
        _.addEventListener("error", j, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (_.crossOrigin = this.crossOrigin),
        d.manager.itemStart(e),
        _.src = e,
        _
    }
}
class CubeTextureLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = new CubeTexture;
        d.colorSpace = SRGBColorSpace;
        const g = new ImageLoader(this.manager);
        g.setCrossOrigin(this.crossOrigin),
        g.setPath(this.path);
        let _ = 0;
        function b(j) {
            g.load(e[j], function($) {
                d.images[j] = $,
                _++,
                _ === 6 && (d.needsUpdate = !0,
                a && a(d))
            }, void 0, c)
        }
        for (let j = 0; j < e.length; ++j)
            b(j);
        return d
    }
}
class DataTextureLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = this
          , g = new DataTexture
          , _ = new FileLoader(this.manager);
        return _.setResponseType("arraybuffer"),
        _.setRequestHeader(this.requestHeader),
        _.setPath(this.path),
        _.setWithCredentials(d.withCredentials),
        _.load(e, function(b) {
            let j;
            try {
                j = d.parse(b)
            } catch ($) {
                if (c !== void 0)
                    c($);
                else {
                    console.error($);
                    return
                }
            }
            j.image !== void 0 ? g.image = j.image : j.data !== void 0 && (g.image.width = j.width,
            g.image.height = j.height,
            g.image.data = j.data),
            g.wrapS = j.wrapS !== void 0 ? j.wrapS : ClampToEdgeWrapping,
            g.wrapT = j.wrapT !== void 0 ? j.wrapT : ClampToEdgeWrapping,
            g.magFilter = j.magFilter !== void 0 ? j.magFilter : LinearFilter,
            g.minFilter = j.minFilter !== void 0 ? j.minFilter : LinearFilter,
            g.anisotropy = j.anisotropy !== void 0 ? j.anisotropy : 1,
            j.colorSpace !== void 0 && (g.colorSpace = j.colorSpace),
            j.flipY !== void 0 && (g.flipY = j.flipY),
            j.format !== void 0 && (g.format = j.format),
            j.type !== void 0 && (g.type = j.type),
            j.mipmaps !== void 0 && (g.mipmaps = j.mipmaps,
            g.minFilter = LinearMipmapLinearFilter),
            j.mipmapCount === 1 && (g.minFilter = LinearFilter),
            j.generateMipmaps !== void 0 && (g.generateMipmaps = j.generateMipmaps),
            g.needsUpdate = !0,
            a && a(g, j)
        }, o, c),
        g
    }
}
class TextureLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = new Texture
          , g = new ImageLoader(this.manager);
        return g.setCrossOrigin(this.crossOrigin),
        g.setPath(this.path),
        g.load(e, function(_) {
            d.image = _,
            d.needsUpdate = !0,
            a !== void 0 && a(d)
        }, o, c),
        d
    }
}
class Light extends Object3D {
    constructor(e, a=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Color(e),
        this.intensity = a
    }
    dispose() {}
    copy(e, a) {
        return super.copy(e, a),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return a.object.color = this.color.getHex(),
        a.object.intensity = this.intensity,
        this.groundColor !== void 0 && (a.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (a.object.distance = this.distance),
        this.angle !== void 0 && (a.object.angle = this.angle),
        this.decay !== void 0 && (a.object.decay = this.decay),
        this.penumbra !== void 0 && (a.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (a.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (a.object.target = this.target.uuid),
        a
    }
}
class HemisphereLight extends Light {
    constructor(e, a, o) {
        super(e, o),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(Object3D.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Color(a)
    }
    copy(e, a) {
        return super.copy(e, a),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const _projScreenMatrix$1 = new Matrix4
  , _lightPositionWorld$1 = new Vector3
  , _lookTarget$1 = new Vector3;
class LightShadow {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Vector2(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Matrix4,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Frustum,
        this._frameExtents = new Vector2(1,1),
        this._viewportCount = 1,
        this._viewports = [new Vector4(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const a = this.camera
          , o = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld),
        a.position.copy(_lightPositionWorld$1),
        _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld),
        a.lookAt(_lookTarget$1),
        a.updateMatrixWorld(),
        _projScreenMatrix$1.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),
        o.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        o.multiply(_projScreenMatrix$1)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class SpotLightShadow extends LightShadow {
    constructor() {
        super(new PerspectiveCamera(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const a = this.camera
          , o = RAD2DEG * 2 * e.angle * this.focus
          , c = this.mapSize.width / this.mapSize.height
          , d = e.distance || a.far;
        (o !== a.fov || c !== a.aspect || d !== a.far) && (a.fov = o,
        a.aspect = c,
        a.far = d,
        a.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class SpotLight extends Light {
    constructor(e, a, o=0, c=Math.PI / 3, d=0, g=2) {
        super(e, a),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(Object3D.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Object3D,
        this.distance = o,
        this.angle = c,
        this.penumbra = d,
        this.decay = g,
        this.map = null,
        this.shadow = new SpotLightShadow
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, a) {
        return super.copy(e, a),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const _projScreenMatrix = new Matrix4
  , _lightPositionWorld = new Vector3
  , _lookTarget = new Vector3;
class PointLightShadow extends LightShadow {
    constructor() {
        super(new PerspectiveCamera(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new Vector2(4,2),
        this._viewportCount = 6,
        this._viewports = [new Vector4(2,1,1,1), new Vector4(0,1,1,1), new Vector4(3,1,1,1), new Vector4(1,1,1,1), new Vector4(3,0,1,1), new Vector4(1,0,1,1)],
        this._cubeDirections = [new Vector3(1,0,0), new Vector3(-1,0,0), new Vector3(0,0,1), new Vector3(0,0,-1), new Vector3(0,1,0), new Vector3(0,-1,0)],
        this._cubeUps = [new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,0,1), new Vector3(0,0,-1)]
    }
    updateMatrices(e, a=0) {
        const o = this.camera
          , c = this.matrix
          , d = e.distance || o.far;
        d !== o.far && (o.far = d,
        o.updateProjectionMatrix()),
        _lightPositionWorld.setFromMatrixPosition(e.matrixWorld),
        o.position.copy(_lightPositionWorld),
        _lookTarget.copy(o.position),
        _lookTarget.add(this._cubeDirections[a]),
        o.up.copy(this._cubeUps[a]),
        o.lookAt(_lookTarget),
        o.updateMatrixWorld(),
        c.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z),
        _projScreenMatrix.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(_projScreenMatrix)
    }
}
class PointLight extends Light {
    constructor(e, a, o=0, c=2) {
        super(e, a),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = o,
        this.decay = c,
        this.shadow = new PointLightShadow
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, a) {
        return super.copy(e, a),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class DirectionalLightShadow extends LightShadow {
    constructor() {
        super(new OrthographicCamera(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class DirectionalLight extends Light {
    constructor(e, a) {
        super(e, a),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Object3D.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Object3D,
        this.shadow = new DirectionalLightShadow
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class AmbientLight extends Light {
    constructor(e, a) {
        super(e, a),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class RectAreaLight extends Light {
    constructor(e, a, o=10, c=10) {
        super(e, a),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = o,
        this.height = c
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return a.object.width = this.width,
        a.object.height = this.height,
        a
    }
}
class SphericalHarmonics3 {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new Vector3)
    }
    set(e) {
        for (let a = 0; a < 9; a++)
            this.coefficients[a].copy(e[a]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, a) {
        const o = e.x
          , c = e.y
          , d = e.z
          , g = this.coefficients;
        return a.copy(g[0]).multiplyScalar(.282095),
        a.addScaledVector(g[1], .488603 * c),
        a.addScaledVector(g[2], .488603 * d),
        a.addScaledVector(g[3], .488603 * o),
        a.addScaledVector(g[4], 1.092548 * (o * c)),
        a.addScaledVector(g[5], 1.092548 * (c * d)),
        a.addScaledVector(g[6], .315392 * (3 * d * d - 1)),
        a.addScaledVector(g[7], 1.092548 * (o * d)),
        a.addScaledVector(g[8], .546274 * (o * o - c * c)),
        a
    }
    getIrradianceAt(e, a) {
        const o = e.x
          , c = e.y
          , d = e.z
          , g = this.coefficients;
        return a.copy(g[0]).multiplyScalar(.886227),
        a.addScaledVector(g[1], 2 * .511664 * c),
        a.addScaledVector(g[2], 2 * .511664 * d),
        a.addScaledVector(g[3], 2 * .511664 * o),
        a.addScaledVector(g[4], 2 * .429043 * o * c),
        a.addScaledVector(g[5], 2 * .429043 * c * d),
        a.addScaledVector(g[6], .743125 * d * d - .247708),
        a.addScaledVector(g[7], 2 * .429043 * o * d),
        a.addScaledVector(g[8], .429043 * (o * o - c * c)),
        a
    }
    add(e) {
        for (let a = 0; a < 9; a++)
            this.coefficients[a].add(e.coefficients[a]);
        return this
    }
    addScaledSH(e, a) {
        for (let o = 0; o < 9; o++)
            this.coefficients[o].addScaledVector(e.coefficients[o], a);
        return this
    }
    scale(e) {
        for (let a = 0; a < 9; a++)
            this.coefficients[a].multiplyScalar(e);
        return this
    }
    lerp(e, a) {
        for (let o = 0; o < 9; o++)
            this.coefficients[o].lerp(e.coefficients[o], a);
        return this
    }
    equals(e) {
        for (let a = 0; a < 9; a++)
            if (!this.coefficients[a].equals(e.coefficients[a]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, a=0) {
        const o = this.coefficients;
        for (let c = 0; c < 9; c++)
            o[c].fromArray(e, a + c * 3);
        return this
    }
    toArray(e=[], a=0) {
        const o = this.coefficients;
        for (let c = 0; c < 9; c++)
            o[c].toArray(e, a + c * 3);
        return e
    }
    static getBasisAt(e, a) {
        const o = e.x
          , c = e.y
          , d = e.z;
        a[0] = .282095,
        a[1] = .488603 * c,
        a[2] = .488603 * d,
        a[3] = .488603 * o,
        a[4] = 1.092548 * o * c,
        a[5] = 1.092548 * c * d,
        a[6] = .315392 * (3 * d * d - 1),
        a[7] = 1.092548 * o * d,
        a[8] = .546274 * (o * o - c * c)
    }
}
class LightProbe extends Light {
    constructor(e=new SphericalHarmonics3, a=1) {
        super(void 0, a),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return a.object.sh = this.sh.toArray(),
        a
    }
}
class MaterialLoader extends Loader$1 {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, a, o, c) {
        const d = this
          , g = new FileLoader(d.manager);
        g.setPath(d.path),
        g.setRequestHeader(d.requestHeader),
        g.setWithCredentials(d.withCredentials),
        g.load(e, function(_) {
            try {
                a(d.parse(JSON.parse(_)))
            } catch (b) {
                c ? c(b) : console.error(b),
                d.manager.itemError(e)
            }
        }, o, c)
    }
    parse(e) {
        const a = this.textures;
        function o(d) {
            return a[d] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", d),
            a[d]
        }
        const c = MaterialLoader.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (c.uuid = e.uuid),
        e.name !== void 0 && (c.name = e.name),
        e.color !== void 0 && c.color !== void 0 && c.color.setHex(e.color),
        e.roughness !== void 0 && (c.roughness = e.roughness),
        e.metalness !== void 0 && (c.metalness = e.metalness),
        e.sheen !== void 0 && (c.sheen = e.sheen),
        e.sheenColor !== void 0 && (c.sheenColor = new Color().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (c.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && c.emissive !== void 0 && c.emissive.setHex(e.emissive),
        e.specular !== void 0 && c.specular !== void 0 && c.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (c.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && c.specularColor !== void 0 && c.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (c.shininess = e.shininess),
        e.clearcoat !== void 0 && (c.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (c.clearcoatRoughness = e.clearcoatRoughness),
        e.dispersion !== void 0 && (c.dispersion = e.dispersion),
        e.iridescence !== void 0 && (c.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (c.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (c.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (c.transmission = e.transmission),
        e.thickness !== void 0 && (c.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (c.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && c.attenuationColor !== void 0 && c.attenuationColor.setHex(e.attenuationColor),
        e.anisotropy !== void 0 && (c.anisotropy = e.anisotropy),
        e.anisotropyRotation !== void 0 && (c.anisotropyRotation = e.anisotropyRotation),
        e.fog !== void 0 && (c.fog = e.fog),
        e.flatShading !== void 0 && (c.flatShading = e.flatShading),
        e.blending !== void 0 && (c.blending = e.blending),
        e.combine !== void 0 && (c.combine = e.combine),
        e.side !== void 0 && (c.side = e.side),
        e.shadowSide !== void 0 && (c.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (c.opacity = e.opacity),
        e.transparent !== void 0 && (c.transparent = e.transparent),
        e.alphaTest !== void 0 && (c.alphaTest = e.alphaTest),
        e.alphaHash !== void 0 && (c.alphaHash = e.alphaHash),
        e.depthFunc !== void 0 && (c.depthFunc = e.depthFunc),
        e.depthTest !== void 0 && (c.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (c.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (c.colorWrite = e.colorWrite),
        e.blendSrc !== void 0 && (c.blendSrc = e.blendSrc),
        e.blendDst !== void 0 && (c.blendDst = e.blendDst),
        e.blendEquation !== void 0 && (c.blendEquation = e.blendEquation),
        e.blendSrcAlpha !== void 0 && (c.blendSrcAlpha = e.blendSrcAlpha),
        e.blendDstAlpha !== void 0 && (c.blendDstAlpha = e.blendDstAlpha),
        e.blendEquationAlpha !== void 0 && (c.blendEquationAlpha = e.blendEquationAlpha),
        e.blendColor !== void 0 && c.blendColor !== void 0 && c.blendColor.setHex(e.blendColor),
        e.blendAlpha !== void 0 && (c.blendAlpha = e.blendAlpha),
        e.stencilWriteMask !== void 0 && (c.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (c.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (c.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (c.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (c.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (c.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (c.stencilZPass = e.stencilZPass),
        e.stencilWrite !== void 0 && (c.stencilWrite = e.stencilWrite),
        e.wireframe !== void 0 && (c.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (c.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (c.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (c.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (c.rotation = e.rotation),
        e.linewidth !== void 0 && (c.linewidth = e.linewidth),
        e.dashSize !== void 0 && (c.dashSize = e.dashSize),
        e.gapSize !== void 0 && (c.gapSize = e.gapSize),
        e.scale !== void 0 && (c.scale = e.scale),
        e.polygonOffset !== void 0 && (c.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (c.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (c.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (c.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (c.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (c.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (c.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (c.visible = e.visible),
        e.toneMapped !== void 0 && (c.toneMapped = e.toneMapped),
        e.userData !== void 0 && (c.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? c.vertexColors = e.vertexColors > 0 : c.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const d in e.uniforms) {
                const g = e.uniforms[d];
                switch (c.uniforms[d] = {},
                g.type) {
                case "t":
                    c.uniforms[d].value = o(g.value);
                    break;
                case "c":
                    c.uniforms[d].value = new Color().setHex(g.value);
                    break;
                case "v2":
                    c.uniforms[d].value = new Vector2().fromArray(g.value);
                    break;
                case "v3":
                    c.uniforms[d].value = new Vector3().fromArray(g.value);
                    break;
                case "v4":
                    c.uniforms[d].value = new Vector4().fromArray(g.value);
                    break;
                case "m3":
                    c.uniforms[d].value = new Matrix3().fromArray(g.value);
                    break;
                case "m4":
                    c.uniforms[d].value = new Matrix4().fromArray(g.value);
                    break;
                default:
                    c.uniforms[d].value = g.value
                }
            }
        if (e.defines !== void 0 && (c.defines = e.defines),
        e.vertexShader !== void 0 && (c.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (c.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (c.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const d in e.extensions)
                c.extensions[d] = e.extensions[d];
        if (e.lights !== void 0 && (c.lights = e.lights),
        e.clipping !== void 0 && (c.clipping = e.clipping),
        e.size !== void 0 && (c.size = e.size),
        e.sizeAttenuation !== void 0 && (c.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (c.map = o(e.map)),
        e.matcap !== void 0 && (c.matcap = o(e.matcap)),
        e.alphaMap !== void 0 && (c.alphaMap = o(e.alphaMap)),
        e.bumpMap !== void 0 && (c.bumpMap = o(e.bumpMap)),
        e.bumpScale !== void 0 && (c.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (c.normalMap = o(e.normalMap)),
        e.normalMapType !== void 0 && (c.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let d = e.normalScale;
            Array.isArray(d) === !1 && (d = [d, d]),
            c.normalScale = new Vector2().fromArray(d)
        }
        return e.displacementMap !== void 0 && (c.displacementMap = o(e.displacementMap)),
        e.displacementScale !== void 0 && (c.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (c.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (c.roughnessMap = o(e.roughnessMap)),
        e.metalnessMap !== void 0 && (c.metalnessMap = o(e.metalnessMap)),
        e.emissiveMap !== void 0 && (c.emissiveMap = o(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (c.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (c.specularMap = o(e.specularMap)),
        e.specularIntensityMap !== void 0 && (c.specularIntensityMap = o(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (c.specularColorMap = o(e.specularColorMap)),
        e.envMap !== void 0 && (c.envMap = o(e.envMap)),
        e.envMapRotation !== void 0 && c.envMapRotation.fromArray(e.envMapRotation),
        e.envMapIntensity !== void 0 && (c.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (c.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (c.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (c.lightMap = o(e.lightMap)),
        e.lightMapIntensity !== void 0 && (c.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (c.aoMap = o(e.aoMap)),
        e.aoMapIntensity !== void 0 && (c.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (c.gradientMap = o(e.gradientMap)),
        e.clearcoatMap !== void 0 && (c.clearcoatMap = o(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (c.clearcoatRoughnessMap = o(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (c.clearcoatNormalMap = o(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (c.clearcoatNormalScale = new Vector2().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (c.iridescenceMap = o(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (c.iridescenceThicknessMap = o(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (c.transmissionMap = o(e.transmissionMap)),
        e.thicknessMap !== void 0 && (c.thicknessMap = o(e.thicknessMap)),
        e.anisotropyMap !== void 0 && (c.anisotropyMap = o(e.anisotropyMap)),
        e.sheenColorMap !== void 0 && (c.sheenColorMap = o(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (c.sheenRoughnessMap = o(e.sheenRoughnessMap)),
        c
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const a = {
            ShadowMaterial,
            SpriteMaterial,
            RawShaderMaterial,
            ShaderMaterial,
            PointsMaterial,
            MeshPhysicalMaterial,
            MeshStandardMaterial,
            MeshPhongMaterial,
            MeshToonMaterial,
            MeshNormalMaterial,
            MeshLambertMaterial,
            MeshDepthMaterial,
            MeshDistanceMaterial,
            MeshBasicMaterial,
            MeshMatcapMaterial,
            LineDashedMaterial,
            LineBasicMaterial,
            Material
        };
        return new a[e]
    }
}
class LoaderUtils {
    static decodeText(e) {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
        typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let a = "";
        for (let o = 0, c = e.length; o < c; o++)
            a += String.fromCharCode(e[o]);
        try {
            return decodeURIComponent(escape(a))
        } catch {
            return a
        }
    }
    static extractUrlBase(e) {
        const a = e.lastIndexOf("/");
        return a === -1 ? "./" : e.slice(0, a + 1)
    }
    static resolveURL(e, a) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(a) && /^\//.test(e) && (a = a.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : a + e)
    }
}
class InstancedBufferGeometry extends BufferGeometry {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class BufferGeometryLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = this
          , g = new FileLoader(d.manager);
        g.setPath(d.path),
        g.setRequestHeader(d.requestHeader),
        g.setWithCredentials(d.withCredentials),
        g.load(e, function(_) {
            try {
                a(d.parse(JSON.parse(_)))
            } catch (b) {
                c ? c(b) : console.error(b),
                d.manager.itemError(e)
            }
        }, o, c)
    }
    parse(e) {
        const a = {}
          , o = {};
        function c(rt, st) {
            if (a[st] !== void 0)
                return a[st];
            const ct = rt.interleavedBuffers[st]
              , it = d(rt, ct.buffer)
              , ot = getTypedArray(ct.type, it)
              , at = new InterleavedBuffer(ot,ct.stride);
            return at.uuid = ct.uuid,
            a[st] = at,
            at
        }
        function d(rt, st) {
            if (o[st] !== void 0)
                return o[st];
            const ct = rt.arrayBuffers[st]
              , it = new Uint32Array(ct).buffer;
            return o[st] = it,
            it
        }
        const g = e.isInstancedBufferGeometry ? new InstancedBufferGeometry : new BufferGeometry
          , _ = e.data.index;
        if (_ !== void 0) {
            const rt = getTypedArray(_.type, _.array);
            g.setIndex(new BufferAttribute(rt,1))
        }
        const b = e.data.attributes;
        for (const rt in b) {
            const st = b[rt];
            let lt;
            if (st.isInterleavedBufferAttribute) {
                const ct = c(e.data, st.data);
                lt = new InterleavedBufferAttribute(ct,st.itemSize,st.offset,st.normalized)
            } else {
                const ct = getTypedArray(st.type, st.array)
                  , it = st.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                lt = new it(ct,st.itemSize,st.normalized)
            }
            st.name !== void 0 && (lt.name = st.name),
            st.usage !== void 0 && lt.setUsage(st.usage),
            g.setAttribute(rt, lt)
        }
        const j = e.data.morphAttributes;
        if (j)
            for (const rt in j) {
                const st = j[rt]
                  , lt = [];
                for (let ct = 0, it = st.length; ct < it; ct++) {
                    const ot = st[ct];
                    let at;
                    if (ot.isInterleavedBufferAttribute) {
                        const ht = c(e.data, ot.data);
                        at = new InterleavedBufferAttribute(ht,ot.itemSize,ot.offset,ot.normalized)
                    } else {
                        const ht = getTypedArray(ot.type, ot.array);
                        at = new BufferAttribute(ht,ot.itemSize,ot.normalized)
                    }
                    ot.name !== void 0 && (at.name = ot.name),
                    lt.push(at)
                }
                g.morphAttributes[rt] = lt
            }
        e.data.morphTargetsRelative && (g.morphTargetsRelative = !0);
        const nt = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (nt !== void 0)
            for (let rt = 0, st = nt.length; rt !== st; ++rt) {
                const lt = nt[rt];
                g.addGroup(lt.start, lt.count, lt.materialIndex)
            }
        const tt = e.data.boundingSphere;
        if (tt !== void 0) {
            const rt = new Vector3;
            tt.center !== void 0 && rt.fromArray(tt.center),
            g.boundingSphere = new Sphere(rt,tt.radius)
        }
        return e.name && (g.name = e.name),
        e.userData && (g.userData = e.userData),
        g
    }
}
class ObjectLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = this
          , g = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || g;
        const _ = new FileLoader(this.manager);
        _.setPath(this.path),
        _.setRequestHeader(this.requestHeader),
        _.setWithCredentials(this.withCredentials),
        _.load(e, function(b) {
            let j = null;
            try {
                j = JSON.parse(b)
            } catch (nt) {
                c !== void 0 && c(nt),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", nt.message);
                return
            }
            const $ = j.metadata;
            if ($ === void 0 || $.type === void 0 || $.type.toLowerCase() === "geometry") {
                c !== void 0 && c(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            d.parse(j, a)
        }, o, c)
    }
    async loadAsync(e, a) {
        const o = this
          , c = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || c;
        const d = new FileLoader(this.manager);
        d.setPath(this.path),
        d.setRequestHeader(this.requestHeader),
        d.setWithCredentials(this.withCredentials);
        const g = await d.loadAsync(e, a)
          , _ = JSON.parse(g)
          , b = _.metadata;
        if (b === void 0 || b.type === void 0 || b.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await o.parseAsync(_)
    }
    parse(e, a) {
        const o = this.parseAnimations(e.animations)
          , c = this.parseShapes(e.shapes)
          , d = this.parseGeometries(e.geometries, c)
          , g = this.parseImages(e.images, function() {
            a !== void 0 && a(j)
        })
          , _ = this.parseTextures(e.textures, g)
          , b = this.parseMaterials(e.materials, _)
          , j = this.parseObject(e.object, d, b, _, o)
          , $ = this.parseSkeletons(e.skeletons, j);
        if (this.bindSkeletons(j, $),
        this.bindLightTargets(j),
        a !== void 0) {
            let nt = !1;
            for (const tt in g)
                if (g[tt].data instanceof HTMLImageElement) {
                    nt = !0;
                    break
                }
            nt === !1 && a(j)
        }
        return j
    }
    async parseAsync(e) {
        const a = this.parseAnimations(e.animations)
          , o = this.parseShapes(e.shapes)
          , c = this.parseGeometries(e.geometries, o)
          , d = await this.parseImagesAsync(e.images)
          , g = this.parseTextures(e.textures, d)
          , _ = this.parseMaterials(e.materials, g)
          , b = this.parseObject(e.object, c, _, g, a)
          , j = this.parseSkeletons(e.skeletons, b);
        return this.bindSkeletons(b, j),
        this.bindLightTargets(b),
        b
    }
    parseShapes(e) {
        const a = {};
        if (e !== void 0)
            for (let o = 0, c = e.length; o < c; o++) {
                const d = new Shape().fromJSON(e[o]);
                a[d.uuid] = d
            }
        return a
    }
    parseSkeletons(e, a) {
        const o = {}
          , c = {};
        if (a.traverse(function(d) {
            d.isBone && (c[d.uuid] = d)
        }),
        e !== void 0)
            for (let d = 0, g = e.length; d < g; d++) {
                const _ = new Skeleton().fromJSON(e[d], c);
                o[_.uuid] = _
            }
        return o
    }
    parseGeometries(e, a) {
        const o = {};
        if (e !== void 0) {
            const c = new BufferGeometryLoader;
            for (let d = 0, g = e.length; d < g; d++) {
                let _;
                const b = e[d];
                switch (b.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    _ = c.parse(b);
                    break;
                default:
                    b.type in Geometries ? _ = Geometries[b.type].fromJSON(b, a) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${b.type}"`)
                }
                _.uuid = b.uuid,
                b.name !== void 0 && (_.name = b.name),
                b.userData !== void 0 && (_.userData = b.userData),
                o[b.uuid] = _
            }
        }
        return o
    }
    parseMaterials(e, a) {
        const o = {}
          , c = {};
        if (e !== void 0) {
            const d = new MaterialLoader;
            d.setTextures(a);
            for (let g = 0, _ = e.length; g < _; g++) {
                const b = e[g];
                o[b.uuid] === void 0 && (o[b.uuid] = d.parse(b)),
                c[b.uuid] = o[b.uuid]
            }
        }
        return c
    }
    parseAnimations(e) {
        const a = {};
        if (e !== void 0)
            for (let o = 0; o < e.length; o++) {
                const c = e[o]
                  , d = AnimationClip.parse(c);
                a[d.uuid] = d
            }
        return a
    }
    parseImages(e, a) {
        const o = this
          , c = {};
        let d;
        function g(b) {
            return o.manager.itemStart(b),
            d.load(b, function() {
                o.manager.itemEnd(b)
            }, void 0, function() {
                o.manager.itemError(b),
                o.manager.itemEnd(b)
            })
        }
        function _(b) {
            if (typeof b == "string") {
                const j = b
                  , $ = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(j) ? j : o.resourcePath + j;
                return g($)
            } else
                return b.data ? {
                    data: getTypedArray(b.type, b.data),
                    width: b.width,
                    height: b.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const b = new LoadingManager(a);
            d = new ImageLoader(b),
            d.setCrossOrigin(this.crossOrigin);
            for (let j = 0, $ = e.length; j < $; j++) {
                const nt = e[j]
                  , tt = nt.url;
                if (Array.isArray(tt)) {
                    const rt = [];
                    for (let st = 0, lt = tt.length; st < lt; st++) {
                        const ct = tt[st]
                          , it = _(ct);
                        it !== null && (it instanceof HTMLImageElement ? rt.push(it) : rt.push(new DataTexture(it.data,it.width,it.height)))
                    }
                    c[nt.uuid] = new Source(rt)
                } else {
                    const rt = _(nt.url);
                    c[nt.uuid] = new Source(rt)
                }
            }
        }
        return c
    }
    async parseImagesAsync(e) {
        const a = this
          , o = {};
        let c;
        async function d(g) {
            if (typeof g == "string") {
                const _ = g
                  , b = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_) ? _ : a.resourcePath + _;
                return await c.loadAsync(b)
            } else
                return g.data ? {
                    data: getTypedArray(g.type, g.data),
                    width: g.width,
                    height: g.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            c = new ImageLoader(this.manager),
            c.setCrossOrigin(this.crossOrigin);
            for (let g = 0, _ = e.length; g < _; g++) {
                const b = e[g]
                  , j = b.url;
                if (Array.isArray(j)) {
                    const $ = [];
                    for (let nt = 0, tt = j.length; nt < tt; nt++) {
                        const rt = j[nt]
                          , st = await d(rt);
                        st !== null && (st instanceof HTMLImageElement ? $.push(st) : $.push(new DataTexture(st.data,st.width,st.height)))
                    }
                    o[b.uuid] = new Source($)
                } else {
                    const $ = await d(b.url);
                    o[b.uuid] = new Source($)
                }
            }
        }
        return o
    }
    parseTextures(e, a) {
        function o(d, g) {
            return typeof d == "number" ? d : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", d),
            g[d])
        }
        const c = {};
        if (e !== void 0)
            for (let d = 0, g = e.length; d < g; d++) {
                const _ = e[d];
                _.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', _.uuid),
                a[_.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", _.image);
                const b = a[_.image]
                  , j = b.data;
                let $;
                Array.isArray(j) ? ($ = new CubeTexture,
                j.length === 6 && ($.needsUpdate = !0)) : (j && j.data ? $ = new DataTexture : $ = new Texture,
                j && ($.needsUpdate = !0)),
                $.source = b,
                $.uuid = _.uuid,
                _.name !== void 0 && ($.name = _.name),
                _.mapping !== void 0 && ($.mapping = o(_.mapping, TEXTURE_MAPPING)),
                _.channel !== void 0 && ($.channel = _.channel),
                _.offset !== void 0 && $.offset.fromArray(_.offset),
                _.repeat !== void 0 && $.repeat.fromArray(_.repeat),
                _.center !== void 0 && $.center.fromArray(_.center),
                _.rotation !== void 0 && ($.rotation = _.rotation),
                _.wrap !== void 0 && ($.wrapS = o(_.wrap[0], TEXTURE_WRAPPING),
                $.wrapT = o(_.wrap[1], TEXTURE_WRAPPING)),
                _.format !== void 0 && ($.format = _.format),
                _.internalFormat !== void 0 && ($.internalFormat = _.internalFormat),
                _.type !== void 0 && ($.type = _.type),
                _.colorSpace !== void 0 && ($.colorSpace = _.colorSpace),
                _.minFilter !== void 0 && ($.minFilter = o(_.minFilter, TEXTURE_FILTER)),
                _.magFilter !== void 0 && ($.magFilter = o(_.magFilter, TEXTURE_FILTER)),
                _.anisotropy !== void 0 && ($.anisotropy = _.anisotropy),
                _.flipY !== void 0 && ($.flipY = _.flipY),
                _.generateMipmaps !== void 0 && ($.generateMipmaps = _.generateMipmaps),
                _.premultiplyAlpha !== void 0 && ($.premultiplyAlpha = _.premultiplyAlpha),
                _.unpackAlignment !== void 0 && ($.unpackAlignment = _.unpackAlignment),
                _.compareFunction !== void 0 && ($.compareFunction = _.compareFunction),
                _.userData !== void 0 && ($.userData = _.userData),
                c[_.uuid] = $
            }
        return c
    }
    parseObject(e, a, o, c, d) {
        let g;
        function _(tt) {
            return a[tt] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", tt),
            a[tt]
        }
        function b(tt) {
            if (tt !== void 0) {
                if (Array.isArray(tt)) {
                    const rt = [];
                    for (let st = 0, lt = tt.length; st < lt; st++) {
                        const ct = tt[st];
                        o[ct] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", ct),
                        rt.push(o[ct])
                    }
                    return rt
                }
                return o[tt] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", tt),
                o[tt]
            }
        }
        function j(tt) {
            return c[tt] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", tt),
            c[tt]
        }
        let $, nt;
        switch (e.type) {
        case "Scene":
            g = new Scene,
            e.background !== void 0 && (Number.isInteger(e.background) ? g.background = new Color(e.background) : g.background = j(e.background)),
            e.environment !== void 0 && (g.environment = j(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? g.fog = new Fog(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (g.fog = new FogExp2(e.fog.color,e.fog.density)),
            e.fog.name !== "" && (g.fog.name = e.fog.name)),
            e.backgroundBlurriness !== void 0 && (g.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (g.backgroundIntensity = e.backgroundIntensity),
            e.backgroundRotation !== void 0 && g.backgroundRotation.fromArray(e.backgroundRotation),
            e.environmentIntensity !== void 0 && (g.environmentIntensity = e.environmentIntensity),
            e.environmentRotation !== void 0 && g.environmentRotation.fromArray(e.environmentRotation);
            break;
        case "PerspectiveCamera":
            g = new PerspectiveCamera(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (g.focus = e.focus),
            e.zoom !== void 0 && (g.zoom = e.zoom),
            e.filmGauge !== void 0 && (g.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (g.filmOffset = e.filmOffset),
            e.view !== void 0 && (g.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            g = new OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (g.zoom = e.zoom),
            e.view !== void 0 && (g.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            g = new AmbientLight(e.color,e.intensity);
            break;
        case "DirectionalLight":
            g = new DirectionalLight(e.color,e.intensity),
            g.target = e.target || "";
            break;
        case "PointLight":
            g = new PointLight(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            g = new RectAreaLight(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            g = new SpotLight(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),
            g.target = e.target || "";
            break;
        case "HemisphereLight":
            g = new HemisphereLight(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            g = new LightProbe().fromJSON(e);
            break;
        case "SkinnedMesh":
            $ = _(e.geometry),
            nt = b(e.material),
            g = new SkinnedMesh($,nt),
            e.bindMode !== void 0 && (g.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && g.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (g.skeleton = e.skeleton);
            break;
        case "Mesh":
            $ = _(e.geometry),
            nt = b(e.material),
            g = new Mesh($,nt);
            break;
        case "InstancedMesh":
            $ = _(e.geometry),
            nt = b(e.material);
            const tt = e.count
              , rt = e.instanceMatrix
              , st = e.instanceColor;
            g = new InstancedMesh($,nt,tt),
            g.instanceMatrix = new InstancedBufferAttribute(new Float32Array(rt.array),16),
            st !== void 0 && (g.instanceColor = new InstancedBufferAttribute(new Float32Array(st.array),st.itemSize));
            break;
        case "BatchedMesh":
            $ = _(e.geometry),
            nt = b(e.material),
            g = new BatchedMesh(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,nt),
            g.geometry = $,
            g.perObjectFrustumCulled = e.perObjectFrustumCulled,
            g.sortObjects = e.sortObjects,
            g._drawRanges = e.drawRanges,
            g._reservedRanges = e.reservedRanges,
            g._visibility = e.visibility,
            g._active = e.active,
            g._bounds = e.bounds.map(lt => {
                const ct = new Box3;
                ct.min.fromArray(lt.boxMin),
                ct.max.fromArray(lt.boxMax);
                const it = new Sphere;
                return it.radius = lt.sphereRadius,
                it.center.fromArray(lt.sphereCenter),
                {
                    boxInitialized: lt.boxInitialized,
                    box: ct,
                    sphereInitialized: lt.sphereInitialized,
                    sphere: it
                }
            }
            ),
            g._maxInstanceCount = e.maxInstanceCount,
            g._maxVertexCount = e.maxVertexCount,
            g._maxIndexCount = e.maxIndexCount,
            g._geometryInitialized = e.geometryInitialized,
            g._geometryCount = e.geometryCount,
            g._matricesTexture = j(e.matricesTexture.uuid),
            e.colorsTexture !== void 0 && (g._colorsTexture = j(e.colorsTexture.uuid));
            break;
        case "LOD":
            g = new LOD;
            break;
        case "Line":
            g = new Line(_(e.geometry),b(e.material));
            break;
        case "LineLoop":
            g = new LineLoop(_(e.geometry),b(e.material));
            break;
        case "LineSegments":
            g = new LineSegments(_(e.geometry),b(e.material));
            break;
        case "PointCloud":
        case "Points":
            g = new Points$1(_(e.geometry),b(e.material));
            break;
        case "Sprite":
            g = new Sprite(b(e.material));
            break;
        case "Group":
            g = new Group;
            break;
        case "Bone":
            g = new Bone;
            break;
        default:
            g = new Object3D
        }
        if (g.uuid = e.uuid,
        e.name !== void 0 && (g.name = e.name),
        e.matrix !== void 0 ? (g.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (g.matrixAutoUpdate = e.matrixAutoUpdate),
        g.matrixAutoUpdate && g.matrix.decompose(g.position, g.quaternion, g.scale)) : (e.position !== void 0 && g.position.fromArray(e.position),
        e.rotation !== void 0 && g.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && g.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && g.scale.fromArray(e.scale)),
        e.up !== void 0 && g.up.fromArray(e.up),
        e.castShadow !== void 0 && (g.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (g.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.intensity !== void 0 && (g.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (g.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (g.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (g.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && g.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (g.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (g.visible = e.visible),
        e.frustumCulled !== void 0 && (g.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (g.renderOrder = e.renderOrder),
        e.userData !== void 0 && (g.userData = e.userData),
        e.layers !== void 0 && (g.layers.mask = e.layers),
        e.children !== void 0) {
            const tt = e.children;
            for (let rt = 0; rt < tt.length; rt++)
                g.add(this.parseObject(tt[rt], a, o, c, d))
        }
        if (e.animations !== void 0) {
            const tt = e.animations;
            for (let rt = 0; rt < tt.length; rt++) {
                const st = tt[rt];
                g.animations.push(d[st])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (g.autoUpdate = e.autoUpdate);
            const tt = e.levels;
            for (let rt = 0; rt < tt.length; rt++) {
                const st = tt[rt]
                  , lt = g.getObjectByProperty("uuid", st.object);
                lt !== void 0 && g.addLevel(lt, st.distance, st.hysteresis)
            }
        }
        return g
    }
    bindSkeletons(e, a) {
        Object.keys(a).length !== 0 && e.traverse(function(o) {
            if (o.isSkinnedMesh === !0 && o.skeleton !== void 0) {
                const c = a[o.skeleton];
                c === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", o.skeleton) : o.bind(c, o.bindMatrix)
            }
        })
    }
    bindLightTargets(e) {
        e.traverse(function(a) {
            if (a.isDirectionalLight || a.isSpotLight) {
                const o = a.target
                  , c = e.getObjectByProperty("uuid", o);
                c !== void 0 ? a.target = c : a.target = new Object3D
            }
        })
    }
}
const TEXTURE_MAPPING = {
    UVMapping,
    CubeReflectionMapping,
    CubeRefractionMapping,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    CubeUVReflectionMapping
}
  , TEXTURE_WRAPPING = {
    RepeatWrapping,
    ClampToEdgeWrapping,
    MirroredRepeatWrapping
}
  , TEXTURE_FILTER = {
    NearestFilter,
    NearestMipmapNearestFilter,
    NearestMipmapLinearFilter,
    LinearFilter,
    LinearMipmapNearestFilter,
    LinearMipmapLinearFilter
};
class ImageBitmapLoader extends Loader$1 {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, a, o, c) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const d = this
          , g = Cache.get(e);
        if (g !== void 0) {
            if (d.manager.itemStart(e),
            g.then) {
                g.then(j => {
                    a && a(j),
                    d.manager.itemEnd(e)
                }
                ).catch(j => {
                    c && c(j)
                }
                );
                return
            }
            return setTimeout(function() {
                a && a(g),
                d.manager.itemEnd(e)
            }, 0),
            g
        }
        const _ = {};
        _.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        _.headers = this.requestHeader;
        const b = fetch(e, _).then(function(j) {
            return j.blob()
        }).then(function(j) {
            return createImageBitmap(j, Object.assign(d.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(j) {
            return Cache.add(e, j),
            a && a(j),
            d.manager.itemEnd(e),
            j
        }).catch(function(j) {
            c && c(j),
            Cache.remove(e),
            d.manager.itemError(e),
            d.manager.itemEnd(e)
        });
        Cache.add(e, b),
        d.manager.itemStart(e)
    }
}
let _context;
class AudioContext {
    static getContext() {
        return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)),
        _context
    }
    static setContext(e) {
        _context = e
    }
}
class AudioLoader extends Loader$1 {
    constructor(e) {
        super(e)
    }
    load(e, a, o, c) {
        const d = this
          , g = new FileLoader(this.manager);
        g.setResponseType("arraybuffer"),
        g.setPath(this.path),
        g.setRequestHeader(this.requestHeader),
        g.setWithCredentials(this.withCredentials),
        g.load(e, function(b) {
            try {
                const j = b.slice(0);
                AudioContext.getContext().decodeAudioData(j, function(nt) {
                    a(nt)
                }).catch(_)
            } catch (j) {
                _(j)
            }
        }, o, c);
        function _(b) {
            c ? c(b) : console.error(b),
            d.manager.itemError(e)
        }
    }
}
const _eyeRight = new Matrix4
  , _eyeLeft = new Matrix4
  , _projectionMatrix = new Matrix4;
class StereoCamera {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new PerspectiveCamera,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new PerspectiveCamera,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const a = this._cache;
        if (a.focus !== e.focus || a.fov !== e.fov || a.aspect !== e.aspect * this.aspect || a.near !== e.near || a.far !== e.far || a.zoom !== e.zoom || a.eyeSep !== this.eyeSep) {
            a.focus = e.focus,
            a.fov = e.fov,
            a.aspect = e.aspect * this.aspect,
            a.near = e.near,
            a.far = e.far,
            a.zoom = e.zoom,
            a.eyeSep = this.eyeSep,
            _projectionMatrix.copy(e.projectionMatrix);
            const c = a.eyeSep / 2
              , d = c * a.near / a.focus
              , g = a.near * Math.tan(DEG2RAD * a.fov * .5) / a.zoom;
            let _, b;
            _eyeLeft.elements[12] = -c,
            _eyeRight.elements[12] = c,
            _ = -g * a.aspect + d,
            b = g * a.aspect + d,
            _projectionMatrix.elements[0] = 2 * a.near / (b - _),
            _projectionMatrix.elements[8] = (b + _) / (b - _),
            this.cameraL.projectionMatrix.copy(_projectionMatrix),
            _ = -g * a.aspect - d,
            b = g * a.aspect - d,
            _projectionMatrix.elements[0] = 2 * a.near / (b - _),
            _projectionMatrix.elements[8] = (b + _) / (b - _),
            this.cameraR.projectionMatrix.copy(_projectionMatrix)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight)
    }
}
class Clock {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = now(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const a = now();
            e = (a - this.oldTime) / 1e3,
            this.oldTime = a,
            this.elapsedTime += e
        }
        return e
    }
}
function now() {
    return (typeof performance > "u" ? Date : performance).now()
}
const _position$1 = new Vector3
  , _quaternion$1 = new Quaternion
  , _scale$1 = new Vector3
  , _orientation$1 = new Vector3;
class AudioListener extends Object3D {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = AudioContext.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new Clock
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const a = this.context.listener
          , o = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1),
        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1),
        a.positionX) {
            const c = this.context.currentTime + this.timeDelta;
            a.positionX.linearRampToValueAtTime(_position$1.x, c),
            a.positionY.linearRampToValueAtTime(_position$1.y, c),
            a.positionZ.linearRampToValueAtTime(_position$1.z, c),
            a.forwardX.linearRampToValueAtTime(_orientation$1.x, c),
            a.forwardY.linearRampToValueAtTime(_orientation$1.y, c),
            a.forwardZ.linearRampToValueAtTime(_orientation$1.z, c),
            a.upX.linearRampToValueAtTime(o.x, c),
            a.upY.linearRampToValueAtTime(o.y, c),
            a.upZ.linearRampToValueAtTime(o.z, c)
        } else
            a.setPosition(_position$1.x, _position$1.y, _position$1.z),
            a.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, o.x, o.y, o.z)
    }
}
class Audio extends Object3D {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const a = this.context.createBufferSource();
        return a.buffer = this.buffer,
        a.loop = this.loop,
        a.loopStart = this.loopStart,
        a.loopEnd = this.loopEnd,
        a.onended = this.onEnded.bind(this),
        a.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = a,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source !== null && (this.source.stop(),
        this.source.onended = null),
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, a = this.filters.length; e < a; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, a = this.filters.length; e < a; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        return this.detune = e,
        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
        this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const _position = new Vector3
  , _quaternion = new Quaternion
  , _scale = new Vector3
  , _orientation = new Vector3;
class PositionalAudio extends Audio {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    connect() {
        super.connect(),
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, a, o) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = a,
        this.panner.coneOuterGain = o,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(_position, _quaternion, _scale),
        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
        const a = this.panner;
        if (a.positionX) {
            const o = this.context.currentTime + this.listener.timeDelta;
            a.positionX.linearRampToValueAtTime(_position.x, o),
            a.positionY.linearRampToValueAtTime(_position.y, o),
            a.positionZ.linearRampToValueAtTime(_position.z, o),
            a.orientationX.linearRampToValueAtTime(_orientation.x, o),
            a.orientationY.linearRampToValueAtTime(_orientation.y, o),
            a.orientationZ.linearRampToValueAtTime(_orientation.z, o)
        } else
            a.setPosition(_position.x, _position.y, _position.z),
            a.setOrientation(_orientation.x, _orientation.y, _orientation.z)
    }
}
class AudioAnalyser {
    constructor(e, a=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = a,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const a = this.getFrequencyData();
        for (let o = 0; o < a.length; o++)
            e += a[o];
        return e / a.length
    }
}
class PropertyMixer {
    constructor(e, a, o) {
        this.binding = e,
        this.valueSize = o;
        let c, d, g;
        switch (a) {
        case "quaternion":
            c = this._slerp,
            d = this._slerpAdditive,
            g = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(o * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            c = this._select,
            d = this._select,
            g = this._setAdditiveIdentityOther,
            this.buffer = new Array(o * 5);
            break;
        default:
            c = this._lerp,
            d = this._lerpAdditive,
            g = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(o * 5)
        }
        this._mixBufferRegion = c,
        this._mixBufferRegionAdditive = d,
        this._setIdentity = g,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, a) {
        const o = this.buffer
          , c = this.valueSize
          , d = e * c + c;
        let g = this.cumulativeWeight;
        if (g === 0) {
            for (let _ = 0; _ !== c; ++_)
                o[d + _] = o[_];
            g = a
        } else {
            g += a;
            const _ = a / g;
            this._mixBufferRegion(o, d, 0, _, c)
        }
        this.cumulativeWeight = g
    }
    accumulateAdditive(e) {
        const a = this.buffer
          , o = this.valueSize
          , c = o * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(a, c, 0, e, o),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const a = this.valueSize
          , o = this.buffer
          , c = e * a + a
          , d = this.cumulativeWeight
          , g = this.cumulativeWeightAdditive
          , _ = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        d < 1) {
            const b = a * this._origIndex;
            this._mixBufferRegion(o, c, b, 1 - d, a)
        }
        g > 0 && this._mixBufferRegionAdditive(o, c, this._addIndex * a, 1, a);
        for (let b = a, j = a + a; b !== j; ++b)
            if (o[b] !== o[b + a]) {
                _.setValue(o, c);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , a = this.buffer
          , o = this.valueSize
          , c = o * this._origIndex;
        e.getValue(a, c);
        for (let d = o, g = c; d !== g; ++d)
            a[d] = a[c + d % o];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , a = e + this.valueSize;
        for (let o = e; o < a; o++)
            this.buffer[o] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , a = this._addIndex * this.valueSize;
        for (let o = 0; o < this.valueSize; o++)
            this.buffer[a + o] = this.buffer[e + o]
    }
    _select(e, a, o, c, d) {
        if (c >= .5)
            for (let g = 0; g !== d; ++g)
                e[a + g] = e[o + g]
    }
    _slerp(e, a, o, c) {
        Quaternion.slerpFlat(e, a, e, a, e, o, c)
    }
    _slerpAdditive(e, a, o, c, d) {
        const g = this._workIndex * d;
        Quaternion.multiplyQuaternionsFlat(e, g, e, a, e, o),
        Quaternion.slerpFlat(e, a, e, a, e, g, c)
    }
    _lerp(e, a, o, c, d) {
        const g = 1 - c;
        for (let _ = 0; _ !== d; ++_) {
            const b = a + _;
            e[b] = e[b] * g + e[o + _] * c
        }
    }
    _lerpAdditive(e, a, o, c, d) {
        for (let g = 0; g !== d; ++g) {
            const _ = a + g;
            e[_] = e[_] + e[o + g] * c
        }
    }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/"
  , _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]","g")
  , _wordChar = "[^" + _RESERVED_CHARS_RE + "]"
  , _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]"
  , _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar)
  , _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot)
  , _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar)
  , _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar)
  , _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$")
  , _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
    constructor(e, a, o) {
        const c = o || PropertyBinding.parseTrackName(a);
        this._targetGroup = e,
        this._bindings = e.subscribe_(a, c)
    }
    getValue(e, a) {
        this.bind();
        const o = this._targetGroup.nCachedObjects_
          , c = this._bindings[o];
        c !== void 0 && c.getValue(e, a)
    }
    setValue(e, a) {
        const o = this._bindings;
        for (let c = this._targetGroup.nCachedObjects_, d = o.length; c !== d; ++c)
            o[c].setValue(e, a)
    }
    bind() {
        const e = this._bindings;
        for (let a = this._targetGroup.nCachedObjects_, o = e.length; a !== o; ++a)
            e[a].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let a = this._targetGroup.nCachedObjects_, o = e.length; a !== o; ++a)
            e[a].unbind()
    }
}
class PropertyBinding {
    constructor(e, a, o) {
        this.path = a,
        this.parsedPath = o || PropertyBinding.parseTrackName(a),
        this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, a, o) {
        return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite(e,a,o) : new PropertyBinding(e,a,o)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(_reservedRe, "")
    }
    static parseTrackName(e) {
        const a = _trackRe.exec(e);
        if (a === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const o = {
            nodeName: a[2],
            objectName: a[3],
            objectIndex: a[4],
            propertyName: a[5],
            propertyIndex: a[6]
        }
          , c = o.nodeName && o.nodeName.lastIndexOf(".");
        if (c !== void 0 && c !== -1) {
            const d = o.nodeName.substring(c + 1);
            _supportedObjectNames.indexOf(d) !== -1 && (o.nodeName = o.nodeName.substring(0, c),
            o.objectName = d)
        }
        if (o.propertyName === null || o.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return o
    }
    static findNode(e, a) {
        if (a === void 0 || a === "" || a === "." || a === -1 || a === e.name || a === e.uuid)
            return e;
        if (e.skeleton) {
            const o = e.skeleton.getBoneByName(a);
            if (o !== void 0)
                return o
        }
        if (e.children) {
            const o = function(d) {
                for (let g = 0; g < d.length; g++) {
                    const _ = d[g];
                    if (_.name === a || _.uuid === a)
                        return _;
                    const b = o(_.children);
                    if (b)
                        return b
                }
                return null
            }
              , c = o(e.children);
            if (c)
                return c
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, a) {
        e[a] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, a) {
        const o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            e[a++] = o[c]
    }
    _getValue_arrayElement(e, a) {
        e[a] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, a) {
        this.resolvedProperty.toArray(e, a)
    }
    _setValue_direct(e, a) {
        this.targetObject[this.propertyName] = e[a]
    }
    _setValue_direct_setNeedsUpdate(e, a) {
        this.targetObject[this.propertyName] = e[a],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, a) {
        this.targetObject[this.propertyName] = e[a],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, a) {
        const o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            o[c] = e[a++]
    }
    _setValue_array_setNeedsUpdate(e, a) {
        const o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            o[c] = e[a++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, a) {
        const o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            o[c] = e[a++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, a) {
        this.resolvedProperty[this.propertyIndex] = e[a]
    }
    _setValue_arrayElement_setNeedsUpdate(e, a) {
        this.resolvedProperty[this.propertyIndex] = e[a],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, a) {
        this.resolvedProperty[this.propertyIndex] = e[a],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, a) {
        this.resolvedProperty.fromArray(e, a)
    }
    _setValue_fromArray_setNeedsUpdate(e, a) {
        this.resolvedProperty.fromArray(e, a),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, a) {
        this.resolvedProperty.fromArray(e, a),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, a) {
        this.bind(),
        this.getValue(e, a)
    }
    _setValue_unbound(e, a) {
        this.bind(),
        this.setValue(e, a)
    }
    bind() {
        let e = this.node;
        const a = this.parsedPath
          , o = a.objectName
          , c = a.propertyName;
        let d = a.propertyIndex;
        if (e || (e = PropertyBinding.findNode(this.rootNode, a.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (o) {
            let j = a.objectIndex;
            switch (o) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let $ = 0; $ < e.length; $++)
                    if (e[$].name === j) {
                        j = $;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[o] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[o]
            }
            if (j !== void 0) {
                if (e[j] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[j]
            }
        }
        const g = e[c];
        if (g === void 0) {
            const j = a.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + j + "." + c + " but it wasn't found.", e);
            return
        }
        let _ = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? _ = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (_ = this.Versioning.MatrixWorldNeedsUpdate);
        let b = this.BindingType.Direct;
        if (d !== void 0) {
            if (c === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[d] !== void 0 && (d = e.morphTargetDictionary[d])
            }
            b = this.BindingType.ArrayElement,
            this.resolvedProperty = g,
            this.propertyIndex = d
        } else
            g.fromArray !== void 0 && g.toArray !== void 0 ? (b = this.BindingType.HasFromToArray,
            this.resolvedProperty = g) : Array.isArray(g) ? (b = this.BindingType.EntireArray,
            this.resolvedProperty = g) : this.propertyName = c;
        this.getValue = this.GetterByBindingType[b],
        this.setValue = this.SetterByBindingTypeAndVersioning[b][_]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class AnimationObjectGroup {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let o = 0, c = arguments.length; o !== c; ++o)
            e[arguments[o].uuid] = o;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const a = this;
        this.stats = {
            objects: {
                get total() {
                    return a._objects.length
                },
                get inUse() {
                    return this.total - a.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return a._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , a = this._indicesByUUID
          , o = this._paths
          , c = this._parsedPaths
          , d = this._bindings
          , g = d.length;
        let _, b = e.length, j = this.nCachedObjects_;
        for (let $ = 0, nt = arguments.length; $ !== nt; ++$) {
            const tt = arguments[$]
              , rt = tt.uuid;
            let st = a[rt];
            if (st === void 0) {
                st = b++,
                a[rt] = st,
                e.push(tt);
                for (let lt = 0, ct = g; lt !== ct; ++lt)
                    d[lt].push(new PropertyBinding(tt,o[lt],c[lt]))
            } else if (st < j) {
                _ = e[st];
                const lt = --j
                  , ct = e[lt];
                a[ct.uuid] = st,
                e[st] = ct,
                a[rt] = lt,
                e[lt] = tt;
                for (let it = 0, ot = g; it !== ot; ++it) {
                    const at = d[it]
                      , ht = at[lt];
                    let pt = at[st];
                    at[st] = ht,
                    pt === void 0 && (pt = new PropertyBinding(tt,o[it],c[it])),
                    at[lt] = pt
                }
            } else
                e[st] !== _ && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = j
    }
    remove() {
        const e = this._objects
          , a = this._indicesByUUID
          , o = this._bindings
          , c = o.length;
        let d = this.nCachedObjects_;
        for (let g = 0, _ = arguments.length; g !== _; ++g) {
            const b = arguments[g]
              , j = b.uuid
              , $ = a[j];
            if ($ !== void 0 && $ >= d) {
                const nt = d++
                  , tt = e[nt];
                a[tt.uuid] = $,
                e[$] = tt,
                a[j] = nt,
                e[nt] = b;
                for (let rt = 0, st = c; rt !== st; ++rt) {
                    const lt = o[rt]
                      , ct = lt[nt]
                      , it = lt[$];
                    lt[$] = ct,
                    lt[nt] = it
                }
            }
        }
        this.nCachedObjects_ = d
    }
    uncache() {
        const e = this._objects
          , a = this._indicesByUUID
          , o = this._bindings
          , c = o.length;
        let d = this.nCachedObjects_
          , g = e.length;
        for (let _ = 0, b = arguments.length; _ !== b; ++_) {
            const j = arguments[_]
              , $ = j.uuid
              , nt = a[$];
            if (nt !== void 0)
                if (delete a[$],
                nt < d) {
                    const tt = --d
                      , rt = e[tt]
                      , st = --g
                      , lt = e[st];
                    a[rt.uuid] = nt,
                    e[nt] = rt,
                    a[lt.uuid] = tt,
                    e[tt] = lt,
                    e.pop();
                    for (let ct = 0, it = c; ct !== it; ++ct) {
                        const ot = o[ct]
                          , at = ot[tt]
                          , ht = ot[st];
                        ot[nt] = at,
                        ot[tt] = ht,
                        ot.pop()
                    }
                } else {
                    const tt = --g
                      , rt = e[tt];
                    tt > 0 && (a[rt.uuid] = nt),
                    e[nt] = rt,
                    e.pop();
                    for (let st = 0, lt = c; st !== lt; ++st) {
                        const ct = o[st];
                        ct[nt] = ct[tt],
                        ct.pop()
                    }
                }
        }
        this.nCachedObjects_ = d
    }
    subscribe_(e, a) {
        const o = this._bindingsIndicesByPath;
        let c = o[e];
        const d = this._bindings;
        if (c !== void 0)
            return d[c];
        const g = this._paths
          , _ = this._parsedPaths
          , b = this._objects
          , j = b.length
          , $ = this.nCachedObjects_
          , nt = new Array(j);
        c = d.length,
        o[e] = c,
        g.push(e),
        _.push(a),
        d.push(nt);
        for (let tt = $, rt = b.length; tt !== rt; ++tt) {
            const st = b[tt];
            nt[tt] = new PropertyBinding(st,e,a)
        }
        return nt
    }
    unsubscribe_(e) {
        const a = this._bindingsIndicesByPath
          , o = a[e];
        if (o !== void 0) {
            const c = this._paths
              , d = this._parsedPaths
              , g = this._bindings
              , _ = g.length - 1
              , b = g[_]
              , j = e[_];
            a[j] = o,
            g[o] = b,
            g.pop(),
            d[o] = d[_],
            d.pop(),
            c[o] = c[_],
            c.pop()
        }
    }
}
class AnimationAction {
    constructor(e, a, o=null, c=a.blendMode) {
        this._mixer = e,
        this._clip = a,
        this._localRoot = o,
        this.blendMode = c;
        const d = a.tracks
          , g = d.length
          , _ = new Array(g)
          , b = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for (let j = 0; j !== g; ++j) {
            const $ = d[j].createInterpolant(null);
            _[j] = $,
            $.settings = b
        }
        this._interpolantSettings = b,
        this._interpolants = _,
        this._propertyBindings = new Array(g),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = LoopRepeat,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, a) {
        return this.loop = e,
        this.repetitions = a,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, a, o) {
        if (e.fadeOut(a),
        this.fadeIn(a),
        o) {
            const c = this._clip.duration
              , d = e._clip.duration
              , g = d / c
              , _ = c / d;
            e.warp(1, g, a),
            this.warp(_, 1, a)
        }
        return this
    }
    crossFadeTo(e, a, o) {
        return e.crossFadeFrom(this, a, o)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, a, o) {
        const c = this._mixer
          , d = c.time
          , g = this.timeScale;
        let _ = this._timeScaleInterpolant;
        _ === null && (_ = c._lendControlInterpolant(),
        this._timeScaleInterpolant = _);
        const b = _.parameterPositions
          , j = _.sampleValues;
        return b[0] = d,
        b[1] = d + o,
        j[0] = e / g,
        j[1] = a / g,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, a, o, c) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const d = this._startTime;
        if (d !== null) {
            const b = (e - d) * o;
            b < 0 || o === 0 ? a = 0 : (this._startTime = null,
            a = o * b)
        }
        a *= this._updateTimeScale(e);
        const g = this._updateTime(a)
          , _ = this._updateWeight(e);
        if (_ > 0) {
            const b = this._interpolants
              , j = this._propertyBindings;
            switch (this.blendMode) {
            case AdditiveAnimationBlendMode:
                for (let $ = 0, nt = b.length; $ !== nt; ++$)
                    b[$].evaluate(g),
                    j[$].accumulateAdditive(_);
                break;
            case NormalAnimationBlendMode:
            default:
                for (let $ = 0, nt = b.length; $ !== nt; ++$)
                    b[$].evaluate(g),
                    j[$].accumulate(c, _)
            }
        }
    }
    _updateWeight(e) {
        let a = 0;
        if (this.enabled) {
            a = this.weight;
            const o = this._weightInterpolant;
            if (o !== null) {
                const c = o.evaluate(e)[0];
                a *= c,
                e > o.parameterPositions[1] && (this.stopFading(),
                c === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = a,
        a
    }
    _updateTimeScale(e) {
        let a = 0;
        if (!this.paused) {
            a = this.timeScale;
            const o = this._timeScaleInterpolant;
            if (o !== null) {
                const c = o.evaluate(e)[0];
                a *= c,
                e > o.parameterPositions[1] && (this.stopWarping(),
                a === 0 ? this.paused = !0 : this.timeScale = a)
            }
        }
        return this._effectiveTimeScale = a,
        a
    }
    _updateTime(e) {
        const a = this._clip.duration
          , o = this.loop;
        let c = this.time + e
          , d = this._loopCount;
        const g = o === LoopPingPong;
        if (e === 0)
            return d === -1 ? c : g && (d & 1) === 1 ? a - c : c;
        if (o === LoopOnce) {
            d === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (c >= a)
                    c = a;
                else if (c < 0)
                    c = 0;
                else {
                    this.time = c;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = c,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (d === -1 && (e >= 0 ? (d = 0,
            this._setEndings(!0, this.repetitions === 0, g)) : this._setEndings(this.repetitions === 0, !0, g)),
            c >= a || c < 0) {
                const _ = Math.floor(c / a);
                c -= a * _,
                d += Math.abs(_);
                const b = this.repetitions - d;
                if (b <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    c = e > 0 ? a : 0,
                    this.time = c,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (b === 1) {
                        const j = e < 0;
                        this._setEndings(j, !j, g)
                    } else
                        this._setEndings(!1, !1, g);
                    this._loopCount = d,
                    this.time = c,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: _
                    })
                }
            } else
                this.time = c;
            if (g && (d & 1) === 1)
                return a - c
        }
        return c
    }
    _setEndings(e, a, o) {
        const c = this._interpolantSettings;
        o ? (c.endingStart = ZeroSlopeEnding,
        c.endingEnd = ZeroSlopeEnding) : (e ? c.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : c.endingStart = WrapAroundEnding,
        a ? c.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : c.endingEnd = WrapAroundEnding)
    }
    _scheduleFading(e, a, o) {
        const c = this._mixer
          , d = c.time;
        let g = this._weightInterpolant;
        g === null && (g = c._lendControlInterpolant(),
        this._weightInterpolant = g);
        const _ = g.parameterPositions
          , b = g.sampleValues;
        return _[0] = d,
        b[0] = a,
        _[1] = d + e,
        b[1] = o,
        this
    }
}
const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, a) {
        const o = e._localRoot || this._root
          , c = e._clip.tracks
          , d = c.length
          , g = e._propertyBindings
          , _ = e._interpolants
          , b = o.uuid
          , j = this._bindingsByRootAndName;
        let $ = j[b];
        $ === void 0 && ($ = {},
        j[b] = $);
        for (let nt = 0; nt !== d; ++nt) {
            const tt = c[nt]
              , rt = tt.name;
            let st = $[rt];
            if (st !== void 0)
                ++st.referenceCount,
                g[nt] = st;
            else {
                if (st = g[nt],
                st !== void 0) {
                    st._cacheIndex === null && (++st.referenceCount,
                    this._addInactiveBinding(st, b, rt));
                    continue
                }
                const lt = a && a._propertyBindings[nt].binding.parsedPath;
                st = new PropertyMixer(PropertyBinding.create(o, rt, lt),tt.ValueTypeName,tt.getValueSize()),
                ++st.referenceCount,
                this._addInactiveBinding(st, b, rt),
                g[nt] = st
            }
            _[nt].resultBuffer = st.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const o = (e._localRoot || this._root).uuid
                  , c = e._clip.uuid
                  , d = this._actionsByClip[c];
                this._bindAction(e, d && d.knownActions[0]),
                this._addInactiveAction(e, c, o)
            }
            const a = e._propertyBindings;
            for (let o = 0, c = a.length; o !== c; ++o) {
                const d = a[o];
                d.useCount++ === 0 && (this._lendBinding(d),
                d.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const a = e._propertyBindings;
            for (let o = 0, c = a.length; o !== c; ++o) {
                const d = a[o];
                --d.useCount === 0 && (d.restoreOriginalState(),
                this._takeBackBinding(d))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const a = e._cacheIndex;
        return a !== null && a < this._nActiveActions
    }
    _addInactiveAction(e, a, o) {
        const c = this._actions
          , d = this._actionsByClip;
        let g = d[a];
        if (g === void 0)
            g = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            d[a] = g;
        else {
            const _ = g.knownActions;
            e._byClipCacheIndex = _.length,
            _.push(e)
        }
        e._cacheIndex = c.length,
        c.push(e),
        g.actionByRoot[o] = e
    }
    _removeInactiveAction(e) {
        const a = this._actions
          , o = a[a.length - 1]
          , c = e._cacheIndex;
        o._cacheIndex = c,
        a[c] = o,
        a.pop(),
        e._cacheIndex = null;
        const d = e._clip.uuid
          , g = this._actionsByClip
          , _ = g[d]
          , b = _.knownActions
          , j = b[b.length - 1]
          , $ = e._byClipCacheIndex;
        j._byClipCacheIndex = $,
        b[$] = j,
        b.pop(),
        e._byClipCacheIndex = null;
        const nt = _.actionByRoot
          , tt = (e._localRoot || this._root).uuid;
        delete nt[tt],
        b.length === 0 && delete g[d],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const a = e._propertyBindings;
        for (let o = 0, c = a.length; o !== c; ++o) {
            const d = a[o];
            --d.referenceCount === 0 && this._removeInactiveBinding(d)
        }
    }
    _lendAction(e) {
        const a = this._actions
          , o = e._cacheIndex
          , c = this._nActiveActions++
          , d = a[c];
        e._cacheIndex = c,
        a[c] = e,
        d._cacheIndex = o,
        a[o] = d
    }
    _takeBackAction(e) {
        const a = this._actions
          , o = e._cacheIndex
          , c = --this._nActiveActions
          , d = a[c];
        e._cacheIndex = c,
        a[c] = e,
        d._cacheIndex = o,
        a[o] = d
    }
    _addInactiveBinding(e, a, o) {
        const c = this._bindingsByRootAndName
          , d = this._bindings;
        let g = c[a];
        g === void 0 && (g = {},
        c[a] = g),
        g[o] = e,
        e._cacheIndex = d.length,
        d.push(e)
    }
    _removeInactiveBinding(e) {
        const a = this._bindings
          , o = e.binding
          , c = o.rootNode.uuid
          , d = o.path
          , g = this._bindingsByRootAndName
          , _ = g[c]
          , b = a[a.length - 1]
          , j = e._cacheIndex;
        b._cacheIndex = j,
        a[j] = b,
        a.pop(),
        delete _[d],
        Object.keys(_).length === 0 && delete g[c]
    }
    _lendBinding(e) {
        const a = this._bindings
          , o = e._cacheIndex
          , c = this._nActiveBindings++
          , d = a[c];
        e._cacheIndex = c,
        a[c] = e,
        d._cacheIndex = o,
        a[o] = d
    }
    _takeBackBinding(e) {
        const a = this._bindings
          , o = e._cacheIndex
          , c = --this._nActiveBindings
          , d = a[c];
        e._cacheIndex = c,
        a[c] = e,
        d._cacheIndex = o,
        a[o] = d
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , a = this._nActiveControlInterpolants++;
        let o = e[a];
        return o === void 0 && (o = new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),
        o.__cacheIndex = a,
        e[a] = o),
        o
    }
    _takeBackControlInterpolant(e) {
        const a = this._controlInterpolants
          , o = e.__cacheIndex
          , c = --this._nActiveControlInterpolants
          , d = a[c];
        e.__cacheIndex = c,
        a[c] = e,
        d.__cacheIndex = o,
        a[o] = d
    }
    clipAction(e, a, o) {
        const c = a || this._root
          , d = c.uuid;
        let g = typeof e == "string" ? AnimationClip.findByName(c, e) : e;
        const _ = g !== null ? g.uuid : e
          , b = this._actionsByClip[_];
        let j = null;
        if (o === void 0 && (g !== null ? o = g.blendMode : o = NormalAnimationBlendMode),
        b !== void 0) {
            const nt = b.actionByRoot[d];
            if (nt !== void 0 && nt.blendMode === o)
                return nt;
            j = b.knownActions[0],
            g === null && (g = j._clip)
        }
        if (g === null)
            return null;
        const $ = new AnimationAction(this,g,a,o);
        return this._bindAction($, j),
        this._addInactiveAction($, _, d),
        $
    }
    existingAction(e, a) {
        const o = a || this._root
          , c = o.uuid
          , d = typeof e == "string" ? AnimationClip.findByName(o, e) : e
          , g = d ? d.uuid : e
          , _ = this._actionsByClip[g];
        return _ !== void 0 && _.actionByRoot[c] || null
    }
    stopAllAction() {
        const e = this._actions
          , a = this._nActiveActions;
        for (let o = a - 1; o >= 0; --o)
            e[o].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const a = this._actions
          , o = this._nActiveActions
          , c = this.time += e
          , d = Math.sign(e)
          , g = this._accuIndex ^= 1;
        for (let j = 0; j !== o; ++j)
            a[j]._update(c, e, d, g);
        const _ = this._bindings
          , b = this._nActiveBindings;
        for (let j = 0; j !== b; ++j)
            _[j].apply(g);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let a = 0; a < this._actions.length; a++)
            this._actions[a].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const a = this._actions
          , o = e.uuid
          , c = this._actionsByClip
          , d = c[o];
        if (d !== void 0) {
            const g = d.knownActions;
            for (let _ = 0, b = g.length; _ !== b; ++_) {
                const j = g[_];
                this._deactivateAction(j);
                const $ = j._cacheIndex
                  , nt = a[a.length - 1];
                j._cacheIndex = null,
                j._byClipCacheIndex = null,
                nt._cacheIndex = $,
                a[$] = nt,
                a.pop(),
                this._removeInactiveBindingsForAction(j)
            }
            delete c[o]
        }
    }
    uncacheRoot(e) {
        const a = e.uuid
          , o = this._actionsByClip;
        for (const g in o) {
            const _ = o[g].actionByRoot
              , b = _[a];
            b !== void 0 && (this._deactivateAction(b),
            this._removeInactiveAction(b))
        }
        const c = this._bindingsByRootAndName
          , d = c[a];
        if (d !== void 0)
            for (const g in d) {
                const _ = d[g];
                _.restoreOriginalState(),
                this._removeInactiveBinding(_)
            }
    }
    uncacheAction(e, a) {
        const o = this.existingAction(e, a);
        o !== null && (this._deactivateAction(o),
        this._removeInactiveAction(o))
    }
}
class Uniform {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let _id = 0;
class UniformsGroup extends EventDispatcher {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: _id++
        }),
        this.name = "",
        this.usage = StaticDrawUsage,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const a = this.uniforms.indexOf(e);
        return a !== -1 && this.uniforms.splice(a, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const a = e.uniforms;
        this.uniforms.length = 0;
        for (let o = 0, c = a.length; o < c; o++) {
            const d = Array.isArray(a[o]) ? a[o] : [a[o]];
            for (let g = 0; g < d.length; g++)
                this.uniforms.push(d[g].clone())
        }
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
    constructor(e, a, o=1) {
        super(e, a),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = o
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const a = super.clone(e);
        return a.meshPerAttribute = this.meshPerAttribute,
        a
    }
    toJSON(e) {
        const a = super.toJSON(e);
        return a.isInstancedInterleavedBuffer = !0,
        a.meshPerAttribute = this.meshPerAttribute,
        a
    }
}
class GLBufferAttribute {
    constructor(e, a, o, c, d) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = a,
        this.itemSize = o,
        this.elementSize = c,
        this.count = d,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, a) {
        return this.type = e,
        this.elementSize = a,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
const _matrix = new Matrix4;
class Raycaster {
    constructor(e, a, o=0, c=1 / 0) {
        this.ray = new Ray(e,a),
        this.near = o,
        this.far = c,
        this.camera = null,
        this.layers = new Layers,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, a) {
        this.ray.set(e, a)
    }
    setFromCamera(e, a) {
        a.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(a.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(a).sub(this.ray.origin).normalize(),
        this.camera = a) : a.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (a.near + a.far) / (a.near - a.far)).unproject(a),
        this.ray.direction.set(0, 0, -1).transformDirection(a.matrixWorld),
        this.camera = a) : console.error("THREE.Raycaster: Unsupported camera type: " + a.type)
    }
    setFromXRController(e) {
        return _matrix.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix),
        this
    }
    intersectObject(e, a=!0, o=[]) {
        return intersect(e, this, o, a),
        o.sort(ascSort),
        o
    }
    intersectObjects(e, a=!0, o=[]) {
        for (let c = 0, d = e.length; c < d; c++)
            intersect(e[c], this, o, a);
        return o.sort(ascSort),
        o
    }
}
function ascSort(s, e) {
    return s.distance - e.distance
}
function intersect(s, e, a, o) {
    let c = !0;
    if (s.layers.test(e.layers) && s.raycast(e, a) === !1 && (c = !1),
    c === !0 && o === !0) {
        const d = s.children;
        for (let g = 0, _ = d.length; g < _; g++)
            intersect(d[g], e, a, !0)
    }
}
class Spherical {
    constructor(e=1, a=0, o=0) {
        return this.radius = e,
        this.phi = a,
        this.theta = o,
        this
    }
    set(e, a, o) {
        return this.radius = e,
        this.phi = a,
        this.theta = o,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, a, o) {
        return this.radius = Math.sqrt(e * e + a * a + o * o),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, o),
        this.phi = Math.acos(clamp(a / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Cylindrical {
    constructor(e=1, a=0, o=0) {
        return this.radius = e,
        this.theta = a,
        this.y = o,
        this
    }
    set(e, a, o) {
        return this.radius = e,
        this.theta = a,
        this.y = o,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, a, o) {
        return this.radius = Math.sqrt(e * e + o * o),
        this.theta = Math.atan2(e, o),
        this.y = a,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Matrix2 {
    constructor(e, a, o, c) {
        Matrix2.prototype.isMatrix2 = !0,
        this.elements = [1, 0, 0, 1],
        e !== void 0 && this.set(e, a, o, c)
    }
    identity() {
        return this.set(1, 0, 0, 1),
        this
    }
    fromArray(e, a=0) {
        for (let o = 0; o < 4; o++)
            this.elements[o] = e[o + a];
        return this
    }
    set(e, a, o, c) {
        const d = this.elements;
        return d[0] = e,
        d[2] = a,
        d[1] = o,
        d[3] = c,
        this
    }
}
const _vector$4 = new Vector2;
class Box2 {
    constructor(e=new Vector2(1 / 0,1 / 0), a=new Vector2(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = a
    }
    set(e, a) {
        return this.min.copy(e),
        this.max.copy(a),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let a = 0, o = e.length; a < o; a++)
            this.expandByPoint(e[a]);
        return this
    }
    setFromCenterAndSize(e, a) {
        const o = _vector$4.copy(a).multiplyScalar(.5);
        return this.min.copy(e).sub(o),
        this.max.copy(e).add(o),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, a) {
        return a.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
    }
    clampPoint(e, a) {
        return a.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, _vector$4).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const _startP = new Vector3
  , _startEnd = new Vector3;
class Line3 {
    constructor(e=new Vector3, a=new Vector3) {
        this.start = e,
        this.end = a
    }
    set(e, a) {
        return this.start.copy(e),
        this.end.copy(a),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, a) {
        return this.delta(a).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, a) {
        _startP.subVectors(e, this.start),
        _startEnd.subVectors(this.end, this.start);
        const o = _startEnd.dot(_startEnd);
        let d = _startEnd.dot(_startP) / o;
        return a && (d = clamp(d, 0, 1)),
        d
    }
    closestPointToPoint(e, a, o) {
        const c = this.closestPointToPointParameter(e, a);
        return this.delta(o).multiplyScalar(c).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _vector$3 = new Vector3;
class SpotLightHelper extends Object3D {
    constructor(e, a) {
        super(),
        this.light = e,
        this.matrixAutoUpdate = !1,
        this.color = a,
        this.type = "SpotLightHelper";
        const o = new BufferGeometry
          , c = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let g = 0, _ = 1, b = 32; g < b; g++,
        _++) {
            const j = g / b * Math.PI * 2
              , $ = _ / b * Math.PI * 2;
            c.push(Math.cos(j), Math.sin(j), 1, Math.cos($), Math.sin($), 1)
        }
        o.setAttribute("position", new Float32BufferAttribute(c,3));
        const d = new LineBasicMaterial({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new LineSegments(o,d),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        this.parent ? (this.parent.updateWorldMatrix(!0),
        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
        this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3
          , a = e * Math.tan(this.light.angle);
        this.cone.scale.set(a, a, e),
        _vector$3.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(_vector$3),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const _vector$2 = new Vector3
  , _boneMatrix = new Matrix4
  , _matrixWorldInv = new Matrix4;
class SkeletonHelper extends LineSegments {
    constructor(e) {
        const a = getBoneList(e)
          , o = new BufferGeometry
          , c = []
          , d = []
          , g = new Color(0,0,1)
          , _ = new Color(0,1,0);
        for (let j = 0; j < a.length; j++) {
            const $ = a[j];
            $.parent && $.parent.isBone && (c.push(0, 0, 0),
            c.push(0, 0, 0),
            d.push(g.r, g.g, g.b),
            d.push(_.r, _.g, _.b))
        }
        o.setAttribute("position", new Float32BufferAttribute(c,3)),
        o.setAttribute("color", new Float32BufferAttribute(d,3));
        const b = new LineBasicMaterial({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(o, b),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = a,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const a = this.bones
          , o = this.geometry
          , c = o.getAttribute("position");
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for (let d = 0, g = 0; d < a.length; d++) {
            const _ = a[d];
            _.parent && _.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, _.matrixWorld),
            _vector$2.setFromMatrixPosition(_boneMatrix),
            c.setXYZ(g, _vector$2.x, _vector$2.y, _vector$2.z),
            _boneMatrix.multiplyMatrices(_matrixWorldInv, _.parent.matrixWorld),
            _vector$2.setFromMatrixPosition(_boneMatrix),
            c.setXYZ(g + 1, _vector$2.x, _vector$2.y, _vector$2.z),
            g += 2)
        }
        o.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function getBoneList(s) {
    const e = [];
    s.isBone === !0 && e.push(s);
    for (let a = 0; a < s.children.length; a++)
        e.push.apply(e, getBoneList(s.children[a]));
    return e
}
class PointLightHelper extends Mesh {
    constructor(e, a, o) {
        const c = new SphereGeometry(a,4,2)
          , d = new MeshBasicMaterial({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(c, d),
        this.light = e,
        this.color = o,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const _vector$1 = new Vector3
  , _color1 = new Color
  , _color2 = new Color;
class HemisphereLightHelper extends Object3D {
    constructor(e, a, o) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = o,
        this.type = "HemisphereLightHelper";
        const c = new OctahedronGeometry(a);
        c.rotateY(Math.PI * .5),
        this.material = new MeshBasicMaterial({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const d = c.getAttribute("position")
          , g = new Float32Array(d.count * 3);
        c.setAttribute("color", new BufferAttribute(g,3)),
        this.add(new Mesh(c,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const a = e.geometry.getAttribute("color");
            _color1.copy(this.light.color),
            _color2.copy(this.light.groundColor);
            for (let o = 0, c = a.count; o < c; o++) {
                const d = o < c / 2 ? _color1 : _color2;
                a.setXYZ(o, d.r, d.g, d.b)
            }
            a.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class GridHelper extends LineSegments {
    constructor(e=10, a=10, o=4473924, c=8947848) {
        o = new Color(o),
        c = new Color(c);
        const d = a / 2
          , g = e / a
          , _ = e / 2
          , b = []
          , j = [];
        for (let tt = 0, rt = 0, st = -_; tt <= a; tt++,
        st += g) {
            b.push(-_, 0, st, _, 0, st),
            b.push(st, 0, -_, st, 0, _);
            const lt = tt === d ? o : c;
            lt.toArray(j, rt),
            rt += 3,
            lt.toArray(j, rt),
            rt += 3,
            lt.toArray(j, rt),
            rt += 3,
            lt.toArray(j, rt),
            rt += 3
        }
        const $ = new BufferGeometry;
        $.setAttribute("position", new Float32BufferAttribute(b,3)),
        $.setAttribute("color", new Float32BufferAttribute(j,3));
        const nt = new LineBasicMaterial({
            vertexColors: !0,
            toneMapped: !1
        });
        super($, nt),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class PolarGridHelper extends LineSegments {
    constructor(e=10, a=16, o=8, c=64, d=4473924, g=8947848) {
        d = new Color(d),
        g = new Color(g);
        const _ = []
          , b = [];
        if (a > 1)
            for (let nt = 0; nt < a; nt++) {
                const tt = nt / a * (Math.PI * 2)
                  , rt = Math.sin(tt) * e
                  , st = Math.cos(tt) * e;
                _.push(0, 0, 0),
                _.push(rt, 0, st);
                const lt = nt & 1 ? d : g;
                b.push(lt.r, lt.g, lt.b),
                b.push(lt.r, lt.g, lt.b)
            }
        for (let nt = 0; nt < o; nt++) {
            const tt = nt & 1 ? d : g
              , rt = e - e / o * nt;
            for (let st = 0; st < c; st++) {
                let lt = st / c * (Math.PI * 2)
                  , ct = Math.sin(lt) * rt
                  , it = Math.cos(lt) * rt;
                _.push(ct, 0, it),
                b.push(tt.r, tt.g, tt.b),
                lt = (st + 1) / c * (Math.PI * 2),
                ct = Math.sin(lt) * rt,
                it = Math.cos(lt) * rt,
                _.push(ct, 0, it),
                b.push(tt.r, tt.g, tt.b)
            }
        }
        const j = new BufferGeometry;
        j.setAttribute("position", new Float32BufferAttribute(_,3)),
        j.setAttribute("color", new Float32BufferAttribute(b,3));
        const $ = new LineBasicMaterial({
            vertexColors: !0,
            toneMapped: !1
        });
        super(j, $),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const _v1 = new Vector3
  , _v2 = new Vector3
  , _v3 = new Vector3;
class DirectionalLightHelper extends Object3D {
    constructor(e, a, o) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = o,
        this.type = "DirectionalLightHelper",
        a === void 0 && (a = 1);
        let c = new BufferGeometry;
        c.setAttribute("position", new Float32BufferAttribute([-a, a, 0, a, a, 0, a, -a, 0, -a, -a, 0, -a, a, 0],3));
        const d = new LineBasicMaterial({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Line(c,d),
        this.add(this.lightPlane),
        c = new BufferGeometry,
        c.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Line(c,d),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        _v1.setFromMatrixPosition(this.light.matrixWorld),
        _v2.setFromMatrixPosition(this.light.target.matrixWorld),
        _v3.subVectors(_v2, _v1),
        this.lightPlane.lookAt(_v2),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(_v2),
        this.targetLine.scale.z = _v3.length()
    }
}
const _vector = new Vector3
  , _camera = new Camera;
class CameraHelper extends LineSegments {
    constructor(e) {
        const a = new BufferGeometry
          , o = new LineBasicMaterial({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , c = []
          , d = []
          , g = {};
        _("n1", "n2"),
        _("n2", "n4"),
        _("n4", "n3"),
        _("n3", "n1"),
        _("f1", "f2"),
        _("f2", "f4"),
        _("f4", "f3"),
        _("f3", "f1"),
        _("n1", "f1"),
        _("n2", "f2"),
        _("n3", "f3"),
        _("n4", "f4"),
        _("p", "n1"),
        _("p", "n2"),
        _("p", "n3"),
        _("p", "n4"),
        _("u1", "u2"),
        _("u2", "u3"),
        _("u3", "u1"),
        _("c", "t"),
        _("p", "c"),
        _("cn1", "cn2"),
        _("cn3", "cn4"),
        _("cf1", "cf2"),
        _("cf3", "cf4");
        function _(st, lt) {
            b(st),
            b(lt)
        }
        function b(st) {
            c.push(0, 0, 0),
            d.push(0, 0, 0),
            g[st] === void 0 && (g[st] = []),
            g[st].push(c.length / 3 - 1)
        }
        a.setAttribute("position", new Float32BufferAttribute(c,3)),
        a.setAttribute("color", new Float32BufferAttribute(d,3)),
        super(a, o),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = g,
        this.update();
        const j = new Color(16755200)
          , $ = new Color(16711680)
          , nt = new Color(43775)
          , tt = new Color(16777215)
          , rt = new Color(3355443);
        this.setColors(j, $, nt, tt, rt)
    }
    setColors(e, a, o, c, d) {
        const _ = this.geometry.getAttribute("color");
        _.setXYZ(0, e.r, e.g, e.b),
        _.setXYZ(1, e.r, e.g, e.b),
        _.setXYZ(2, e.r, e.g, e.b),
        _.setXYZ(3, e.r, e.g, e.b),
        _.setXYZ(4, e.r, e.g, e.b),
        _.setXYZ(5, e.r, e.g, e.b),
        _.setXYZ(6, e.r, e.g, e.b),
        _.setXYZ(7, e.r, e.g, e.b),
        _.setXYZ(8, e.r, e.g, e.b),
        _.setXYZ(9, e.r, e.g, e.b),
        _.setXYZ(10, e.r, e.g, e.b),
        _.setXYZ(11, e.r, e.g, e.b),
        _.setXYZ(12, e.r, e.g, e.b),
        _.setXYZ(13, e.r, e.g, e.b),
        _.setXYZ(14, e.r, e.g, e.b),
        _.setXYZ(15, e.r, e.g, e.b),
        _.setXYZ(16, e.r, e.g, e.b),
        _.setXYZ(17, e.r, e.g, e.b),
        _.setXYZ(18, e.r, e.g, e.b),
        _.setXYZ(19, e.r, e.g, e.b),
        _.setXYZ(20, e.r, e.g, e.b),
        _.setXYZ(21, e.r, e.g, e.b),
        _.setXYZ(22, e.r, e.g, e.b),
        _.setXYZ(23, e.r, e.g, e.b),
        _.setXYZ(24, a.r, a.g, a.b),
        _.setXYZ(25, a.r, a.g, a.b),
        _.setXYZ(26, a.r, a.g, a.b),
        _.setXYZ(27, a.r, a.g, a.b),
        _.setXYZ(28, a.r, a.g, a.b),
        _.setXYZ(29, a.r, a.g, a.b),
        _.setXYZ(30, a.r, a.g, a.b),
        _.setXYZ(31, a.r, a.g, a.b),
        _.setXYZ(32, o.r, o.g, o.b),
        _.setXYZ(33, o.r, o.g, o.b),
        _.setXYZ(34, o.r, o.g, o.b),
        _.setXYZ(35, o.r, o.g, o.b),
        _.setXYZ(36, o.r, o.g, o.b),
        _.setXYZ(37, o.r, o.g, o.b),
        _.setXYZ(38, c.r, c.g, c.b),
        _.setXYZ(39, c.r, c.g, c.b),
        _.setXYZ(40, d.r, d.g, d.b),
        _.setXYZ(41, d.r, d.g, d.b),
        _.setXYZ(42, d.r, d.g, d.b),
        _.setXYZ(43, d.r, d.g, d.b),
        _.setXYZ(44, d.r, d.g, d.b),
        _.setXYZ(45, d.r, d.g, d.b),
        _.setXYZ(46, d.r, d.g, d.b),
        _.setXYZ(47, d.r, d.g, d.b),
        _.setXYZ(48, d.r, d.g, d.b),
        _.setXYZ(49, d.r, d.g, d.b),
        _.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , a = this.pointMap
          , o = 1
          , c = 1;
        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        setPoint("c", a, e, _camera, 0, 0, -1),
        setPoint("t", a, e, _camera, 0, 0, 1),
        setPoint("n1", a, e, _camera, -o, -c, -1),
        setPoint("n2", a, e, _camera, o, -c, -1),
        setPoint("n3", a, e, _camera, -o, c, -1),
        setPoint("n4", a, e, _camera, o, c, -1),
        setPoint("f1", a, e, _camera, -o, -c, 1),
        setPoint("f2", a, e, _camera, o, -c, 1),
        setPoint("f3", a, e, _camera, -o, c, 1),
        setPoint("f4", a, e, _camera, o, c, 1),
        setPoint("u1", a, e, _camera, o * .7, c * 1.1, -1),
        setPoint("u2", a, e, _camera, -o * .7, c * 1.1, -1),
        setPoint("u3", a, e, _camera, 0, c * 2, -1),
        setPoint("cf1", a, e, _camera, -o, 0, 1),
        setPoint("cf2", a, e, _camera, o, 0, 1),
        setPoint("cf3", a, e, _camera, 0, -c, 1),
        setPoint("cf4", a, e, _camera, 0, c, 1),
        setPoint("cn1", a, e, _camera, -o, 0, -1),
        setPoint("cn2", a, e, _camera, o, 0, -1),
        setPoint("cn3", a, e, _camera, 0, -c, -1),
        setPoint("cn4", a, e, _camera, 0, c, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function setPoint(s, e, a, o, c, d, g) {
    _vector.set(c, d, g).unproject(o);
    const _ = e[s];
    if (_ !== void 0) {
        const b = a.getAttribute("position");
        for (let j = 0, $ = _.length; j < $; j++)
            b.setXYZ(_[j], _vector.x, _vector.y, _vector.z)
    }
}
const _box = new Box3;
class BoxHelper extends LineSegments {
    constructor(e, a=16776960) {
        const o = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , c = new Float32Array(8 * 3)
          , d = new BufferGeometry;
        d.setIndex(new BufferAttribute(o,1)),
        d.setAttribute("position", new BufferAttribute(c,3)),
        super(d, new LineBasicMaterial({
            color: a,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && _box.setFromObject(this.object),
        _box.isEmpty())
            return;
        const a = _box.min
          , o = _box.max
          , c = this.geometry.attributes.position
          , d = c.array;
        d[0] = o.x,
        d[1] = o.y,
        d[2] = o.z,
        d[3] = a.x,
        d[4] = o.y,
        d[5] = o.z,
        d[6] = a.x,
        d[7] = a.y,
        d[8] = o.z,
        d[9] = o.x,
        d[10] = a.y,
        d[11] = o.z,
        d[12] = o.x,
        d[13] = o.y,
        d[14] = a.z,
        d[15] = a.x,
        d[16] = o.y,
        d[17] = a.z,
        d[18] = a.x,
        d[19] = a.y,
        d[20] = a.z,
        d[21] = o.x,
        d[22] = a.y,
        d[23] = a.z,
        c.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, a) {
        return super.copy(e, a),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class Box3Helper extends LineSegments {
    constructor(e, a=16776960) {
        const o = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , c = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , d = new BufferGeometry;
        d.setIndex(new BufferAttribute(o,1)),
        d.setAttribute("position", new Float32BufferAttribute(c,3)),
        super(d, new LineBasicMaterial({
            color: a,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const a = this.box;
        a.isEmpty() || (a.getCenter(this.position),
        a.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class PlaneHelper extends Line {
    constructor(e, a=1, o=16776960) {
        const c = o
          , d = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , g = new BufferGeometry;
        g.setAttribute("position", new Float32BufferAttribute(d,3)),
        g.computeBoundingSphere(),
        super(g, new LineBasicMaterial({
            color: c,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = a;
        const _ = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , b = new BufferGeometry;
        b.setAttribute("position", new Float32BufferAttribute(_,3)),
        b.computeBoundingSphere(),
        this.add(new Mesh(b,new MeshBasicMaterial({
            color: c,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const _axis = new Vector3;
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
    constructor(e=new Vector3(0,0,1), a=new Vector3(0,0,0), o=1, c=16776960, d=o * .2, g=d * .2) {
        super(),
        this.type = "ArrowHelper",
        _lineGeometry === void 0 && (_lineGeometry = new BufferGeometry,
        _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0],3)),
        _coneGeometry = new CylinderGeometry(0,.5,1,5,1),
        _coneGeometry.translate(0, -.5, 0)),
        this.position.copy(a),
        this.line = new Line(_lineGeometry,new LineBasicMaterial({
            color: c,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Mesh(_coneGeometry,new MeshBasicMaterial({
            color: c,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(o, d, g)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            _axis.set(e.z, 0, -e.x).normalize();
            const a = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(_axis, a)
        }
    }
    setLength(e, a=e * .2, o=a * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - a), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(o, a, o),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class AxesHelper extends LineSegments {
    constructor(e=1) {
        const a = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , o = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , c = new BufferGeometry;
        c.setAttribute("position", new Float32BufferAttribute(a,3)),
        c.setAttribute("color", new Float32BufferAttribute(o,3));
        const d = new LineBasicMaterial({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, d),
        this.type = "AxesHelper"
    }
    setColors(e, a, o) {
        const c = new Color
          , d = this.geometry.attributes.color.array;
        return c.set(e),
        c.toArray(d, 0),
        c.toArray(d, 3),
        c.set(a),
        c.toArray(d, 6),
        c.toArray(d, 9),
        c.set(o),
        c.toArray(d, 12),
        c.toArray(d, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class ShapePath {
    constructor() {
        this.type = "ShapePath",
        this.color = new Color,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, a) {
        return this.currentPath = new Path,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, a),
        this
    }
    lineTo(e, a) {
        return this.currentPath.lineTo(e, a),
        this
    }
    quadraticCurveTo(e, a, o, c) {
        return this.currentPath.quadraticCurveTo(e, a, o, c),
        this
    }
    bezierCurveTo(e, a, o, c, d, g) {
        return this.currentPath.bezierCurveTo(e, a, o, c, d, g),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function a(it) {
            const ot = [];
            for (let at = 0, ht = it.length; at < ht; at++) {
                const pt = it[at]
                  , dt = new Shape;
                dt.curves = pt.curves,
                ot.push(dt)
            }
            return ot
        }
        function o(it, ot) {
            const at = ot.length;
            let ht = !1;
            for (let pt = at - 1, dt = 0; dt < at; pt = dt++) {
                let yt = ot[pt]
                  , vt = ot[dt]
                  , xt = vt.x - yt.x
                  , _t = vt.y - yt.y;
                if (Math.abs(_t) > Number.EPSILON) {
                    if (_t < 0 && (yt = ot[dt],
                    xt = -xt,
                    vt = ot[pt],
                    _t = -_t),
                    it.y < yt.y || it.y > vt.y)
                        continue;
                    if (it.y === yt.y) {
                        if (it.x === yt.x)
                            return !0
                    } else {
                        const bt = _t * (it.x - yt.x) - xt * (it.y - yt.y);
                        if (bt === 0)
                            return !0;
                        if (bt < 0)
                            continue;
                        ht = !ht
                    }
                } else {
                    if (it.y !== yt.y)
                        continue;
                    if (vt.x <= it.x && it.x <= yt.x || yt.x <= it.x && it.x <= vt.x)
                        return !0
                }
            }
            return ht
        }
        const c = ShapeUtils.isClockWise
          , d = this.subPaths;
        if (d.length === 0)
            return [];
        let g, _, b;
        const j = [];
        if (d.length === 1)
            return _ = d[0],
            b = new Shape,
            b.curves = _.curves,
            j.push(b),
            j;
        let $ = !c(d[0].getPoints());
        $ = e ? !$ : $;
        const nt = []
          , tt = [];
        let rt = [], st = 0, lt;
        tt[st] = void 0,
        rt[st] = [];
        for (let it = 0, ot = d.length; it < ot; it++)
            _ = d[it],
            lt = _.getPoints(),
            g = c(lt),
            g = e ? !g : g,
            g ? (!$ && tt[st] && st++,
            tt[st] = {
                s: new Shape,
                p: lt
            },
            tt[st].s.curves = _.curves,
            $ && st++,
            rt[st] = []) : rt[st].push({
                h: _,
                p: lt[0]
            });
        if (!tt[0])
            return a(d);
        if (tt.length > 1) {
            let it = !1
              , ot = 0;
            for (let at = 0, ht = tt.length; at < ht; at++)
                nt[at] = [];
            for (let at = 0, ht = tt.length; at < ht; at++) {
                const pt = rt[at];
                for (let dt = 0; dt < pt.length; dt++) {
                    const yt = pt[dt];
                    let vt = !0;
                    for (let xt = 0; xt < tt.length; xt++)
                        o(yt.p, tt[xt].p) && (at !== xt && ot++,
                        vt ? (vt = !1,
                        nt[xt].push(yt)) : it = !0);
                    vt && nt[at].push(yt)
                }
            }
            ot > 0 && it === !1 && (rt = nt)
        }
        let ct;
        for (let it = 0, ot = tt.length; it < ot; it++) {
            b = tt[it].s,
            j.push(b),
            ct = rt[it];
            for (let at = 0, ht = ct.length; at < ht; at++)
                b.holes.push(ct[at].h)
        }
        return j
    }
}
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
    constructor(e=1, a=1, o=1, c={}) {
        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),
        super(e, a, {
            ...c,
            count: o
        }),
        this.isWebGLMultipleRenderTargets = !0
    }
    get texture() {
        return this.textures
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: REVISION
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
const THREE = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping,
    AddEquation,
    AddOperation,
    AdditiveAnimationBlendMode,
    AdditiveBlending,
    AgXToneMapping,
    AlphaFormat,
    AlwaysCompare,
    AlwaysDepth,
    AlwaysStencilFunc,
    AmbientLight,
    AnimationAction,
    AnimationClip,
    AnimationLoader,
    AnimationMixer,
    AnimationObjectGroup,
    AnimationUtils,
    ArcCurve,
    ArrayCamera,
    ArrowHelper,
    AttachedBindMode,
    Audio,
    AudioAnalyser,
    AudioContext,
    AudioListener,
    AudioLoader,
    AxesHelper,
    BackSide,
    BasicDepthPacking,
    BasicShadowMap,
    BatchedMesh,
    Bone,
    BooleanKeyframeTrack,
    Box2,
    Box3,
    Box3Helper,
    BoxGeometry,
    BoxHelper,
    BufferAttribute,
    BufferGeometry,
    BufferGeometryLoader,
    ByteType,
    Cache,
    Camera,
    CameraHelper,
    CanvasTexture,
    CapsuleGeometry,
    CatmullRomCurve3,
    CineonToneMapping,
    CircleGeometry,
    ClampToEdgeWrapping,
    Clock,
    Color,
    ColorKeyframeTrack,
    ColorManagement,
    CompressedArrayTexture,
    CompressedCubeTexture,
    CompressedTexture,
    CompressedTextureLoader,
    ConeGeometry,
    ConstantAlphaFactor,
    ConstantColorFactor,
    CubeCamera,
    CubeReflectionMapping,
    CubeRefractionMapping,
    CubeTexture,
    CubeTextureLoader,
    CubeUVReflectionMapping,
    CubicBezierCurve,
    CubicBezierCurve3,
    CubicInterpolant,
    CullFaceBack,
    CullFaceFront,
    CullFaceFrontBack,
    CullFaceNone,
    Curve,
    CurvePath,
    CustomBlending,
    CustomToneMapping,
    CylinderGeometry,
    Cylindrical,
    Data3DTexture,
    DataArrayTexture,
    DataTexture,
    DataTextureLoader,
    DataUtils,
    DecrementStencilOp,
    DecrementWrapStencilOp,
    DefaultLoadingManager,
    DepthFormat,
    DepthStencilFormat,
    DepthTexture,
    DetachedBindMode,
    DirectionalLight,
    DirectionalLightHelper,
    DiscreteInterpolant,
    DisplayP3ColorSpace,
    DodecahedronGeometry,
    DoubleSide,
    DstAlphaFactor,
    DstColorFactor,
    DynamicCopyUsage,
    DynamicDrawUsage,
    DynamicReadUsage,
    EdgesGeometry,
    EllipseCurve,
    EqualCompare,
    EqualDepth,
    EqualStencilFunc,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    Euler,
    EventDispatcher,
    ExtrudeGeometry,
    FileLoader,
    Float16BufferAttribute,
    Float32BufferAttribute,
    FloatType,
    Fog,
    FogExp2,
    FramebufferTexture,
    FrontSide,
    Frustum,
    GLBufferAttribute,
    GLSL1,
    GLSL3,
    GreaterCompare,
    GreaterDepth,
    GreaterEqualCompare,
    GreaterEqualDepth,
    GreaterEqualStencilFunc,
    GreaterStencilFunc,
    GridHelper,
    Group,
    HalfFloatType,
    HemisphereLight,
    HemisphereLightHelper,
    IcosahedronGeometry,
    ImageBitmapLoader,
    ImageLoader,
    ImageUtils,
    IncrementStencilOp,
    IncrementWrapStencilOp,
    InstancedBufferAttribute,
    InstancedBufferGeometry,
    InstancedInterleavedBuffer,
    InstancedMesh,
    Int16BufferAttribute,
    Int32BufferAttribute,
    Int8BufferAttribute,
    IntType,
    InterleavedBuffer,
    InterleavedBufferAttribute,
    Interpolant,
    InterpolateDiscrete,
    InterpolateLinear,
    InterpolateSmooth,
    InvertStencilOp,
    KeepStencilOp,
    KeyframeTrack,
    LOD,
    LatheGeometry,
    Layers,
    LessCompare,
    LessDepth,
    LessEqualCompare,
    LessEqualDepth,
    LessEqualStencilFunc,
    LessStencilFunc,
    Light,
    LightProbe,
    Line,
    Line3,
    LineBasicMaterial,
    LineCurve,
    LineCurve3,
    LineDashedMaterial,
    LineLoop,
    LineSegments,
    LinearDisplayP3ColorSpace,
    LinearFilter,
    LinearInterpolant,
    LinearMipMapLinearFilter,
    LinearMipMapNearestFilter,
    LinearMipmapLinearFilter,
    LinearMipmapNearestFilter,
    LinearSRGBColorSpace,
    LinearToneMapping,
    LinearTransfer,
    Loader: Loader$1,
    LoaderUtils,
    LoadingManager,
    LoopOnce,
    LoopPingPong,
    LoopRepeat,
    LuminanceAlphaFormat,
    LuminanceFormat,
    MOUSE,
    Material,
    MaterialLoader,
    MathUtils,
    Matrix2,
    Matrix3,
    Matrix4,
    MaxEquation,
    Mesh,
    MeshBasicMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshLambertMaterial,
    MeshMatcapMaterial,
    MeshNormalMaterial,
    MeshPhongMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshToonMaterial,
    MinEquation,
    MirroredRepeatWrapping,
    MixOperation,
    MultiplyBlending,
    MultiplyOperation,
    NearestFilter,
    NearestMipMapLinearFilter,
    NearestMipMapNearestFilter,
    NearestMipmapLinearFilter,
    NearestMipmapNearestFilter,
    NeutralToneMapping,
    NeverCompare,
    NeverDepth,
    NeverStencilFunc,
    NoBlending,
    NoColorSpace,
    NoToneMapping,
    NormalAnimationBlendMode,
    NormalBlending,
    NotEqualCompare,
    NotEqualDepth,
    NotEqualStencilFunc,
    NumberKeyframeTrack,
    Object3D,
    ObjectLoader,
    ObjectSpaceNormalMap,
    OctahedronGeometry,
    OneFactor,
    OneMinusConstantAlphaFactor,
    OneMinusConstantColorFactor,
    OneMinusDstAlphaFactor,
    OneMinusDstColorFactor,
    OneMinusSrcAlphaFactor,
    OneMinusSrcColorFactor,
    OrthographicCamera,
    P3Primaries,
    PCFShadowMap,
    PCFSoftShadowMap,
    PMREMGenerator,
    Path,
    PerspectiveCamera,
    Plane,
    PlaneGeometry,
    PlaneHelper,
    PointLight,
    PointLightHelper,
    Points: Points$1,
    PointsMaterial,
    PolarGridHelper,
    PolyhedronGeometry,
    PositionalAudio,
    PropertyBinding,
    PropertyMixer,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    Quaternion,
    QuaternionKeyframeTrack,
    QuaternionLinearInterpolant,
    RED_GREEN_RGTC2_Format,
    RED_RGTC1_Format,
    REVISION,
    RGBADepthPacking,
    RGBAFormat,
    RGBAIntegerFormat,
    RGBA_ASTC_10x10_Format,
    RGBA_ASTC_10x5_Format,
    RGBA_ASTC_10x6_Format,
    RGBA_ASTC_10x8_Format,
    RGBA_ASTC_12x10_Format,
    RGBA_ASTC_12x12_Format,
    RGBA_ASTC_4x4_Format,
    RGBA_ASTC_5x4_Format,
    RGBA_ASTC_5x5_Format,
    RGBA_ASTC_6x5_Format,
    RGBA_ASTC_6x6_Format,
    RGBA_ASTC_8x5_Format,
    RGBA_ASTC_8x6_Format,
    RGBA_ASTC_8x8_Format,
    RGBA_BPTC_Format,
    RGBA_ETC2_EAC_Format,
    RGBA_PVRTC_2BPPV1_Format,
    RGBA_PVRTC_4BPPV1_Format,
    RGBA_S3TC_DXT1_Format,
    RGBA_S3TC_DXT3_Format,
    RGBA_S3TC_DXT5_Format,
    RGBDepthPacking,
    RGBFormat,
    RGBIntegerFormat,
    RGB_BPTC_SIGNED_Format,
    RGB_BPTC_UNSIGNED_Format,
    RGB_ETC1_Format,
    RGB_ETC2_Format,
    RGB_PVRTC_2BPPV1_Format,
    RGB_PVRTC_4BPPV1_Format,
    RGB_S3TC_DXT1_Format,
    RGDepthPacking,
    RGFormat,
    RGIntegerFormat,
    RawShaderMaterial,
    Ray,
    Raycaster,
    Rec709Primaries,
    RectAreaLight,
    RedFormat,
    RedIntegerFormat,
    ReinhardToneMapping,
    RenderTarget,
    RepeatWrapping,
    ReplaceStencilOp,
    ReverseSubtractEquation,
    RingGeometry,
    SIGNED_RED_GREEN_RGTC2_Format,
    SIGNED_RED_RGTC1_Format,
    SRGBColorSpace,
    SRGBTransfer,
    Scene,
    ShaderChunk,
    ShaderLib,
    ShaderMaterial,
    ShadowMaterial,
    Shape,
    ShapeGeometry,
    ShapePath,
    ShapeUtils,
    ShortType,
    Skeleton,
    SkeletonHelper,
    SkinnedMesh,
    Source,
    Sphere,
    SphereGeometry,
    Spherical,
    SphericalHarmonics3,
    SplineCurve,
    SpotLight,
    SpotLightHelper,
    Sprite,
    SpriteMaterial,
    SrcAlphaFactor,
    SrcAlphaSaturateFactor,
    SrcColorFactor,
    StaticCopyUsage,
    StaticDrawUsage,
    StaticReadUsage,
    StereoCamera,
    StreamCopyUsage,
    StreamDrawUsage,
    StreamReadUsage,
    StringKeyframeTrack,
    SubtractEquation,
    SubtractiveBlending,
    TOUCH,
    TangentSpaceNormalMap,
    TetrahedronGeometry,
    Texture,
    TextureLoader,
    TextureUtils,
    TorusGeometry,
    TorusKnotGeometry,
    Triangle,
    TriangleFanDrawMode,
    TriangleStripDrawMode,
    TrianglesDrawMode,
    TubeGeometry,
    UVMapping,
    Uint16BufferAttribute,
    Uint32BufferAttribute,
    Uint8BufferAttribute,
    Uint8ClampedBufferAttribute,
    Uniform,
    UniformsGroup,
    UniformsLib,
    UniformsUtils,
    UnsignedByteType,
    UnsignedInt248Type,
    UnsignedInt5999Type,
    UnsignedIntType,
    UnsignedShort4444Type,
    UnsignedShort5551Type,
    UnsignedShortType,
    VSMShadowMap,
    Vector2,
    Vector3,
    Vector4,
    VectorKeyframeTrack,
    VideoTexture,
    WebGL3DRenderTarget,
    WebGLArrayRenderTarget,
    WebGLCoordinateSystem,
    WebGLCubeRenderTarget,
    WebGLMultipleRenderTargets,
    WebGLRenderTarget,
    WebGLRenderer,
    WebGLUtils,
    WebGPUCoordinateSystem,
    WireframeGeometry,
    WrapAroundEnding,
    ZeroCurvatureEnding,
    ZeroFactor,
    ZeroSlopeEnding,
    ZeroStencilOp,
    createCanvasElement
}, Symbol.toStringTag, {
    value: "Module"
}));
var constants = {
    exports: {}
}
  , reactReconcilerConstants_production_min = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
reactReconcilerConstants_production_min.ConcurrentRoot = 1;
reactReconcilerConstants_production_min.ContinuousEventPriority = 4;
reactReconcilerConstants_production_min.DefaultEventPriority = 16;
reactReconcilerConstants_production_min.DiscreteEventPriority = 1;
reactReconcilerConstants_production_min.IdleEventPriority = 536870912;
reactReconcilerConstants_production_min.LegacyRoot = 0;
constants.exports = reactReconcilerConstants_production_min;
var constantsExports = constants.exports;
function createStore$2(s) {
    let e;
    const a = new Set
      , o = (j, $) => {
        const nt = typeof j == "function" ? j(e) : j;
        if (nt !== e) {
            const tt = e;
            e = $ ? nt : Object.assign({}, e, nt),
            a.forEach(rt => rt(e, tt))
        }
    }
      , c = () => e
      , d = (j, $=c, nt=Object.is) => {
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let tt = $(e);
        function rt() {
            const st = $(e);
            if (!nt(tt, st)) {
                const lt = tt;
                j(tt = st, lt)
            }
        }
        return a.add(rt),
        () => a.delete(rt)
    }
      , b = {
        setState: o,
        getState: c,
        subscribe: (j, $, nt) => $ || nt ? d(j, $, nt) : (a.add(j),
        () => a.delete(j)),
        destroy: () => a.clear()
    };
    return e = s(o, c, b),
    b
}
const isSSR$1 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , useIsomorphicLayoutEffect$2 = isSSR$1 ? reactExports.useEffect : reactExports.useLayoutEffect;
function create$1(s) {
    const e = typeof s == "function" ? createStore$2(s) : s
      , a = (o=e.getState, c=Object.is) => {
        const [,d] = reactExports.useReducer(ct => ct + 1, 0)
          , g = e.getState()
          , _ = reactExports.useRef(g)
          , b = reactExports.useRef(o)
          , j = reactExports.useRef(c)
          , $ = reactExports.useRef(!1)
          , nt = reactExports.useRef();
        nt.current === void 0 && (nt.current = o(g));
        let tt, rt = !1;
        (_.current !== g || b.current !== o || j.current !== c || $.current) && (tt = o(g),
        rt = !c(nt.current, tt)),
        useIsomorphicLayoutEffect$2( () => {
            rt && (nt.current = tt),
            _.current = g,
            b.current = o,
            j.current = c,
            $.current = !1
        }
        );
        const st = reactExports.useRef(g);
        useIsomorphicLayoutEffect$2( () => {
            const ct = () => {
                try {
                    const ot = e.getState()
                      , at = b.current(ot);
                    j.current(nt.current, at) || (_.current = ot,
                    nt.current = at,
                    d())
                } catch {
                    $.current = !0,
                    d()
                }
            }
              , it = e.subscribe(ct);
            return e.getState() !== st.current && ct(),
            it
        }
        , []);
        const lt = rt ? tt : nt.current;
        return reactExports.useDebugValue(lt),
        lt
    }
    ;
    return Object.assign(a, e),
    a[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const o = [a, e];
        return {
            next() {
                const c = o.length <= 0;
                return {
                    value: o.shift(),
                    done: c
                }
            }
        }
    }
    ,
    a
}
const isPromise = s => typeof s == "object" && typeof s.then == "function"
  , globalCache = [];
function shallowEqualArrays(s, e, a= (o, c) => o === c) {
    if (s === e)
        return !0;
    if (!s || !e)
        return !1;
    const o = s.length;
    if (e.length !== o)
        return !1;
    for (let c = 0; c < o; c++)
        if (!a(s[c], e[c]))
            return !1;
    return !0
}
function query(s, e=null, a=!1, o={}) {
    e === null && (e = [s]);
    for (const d of globalCache)
        if (shallowEqualArrays(e, d.keys, d.equal)) {
            if (a)
                return;
            if (Object.prototype.hasOwnProperty.call(d, "error"))
                throw d.error;
            if (Object.prototype.hasOwnProperty.call(d, "response"))
                return o.lifespan && o.lifespan > 0 && (d.timeout && clearTimeout(d.timeout),
                d.timeout = setTimeout(d.remove, o.lifespan)),
                d.response;
            if (!a)
                throw d.promise
        }
    const c = {
        keys: e,
        equal: o.equal,
        remove: () => {
            const d = globalCache.indexOf(c);
            d !== -1 && globalCache.splice(d, 1)
        }
        ,
        promise: (isPromise(s) ? s : s(...e)).then(d => {
            c.response = d,
            o.lifespan && o.lifespan > 0 && (c.timeout = setTimeout(c.remove, o.lifespan))
        }
        ).catch(d => c.error = d)
    };
    if (globalCache.push(c),
    !a)
        throw c.promise
}
const suspend = (s, e, a) => query(s, e, !1, a)
  , preload = (s, e, a) => void query(s, e, !0, a)
  , clear = s => {
    if (s === void 0 || s.length === 0)
        globalCache.splice(0, globalCache.length);
    else {
        const e = globalCache.find(a => shallowEqualArrays(s, a.keys, a.equal));
        e && e.remove()
    }
}
;
var reactReconciler = {
    exports: {}
}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(s) {
    function e(mt, St) {
        var wt = mt.length;
        mt.push(St);
        e: for (; 0 < wt; ) {
            var Ct = wt - 1 >>> 1
              , Ht = mt[Ct];
            if (0 < c(Ht, St))
                mt[Ct] = St,
                mt[wt] = Ht,
                wt = Ct;
            else
                break e
        }
    }
    function a(mt) {
        return mt.length === 0 ? null : mt[0]
    }
    function o(mt) {
        if (mt.length === 0)
            return null;
        var St = mt[0]
          , wt = mt.pop();
        if (wt !== St) {
            mt[0] = wt;
            e: for (var Ct = 0, Ht = mt.length, en = Ht >>> 1; Ct < en; ) {
                var Ot = 2 * (Ct + 1) - 1
                  , Yt = mt[Ot]
                  , rn = Ot + 1
                  , Xt = mt[rn];
                if (0 > c(Yt, wt))
                    rn < Ht && 0 > c(Xt, Yt) ? (mt[Ct] = Xt,
                    mt[rn] = wt,
                    Ct = rn) : (mt[Ct] = Yt,
                    mt[Ot] = wt,
                    Ct = Ot);
                else if (rn < Ht && 0 > c(Xt, wt))
                    mt[Ct] = Xt,
                    mt[rn] = wt,
                    Ct = rn;
                else
                    break e
            }
        }
        return St
    }
    function c(mt, St) {
        var wt = mt.sortIndex - St.sortIndex;
        return wt !== 0 ? wt : mt.id - St.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var d = performance;
        s.unstable_now = function() {
            return d.now()
        }
    } else {
        var g = Date
          , _ = g.now();
        s.unstable_now = function() {
            return g.now() - _
        }
    }
    var b = []
      , j = []
      , $ = 1
      , nt = null
      , tt = 3
      , rt = !1
      , st = !1
      , lt = !1
      , ct = typeof setTimeout == "function" ? setTimeout : null
      , it = typeof clearTimeout == "function" ? clearTimeout : null
      , ot = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function at(mt) {
        for (var St = a(j); St !== null; ) {
            if (St.callback === null)
                o(j);
            else if (St.startTime <= mt)
                o(j),
                St.sortIndex = St.expirationTime,
                e(b, St);
            else
                break;
            St = a(j)
        }
    }
    function ht(mt) {
        if (lt = !1,
        at(mt),
        !st)
            if (a(b) !== null)
                st = !0,
                Mt(pt);
            else {
                var St = a(j);
                St !== null && Tt(ht, St.startTime - mt)
            }
    }
    function pt(mt, St) {
        st = !1,
        lt && (lt = !1,
        it(vt),
        vt = -1),
        rt = !0;
        var wt = tt;
        try {
            for (at(St),
            nt = a(b); nt !== null && (!(nt.expirationTime > St) || mt && !bt()); ) {
                var Ct = nt.callback;
                if (typeof Ct == "function") {
                    nt.callback = null,
                    tt = nt.priorityLevel;
                    var Ht = Ct(nt.expirationTime <= St);
                    St = s.unstable_now(),
                    typeof Ht == "function" ? nt.callback = Ht : nt === a(b) && o(b),
                    at(St)
                } else
                    o(b);
                nt = a(b)
            }
            if (nt !== null)
                var en = !0;
            else {
                var Ot = a(j);
                Ot !== null && Tt(ht, Ot.startTime - St),
                en = !1
            }
            return en
        } finally {
            nt = null,
            tt = wt,
            rt = !1
        }
    }
    var dt = !1
      , yt = null
      , vt = -1
      , xt = 5
      , _t = -1;
    function bt() {
        return !(s.unstable_now() - _t < xt)
    }
    function Rt() {
        if (yt !== null) {
            var mt = s.unstable_now();
            _t = mt;
            var St = !0;
            try {
                St = yt(!0, mt)
            } finally {
                St ? Ft() : (dt = !1,
                yt = null)
            }
        } else
            dt = !1
    }
    var Ft;
    if (typeof ot == "function")
        Ft = function() {
            ot(Rt)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Bt = new MessageChannel
          , Dt = Bt.port2;
        Bt.port1.onmessage = Rt,
        Ft = function() {
            Dt.postMessage(null)
        }
    } else
        Ft = function() {
            ct(Rt, 0)
        }
        ;
    function Mt(mt) {
        yt = mt,
        dt || (dt = !0,
        Ft())
    }
    function Tt(mt, St) {
        vt = ct(function() {
            mt(s.unstable_now())
        }, St)
    }
    s.unstable_IdlePriority = 5,
    s.unstable_ImmediatePriority = 1,
    s.unstable_LowPriority = 4,
    s.unstable_NormalPriority = 3,
    s.unstable_Profiling = null,
    s.unstable_UserBlockingPriority = 2,
    s.unstable_cancelCallback = function(mt) {
        mt.callback = null
    }
    ,
    s.unstable_continueExecution = function() {
        st || rt || (st = !0,
        Mt(pt))
    }
    ,
    s.unstable_forceFrameRate = function(mt) {
        0 > mt || 125 < mt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : xt = 0 < mt ? Math.floor(1e3 / mt) : 5
    }
    ,
    s.unstable_getCurrentPriorityLevel = function() {
        return tt
    }
    ,
    s.unstable_getFirstCallbackNode = function() {
        return a(b)
    }
    ,
    s.unstable_next = function(mt) {
        switch (tt) {
        case 1:
        case 2:
        case 3:
            var St = 3;
            break;
        default:
            St = tt
        }
        var wt = tt;
        tt = St;
        try {
            return mt()
        } finally {
            tt = wt
        }
    }
    ,
    s.unstable_pauseExecution = function() {}
    ,
    s.unstable_requestPaint = function() {}
    ,
    s.unstable_runWithPriority = function(mt, St) {
        switch (mt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            mt = 3
        }
        var wt = tt;
        tt = mt;
        try {
            return St()
        } finally {
            tt = wt
        }
    }
    ,
    s.unstable_scheduleCallback = function(mt, St, wt) {
        var Ct = s.unstable_now();
        switch (typeof wt == "object" && wt !== null ? (wt = wt.delay,
        wt = typeof wt == "number" && 0 < wt ? Ct + wt : Ct) : wt = Ct,
        mt) {
        case 1:
            var Ht = -1;
            break;
        case 2:
            Ht = 250;
            break;
        case 5:
            Ht = 1073741823;
            break;
        case 4:
            Ht = 1e4;
            break;
        default:
            Ht = 5e3
        }
        return Ht = wt + Ht,
        mt = {
            id: $++,
            callback: St,
            priorityLevel: mt,
            startTime: wt,
            expirationTime: Ht,
            sortIndex: -1
        },
        wt > Ct ? (mt.sortIndex = wt,
        e(j, mt),
        a(b) === null && mt === a(j) && (lt ? (it(vt),
        vt = -1) : lt = !0,
        Tt(ht, wt - Ct))) : (mt.sortIndex = Ht,
        e(b, mt),
        st || rt || (st = !0,
        Mt(pt))),
        mt
    }
    ,
    s.unstable_shouldYield = bt,
    s.unstable_wrapCallback = function(mt) {
        var St = tt;
        return function() {
            var wt = tt;
            tt = St;
            try {
                return mt.apply(this, arguments)
            } finally {
                tt = wt
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var reactReconciler_production_min = function(e) {
    var a = {}
      , o = reactExports
      , c = schedulerExports
      , d = Object.assign;
    function g(_e) {
        for (var et = "https://reactjs.org/docs/error-decoder.html?invariant=" + _e, ut = 1; ut < arguments.length; ut++)
            et += "&args[]=" + encodeURIComponent(arguments[ut]);
        return "Minified React error #" + _e + "; visit " + et + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var _ = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , b = Symbol.for("react.element")
      , j = Symbol.for("react.portal")
      , $ = Symbol.for("react.fragment")
      , nt = Symbol.for("react.strict_mode")
      , tt = Symbol.for("react.profiler")
      , rt = Symbol.for("react.provider")
      , st = Symbol.for("react.context")
      , lt = Symbol.for("react.forward_ref")
      , ct = Symbol.for("react.suspense")
      , it = Symbol.for("react.suspense_list")
      , ot = Symbol.for("react.memo")
      , at = Symbol.for("react.lazy")
      , ht = Symbol.for("react.offscreen")
      , pt = Symbol.iterator;
    function dt(_e) {
        return _e === null || typeof _e != "object" ? null : (_e = pt && _e[pt] || _e["@@iterator"],
        typeof _e == "function" ? _e : null)
    }
    function yt(_e) {
        if (_e == null)
            return null;
        if (typeof _e == "function")
            return _e.displayName || _e.name || null;
        if (typeof _e == "string")
            return _e;
        switch (_e) {
        case $:
            return "Fragment";
        case j:
            return "Portal";
        case tt:
            return "Profiler";
        case nt:
            return "StrictMode";
        case ct:
            return "Suspense";
        case it:
            return "SuspenseList"
        }
        if (typeof _e == "object")
            switch (_e.$$typeof) {
            case st:
                return (_e.displayName || "Context") + ".Consumer";
            case rt:
                return (_e._context.displayName || "Context") + ".Provider";
            case lt:
                var et = _e.render;
                return _e = _e.displayName,
                _e || (_e = et.displayName || et.name || "",
                _e = _e !== "" ? "ForwardRef(" + _e + ")" : "ForwardRef"),
                _e;
            case ot:
                return et = _e.displayName || null,
                et !== null ? et : yt(_e.type) || "Memo";
            case at:
                et = _e._payload,
                _e = _e._init;
                try {
                    return yt(_e(et))
                } catch {}
            }
        return null
    }
    function vt(_e) {
        var et = _e.type;
        switch (_e.tag) {
        case 24:
            return "Cache";
        case 9:
            return (et.displayName || "Context") + ".Consumer";
        case 10:
            return (et._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return _e = et.render,
            _e = _e.displayName || _e.name || "",
            et.displayName || (_e !== "" ? "ForwardRef(" + _e + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return et;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return yt(et);
        case 8:
            return et === nt ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof et == "function")
                return et.displayName || et.name || null;
            if (typeof et == "string")
                return et
        }
        return null
    }
    function xt(_e) {
        var et = _e
          , ut = _e;
        if (_e.alternate)
            for (; et.return; )
                et = et.return;
        else {
            _e = et;
            do
                et = _e,
                et.flags & 4098 && (ut = et.return),
                _e = et.return;
            while (_e)
        }
        return et.tag === 3 ? ut : null
    }
    function _t(_e) {
        if (xt(_e) !== _e)
            throw Error(g(188))
    }
    function bt(_e) {
        var et = _e.alternate;
        if (!et) {
            if (et = xt(_e),
            et === null)
                throw Error(g(188));
            return et !== _e ? null : _e
        }
        for (var ut = _e, ft = et; ; ) {
            var gt = ut.return;
            if (gt === null)
                break;
            var Et = gt.alternate;
            if (Et === null) {
                if (ft = gt.return,
                ft !== null) {
                    ut = ft;
                    continue
                }
                break
            }
            if (gt.child === Et.child) {
                for (Et = gt.child; Et; ) {
                    if (Et === ut)
                        return _t(gt),
                        _e;
                    if (Et === ft)
                        return _t(gt),
                        et;
                    Et = Et.sibling
                }
                throw Error(g(188))
            }
            if (ut.return !== ft.return)
                ut = gt,
                ft = Et;
            else {
                for (var It = !1, Ut = gt.child; Ut; ) {
                    if (Ut === ut) {
                        It = !0,
                        ut = gt,
                        ft = Et;
                        break
                    }
                    if (Ut === ft) {
                        It = !0,
                        ft = gt,
                        ut = Et;
                        break
                    }
                    Ut = Ut.sibling
                }
                if (!It) {
                    for (Ut = Et.child; Ut; ) {
                        if (Ut === ut) {
                            It = !0,
                            ut = Et,
                            ft = gt;
                            break
                        }
                        if (Ut === ft) {
                            It = !0,
                            ft = Et,
                            ut = gt;
                            break
                        }
                        Ut = Ut.sibling
                    }
                    if (!It)
                        throw Error(g(189))
                }
            }
            if (ut.alternate !== ft)
                throw Error(g(190))
        }
        if (ut.tag !== 3)
            throw Error(g(188));
        return ut.stateNode.current === ut ? _e : et
    }
    function Rt(_e) {
        return _e = bt(_e),
        _e !== null ? Ft(_e) : null
    }
    function Ft(_e) {
        if (_e.tag === 5 || _e.tag === 6)
            return _e;
        for (_e = _e.child; _e !== null; ) {
            var et = Ft(_e);
            if (et !== null)
                return et;
            _e = _e.sibling
        }
        return null
    }
    function Bt(_e) {
        if (_e.tag === 5 || _e.tag === 6)
            return _e;
        for (_e = _e.child; _e !== null; ) {
            if (_e.tag !== 4) {
                var et = Bt(_e);
                if (et !== null)
                    return et
            }
            _e = _e.sibling
        }
        return null
    }
    var Dt = Array.isArray, Mt = e.getPublicInstance, Tt = e.getRootHostContext, mt = e.getChildHostContext, St = e.prepareForCommit, wt = e.resetAfterCommit, Ct = e.createInstance, Ht = e.appendInitialChild, en = e.finalizeInitialChildren, Ot = e.prepareUpdate, Yt = e.shouldSetTextContent, rn = e.createTextInstance, Xt = e.scheduleTimeout, An = e.cancelTimeout, Ln = e.noTimeout, _n = e.isPrimaryRenderer, yn = e.supportsMutation, Pt = e.supportsPersistence, Qt = e.supportsHydration, jt = e.getInstanceFromNode, fn = e.preparePortalMount, tn = e.getCurrentEventPriority, bn = e.detachDeletedInstance, gn = e.supportsMicrotasks, vn = e.scheduleMicrotask, Lt = e.supportsTestSelectors, At = e.findFiberRoot, $t = e.getBoundingRect, on = e.getTextContent, sn = e.isHiddenSubtree, cn = e.matchAccessibilityRole, Pn = e.setFocusIfFocusable, dn = e.setupIntersectionObserver, Tn = e.appendChild, jn = e.appendChildToContainer, pn = e.commitTextUpdate, kn = e.commitMount, er = e.commitUpdate, $n = e.insertBefore, Dn = e.insertInContainerBefore, Nt = e.removeChild, ln = e.removeChildFromContainer, Cn = e.resetTextContent, Vt = e.hideInstance, hn = e.hideTextInstance, an = e.unhideInstance, un = e.unhideTextInstance, En = e.clearContainer, Hn = e.cloneInstance, Yn = e.createContainerChildSet, tr = e.appendChildToContainerChildSet, hr = e.finalizeContainerChildren, Jn = e.replaceContainerChildren, Mr = e.cloneHiddenInstance, br = e.cloneHiddenTextInstance, go = e.canHydrateInstance, hs = e.canHydrateTextInstance, Js = e.canHydrateSuspenseInstance, na = e.isSuspenseInstancePending, Bs = e.isSuspenseInstanceFallback, Vs = e.registerSuspenseInstanceRetry, vs = e.getNextHydratableSibling, Ns = e.getFirstHydratableChild, yo = e.getFirstHydratableChildWithinContainer, vo = e.getFirstHydratableChildWithinSuspenseInstance, Ll = e.hydrateInstance, Il = e.hydrateTextInstance, Dl = e.hydrateSuspenseInstance, kt = e.getNextHydratableInstanceAfterSuspenseInstance, zt = e.commitHydratedContainer, Kt = e.commitHydratedSuspenseInstance, Zt = e.clearSuspenseBoundary, Wt = e.clearSuspenseBoundaryFromContainer, Sn = e.shouldDeleteUnhydratedTailInstances, In = e.didNotMatchHydratedContainerTextInstance, Vn = e.didNotMatchHydratedTextInstance, Bn;
    function Gn(_e) {
        if (Bn === void 0)
            try {
                throw Error()
            } catch (ut) {
                var et = ut.stack.trim().match(/\n( *(at )?)/);
                Bn = et && et[1] || ""
            }
        return `
` + Bn + _e
    }
    var Xn = !1;
    function zn(_e, et) {
        if (!_e || Xn)
            return "";
        Xn = !0;
        var ut = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (et)
                if (et = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(et.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(et, [])
                    } catch (xn) {
                        var ft = xn
                    }
                    Reflect.construct(_e, [], et)
                } else {
                    try {
                        et.call()
                    } catch (xn) {
                        ft = xn
                    }
                    _e.call(et.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (xn) {
                    ft = xn
                }
                _e()
            }
        } catch (xn) {
            if (xn && ft && typeof xn.stack == "string") {
                for (var gt = xn.stack.split(`
`), Et = ft.stack.split(`
`), It = gt.length - 1, Ut = Et.length - 1; 1 <= It && 0 <= Ut && gt[It] !== Et[Ut]; )
                    Ut--;
                for (; 1 <= It && 0 <= Ut; It--,
                Ut--)
                    if (gt[It] !== Et[Ut]) {
                        if (It !== 1 || Ut !== 1)
                            do
                                if (It--,
                                Ut--,
                                0 > Ut || gt[It] !== Et[Ut]) {
                                    var nn = `
` + gt[It].replace(" at new ", " at ");
                                    return _e.displayName && nn.includes("<anonymous>") && (nn = nn.replace("<anonymous>", _e.displayName)),
                                    nn
                                }
                            while (1 <= It && 0 <= Ut);
                        break
                    }
            }
        } finally {
            Xn = !1,
            Error.prepareStackTrace = ut
        }
        return (_e = _e ? _e.displayName || _e.name : "") ? Gn(_e) : ""
    }
    var nr = Object.prototype.hasOwnProperty
      , lr = []
      , ar = -1;
    function gr(_e) {
        return {
            current: _e
        }
    }
    function Un(_e) {
        0 > ar || (_e.current = lr[ar],
        lr[ar] = null,
        ar--)
    }
    function Mn(_e, et) {
        ar++,
        lr[ar] = _e.current,
        _e.current = et
    }
    var cr = {}
      , qn = gr(cr)
      , ur = gr(!1)
      , Vr = cr;
    function xr(_e, et) {
        var ut = _e.type.contextTypes;
        if (!ut)
            return cr;
        var ft = _e.stateNode;
        if (ft && ft.__reactInternalMemoizedUnmaskedChildContext === et)
            return ft.__reactInternalMemoizedMaskedChildContext;
        var gt = {}, Et;
        for (Et in ut)
            gt[Et] = et[Et];
        return ft && (_e = _e.stateNode,
        _e.__reactInternalMemoizedUnmaskedChildContext = et,
        _e.__reactInternalMemoizedMaskedChildContext = gt),
        gt
    }
    function Ar(_e) {
        return _e = _e.childContextTypes,
        _e != null
    }
    function dr() {
        Un(ur),
        Un(qn)
    }
    function es(_e, et, ut) {
        if (qn.current !== cr)
            throw Error(g(168));
        Mn(qn, et),
        Mn(ur, ut)
    }
    function Os(_e, et, ut) {
        var ft = _e.stateNode;
        if (et = et.childContextTypes,
        typeof ft.getChildContext != "function")
            return ut;
        ft = ft.getChildContext();
        for (var gt in ft)
            if (!(gt in et))
                throw Error(g(108, vt(_e) || "Unknown", gt));
        return d({}, ut, ft)
    }
    function Pr(_e) {
        return _e = (_e = _e.stateNode) && _e.__reactInternalMemoizedMergedChildContext || cr,
        Vr = qn.current,
        Mn(qn, _e),
        Mn(ur, ur.current),
        !0
    }
    function Us(_e, et, ut) {
        var ft = _e.stateNode;
        if (!ft)
            throw Error(g(169));
        ut ? (_e = Os(_e, et, Vr),
        ft.__reactInternalMemoizedMergedChildContext = _e,
        Un(ur),
        Un(qn),
        Mn(qn, _e)) : Un(ur),
        Mn(ur, ut)
    }
    var zr = Math.clz32 ? Math.clz32 : yp
      , xo = Math.log
      , gp = Math.LN2;
    function yp(_e) {
        return _e >>>= 0,
        _e === 0 ? 32 : 31 - (xo(_e) / gp | 0) | 0
    }
    var _o = 64
      , So = 4194304;
    function ga(_e) {
        switch (_e & -_e) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return _e & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return _e & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return _e
        }
    }
    function Eo(_e, et) {
        var ut = _e.pendingLanes;
        if (ut === 0)
            return 0;
        var ft = 0
          , gt = _e.suspendedLanes
          , Et = _e.pingedLanes
          , It = ut & 268435455;
        if (It !== 0) {
            var Ut = It & ~gt;
            Ut !== 0 ? ft = ga(Ut) : (Et &= It,
            Et !== 0 && (ft = ga(Et)))
        } else
            It = ut & ~gt,
            It !== 0 ? ft = ga(It) : Et !== 0 && (ft = ga(Et));
        if (ft === 0)
            return 0;
        if (et !== 0 && et !== ft && !(et & gt) && (gt = ft & -ft,
        Et = et & -et,
        gt >= Et || gt === 16 && (Et & 4194240) !== 0))
            return et;
        if (ft & 4 && (ft |= ut & 16),
        et = _e.entangledLanes,
        et !== 0)
            for (_e = _e.entanglements,
            et &= ft; 0 < et; )
                ut = 31 - zr(et),
                gt = 1 << ut,
                ft |= _e[ut],
                et &= ~gt;
        return ft
    }
    function vp(_e, et) {
        switch (_e) {
        case 1:
        case 2:
        case 4:
            return et + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return et + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function xp(_e, et) {
        for (var ut = _e.suspendedLanes, ft = _e.pingedLanes, gt = _e.expirationTimes, Et = _e.pendingLanes; 0 < Et; ) {
            var It = 31 - zr(Et)
              , Ut = 1 << It
              , nn = gt[It];
            nn === -1 ? (!(Ut & ut) || Ut & ft) && (gt[It] = vp(Ut, et)) : nn <= et && (_e.expiredLanes |= Ut),
            Et &= ~Ut
        }
    }
    function Fl(_e) {
        return _e = _e.pendingLanes & -1073741825,
        _e !== 0 ? _e : _e & 1073741824 ? 1073741824 : 0
    }
    function Bl(_e) {
        for (var et = [], ut = 0; 31 > ut; ut++)
            et.push(_e);
        return et
    }
    function xa(_e, et, ut) {
        _e.pendingLanes |= et,
        et !== 536870912 && (_e.suspendedLanes = 0,
        _e.pingedLanes = 0),
        _e = _e.eventTimes,
        et = 31 - zr(et),
        _e[et] = ut
    }
    function _p(_e, et) {
        var ut = _e.pendingLanes & ~et;
        _e.pendingLanes = et,
        _e.suspendedLanes = 0,
        _e.pingedLanes = 0,
        _e.expiredLanes &= et,
        _e.mutableReadLanes &= et,
        _e.entangledLanes &= et,
        et = _e.entanglements;
        var ft = _e.eventTimes;
        for (_e = _e.expirationTimes; 0 < ut; ) {
            var gt = 31 - zr(ut)
              , Et = 1 << gt;
            et[gt] = 0,
            ft[gt] = -1,
            _e[gt] = -1,
            ut &= ~Et
        }
    }
    function Vl(_e, et) {
        var ut = _e.entangledLanes |= et;
        for (_e = _e.entanglements; ut; ) {
            var ft = 31 - zr(ut)
              , gt = 1 << ft;
            gt & et | _e[ft] & et && (_e[ft] |= et),
            ut &= ~gt
        }
    }
    var ir = 0;
    function Uu(_e) {
        return _e &= -_e,
        1 < _e ? 4 < _e ? _e & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var Nl = c.unstable_scheduleCallback
      , zu = c.unstable_cancelCallback
      , Sp = c.unstable_shouldYield
      , Ep = c.unstable_requestPaint
      , Tr = c.unstable_now
      , Ol = c.unstable_ImmediatePriority
      , Mp = c.unstable_UserBlockingPriority
      , Ul = c.unstable_NormalPriority
      , bp = c.unstable_IdlePriority
      , Mo = null
      , rs = null;
    function Ap(_e) {
        if (rs && typeof rs.onCommitFiberRoot == "function")
            try {
                rs.onCommitFiberRoot(Mo, _e, void 0, (_e.current.flags & 128) === 128)
            } catch {}
    }
    function Tp(_e, et) {
        return _e === et && (_e !== 0 || 1 / _e === 1 / et) || _e !== _e && et !== et
    }
    var ss = typeof Object.is == "function" ? Object.is : Tp
      , fs = null
      , bo = !1
      , zl = !1;
    function Gu(_e) {
        fs === null ? fs = [_e] : fs.push(_e)
    }
    function wp(_e) {
        bo = !0,
        Gu(_e)
    }
    function as() {
        if (!zl && fs !== null) {
            zl = !0;
            var _e = 0
              , et = ir;
            try {
                var ut = fs;
                for (ir = 1; _e < ut.length; _e++) {
                    var ft = ut[_e];
                    do
                        ft = ft(!0);
                    while (ft !== null)
                }
                fs = null,
                bo = !1
            } catch (gt) {
                throw fs !== null && (fs = fs.slice(_e + 1)),
                Nl(Ol, as),
                gt
            } finally {
                ir = et,
                zl = !1
            }
        }
        return null
    }
    var Cp = _.ReactCurrentBatchConfig;
    function Ao(_e, et) {
        if (ss(_e, et))
            return !0;
        if (typeof _e != "object" || _e === null || typeof et != "object" || et === null)
            return !1;
        var ut = Object.keys(_e)
          , ft = Object.keys(et);
        if (ut.length !== ft.length)
            return !1;
        for (ft = 0; ft < ut.length; ft++) {
            var gt = ut[ft];
            if (!nr.call(et, gt) || !ss(_e[gt], et[gt]))
                return !1
        }
        return !0
    }
    function Pp(_e) {
        switch (_e.tag) {
        case 5:
            return Gn(_e.type);
        case 16:
            return Gn("Lazy");
        case 13:
            return Gn("Suspense");
        case 19:
            return Gn("SuspenseList");
        case 0:
        case 2:
        case 15:
            return _e = zn(_e.type, !1),
            _e;
        case 11:
            return _e = zn(_e.type.render, !1),
            _e;
        case 1:
            return _e = zn(_e.type, !0),
            _e;
        default:
            return ""
        }
    }
    function ts(_e, et) {
        if (_e && _e.defaultProps) {
            et = d({}, et),
            _e = _e.defaultProps;
            for (var ut in _e)
                et[ut] === void 0 && (et[ut] = _e[ut]);
            return et
        }
        return et
    }
    var To = gr(null)
      , wo = null
      , zs = null
      , Gl = null;
    function Hl() {
        Gl = zs = wo = null
    }
    function Hu(_e, et, ut) {
        _n ? (Mn(To, et._currentValue),
        et._currentValue = ut) : (Mn(To, et._currentValue2),
        et._currentValue2 = ut)
    }
    function Wl(_e) {
        var et = To.current;
        Un(To),
        _n ? _e._currentValue = et : _e._currentValue2 = et
    }
    function $l(_e, et, ut) {
        for (; _e !== null; ) {
            var ft = _e.alternate;
            if ((_e.childLanes & et) !== et ? (_e.childLanes |= et,
            ft !== null && (ft.childLanes |= et)) : ft !== null && (ft.childLanes & et) !== et && (ft.childLanes |= et),
            _e === ut)
                break;
            _e = _e.return
        }
    }
    function Gs(_e, et) {
        wo = _e,
        Gl = zs = null,
        _e = _e.dependencies,
        _e !== null && _e.firstContext !== null && (_e.lanes & et && (Wr = !0),
        _e.firstContext = null)
    }
    function $r(_e) {
        var et = _n ? _e._currentValue : _e._currentValue2;
        if (Gl !== _e)
            if (_e = {
                context: _e,
                memoizedValue: et,
                next: null
            },
            zs === null) {
                if (wo === null)
                    throw Error(g(308));
                zs = _e,
                wo.dependencies = {
                    lanes: 0,
                    firstContext: _e
                }
            } else
                zs = zs.next = _e;
        return et
    }
    var os = null
      , xs = !1;
    function Xl(_e) {
        _e.updateQueue = {
            baseState: _e.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function Wu(_e, et) {
        _e = _e.updateQueue,
        et.updateQueue === _e && (et.updateQueue = {
            baseState: _e.baseState,
            firstBaseUpdate: _e.firstBaseUpdate,
            lastBaseUpdate: _e.lastBaseUpdate,
            shared: _e.shared,
            effects: _e.effects
        })
    }
    function ds(_e, et) {
        return {
            eventTime: _e,
            lane: et,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function _s(_e, et) {
        var ut = _e.updateQueue;
        ut !== null && (ut = ut.shared,
        _r !== null && _e.mode & 1 && !(_i & 2) ? (_e = ut.interleaved,
        _e === null ? (et.next = et,
        os === null ? os = [ut] : os.push(ut)) : (et.next = _e.next,
        _e.next = et),
        ut.interleaved = et) : (_e = ut.pending,
        _e === null ? et.next = et : (et.next = _e.next,
        _e.next = et),
        ut.pending = et))
    }
    function Co(_e, et, ut) {
        if (et = et.updateQueue,
        et !== null && (et = et.shared,
        (ut & 4194240) !== 0)) {
            var ft = et.lanes;
            ft &= _e.pendingLanes,
            ut |= ft,
            et.lanes = ut,
            Vl(_e, ut)
        }
    }
    function ju(_e, et) {
        var ut = _e.updateQueue
          , ft = _e.alternate;
        if (ft !== null && (ft = ft.updateQueue,
        ut === ft)) {
            var gt = null
              , Et = null;
            if (ut = ut.firstBaseUpdate,
            ut !== null) {
                do {
                    var It = {
                        eventTime: ut.eventTime,
                        lane: ut.lane,
                        tag: ut.tag,
                        payload: ut.payload,
                        callback: ut.callback,
                        next: null
                    };
                    Et === null ? gt = Et = It : Et = Et.next = It,
                    ut = ut.next
                } while (ut !== null);
                Et === null ? gt = Et = et : Et = Et.next = et
            } else
                gt = Et = et;
            ut = {
                baseState: ft.baseState,
                firstBaseUpdate: gt,
                lastBaseUpdate: Et,
                shared: ft.shared,
                effects: ft.effects
            },
            _e.updateQueue = ut;
            return
        }
        _e = ut.lastBaseUpdate,
        _e === null ? ut.firstBaseUpdate = et : _e.next = et,
        ut.lastBaseUpdate = et
    }
    function Po(_e, et, ut, ft) {
        var gt = _e.updateQueue;
        xs = !1;
        var Et = gt.firstBaseUpdate
          , It = gt.lastBaseUpdate
          , Ut = gt.shared.pending;
        if (Ut !== null) {
            gt.shared.pending = null;
            var nn = Ut
              , xn = nn.next;
            nn.next = null,
            It === null ? Et = xn : It.next = xn,
            It = nn;
            var Fn = _e.alternate;
            Fn !== null && (Fn = Fn.updateQueue,
            Ut = Fn.lastBaseUpdate,
            Ut !== It && (Ut === null ? Fn.firstBaseUpdate = xn : Ut.next = xn,
            Fn.lastBaseUpdate = nn))
        }
        if (Et !== null) {
            var Kn = gt.baseState;
            It = 0,
            Fn = xn = nn = null,
            Ut = Et;
            do {
                var Wn = Ut.lane
                  , or = Ut.eventTime;
                if ((ft & Wn) === Wn) {
                    Fn !== null && (Fn = Fn.next = {
                        eventTime: or,
                        lane: 0,
                        tag: Ut.tag,
                        payload: Ut.payload,
                        callback: Ut.callback,
                        next: null
                    });
                    e: {
                        var On = _e
                          , Dr = Ut;
                        switch (Wn = et,
                        or = ut,
                        Dr.tag) {
                        case 1:
                            if (On = Dr.payload,
                            typeof On == "function") {
                                Kn = On.call(or, Kn, Wn);
                                break e
                            }
                            Kn = On;
                            break e;
                        case 3:
                            On.flags = On.flags & -65537 | 128;
                        case 0:
                            if (On = Dr.payload,
                            Wn = typeof On == "function" ? On.call(or, Kn, Wn) : On,
                            Wn == null)
                                break e;
                            Kn = d({}, Kn, Wn);
                            break e;
                        case 2:
                            xs = !0
                        }
                    }
                    Ut.callback !== null && Ut.lane !== 0 && (_e.flags |= 64,
                    Wn = gt.effects,
                    Wn === null ? gt.effects = [Ut] : Wn.push(Ut))
                } else
                    or = {
                        eventTime: or,
                        lane: Wn,
                        tag: Ut.tag,
                        payload: Ut.payload,
                        callback: Ut.callback,
                        next: null
                    },
                    Fn === null ? (xn = Fn = or,
                    nn = Kn) : Fn = Fn.next = or,
                    It |= Wn;
                if (Ut = Ut.next,
                Ut === null) {
                    if (Ut = gt.shared.pending,
                    Ut === null)
                        break;
                    Wn = Ut,
                    Ut = Wn.next,
                    Wn.next = null,
                    gt.lastBaseUpdate = Wn,
                    gt.shared.pending = null
                }
            } while (!0);
            if (Fn === null && (nn = Kn),
            gt.baseState = nn,
            gt.firstBaseUpdate = xn,
            gt.lastBaseUpdate = Fn,
            et = gt.shared.interleaved,
            et !== null) {
                gt = et;
                do
                    It |= gt.lane,
                    gt = gt.next;
                while (gt !== et)
            } else
                Et === null && (gt.shared.lanes = 0);
            Zs |= It,
            _e.lanes = It,
            _e.memoizedState = Kn
        }
    }
    function $u(_e, et, ut) {
        if (_e = et.effects,
        et.effects = null,
        _e !== null)
            for (et = 0; et < _e.length; et++) {
                var ft = _e[et]
                  , gt = ft.callback;
                if (gt !== null) {
                    if (ft.callback = null,
                    ft = ut,
                    typeof gt != "function")
                        throw Error(g(191, gt));
                    gt.call(ft)
                }
            }
    }
    var Xu = new o.Component().refs;
    function Yl(_e, et, ut, ft) {
        et = _e.memoizedState,
        ut = ut(ft, et),
        ut = ut == null ? et : d({}, et, ut),
        _e.memoizedState = ut,
        _e.lanes === 0 && (_e.updateQueue.baseState = ut)
    }
    var ko = {
        isMounted: function(_e) {
            return (_e = _e._reactInternals) ? xt(_e) === _e : !1
        },
        enqueueSetState: function(_e, et, ut) {
            _e = _e._reactInternals;
            var ft = Br()
              , gt = Ms(_e)
              , Et = ds(ft, gt);
            Et.payload = et,
            ut != null && (Et.callback = ut),
            _s(_e, Et),
            et = Zr(_e, gt, ft),
            et !== null && Co(et, _e, gt)
        },
        enqueueReplaceState: function(_e, et, ut) {
            _e = _e._reactInternals;
            var ft = Br()
              , gt = Ms(_e)
              , Et = ds(ft, gt);
            Et.tag = 1,
            Et.payload = et,
            ut != null && (Et.callback = ut),
            _s(_e, Et),
            et = Zr(_e, gt, ft),
            et !== null && Co(et, _e, gt)
        },
        enqueueForceUpdate: function(_e, et) {
            _e = _e._reactInternals;
            var ut = Br()
              , ft = Ms(_e)
              , gt = ds(ut, ft);
            gt.tag = 2,
            et != null && (gt.callback = et),
            _s(_e, gt),
            et = Zr(_e, ft, ut),
            et !== null && Co(et, _e, ft)
        }
    };
    function qu(_e, et, ut, ft, gt, Et, It) {
        return _e = _e.stateNode,
        typeof _e.shouldComponentUpdate == "function" ? _e.shouldComponentUpdate(ft, Et, It) : et.prototype && et.prototype.isPureReactComponent ? !Ao(ut, ft) || !Ao(gt, Et) : !0
    }
    function Yu(_e, et, ut) {
        var ft = !1
          , gt = cr
          , Et = et.contextType;
        return typeof Et == "object" && Et !== null ? Et = $r(Et) : (gt = Ar(et) ? Vr : qn.current,
        ft = et.contextTypes,
        Et = (ft = ft != null) ? xr(_e, gt) : cr),
        et = new et(ut,Et),
        _e.memoizedState = et.state !== null && et.state !== void 0 ? et.state : null,
        et.updater = ko,
        _e.stateNode = et,
        et._reactInternals = _e,
        ft && (_e = _e.stateNode,
        _e.__reactInternalMemoizedUnmaskedChildContext = gt,
        _e.__reactInternalMemoizedMaskedChildContext = Et),
        et
    }
    function Ku(_e, et, ut, ft) {
        _e = et.state,
        typeof et.componentWillReceiveProps == "function" && et.componentWillReceiveProps(ut, ft),
        typeof et.UNSAFE_componentWillReceiveProps == "function" && et.UNSAFE_componentWillReceiveProps(ut, ft),
        et.state !== _e && ko.enqueueReplaceState(et, et.state, null)
    }
    function Kl(_e, et, ut, ft) {
        var gt = _e.stateNode;
        gt.props = ut,
        gt.state = _e.memoizedState,
        gt.refs = Xu,
        Xl(_e);
        var Et = et.contextType;
        typeof Et == "object" && Et !== null ? gt.context = $r(Et) : (Et = Ar(et) ? Vr : qn.current,
        gt.context = xr(_e, Et)),
        gt.state = _e.memoizedState,
        Et = et.getDerivedStateFromProps,
        typeof Et == "function" && (Yl(_e, et, Et, ut),
        gt.state = _e.memoizedState),
        typeof et.getDerivedStateFromProps == "function" || typeof gt.getSnapshotBeforeUpdate == "function" || typeof gt.UNSAFE_componentWillMount != "function" && typeof gt.componentWillMount != "function" || (et = gt.state,
        typeof gt.componentWillMount == "function" && gt.componentWillMount(),
        typeof gt.UNSAFE_componentWillMount == "function" && gt.UNSAFE_componentWillMount(),
        et !== gt.state && ko.enqueueReplaceState(gt, gt.state, null),
        Po(_e, ut, gt, ft),
        gt.state = _e.memoizedState),
        typeof gt.componentDidMount == "function" && (_e.flags |= 4194308)
    }
    var Hs = []
      , Ws = 0
      , Ro = null
      , Lo = 0
      , Xr = []
      , qr = 0
      , ws = null
      , ps = 1
      , ms = "";
    function Cs(_e, et) {
        Hs[Ws++] = Lo,
        Hs[Ws++] = Ro,
        Ro = _e,
        Lo = et
    }
    function Zu(_e, et, ut) {
        Xr[qr++] = ps,
        Xr[qr++] = ms,
        Xr[qr++] = ws,
        ws = _e;
        var ft = ps;
        _e = ms;
        var gt = 32 - zr(ft) - 1;
        ft &= ~(1 << gt),
        ut += 1;
        var Et = 32 - zr(et) + gt;
        if (30 < Et) {
            var It = gt - gt % 5;
            Et = (ft & (1 << It) - 1).toString(32),
            ft >>= It,
            gt -= It,
            ps = 1 << 32 - zr(et) + gt | ut << gt | ft,
            ms = Et + _e
        } else
            ps = 1 << Et | ut << gt | ft,
            ms = _e
    }
    function Zl(_e) {
        _e.return !== null && (Cs(_e, 1),
        Zu(_e, 1, 0))
    }
    function Ql(_e) {
        for (; _e === Ro; )
            Ro = Hs[--Ws],
            Hs[Ws] = null,
            Lo = Hs[--Ws],
            Hs[Ws] = null;
        for (; _e === ws; )
            ws = Xr[--qr],
            Xr[qr] = null,
            ms = Xr[--qr],
            Xr[qr] = null,
            ps = Xr[--qr],
            Xr[qr] = null
    }
    var Gr = null
      , Hr = null
      , pr = !1
      , ba = !1
      , ns = null;
    function Qu(_e, et) {
        var ut = Qr(5, null, null, 0);
        ut.elementType = "DELETED",
        ut.stateNode = et,
        ut.return = _e,
        et = _e.deletions,
        et === null ? (_e.deletions = [ut],
        _e.flags |= 16) : et.push(ut)
    }
    function Ju(_e, et) {
        switch (_e.tag) {
        case 5:
            return et = go(et, _e.type, _e.pendingProps),
            et !== null ? (_e.stateNode = et,
            Gr = _e,
            Hr = Ns(et),
            !0) : !1;
        case 6:
            return et = hs(et, _e.pendingProps),
            et !== null ? (_e.stateNode = et,
            Gr = _e,
            Hr = null,
            !0) : !1;
        case 13:
            if (et = Js(et),
            et !== null) {
                var ut = ws !== null ? {
                    id: ps,
                    overflow: ms
                } : null;
                return _e.memoizedState = {
                    dehydrated: et,
                    treeContext: ut,
                    retryLane: 1073741824
                },
                ut = Qr(18, null, null, 0),
                ut.stateNode = et,
                ut.return = _e,
                _e.child = ut,
                Gr = _e,
                Hr = null,
                !0
            }
            return !1;
        default:
            return !1
        }
    }
    function Jl(_e) {
        return (_e.mode & 1) !== 0 && (_e.flags & 128) === 0
    }
    function _c(_e) {
        if (pr) {
            var et = Hr;
            if (et) {
                var ut = et;
                if (!Ju(_e, et)) {
                    if (Jl(_e))
                        throw Error(g(418));
                    et = vs(ut);
                    var ft = Gr;
                    et && Ju(_e, et) ? Qu(ft, ut) : (_e.flags = _e.flags & -4097 | 2,
                    pr = !1,
                    Gr = _e)
                }
            } else {
                if (Jl(_e))
                    throw Error(g(418));
                _e.flags = _e.flags & -4097 | 2,
                pr = !1,
                Gr = _e
            }
        }
    }
    function e0(_e) {
        for (_e = _e.return; _e !== null && _e.tag !== 5 && _e.tag !== 3 && _e.tag !== 13; )
            _e = _e.return;
        Gr = _e
    }
    function $a(_e) {
        if (!Qt || _e !== Gr)
            return !1;
        if (!pr)
            return e0(_e),
            pr = !0,
            !1;
        if (_e.tag !== 3 && (_e.tag !== 5 || Sn(_e.type) && !Yt(_e.type, _e.memoizedProps))) {
            var et = Hr;
            if (et) {
                if (Jl(_e)) {
                    for (_e = Hr; _e; )
                        _e = vs(_e);
                    throw Error(g(418))
                }
                for (; et; )
                    Qu(_e, et),
                    et = vs(et)
            }
        }
        if (e0(_e),
        _e.tag === 13) {
            if (!Qt)
                throw Error(g(316));
            if (_e = _e.memoizedState,
            _e = _e !== null ? _e.dehydrated : null,
            !_e)
                throw Error(g(317));
            Hr = kt(_e)
        } else
            Hr = Gr ? vs(_e.stateNode) : null;
        return !0
    }
    function js() {
        Qt && (Hr = Gr = null,
        ba = pr = !1)
    }
    function eu(_e) {
        ns === null ? ns = [_e] : ns.push(_e)
    }
    function eo(_e, et, ut) {
        if (_e = ut.ref,
        _e !== null && typeof _e != "function" && typeof _e != "object") {
            if (ut._owner) {
                if (ut = ut._owner,
                ut) {
                    if (ut.tag !== 1)
                        throw Error(g(309));
                    var ft = ut.stateNode
                }
                if (!ft)
                    throw Error(g(147, _e));
                var gt = ft
                  , Et = "" + _e;
                return et !== null && et.ref !== null && typeof et.ref == "function" && et.ref._stringRef === Et ? et.ref : (et = function(It) {
                    var Ut = gt.refs;
                    Ut === Xu && (Ut = gt.refs = {}),
                    It === null ? delete Ut[Et] : Ut[Et] = It
                }
                ,
                et._stringRef = Et,
                et)
            }
            if (typeof _e != "string")
                throw Error(g(284));
            if (!ut._owner)
                throw Error(g(290, _e))
        }
        return _e
    }
    function Io(_e, et) {
        throw _e = Object.prototype.toString.call(et),
        Error(g(31, _e === "[object Object]" ? "object with keys {" + Object.keys(et).join(", ") + "}" : _e))
    }
    function t0(_e) {
        var et = _e._init;
        return et(_e._payload)
    }
    function n0(_e) {
        function et(qt, Gt) {
            if (_e) {
                var Jt = qt.deletions;
                Jt === null ? (qt.deletions = [Gt],
                qt.flags |= 16) : Jt.push(Gt)
            }
        }
        function ut(qt, Gt) {
            if (!_e)
                return null;
            for (; Gt !== null; )
                et(qt, Gt),
                Gt = Gt.sibling;
            return null
        }
        function ft(qt, Gt) {
            for (qt = new Map; Gt !== null; )
                Gt.key !== null ? qt.set(Gt.key, Gt) : qt.set(Gt.index, Gt),
                Gt = Gt.sibling;
            return qt
        }
        function gt(qt, Gt) {
            return qt = As(qt, Gt),
            qt.index = 0,
            qt.sibling = null,
            qt
        }
        function Et(qt, Gt, Jt) {
            return qt.index = Jt,
            _e ? (Jt = qt.alternate,
            Jt !== null ? (Jt = Jt.index,
            Jt < Gt ? (qt.flags |= 2,
            Gt) : Jt) : (qt.flags |= 2,
            Gt)) : (qt.flags |= 1048576,
            Gt)
        }
        function It(qt) {
            return _e && qt.alternate === null && (qt.flags |= 2),
            qt
        }
        function Ut(qt, Gt, Jt, Rn) {
            return Gt === null || Gt.tag !== 6 ? (Gt = Vu(Jt, qt.mode, Rn),
            Gt.return = qt,
            Gt) : (Gt = gt(Gt, Jt),
            Gt.return = qt,
            Gt)
        }
        function nn(qt, Gt, Jt, Rn) {
            var Nn = Jt.type;
            return Nn === $ ? Fn(qt, Gt, Jt.props.children, Rn, Jt.key) : Gt !== null && (Gt.elementType === Nn || typeof Nn == "object" && Nn !== null && Nn.$$typeof === at && t0(Nn) === Gt.type) ? (Rn = gt(Gt, Jt.props),
            Rn.ref = eo(qt, Gt, Jt),
            Rn.return = qt,
            Rn) : (Rn = Pl(Jt.type, Jt.key, Jt.props, null, qt.mode, Rn),
            Rn.ref = eo(qt, Gt, Jt),
            Rn.return = qt,
            Rn)
        }
        function xn(qt, Gt, Jt, Rn) {
            return Gt === null || Gt.tag !== 4 || Gt.stateNode.containerInfo !== Jt.containerInfo || Gt.stateNode.implementation !== Jt.implementation ? (Gt = Nu(Jt, qt.mode, Rn),
            Gt.return = qt,
            Gt) : (Gt = gt(Gt, Jt.children || []),
            Gt.return = qt,
            Gt)
        }
        function Fn(qt, Gt, Jt, Rn, Nn) {
            return Gt === null || Gt.tag !== 7 ? (Gt = Fs(Jt, qt.mode, Rn, Nn),
            Gt.return = qt,
            Gt) : (Gt = gt(Gt, Jt),
            Gt.return = qt,
            Gt)
        }
        function Kn(qt, Gt, Jt) {
            if (typeof Gt == "string" && Gt !== "" || typeof Gt == "number")
                return Gt = Vu("" + Gt, qt.mode, Jt),
                Gt.return = qt,
                Gt;
            if (typeof Gt == "object" && Gt !== null) {
                switch (Gt.$$typeof) {
                case b:
                    return Jt = Pl(Gt.type, Gt.key, Gt.props, null, qt.mode, Jt),
                    Jt.ref = eo(qt, null, Gt),
                    Jt.return = qt,
                    Jt;
                case j:
                    return Gt = Nu(Gt, qt.mode, Jt),
                    Gt.return = qt,
                    Gt;
                case at:
                    var Rn = Gt._init;
                    return Kn(qt, Rn(Gt._payload), Jt)
                }
                if (Dt(Gt) || dt(Gt))
                    return Gt = Fs(Gt, qt.mode, Jt, null),
                    Gt.return = qt,
                    Gt;
                Io(qt, Gt)
            }
            return null
        }
        function Wn(qt, Gt, Jt, Rn) {
            var Nn = Gt !== null ? Gt.key : null;
            if (typeof Jt == "string" && Jt !== "" || typeof Jt == "number")
                return Nn !== null ? null : Ut(qt, Gt, "" + Jt, Rn);
            if (typeof Jt == "object" && Jt !== null) {
                switch (Jt.$$typeof) {
                case b:
                    return Jt.key === Nn ? nn(qt, Gt, Jt, Rn) : null;
                case j:
                    return Jt.key === Nn ? xn(qt, Gt, Jt, Rn) : null;
                case at:
                    return Nn = Jt._init,
                    Wn(qt, Gt, Nn(Jt._payload), Rn)
                }
                if (Dt(Jt) || dt(Jt))
                    return Nn !== null ? null : Fn(qt, Gt, Jt, Rn, null);
                Io(qt, Jt)
            }
            return null
        }
        function or(qt, Gt, Jt, Rn, Nn) {
            if (typeof Rn == "string" && Rn !== "" || typeof Rn == "number")
                return qt = qt.get(Jt) || null,
                Ut(Gt, qt, "" + Rn, Nn);
            if (typeof Rn == "object" && Rn !== null) {
                switch (Rn.$$typeof) {
                case b:
                    return qt = qt.get(Rn.key === null ? Jt : Rn.key) || null,
                    nn(Gt, qt, Rn, Nn);
                case j:
                    return qt = qt.get(Rn.key === null ? Jt : Rn.key) || null,
                    xn(Gt, qt, Rn, Nn);
                case at:
                    var Qn = Rn._init;
                    return or(qt, Gt, Jt, Qn(Rn._payload), Nn)
                }
                if (Dt(Rn) || dt(Rn))
                    return qt = qt.get(Jt) || null,
                    Fn(Gt, qt, Rn, Nn, null);
                Io(Gt, Rn)
            }
            return null
        }
        function On(qt, Gt, Jt, Rn) {
            for (var Nn = null, Qn = null, Zn = Gt, rr = Gt = 0, Cr = null; Zn !== null && rr < Jt.length; rr++) {
                Zn.index > rr ? (Cr = Zn,
                Zn = null) : Cr = Zn.sibling;
                var sr = Wn(qt, Zn, Jt[rr], Rn);
                if (sr === null) {
                    Zn === null && (Zn = Cr);
                    break
                }
                _e && Zn && sr.alternate === null && et(qt, Zn),
                Gt = Et(sr, Gt, rr),
                Qn === null ? Nn = sr : Qn.sibling = sr,
                Qn = sr,
                Zn = Cr
            }
            if (rr === Jt.length)
                return ut(qt, Zn),
                pr && Cs(qt, rr),
                Nn;
            if (Zn === null) {
                for (; rr < Jt.length; rr++)
                    Zn = Kn(qt, Jt[rr], Rn),
                    Zn !== null && (Gt = Et(Zn, Gt, rr),
                    Qn === null ? Nn = Zn : Qn.sibling = Zn,
                    Qn = Zn);
                return pr && Cs(qt, rr),
                Nn
            }
            for (Zn = ft(qt, Zn); rr < Jt.length; rr++)
                Cr = or(Zn, qt, rr, Jt[rr], Rn),
                Cr !== null && (_e && Cr.alternate !== null && Zn.delete(Cr.key === null ? rr : Cr.key),
                Gt = Et(Cr, Gt, rr),
                Qn === null ? Nn = Cr : Qn.sibling = Cr,
                Qn = Cr);
            return _e && Zn.forEach(function(Ts) {
                return et(qt, Ts)
            }),
            pr && Cs(qt, rr),
            Nn
        }
        function Dr(qt, Gt, Jt, Rn) {
            var Nn = dt(Jt);
            if (typeof Nn != "function")
                throw Error(g(150));
            if (Jt = Nn.call(Jt),
            Jt == null)
                throw Error(g(151));
            for (var Qn = Nn = null, Zn = Gt, rr = Gt = 0, Cr = null, sr = Jt.next(); Zn !== null && !sr.done; rr++,
            sr = Jt.next()) {
                Zn.index > rr ? (Cr = Zn,
                Zn = null) : Cr = Zn.sibling;
                var Ts = Wn(qt, Zn, sr.value, Rn);
                if (Ts === null) {
                    Zn === null && (Zn = Cr);
                    break
                }
                _e && Zn && Ts.alternate === null && et(qt, Zn),
                Gt = Et(Ts, Gt, rr),
                Qn === null ? Nn = Ts : Qn.sibling = Ts,
                Qn = Ts,
                Zn = Cr
            }
            if (sr.done)
                return ut(qt, Zn),
                pr && Cs(qt, rr),
                Nn;
            if (Zn === null) {
                for (; !sr.done; rr++,
                sr = Jt.next())
                    sr = Kn(qt, sr.value, Rn),
                    sr !== null && (Gt = Et(sr, Gt, rr),
                    Qn === null ? Nn = sr : Qn.sibling = sr,
                    Qn = sr);
                return pr && Cs(qt, rr),
                Nn
            }
            for (Zn = ft(qt, Zn); !sr.done; rr++,
            sr = Jt.next())
                sr = or(Zn, qt, rr, sr.value, Rn),
                sr !== null && (_e && sr.alternate !== null && Zn.delete(sr.key === null ? rr : sr.key),
                Gt = Et(sr, Gt, rr),
                Qn === null ? Nn = sr : Qn.sibling = sr,
                Qn = sr);
            return _e && Zn.forEach(function(am) {
                return et(qt, am)
            }),
            pr && Cs(qt, rr),
            Nn
        }
        function Jr(qt, Gt, Jt, Rn) {
            if (typeof Jt == "object" && Jt !== null && Jt.type === $ && Jt.key === null && (Jt = Jt.props.children),
            typeof Jt == "object" && Jt !== null) {
                switch (Jt.$$typeof) {
                case b:
                    e: {
                        for (var Nn = Jt.key, Qn = Gt; Qn !== null; ) {
                            if (Qn.key === Nn) {
                                if (Nn = Jt.type,
                                Nn === $) {
                                    if (Qn.tag === 7) {
                                        ut(qt, Qn.sibling),
                                        Gt = gt(Qn, Jt.props.children),
                                        Gt.return = qt,
                                        qt = Gt;
                                        break e
                                    }
                                } else if (Qn.elementType === Nn || typeof Nn == "object" && Nn !== null && Nn.$$typeof === at && t0(Nn) === Qn.type) {
                                    ut(qt, Qn.sibling),
                                    Gt = gt(Qn, Jt.props),
                                    Gt.ref = eo(qt, Qn, Jt),
                                    Gt.return = qt,
                                    qt = Gt;
                                    break e
                                }
                                ut(qt, Qn);
                                break
                            } else
                                et(qt, Qn);
                            Qn = Qn.sibling
                        }
                        Jt.type === $ ? (Gt = Fs(Jt.props.children, qt.mode, Rn, Jt.key),
                        Gt.return = qt,
                        qt = Gt) : (Rn = Pl(Jt.type, Jt.key, Jt.props, null, qt.mode, Rn),
                        Rn.ref = eo(qt, Gt, Jt),
                        Rn.return = qt,
                        qt = Rn)
                    }
                    return It(qt);
                case j:
                    e: {
                        for (Qn = Jt.key; Gt !== null; ) {
                            if (Gt.key === Qn)
                                if (Gt.tag === 4 && Gt.stateNode.containerInfo === Jt.containerInfo && Gt.stateNode.implementation === Jt.implementation) {
                                    ut(qt, Gt.sibling),
                                    Gt = gt(Gt, Jt.children || []),
                                    Gt.return = qt,
                                    qt = Gt;
                                    break e
                                } else {
                                    ut(qt, Gt);
                                    break
                                }
                            else
                                et(qt, Gt);
                            Gt = Gt.sibling
                        }
                        Gt = Nu(Jt, qt.mode, Rn),
                        Gt.return = qt,
                        qt = Gt
                    }
                    return It(qt);
                case at:
                    return Qn = Jt._init,
                    Jr(qt, Gt, Qn(Jt._payload), Rn)
                }
                if (Dt(Jt))
                    return On(qt, Gt, Jt, Rn);
                if (dt(Jt))
                    return Dr(qt, Gt, Jt, Rn);
                Io(qt, Jt)
            }
            return typeof Jt == "string" && Jt !== "" || typeof Jt == "number" ? (Jt = "" + Jt,
            Gt !== null && Gt.tag === 6 ? (ut(qt, Gt.sibling),
            Gt = gt(Gt, Jt),
            Gt.return = qt,
            qt = Gt) : (ut(qt, Gt),
            Gt = Vu(Jt, qt.mode, Rn),
            Gt.return = qt,
            qt = Gt),
            It(qt)) : ut(qt, Gt)
        }
        return Jr
    }
    var $s = n0(!0)
      , i0 = n0(!1)
      , to = {}
      , Yr = gr(to)
      , no = gr(to)
      , Xs = gr(to);
    function ls(_e) {
        if (_e === to)
            throw Error(g(174));
        return _e
    }
    function tu(_e, et) {
        Mn(Xs, et),
        Mn(no, _e),
        Mn(Yr, to),
        _e = Tt(et),
        Un(Yr),
        Mn(Yr, _e)
    }
    function qs() {
        Un(Yr),
        Un(no),
        Un(Xs)
    }
    function r0(_e) {
        var et = ls(Xs.current)
          , ut = ls(Yr.current);
        et = mt(ut, _e.type, et),
        ut !== et && (Mn(no, _e),
        Mn(Yr, et))
    }
    function nu(_e) {
        no.current === _e && (Un(Yr),
        Un(no))
    }
    var mr = gr(0);
    function Do(_e) {
        for (var et = _e; et !== null; ) {
            if (et.tag === 13) {
                var ut = et.memoizedState;
                if (ut !== null && (ut = ut.dehydrated,
                ut === null || na(ut) || Bs(ut)))
                    return et
            } else if (et.tag === 19 && et.memoizedProps.revealOrder !== void 0) {
                if (et.flags & 128)
                    return et
            } else if (et.child !== null) {
                et.child.return = et,
                et = et.child;
                continue
            }
            if (et === _e)
                break;
            for (; et.sibling === null; ) {
                if (et.return === null || et.return === _e)
                    return null;
                et = et.return
            }
            et.sibling.return = et.return,
            et = et.sibling
        }
        return null
    }
    var iu = [];
    function ru() {
        for (var _e = 0; _e < iu.length; _e++) {
            var et = iu[_e];
            _n ? et._workInProgressVersionPrimary = null : et._workInProgressVersionSecondary = null
        }
        iu.length = 0
    }
    var Fo = _.ReactCurrentDispatcher
      , Kr = _.ReactCurrentBatchConfig
      , Ys = 0
      , yr = null
      , Rr = null
      , wr = null
      , Bo = !1
      , io = !1
      , ro = 0
      , kp = 0;
    function Lr() {
        throw Error(g(321))
    }
    function su(_e, et) {
        if (et === null)
            return !1;
        for (var ut = 0; ut < et.length && ut < _e.length; ut++)
            if (!ss(_e[ut], et[ut]))
                return !1;
        return !0
    }
    function au(_e, et, ut, ft, gt, Et) {
        if (Ys = Et,
        yr = et,
        et.memoizedState = null,
        et.updateQueue = null,
        et.lanes = 0,
        Fo.current = _e === null || _e.memoizedState === null ? Dp : Fp,
        _e = ut(ft, gt),
        io) {
            Et = 0;
            do {
                if (io = !1,
                ro = 0,
                25 <= Et)
                    throw Error(g(301));
                Et += 1,
                wr = Rr = null,
                et.updateQueue = null,
                Fo.current = Bp,
                _e = ut(ft, gt)
            } while (io)
        }
        if (Fo.current = zo,
        et = Rr !== null && Rr.next !== null,
        Ys = 0,
        wr = Rr = yr = null,
        Bo = !1,
        et)
            throw Error(g(300));
        return _e
    }
    function ou() {
        var _e = ro !== 0;
        return ro = 0,
        _e
    }
    function gs() {
        var _e = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return wr === null ? yr.memoizedState = wr = _e : wr = wr.next = _e,
        wr
    }
    function cs() {
        if (Rr === null) {
            var _e = yr.alternate;
            _e = _e !== null ? _e.memoizedState : null
        } else
            _e = Rr.next;
        var et = wr === null ? yr.memoizedState : wr.next;
        if (et !== null)
            wr = et,
            Rr = _e;
        else {
            if (_e === null)
                throw Error(g(310));
            Rr = _e,
            _e = {
                memoizedState: Rr.memoizedState,
                baseState: Rr.baseState,
                baseQueue: Rr.baseQueue,
                queue: Rr.queue,
                next: null
            },
            wr === null ? yr.memoizedState = wr = _e : wr = wr.next = _e
        }
        return wr
    }
    function Ps(_e, et) {
        return typeof et == "function" ? et(_e) : et
    }
    function Vo(_e) {
        var et = cs()
          , ut = et.queue;
        if (ut === null)
            throw Error(g(311));
        ut.lastRenderedReducer = _e;
        var ft = Rr
          , gt = ft.baseQueue
          , Et = ut.pending;
        if (Et !== null) {
            if (gt !== null) {
                var It = gt.next;
                gt.next = Et.next,
                Et.next = It
            }
            ft.baseQueue = gt = Et,
            ut.pending = null
        }
        if (gt !== null) {
            Et = gt.next,
            ft = ft.baseState;
            var Ut = It = null
              , nn = null
              , xn = Et;
            do {
                var Fn = xn.lane;
                if ((Ys & Fn) === Fn)
                    nn !== null && (nn = nn.next = {
                        lane: 0,
                        action: xn.action,
                        hasEagerState: xn.hasEagerState,
                        eagerState: xn.eagerState,
                        next: null
                    }),
                    ft = xn.hasEagerState ? xn.eagerState : _e(ft, xn.action);
                else {
                    var Kn = {
                        lane: Fn,
                        action: xn.action,
                        hasEagerState: xn.hasEagerState,
                        eagerState: xn.eagerState,
                        next: null
                    };
                    nn === null ? (Ut = nn = Kn,
                    It = ft) : nn = nn.next = Kn,
                    yr.lanes |= Fn,
                    Zs |= Fn
                }
                xn = xn.next
            } while (xn !== null && xn !== Et);
            nn === null ? It = ft : nn.next = Ut,
            ss(ft, et.memoizedState) || (Wr = !0),
            et.memoizedState = ft,
            et.baseState = It,
            et.baseQueue = nn,
            ut.lastRenderedState = ft
        }
        if (_e = ut.interleaved,
        _e !== null) {
            gt = _e;
            do
                Et = gt.lane,
                yr.lanes |= Et,
                Zs |= Et,
                gt = gt.next;
            while (gt !== _e)
        } else
            gt === null && (ut.lanes = 0);
        return [et.memoizedState, ut.dispatch]
    }
    function No(_e) {
        var et = cs()
          , ut = et.queue;
        if (ut === null)
            throw Error(g(311));
        ut.lastRenderedReducer = _e;
        var ft = ut.dispatch
          , gt = ut.pending
          , Et = et.memoizedState;
        if (gt !== null) {
            ut.pending = null;
            var It = gt = gt.next;
            do
                Et = _e(Et, It.action),
                It = It.next;
            while (It !== gt);
            ss(Et, et.memoizedState) || (Wr = !0),
            et.memoizedState = Et,
            et.baseQueue === null && (et.baseState = Et),
            ut.lastRenderedState = Et
        }
        return [Et, ft]
    }
    function s0() {}
    function a0(_e, et) {
        var ut = yr
          , ft = cs()
          , gt = et()
          , Et = !ss(ft.memoizedState, gt);
        if (Et && (ft.memoizedState = gt,
        Wr = !0),
        ft = ft.queue,
        ao(c0.bind(null, ut, ft, _e), [_e]),
        ft.getSnapshot !== et || Et || wr !== null && wr.memoizedState.tag & 1) {
            if (ut.flags |= 2048,
            so(9, l0.bind(null, ut, ft, gt, et), void 0, null),
            _r === null)
                throw Error(g(349));
            Ys & 30 || o0(ut, et, gt)
        }
        return gt
    }
    function o0(_e, et, ut) {
        _e.flags |= 16384,
        _e = {
            getSnapshot: et,
            value: ut
        },
        et = yr.updateQueue,
        et === null ? (et = {
            lastEffect: null,
            stores: null
        },
        yr.updateQueue = et,
        et.stores = [_e]) : (ut = et.stores,
        ut === null ? et.stores = [_e] : ut.push(_e))
    }
    function l0(_e, et, ut, ft) {
        et.value = ut,
        et.getSnapshot = ft,
        u0(et) && Zr(_e, 1, -1)
    }
    function c0(_e, et, ut) {
        return ut(function() {
            u0(et) && Zr(_e, 1, -1)
        })
    }
    function u0(_e) {
        var et = _e.getSnapshot;
        _e = _e.value;
        try {
            var ut = et();
            return !ss(_e, ut)
        } catch {
            return !0
        }
    }
    function lu(_e) {
        var et = gs();
        return typeof _e == "function" && (_e = _e()),
        et.memoizedState = et.baseState = _e,
        _e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ps,
            lastRenderedState: _e
        },
        et.queue = _e,
        _e = _e.dispatch = Ip.bind(null, yr, _e),
        [et.memoizedState, _e]
    }
    function so(_e, et, ut, ft) {
        return _e = {
            tag: _e,
            create: et,
            destroy: ut,
            deps: ft,
            next: null
        },
        et = yr.updateQueue,
        et === null ? (et = {
            lastEffect: null,
            stores: null
        },
        yr.updateQueue = et,
        et.lastEffect = _e.next = _e) : (ut = et.lastEffect,
        ut === null ? et.lastEffect = _e.next = _e : (ft = ut.next,
        ut.next = _e,
        _e.next = ft,
        et.lastEffect = _e)),
        _e
    }
    function h0() {
        return cs().memoizedState
    }
    function Oo(_e, et, ut, ft) {
        var gt = gs();
        yr.flags |= _e,
        gt.memoizedState = so(1 | et, ut, void 0, ft === void 0 ? null : ft)
    }
    function Uo(_e, et, ut, ft) {
        var gt = cs();
        ft = ft === void 0 ? null : ft;
        var Et = void 0;
        if (Rr !== null) {
            var It = Rr.memoizedState;
            if (Et = It.destroy,
            ft !== null && su(ft, It.deps)) {
                gt.memoizedState = so(et, ut, Et, ft);
                return
            }
        }
        yr.flags |= _e,
        gt.memoizedState = so(1 | et, ut, Et, ft)
    }
    function cu(_e, et) {
        return Oo(8390656, 8, _e, et)
    }
    function ao(_e, et) {
        return Uo(2048, 8, _e, et)
    }
    function f0(_e, et) {
        return Uo(4, 2, _e, et)
    }
    function d0(_e, et) {
        return Uo(4, 4, _e, et)
    }
    function p0(_e, et) {
        if (typeof et == "function")
            return _e = _e(),
            et(_e),
            function() {
                et(null)
            }
            ;
        if (et != null)
            return _e = _e(),
            et.current = _e,
            function() {
                et.current = null
            }
    }
    function m0(_e, et, ut) {
        return ut = ut != null ? ut.concat([_e]) : null,
        Uo(4, 4, p0.bind(null, et, _e), ut)
    }
    function uu() {}
    function g0(_e, et) {
        var ut = cs();
        et = et === void 0 ? null : et;
        var ft = ut.memoizedState;
        return ft !== null && et !== null && su(et, ft[1]) ? ft[0] : (ut.memoizedState = [_e, et],
        _e)
    }
    function y0(_e, et) {
        var ut = cs();
        et = et === void 0 ? null : et;
        var ft = ut.memoizedState;
        return ft !== null && et !== null && su(et, ft[1]) ? ft[0] : (_e = _e(),
        ut.memoizedState = [_e, et],
        _e)
    }
    function Rp(_e, et) {
        var ut = ir;
        ir = ut !== 0 && 4 > ut ? ut : 4,
        _e(!0);
        var ft = Kr.transition;
        Kr.transition = {};
        try {
            _e(!1),
            et()
        } finally {
            ir = ut,
            Kr.transition = ft
        }
    }
    function v0() {
        return cs().memoizedState
    }
    function Lp(_e, et, ut) {
        var ft = Ms(_e);
        ut = {
            lane: ft,
            action: ut,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        x0(_e) ? _0(et, ut) : (S0(_e, et, ut),
        ut = Br(),
        _e = Zr(_e, ft, ut),
        _e !== null && E0(_e, et, ft))
    }
    function Ip(_e, et, ut) {
        var ft = Ms(_e)
          , gt = {
            lane: ft,
            action: ut,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (x0(_e))
            _0(et, gt);
        else {
            S0(_e, et, gt);
            var Et = _e.alternate;
            if (_e.lanes === 0 && (Et === null || Et.lanes === 0) && (Et = et.lastRenderedReducer,
            Et !== null))
                try {
                    var It = et.lastRenderedState
                      , Ut = Et(It, ut);
                    if (gt.hasEagerState = !0,
                    gt.eagerState = Ut,
                    ss(Ut, It))
                        return
                } catch {} finally {}
            ut = Br(),
            _e = Zr(_e, ft, ut),
            _e !== null && E0(_e, et, ft)
        }
    }
    function x0(_e) {
        var et = _e.alternate;
        return _e === yr || et !== null && et === yr
    }
    function _0(_e, et) {
        io = Bo = !0;
        var ut = _e.pending;
        ut === null ? et.next = et : (et.next = ut.next,
        ut.next = et),
        _e.pending = et
    }
    function S0(_e, et, ut) {
        _r !== null && _e.mode & 1 && !(_i & 2) ? (_e = et.interleaved,
        _e === null ? (ut.next = ut,
        os === null ? os = [et] : os.push(et)) : (ut.next = _e.next,
        _e.next = ut),
        et.interleaved = ut) : (_e = et.pending,
        _e === null ? ut.next = ut : (ut.next = _e.next,
        _e.next = ut),
        et.pending = ut)
    }
    function E0(_e, et, ut) {
        if (ut & 4194240) {
            var ft = et.lanes;
            ft &= _e.pendingLanes,
            ut |= ft,
            et.lanes = ut,
            Vl(_e, ut)
        }
    }
    var zo = {
        readContext: $r,
        useCallback: Lr,
        useContext: Lr,
        useEffect: Lr,
        useImperativeHandle: Lr,
        useInsertionEffect: Lr,
        useLayoutEffect: Lr,
        useMemo: Lr,
        useReducer: Lr,
        useRef: Lr,
        useState: Lr,
        useDebugValue: Lr,
        useDeferredValue: Lr,
        useTransition: Lr,
        useMutableSource: Lr,
        useSyncExternalStore: Lr,
        useId: Lr,
        unstable_isNewReconciler: !1
    }
      , Dp = {
        readContext: $r,
        useCallback: function(_e, et) {
            return gs().memoizedState = [_e, et === void 0 ? null : et],
            _e
        },
        useContext: $r,
        useEffect: cu,
        useImperativeHandle: function(_e, et, ut) {
            return ut = ut != null ? ut.concat([_e]) : null,
            Oo(4194308, 4, p0.bind(null, et, _e), ut)
        },
        useLayoutEffect: function(_e, et) {
            return Oo(4194308, 4, _e, et)
        },
        useInsertionEffect: function(_e, et) {
            return Oo(4, 2, _e, et)
        },
        useMemo: function(_e, et) {
            var ut = gs();
            return et = et === void 0 ? null : et,
            _e = _e(),
            ut.memoizedState = [_e, et],
            _e
        },
        useReducer: function(_e, et, ut) {
            var ft = gs();
            return et = ut !== void 0 ? ut(et) : et,
            ft.memoizedState = ft.baseState = et,
            _e = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: _e,
                lastRenderedState: et
            },
            ft.queue = _e,
            _e = _e.dispatch = Lp.bind(null, yr, _e),
            [ft.memoizedState, _e]
        },
        useRef: function(_e) {
            var et = gs();
            return _e = {
                current: _e
            },
            et.memoizedState = _e
        },
        useState: lu,
        useDebugValue: uu,
        useDeferredValue: function(_e) {
            var et = lu(_e)
              , ut = et[0]
              , ft = et[1];
            return cu(function() {
                var gt = Kr.transition;
                Kr.transition = {};
                try {
                    ft(_e)
                } finally {
                    Kr.transition = gt
                }
            }, [_e]),
            ut
        },
        useTransition: function() {
            var _e = lu(!1)
              , et = _e[0];
            return _e = Rp.bind(null, _e[1]),
            gs().memoizedState = _e,
            [et, _e]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(_e, et, ut) {
            var ft = yr
              , gt = gs();
            if (pr) {
                if (ut === void 0)
                    throw Error(g(407));
                ut = ut()
            } else {
                if (ut = et(),
                _r === null)
                    throw Error(g(349));
                Ys & 30 || o0(ft, et, ut)
            }
            gt.memoizedState = ut;
            var Et = {
                value: ut,
                getSnapshot: et
            };
            return gt.queue = Et,
            cu(c0.bind(null, ft, Et, _e), [_e]),
            ft.flags |= 2048,
            so(9, l0.bind(null, ft, Et, ut, et), void 0, null),
            ut
        },
        useId: function() {
            var _e = gs()
              , et = _r.identifierPrefix;
            if (pr) {
                var ut = ms
                  , ft = ps;
                ut = (ft & ~(1 << 32 - zr(ft) - 1)).toString(32) + ut,
                et = ":" + et + "R" + ut,
                ut = ro++,
                0 < ut && (et += "H" + ut.toString(32)),
                et += ":"
            } else
                ut = kp++,
                et = ":" + et + "r" + ut.toString(32) + ":";
            return _e.memoizedState = et
        },
        unstable_isNewReconciler: !1
    }
      , Fp = {
        readContext: $r,
        useCallback: g0,
        useContext: $r,
        useEffect: ao,
        useImperativeHandle: m0,
        useInsertionEffect: f0,
        useLayoutEffect: d0,
        useMemo: y0,
        useReducer: Vo,
        useRef: h0,
        useState: function() {
            return Vo(Ps)
        },
        useDebugValue: uu,
        useDeferredValue: function(_e) {
            var et = Vo(Ps)
              , ut = et[0]
              , ft = et[1];
            return ao(function() {
                var gt = Kr.transition;
                Kr.transition = {};
                try {
                    ft(_e)
                } finally {
                    Kr.transition = gt
                }
            }, [_e]),
            ut
        },
        useTransition: function() {
            var _e = Vo(Ps)[0]
              , et = cs().memoizedState;
            return [_e, et]
        },
        useMutableSource: s0,
        useSyncExternalStore: a0,
        useId: v0,
        unstable_isNewReconciler: !1
    }
      , Bp = {
        readContext: $r,
        useCallback: g0,
        useContext: $r,
        useEffect: ao,
        useImperativeHandle: m0,
        useInsertionEffect: f0,
        useLayoutEffect: d0,
        useMemo: y0,
        useReducer: No,
        useRef: h0,
        useState: function() {
            return No(Ps)
        },
        useDebugValue: uu,
        useDeferredValue: function(_e) {
            var et = No(Ps)
              , ut = et[0]
              , ft = et[1];
            return ao(function() {
                var gt = Kr.transition;
                Kr.transition = {};
                try {
                    ft(_e)
                } finally {
                    Kr.transition = gt
                }
            }, [_e]),
            ut
        },
        useTransition: function() {
            var _e = No(Ps)[0]
              , et = cs().memoizedState;
            return [_e, et]
        },
        useMutableSource: s0,
        useSyncExternalStore: a0,
        useId: v0,
        unstable_isNewReconciler: !1
    };
    function hu(_e, et) {
        try {
            var ut = ""
              , ft = et;
            do
                ut += Pp(ft),
                ft = ft.return;
            while (ft);
            var gt = ut
        } catch (Et) {
            gt = `
Error generating stack: ` + Et.message + `
` + Et.stack
        }
        return {
            value: _e,
            source: et,
            stack: gt
        }
    }
    function fu(_e, et) {
        try {
            console.error(et.value)
        } catch (ut) {
            setTimeout(function() {
                throw ut
            })
        }
    }
    var Vp = typeof WeakMap == "function" ? WeakMap : Map;
    function M0(_e, et, ut) {
        ut = ds(-1, ut),
        ut.tag = 3,
        ut.payload = {
            element: null
        };
        var ft = et.value;
        return ut.callback = function() {
            Sl || (Sl = !0,
            ku = ft),
            fu(_e, et)
        }
        ,
        ut
    }
    function b0(_e, et, ut) {
        ut = ds(-1, ut),
        ut.tag = 3;
        var ft = _e.type.getDerivedStateFromError;
        if (typeof ft == "function") {
            var gt = et.value;
            ut.payload = function() {
                return ft(gt)
            }
            ,
            ut.callback = function() {
                fu(_e, et)
            }
        }
        var Et = _e.stateNode;
        return Et !== null && typeof Et.componentDidCatch == "function" && (ut.callback = function() {
            fu(_e, et),
            typeof ft != "function" && (Ss === null ? Ss = new Set([this]) : Ss.add(this));
            var It = et.stack;
            this.componentDidCatch(et.value, {
                componentStack: It !== null ? It : ""
            })
        }
        ),
        ut
    }
    function A0(_e, et, ut) {
        var ft = _e.pingCache;
        if (ft === null) {
            ft = _e.pingCache = new Vp;
            var gt = new Set;
            ft.set(et, gt)
        } else
            gt = ft.get(et),
            gt === void 0 && (gt = new Set,
            ft.set(et, gt));
        gt.has(ut) || (gt.add(ut),
        _e = Zp.bind(null, _e, et, ut),
        et.then(_e, _e))
    }
    function T0(_e) {
        do {
            var et;
            if ((et = _e.tag === 13) && (et = _e.memoizedState,
            et = et !== null ? et.dehydrated !== null : !0),
            et)
                return _e;
            _e = _e.return
        } while (_e !== null);
        return null
    }
    function w0(_e, et, ut, ft, gt) {
        return _e.mode & 1 ? (_e.flags |= 65536,
        _e.lanes = gt,
        _e) : (_e === et ? _e.flags |= 65536 : (_e.flags |= 128,
        ut.flags |= 131072,
        ut.flags &= -52805,
        ut.tag === 1 && (ut.alternate === null ? ut.tag = 17 : (et = ds(-1, 1),
        et.tag = 2,
        _s(ut, et))),
        ut.lanes |= 1),
        _e)
    }
    function us(_e) {
        _e.flags |= 4
    }
    function C0(_e, et) {
        if (_e !== null && _e.child === et.child)
            return !0;
        if (et.flags & 16)
            return !1;
        for (_e = et.child; _e !== null; ) {
            if (_e.flags & 12854 || _e.subtreeFlags & 12854)
                return !1;
            _e = _e.sibling
        }
        return !0
    }
    var oo, lo, Go, Ho;
    if (yn)
        oo = function(_e, et) {
            for (var ut = et.child; ut !== null; ) {
                if (ut.tag === 5 || ut.tag === 6)
                    Ht(_e, ut.stateNode);
                else if (ut.tag !== 4 && ut.child !== null) {
                    ut.child.return = ut,
                    ut = ut.child;
                    continue
                }
                if (ut === et)
                    break;
                for (; ut.sibling === null; ) {
                    if (ut.return === null || ut.return === et)
                        return;
                    ut = ut.return
                }
                ut.sibling.return = ut.return,
                ut = ut.sibling
            }
        }
        ,
        lo = function() {}
        ,
        Go = function(_e, et, ut, ft, gt) {
            if (_e = _e.memoizedProps,
            _e !== ft) {
                var Et = et.stateNode
                  , It = ls(Yr.current);
                ut = Ot(Et, ut, _e, ft, gt, It),
                (et.updateQueue = ut) && us(et)
            }
        }
        ,
        Ho = function(_e, et, ut, ft) {
            ut !== ft && us(et)
        }
        ;
    else if (Pt) {
        oo = function(_e, et, ut, ft) {
            for (var gt = et.child; gt !== null; ) {
                if (gt.tag === 5) {
                    var Et = gt.stateNode;
                    ut && ft && (Et = Mr(Et, gt.type, gt.memoizedProps, gt)),
                    Ht(_e, Et)
                } else if (gt.tag === 6)
                    Et = gt.stateNode,
                    ut && ft && (Et = br(Et, gt.memoizedProps, gt)),
                    Ht(_e, Et);
                else if (gt.tag !== 4) {
                    if (gt.tag === 22 && gt.memoizedState !== null)
                        Et = gt.child,
                        Et !== null && (Et.return = gt),
                        oo(_e, gt, !0, !0);
                    else if (gt.child !== null) {
                        gt.child.return = gt,
                        gt = gt.child;
                        continue
                    }
                }
                if (gt === et)
                    break;
                for (; gt.sibling === null; ) {
                    if (gt.return === null || gt.return === et)
                        return;
                    gt = gt.return
                }
                gt.sibling.return = gt.return,
                gt = gt.sibling
            }
        }
        ;
        var P0 = function(_e, et, ut, ft) {
            for (var gt = et.child; gt !== null; ) {
                if (gt.tag === 5) {
                    var Et = gt.stateNode;
                    ut && ft && (Et = Mr(Et, gt.type, gt.memoizedProps, gt)),
                    tr(_e, Et)
                } else if (gt.tag === 6)
                    Et = gt.stateNode,
                    ut && ft && (Et = br(Et, gt.memoizedProps, gt)),
                    tr(_e, Et);
                else if (gt.tag !== 4) {
                    if (gt.tag === 22 && gt.memoizedState !== null)
                        Et = gt.child,
                        Et !== null && (Et.return = gt),
                        P0(_e, gt, !0, !0);
                    else if (gt.child !== null) {
                        gt.child.return = gt,
                        gt = gt.child;
                        continue
                    }
                }
                if (gt === et)
                    break;
                for (; gt.sibling === null; ) {
                    if (gt.return === null || gt.return === et)
                        return;
                    gt = gt.return
                }
                gt.sibling.return = gt.return,
                gt = gt.sibling
            }
        };
        lo = function(_e, et) {
            var ut = et.stateNode;
            if (!C0(_e, et)) {
                _e = ut.containerInfo;
                var ft = Yn(_e);
                P0(ft, et, !1, !1),
                ut.pendingChildren = ft,
                us(et),
                hr(_e, ft)
            }
        }
        ,
        Go = function(_e, et, ut, ft, gt) {
            var Et = _e.stateNode
              , It = _e.memoizedProps;
            if ((_e = C0(_e, et)) && It === ft)
                et.stateNode = Et;
            else {
                var Ut = et.stateNode
                  , nn = ls(Yr.current)
                  , xn = null;
                It !== ft && (xn = Ot(Ut, ut, It, ft, gt, nn)),
                _e && xn === null ? et.stateNode = Et : (Et = Hn(Et, xn, ut, It, ft, et, _e, Ut),
                en(Et, ut, ft, gt, nn) && us(et),
                et.stateNode = Et,
                _e ? us(et) : oo(Et, et, !1, !1))
            }
        }
        ,
        Ho = function(_e, et, ut, ft) {
            ut !== ft ? (_e = ls(Xs.current),
            ut = ls(Yr.current),
            et.stateNode = rn(ft, _e, ut, et),
            us(et)) : et.stateNode = _e.stateNode
        }
    } else
        lo = function() {}
        ,
        Go = function() {}
        ,
        Ho = function() {}
        ;
    function co(_e, et) {
        if (!pr)
            switch (_e.tailMode) {
            case "hidden":
                et = _e.tail;
                for (var ut = null; et !== null; )
                    et.alternate !== null && (ut = et),
                    et = et.sibling;
                ut === null ? _e.tail = null : ut.sibling = null;
                break;
            case "collapsed":
                ut = _e.tail;
                for (var ft = null; ut !== null; )
                    ut.alternate !== null && (ft = ut),
                    ut = ut.sibling;
                ft === null ? et || _e.tail === null ? _e.tail = null : _e.tail.sibling = null : ft.sibling = null
            }
    }
    function Ir(_e) {
        var et = _e.alternate !== null && _e.alternate.child === _e.child
          , ut = 0
          , ft = 0;
        if (et)
            for (var gt = _e.child; gt !== null; )
                ut |= gt.lanes | gt.childLanes,
                ft |= gt.subtreeFlags & 14680064,
                ft |= gt.flags & 14680064,
                gt.return = _e,
                gt = gt.sibling;
        else
            for (gt = _e.child; gt !== null; )
                ut |= gt.lanes | gt.childLanes,
                ft |= gt.subtreeFlags,
                ft |= gt.flags,
                gt.return = _e,
                gt = gt.sibling;
        return _e.subtreeFlags |= ft,
        _e.childLanes = ut,
        et
    }
    function Np(_e, et, ut) {
        var ft = et.pendingProps;
        switch (Ql(et),
        et.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Ir(et),
            null;
        case 1:
            return Ar(et.type) && dr(),
            Ir(et),
            null;
        case 3:
            return ft = et.stateNode,
            qs(),
            Un(ur),
            Un(qn),
            ru(),
            ft.pendingContext && (ft.context = ft.pendingContext,
            ft.pendingContext = null),
            (_e === null || _e.child === null) && ($a(et) ? us(et) : _e === null || _e.memoizedState.isDehydrated && !(et.flags & 256) || (et.flags |= 1024,
            ns !== null && (Iu(ns),
            ns = null))),
            lo(_e, et),
            Ir(et),
            null;
        case 5:
            nu(et),
            ut = ls(Xs.current);
            var gt = et.type;
            if (_e !== null && et.stateNode != null)
                Go(_e, et, gt, ft, ut),
                _e.ref !== et.ref && (et.flags |= 512,
                et.flags |= 2097152);
            else {
                if (!ft) {
                    if (et.stateNode === null)
                        throw Error(g(166));
                    return Ir(et),
                    null
                }
                if (_e = ls(Yr.current),
                $a(et)) {
                    if (!Qt)
                        throw Error(g(175));
                    _e = Ll(et.stateNode, et.type, et.memoizedProps, ut, _e, et, !ba),
                    et.updateQueue = _e,
                    _e !== null && us(et)
                } else {
                    var Et = Ct(gt, ft, ut, _e, et);
                    oo(Et, et, !1, !1),
                    et.stateNode = Et,
                    en(Et, gt, ft, ut, _e) && us(et)
                }
                et.ref !== null && (et.flags |= 512,
                et.flags |= 2097152)
            }
            return Ir(et),
            null;
        case 6:
            if (_e && et.stateNode != null)
                Ho(_e, et, _e.memoizedProps, ft);
            else {
                if (typeof ft != "string" && et.stateNode === null)
                    throw Error(g(166));
                if (_e = ls(Xs.current),
                ut = ls(Yr.current),
                $a(et)) {
                    if (!Qt)
                        throw Error(g(176));
                    if (_e = et.stateNode,
                    ft = et.memoizedProps,
                    (ut = Il(_e, ft, et, !ba)) && (gt = Gr,
                    gt !== null))
                        switch (Et = (gt.mode & 1) !== 0,
                        gt.tag) {
                        case 3:
                            In(gt.stateNode.containerInfo, _e, ft, Et);
                            break;
                        case 5:
                            Vn(gt.type, gt.memoizedProps, gt.stateNode, _e, ft, Et)
                        }
                    ut && us(et)
                } else
                    et.stateNode = rn(ft, _e, ut, et)
            }
            return Ir(et),
            null;
        case 13:
            if (Un(mr),
            ft = et.memoizedState,
            pr && Hr !== null && et.mode & 1 && !(et.flags & 128)) {
                for (_e = Hr; _e; )
                    _e = vs(_e);
                return js(),
                et.flags |= 98560,
                et
            }
            if (ft !== null && ft.dehydrated !== null) {
                if (ft = $a(et),
                _e === null) {
                    if (!ft)
                        throw Error(g(318));
                    if (!Qt)
                        throw Error(g(344));
                    if (_e = et.memoizedState,
                    _e = _e !== null ? _e.dehydrated : null,
                    !_e)
                        throw Error(g(317));
                    Dl(_e, et)
                } else
                    js(),
                    !(et.flags & 128) && (et.memoizedState = null),
                    et.flags |= 4;
                return Ir(et),
                null
            }
            return ns !== null && (Iu(ns),
            ns = null),
            et.flags & 128 ? (et.lanes = ut,
            et) : (ft = ft !== null,
            ut = !1,
            _e === null ? $a(et) : ut = _e.memoizedState !== null,
            ft && !ut && (et.child.flags |= 8192,
            et.mode & 1 && (_e === null || mr.current & 1 ? Er === 0 && (Er = 3) : Fu())),
            et.updateQueue !== null && (et.flags |= 4),
            Ir(et),
            null);
        case 4:
            return qs(),
            lo(_e, et),
            _e === null && fn(et.stateNode.containerInfo),
            Ir(et),
            null;
        case 10:
            return Wl(et.type._context),
            Ir(et),
            null;
        case 17:
            return Ar(et.type) && dr(),
            Ir(et),
            null;
        case 19:
            if (Un(mr),
            gt = et.memoizedState,
            gt === null)
                return Ir(et),
                null;
            if (ft = (et.flags & 128) !== 0,
            Et = gt.rendering,
            Et === null)
                if (ft)
                    co(gt, !1);
                else {
                    if (Er !== 0 || _e !== null && _e.flags & 128)
                        for (_e = et.child; _e !== null; ) {
                            if (Et = Do(_e),
                            Et !== null) {
                                for (et.flags |= 128,
                                co(gt, !1),
                                _e = Et.updateQueue,
                                _e !== null && (et.updateQueue = _e,
                                et.flags |= 4),
                                et.subtreeFlags = 0,
                                _e = ut,
                                ft = et.child; ft !== null; )
                                    ut = ft,
                                    gt = _e,
                                    ut.flags &= 14680066,
                                    Et = ut.alternate,
                                    Et === null ? (ut.childLanes = 0,
                                    ut.lanes = gt,
                                    ut.child = null,
                                    ut.subtreeFlags = 0,
                                    ut.memoizedProps = null,
                                    ut.memoizedState = null,
                                    ut.updateQueue = null,
                                    ut.dependencies = null,
                                    ut.stateNode = null) : (ut.childLanes = Et.childLanes,
                                    ut.lanes = Et.lanes,
                                    ut.child = Et.child,
                                    ut.subtreeFlags = 0,
                                    ut.deletions = null,
                                    ut.memoizedProps = Et.memoizedProps,
                                    ut.memoizedState = Et.memoizedState,
                                    ut.updateQueue = Et.updateQueue,
                                    ut.type = Et.type,
                                    gt = Et.dependencies,
                                    ut.dependencies = gt === null ? null : {
                                        lanes: gt.lanes,
                                        firstContext: gt.firstContext
                                    }),
                                    ft = ft.sibling;
                                return Mn(mr, mr.current & 1 | 2),
                                et.child
                            }
                            _e = _e.sibling
                        }
                    gt.tail !== null && Tr() > Pu && (et.flags |= 128,
                    ft = !0,
                    co(gt, !1),
                    et.lanes = 4194304)
                }
            else {
                if (!ft)
                    if (_e = Do(Et),
                    _e !== null) {
                        if (et.flags |= 128,
                        ft = !0,
                        _e = _e.updateQueue,
                        _e !== null && (et.updateQueue = _e,
                        et.flags |= 4),
                        co(gt, !0),
                        gt.tail === null && gt.tailMode === "hidden" && !Et.alternate && !pr)
                            return Ir(et),
                            null
                    } else
                        2 * Tr() - gt.renderingStartTime > Pu && ut !== 1073741824 && (et.flags |= 128,
                        ft = !0,
                        co(gt, !1),
                        et.lanes = 4194304);
                gt.isBackwards ? (Et.sibling = et.child,
                et.child = Et) : (_e = gt.last,
                _e !== null ? _e.sibling = Et : et.child = Et,
                gt.last = Et)
            }
            return gt.tail !== null ? (et = gt.tail,
            gt.rendering = et,
            gt.tail = et.sibling,
            gt.renderingStartTime = Tr(),
            et.sibling = null,
            _e = mr.current,
            Mn(mr, ft ? _e & 1 | 2 : _e & 1),
            et) : (Ir(et),
            null);
        case 22:
        case 23:
            return Du(),
            ft = et.memoizedState !== null,
            _e !== null && _e.memoizedState !== null !== ft && (et.flags |= 8192),
            ft && et.mode & 1 ? jr & 1073741824 && (Ir(et),
            yn && et.subtreeFlags & 6 && (et.flags |= 8192)) : Ir(et),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(g(156, et.tag))
    }
    var Op = _.ReactCurrentOwner
      , Wr = !1;
    function Fr(_e, et, ut, ft) {
        et.child = _e === null ? i0(et, null, ut, ft) : $s(et, _e.child, ut, ft)
    }
    function k0(_e, et, ut, ft, gt) {
        ut = ut.render;
        var Et = et.ref;
        return Gs(et, gt),
        ft = au(_e, et, ut, ft, Et, gt),
        ut = ou(),
        _e !== null && !Wr ? (et.updateQueue = _e.updateQueue,
        et.flags &= -2053,
        _e.lanes &= ~gt,
        ys(_e, et, gt)) : (pr && ut && Zl(et),
        et.flags |= 1,
        Fr(_e, et, ft, gt),
        et.child)
    }
    function R0(_e, et, ut, ft, gt) {
        if (_e === null) {
            var Et = ut.type;
            return typeof Et == "function" && !Bu(Et) && Et.defaultProps === void 0 && ut.compare === null && ut.defaultProps === void 0 ? (et.tag = 15,
            et.type = Et,
            L0(_e, et, Et, ft, gt)) : (_e = Pl(ut.type, null, ft, et, et.mode, gt),
            _e.ref = et.ref,
            _e.return = et,
            et.child = _e)
        }
        if (Et = _e.child,
        !(_e.lanes & gt)) {
            var It = Et.memoizedProps;
            if (ut = ut.compare,
            ut = ut !== null ? ut : Ao,
            ut(It, ft) && _e.ref === et.ref)
                return ys(_e, et, gt)
        }
        return et.flags |= 1,
        _e = As(Et, ft),
        _e.ref = et.ref,
        _e.return = et,
        et.child = _e
    }
    function L0(_e, et, ut, ft, gt) {
        if (_e !== null && Ao(_e.memoizedProps, ft) && _e.ref === et.ref)
            if (Wr = !1,
            (_e.lanes & gt) !== 0)
                _e.flags & 131072 && (Wr = !0);
            else
                return et.lanes = _e.lanes,
                ys(_e, et, gt);
        return du(_e, et, ut, ft, gt)
    }
    function I0(_e, et, ut) {
        var ft = et.pendingProps
          , gt = ft.children
          , Et = _e !== null ? _e.memoizedState : null;
        if (ft.mode === "hidden")
            if (!(et.mode & 1))
                et.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                Mn(Ks, jr),
                jr |= ut;
            else if (ut & 1073741824)
                et.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                ft = Et !== null ? Et.baseLanes : ut,
                Mn(Ks, jr),
                jr |= ft;
            else
                return _e = Et !== null ? Et.baseLanes | ut : ut,
                et.lanes = et.childLanes = 1073741824,
                et.memoizedState = {
                    baseLanes: _e,
                    cachePool: null
                },
                et.updateQueue = null,
                Mn(Ks, jr),
                jr |= _e,
                null;
        else
            Et !== null ? (ft = Et.baseLanes | ut,
            et.memoizedState = null) : ft = ut,
            Mn(Ks, jr),
            jr |= ft;
        return Fr(_e, et, gt, ut),
        et.child
    }
    function D0(_e, et) {
        var ut = et.ref;
        (_e === null && ut !== null || _e !== null && _e.ref !== ut) && (et.flags |= 512,
        et.flags |= 2097152)
    }
    function du(_e, et, ut, ft, gt) {
        var Et = Ar(ut) ? Vr : qn.current;
        return Et = xr(et, Et),
        Gs(et, gt),
        ut = au(_e, et, ut, ft, Et, gt),
        ft = ou(),
        _e !== null && !Wr ? (et.updateQueue = _e.updateQueue,
        et.flags &= -2053,
        _e.lanes &= ~gt,
        ys(_e, et, gt)) : (pr && ft && Zl(et),
        et.flags |= 1,
        Fr(_e, et, ut, gt),
        et.child)
    }
    function F0(_e, et, ut, ft, gt) {
        if (Ar(ut)) {
            var Et = !0;
            Pr(et)
        } else
            Et = !1;
        if (Gs(et, gt),
        et.stateNode === null)
            _e !== null && (_e.alternate = null,
            et.alternate = null,
            et.flags |= 2),
            Yu(et, ut, ft),
            Kl(et, ut, ft, gt),
            ft = !0;
        else if (_e === null) {
            var It = et.stateNode
              , Ut = et.memoizedProps;
            It.props = Ut;
            var nn = It.context
              , xn = ut.contextType;
            typeof xn == "object" && xn !== null ? xn = $r(xn) : (xn = Ar(ut) ? Vr : qn.current,
            xn = xr(et, xn));
            var Fn = ut.getDerivedStateFromProps
              , Kn = typeof Fn == "function" || typeof It.getSnapshotBeforeUpdate == "function";
            Kn || typeof It.UNSAFE_componentWillReceiveProps != "function" && typeof It.componentWillReceiveProps != "function" || (Ut !== ft || nn !== xn) && Ku(et, It, ft, xn),
            xs = !1;
            var Wn = et.memoizedState;
            It.state = Wn,
            Po(et, ft, It, gt),
            nn = et.memoizedState,
            Ut !== ft || Wn !== nn || ur.current || xs ? (typeof Fn == "function" && (Yl(et, ut, Fn, ft),
            nn = et.memoizedState),
            (Ut = xs || qu(et, ut, Ut, ft, Wn, nn, xn)) ? (Kn || typeof It.UNSAFE_componentWillMount != "function" && typeof It.componentWillMount != "function" || (typeof It.componentWillMount == "function" && It.componentWillMount(),
            typeof It.UNSAFE_componentWillMount == "function" && It.UNSAFE_componentWillMount()),
            typeof It.componentDidMount == "function" && (et.flags |= 4194308)) : (typeof It.componentDidMount == "function" && (et.flags |= 4194308),
            et.memoizedProps = ft,
            et.memoizedState = nn),
            It.props = ft,
            It.state = nn,
            It.context = xn,
            ft = Ut) : (typeof It.componentDidMount == "function" && (et.flags |= 4194308),
            ft = !1)
        } else {
            It = et.stateNode,
            Wu(_e, et),
            Ut = et.memoizedProps,
            xn = et.type === et.elementType ? Ut : ts(et.type, Ut),
            It.props = xn,
            Kn = et.pendingProps,
            Wn = It.context,
            nn = ut.contextType,
            typeof nn == "object" && nn !== null ? nn = $r(nn) : (nn = Ar(ut) ? Vr : qn.current,
            nn = xr(et, nn));
            var or = ut.getDerivedStateFromProps;
            (Fn = typeof or == "function" || typeof It.getSnapshotBeforeUpdate == "function") || typeof It.UNSAFE_componentWillReceiveProps != "function" && typeof It.componentWillReceiveProps != "function" || (Ut !== Kn || Wn !== nn) && Ku(et, It, ft, nn),
            xs = !1,
            Wn = et.memoizedState,
            It.state = Wn,
            Po(et, ft, It, gt);
            var On = et.memoizedState;
            Ut !== Kn || Wn !== On || ur.current || xs ? (typeof or == "function" && (Yl(et, ut, or, ft),
            On = et.memoizedState),
            (xn = xs || qu(et, ut, xn, ft, Wn, On, nn) || !1) ? (Fn || typeof It.UNSAFE_componentWillUpdate != "function" && typeof It.componentWillUpdate != "function" || (typeof It.componentWillUpdate == "function" && It.componentWillUpdate(ft, On, nn),
            typeof It.UNSAFE_componentWillUpdate == "function" && It.UNSAFE_componentWillUpdate(ft, On, nn)),
            typeof It.componentDidUpdate == "function" && (et.flags |= 4),
            typeof It.getSnapshotBeforeUpdate == "function" && (et.flags |= 1024)) : (typeof It.componentDidUpdate != "function" || Ut === _e.memoizedProps && Wn === _e.memoizedState || (et.flags |= 4),
            typeof It.getSnapshotBeforeUpdate != "function" || Ut === _e.memoizedProps && Wn === _e.memoizedState || (et.flags |= 1024),
            et.memoizedProps = ft,
            et.memoizedState = On),
            It.props = ft,
            It.state = On,
            It.context = nn,
            ft = xn) : (typeof It.componentDidUpdate != "function" || Ut === _e.memoizedProps && Wn === _e.memoizedState || (et.flags |= 4),
            typeof It.getSnapshotBeforeUpdate != "function" || Ut === _e.memoizedProps && Wn === _e.memoizedState || (et.flags |= 1024),
            ft = !1)
        }
        return pu(_e, et, ut, ft, Et, gt)
    }
    function pu(_e, et, ut, ft, gt, Et) {
        D0(_e, et);
        var It = (et.flags & 128) !== 0;
        if (!ft && !It)
            return gt && Us(et, ut, !1),
            ys(_e, et, Et);
        ft = et.stateNode,
        Op.current = et;
        var Ut = It && typeof ut.getDerivedStateFromError != "function" ? null : ft.render();
        return et.flags |= 1,
        _e !== null && It ? (et.child = $s(et, _e.child, null, Et),
        et.child = $s(et, null, Ut, Et)) : Fr(_e, et, Ut, Et),
        et.memoizedState = ft.state,
        gt && Us(et, ut, !0),
        et.child
    }
    function B0(_e) {
        var et = _e.stateNode;
        et.pendingContext ? es(_e, et.pendingContext, et.pendingContext !== et.context) : et.context && es(_e, et.context, !1),
        tu(_e, et.containerInfo)
    }
    function V0(_e, et, ut, ft, gt) {
        return js(),
        eu(gt),
        et.flags |= 256,
        Fr(_e, et, ut, ft),
        et.child
    }
    var Wo = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function jo(_e) {
        return {
            baseLanes: _e,
            cachePool: null
        }
    }
    function N0(_e, et, ut) {
        var ft = et.pendingProps, gt = mr.current, Et = !1, It = (et.flags & 128) !== 0, Ut;
        if ((Ut = It) || (Ut = _e !== null && _e.memoizedState === null ? !1 : (gt & 2) !== 0),
        Ut ? (Et = !0,
        et.flags &= -129) : (_e === null || _e.memoizedState !== null) && (gt |= 1),
        Mn(mr, gt & 1),
        _e === null)
            return _c(et),
            _e = et.memoizedState,
            _e !== null && (_e = _e.dehydrated,
            _e !== null) ? (et.mode & 1 ? Bs(_e) ? et.lanes = 8 : et.lanes = 1073741824 : et.lanes = 1,
            null) : (gt = ft.children,
            _e = ft.fallback,
            Et ? (ft = et.mode,
            Et = et.child,
            gt = {
                mode: "hidden",
                children: gt
            },
            !(ft & 1) && Et !== null ? (Et.childLanes = 0,
            Et.pendingProps = gt) : Et = Rl(gt, ft, 0, null),
            _e = Fs(_e, ft, ut, null),
            Et.return = et,
            _e.return = et,
            Et.sibling = _e,
            et.child = Et,
            et.child.memoizedState = jo(ut),
            et.memoizedState = Wo,
            _e) : mu(et, gt));
        if (gt = _e.memoizedState,
        gt !== null) {
            if (Ut = gt.dehydrated,
            Ut !== null) {
                if (It)
                    return et.flags & 256 ? (et.flags &= -257,
                    $o(_e, et, ut, Error(g(422)))) : et.memoizedState !== null ? (et.child = _e.child,
                    et.flags |= 128,
                    null) : (Et = ft.fallback,
                    gt = et.mode,
                    ft = Rl({
                        mode: "visible",
                        children: ft.children
                    }, gt, 0, null),
                    Et = Fs(Et, gt, ut, null),
                    Et.flags |= 2,
                    ft.return = et,
                    Et.return = et,
                    ft.sibling = Et,
                    et.child = ft,
                    et.mode & 1 && $s(et, _e.child, null, ut),
                    et.child.memoizedState = jo(ut),
                    et.memoizedState = Wo,
                    Et);
                if (!(et.mode & 1))
                    et = $o(_e, et, ut, null);
                else if (Bs(Ut))
                    et = $o(_e, et, ut, Error(g(419)));
                else if (ft = (ut & _e.childLanes) !== 0,
                Wr || ft) {
                    if (ft = _r,
                    ft !== null) {
                        switch (ut & -ut) {
                        case 4:
                            Et = 2;
                            break;
                        case 16:
                            Et = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            Et = 32;
                            break;
                        case 536870912:
                            Et = 268435456;
                            break;
                        default:
                            Et = 0
                        }
                        ft = Et & (ft.suspendedLanes | ut) ? 0 : Et,
                        ft !== 0 && ft !== gt.retryLane && (gt.retryLane = ft,
                        Zr(_e, ft, -1))
                    }
                    Fu(),
                    et = $o(_e, et, ut, Error(g(421)))
                } else
                    na(Ut) ? (et.flags |= 128,
                    et.child = _e.child,
                    et = Qp.bind(null, _e),
                    Vs(Ut, et),
                    et = null) : (ut = gt.treeContext,
                    Qt && (Hr = vo(Ut),
                    Gr = et,
                    pr = !0,
                    ns = null,
                    ba = !1,
                    ut !== null && (Xr[qr++] = ps,
                    Xr[qr++] = ms,
                    Xr[qr++] = ws,
                    ps = ut.id,
                    ms = ut.overflow,
                    ws = et)),
                    et = mu(et, et.pendingProps.children),
                    et.flags |= 4096);
                return et
            }
            return Et ? (ft = U0(_e, et, ft.children, ft.fallback, ut),
            Et = et.child,
            gt = _e.child.memoizedState,
            Et.memoizedState = gt === null ? jo(ut) : {
                baseLanes: gt.baseLanes | ut,
                cachePool: null
            },
            Et.childLanes = _e.childLanes & ~ut,
            et.memoizedState = Wo,
            ft) : (ut = O0(_e, et, ft.children, ut),
            et.memoizedState = null,
            ut)
        }
        return Et ? (ft = U0(_e, et, ft.children, ft.fallback, ut),
        Et = et.child,
        gt = _e.child.memoizedState,
        Et.memoizedState = gt === null ? jo(ut) : {
            baseLanes: gt.baseLanes | ut,
            cachePool: null
        },
        Et.childLanes = _e.childLanes & ~ut,
        et.memoizedState = Wo,
        ft) : (ut = O0(_e, et, ft.children, ut),
        et.memoizedState = null,
        ut)
    }
    function mu(_e, et) {
        return et = Rl({
            mode: "visible",
            children: et
        }, _e.mode, 0, null),
        et.return = _e,
        _e.child = et
    }
    function O0(_e, et, ut, ft) {
        var gt = _e.child;
        return _e = gt.sibling,
        ut = As(gt, {
            mode: "visible",
            children: ut
        }),
        !(et.mode & 1) && (ut.lanes = ft),
        ut.return = et,
        ut.sibling = null,
        _e !== null && (ft = et.deletions,
        ft === null ? (et.deletions = [_e],
        et.flags |= 16) : ft.push(_e)),
        et.child = ut
    }
    function U0(_e, et, ut, ft, gt) {
        var Et = et.mode;
        _e = _e.child;
        var It = _e.sibling
          , Ut = {
            mode: "hidden",
            children: ut
        };
        return !(Et & 1) && et.child !== _e ? (ut = et.child,
        ut.childLanes = 0,
        ut.pendingProps = Ut,
        et.deletions = null) : (ut = As(_e, Ut),
        ut.subtreeFlags = _e.subtreeFlags & 14680064),
        It !== null ? ft = As(It, ft) : (ft = Fs(ft, Et, gt, null),
        ft.flags |= 2),
        ft.return = et,
        ut.return = et,
        ut.sibling = ft,
        et.child = ut,
        ft
    }
    function $o(_e, et, ut, ft) {
        return ft !== null && eu(ft),
        $s(et, _e.child, null, ut),
        _e = mu(et, et.pendingProps.children),
        _e.flags |= 2,
        et.memoizedState = null,
        _e
    }
    function z0(_e, et, ut) {
        _e.lanes |= et;
        var ft = _e.alternate;
        ft !== null && (ft.lanes |= et),
        $l(_e.return, et, ut)
    }
    function gu(_e, et, ut, ft, gt) {
        var Et = _e.memoizedState;
        Et === null ? _e.memoizedState = {
            isBackwards: et,
            rendering: null,
            renderingStartTime: 0,
            last: ft,
            tail: ut,
            tailMode: gt
        } : (Et.isBackwards = et,
        Et.rendering = null,
        Et.renderingStartTime = 0,
        Et.last = ft,
        Et.tail = ut,
        Et.tailMode = gt)
    }
    function G0(_e, et, ut) {
        var ft = et.pendingProps
          , gt = ft.revealOrder
          , Et = ft.tail;
        if (Fr(_e, et, ft.children, ut),
        ft = mr.current,
        ft & 2)
            ft = ft & 1 | 2,
            et.flags |= 128;
        else {
            if (_e !== null && _e.flags & 128)
                e: for (_e = et.child; _e !== null; ) {
                    if (_e.tag === 13)
                        _e.memoizedState !== null && z0(_e, ut, et);
                    else if (_e.tag === 19)
                        z0(_e, ut, et);
                    else if (_e.child !== null) {
                        _e.child.return = _e,
                        _e = _e.child;
                        continue
                    }
                    if (_e === et)
                        break e;
                    for (; _e.sibling === null; ) {
                        if (_e.return === null || _e.return === et)
                            break e;
                        _e = _e.return
                    }
                    _e.sibling.return = _e.return,
                    _e = _e.sibling
                }
            ft &= 1
        }
        if (Mn(mr, ft),
        !(et.mode & 1))
            et.memoizedState = null;
        else
            switch (gt) {
            case "forwards":
                for (ut = et.child,
                gt = null; ut !== null; )
                    _e = ut.alternate,
                    _e !== null && Do(_e) === null && (gt = ut),
                    ut = ut.sibling;
                ut = gt,
                ut === null ? (gt = et.child,
                et.child = null) : (gt = ut.sibling,
                ut.sibling = null),
                gu(et, !1, gt, ut, Et);
                break;
            case "backwards":
                for (ut = null,
                gt = et.child,
                et.child = null; gt !== null; ) {
                    if (_e = gt.alternate,
                    _e !== null && Do(_e) === null) {
                        et.child = gt;
                        break
                    }
                    _e = gt.sibling,
                    gt.sibling = ut,
                    ut = gt,
                    gt = _e
                }
                gu(et, !0, ut, null, Et);
                break;
            case "together":
                gu(et, !1, null, null, void 0);
                break;
            default:
                et.memoizedState = null
            }
        return et.child
    }
    function ys(_e, et, ut) {
        if (_e !== null && (et.dependencies = _e.dependencies),
        Zs |= et.lanes,
        !(ut & et.childLanes))
            return null;
        if (_e !== null && et.child !== _e.child)
            throw Error(g(153));
        if (et.child !== null) {
            for (_e = et.child,
            ut = As(_e, _e.pendingProps),
            et.child = ut,
            ut.return = et; _e.sibling !== null; )
                _e = _e.sibling,
                ut = ut.sibling = As(_e, _e.pendingProps),
                ut.return = et;
            ut.sibling = null
        }
        return et.child
    }
    function Up(_e, et, ut) {
        switch (et.tag) {
        case 3:
            B0(et),
            js();
            break;
        case 5:
            r0(et);
            break;
        case 1:
            Ar(et.type) && Pr(et);
            break;
        case 4:
            tu(et, et.stateNode.containerInfo);
            break;
        case 10:
            Hu(et, et.type._context, et.memoizedProps.value);
            break;
        case 13:
            var ft = et.memoizedState;
            if (ft !== null)
                return ft.dehydrated !== null ? (Mn(mr, mr.current & 1),
                et.flags |= 128,
                null) : ut & et.child.childLanes ? N0(_e, et, ut) : (Mn(mr, mr.current & 1),
                _e = ys(_e, et, ut),
                _e !== null ? _e.sibling : null);
            Mn(mr, mr.current & 1);
            break;
        case 19:
            if (ft = (ut & et.childLanes) !== 0,
            _e.flags & 128) {
                if (ft)
                    return G0(_e, et, ut);
                et.flags |= 128
            }
            var gt = et.memoizedState;
            if (gt !== null && (gt.rendering = null,
            gt.tail = null,
            gt.lastEffect = null),
            Mn(mr, mr.current),
            ft)
                break;
            return null;
        case 22:
        case 23:
            return et.lanes = 0,
            I0(_e, et, ut)
        }
        return ys(_e, et, ut)
    }
    function zp(_e, et) {
        switch (Ql(et),
        et.tag) {
        case 1:
            return Ar(et.type) && dr(),
            _e = et.flags,
            _e & 65536 ? (et.flags = _e & -65537 | 128,
            et) : null;
        case 3:
            return qs(),
            Un(ur),
            Un(qn),
            ru(),
            _e = et.flags,
            _e & 65536 && !(_e & 128) ? (et.flags = _e & -65537 | 128,
            et) : null;
        case 5:
            return nu(et),
            null;
        case 13:
            if (Un(mr),
            _e = et.memoizedState,
            _e !== null && _e.dehydrated !== null) {
                if (et.alternate === null)
                    throw Error(g(340));
                js()
            }
            return _e = et.flags,
            _e & 65536 ? (et.flags = _e & -65537 | 128,
            et) : null;
        case 19:
            return Un(mr),
            null;
        case 4:
            return qs(),
            null;
        case 10:
            return Wl(et.type._context),
            null;
        case 22:
        case 23:
            return Du(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Xo = !1
      , ks = !1
      , Gp = typeof WeakSet == "function" ? WeakSet : Set
      , wn = null;
    function qo(_e, et) {
        var ut = _e.ref;
        if (ut !== null)
            if (typeof ut == "function")
                try {
                    ut(null)
                } catch (ft) {
                    Ur(_e, et, ft)
                }
            else
                ut.current = null
    }
    function yu(_e, et, ut) {
        try {
            ut()
        } catch (ft) {
            Ur(_e, et, ft)
        }
    }
    var H0 = !1;
    function Hp(_e, et) {
        for (St(_e.containerInfo),
        wn = et; wn !== null; )
            if (_e = wn,
            et = _e.child,
            (_e.subtreeFlags & 1028) !== 0 && et !== null)
                et.return = _e,
                wn = et;
            else
                for (; wn !== null; ) {
                    _e = wn;
                    try {
                        var ut = _e.alternate;
                        if (_e.flags & 1024)
                            switch (_e.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (ut !== null) {
                                    var ft = ut.memoizedProps
                                      , gt = ut.memoizedState
                                      , Et = _e.stateNode
                                      , It = Et.getSnapshotBeforeUpdate(_e.elementType === _e.type ? ft : ts(_e.type, ft), gt);
                                    Et.__reactInternalSnapshotBeforeUpdate = It
                                }
                                break;
                            case 3:
                                yn && En(_e.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(g(163))
                            }
                    } catch (Ut) {
                        Ur(_e, _e.return, Ut)
                    }
                    if (et = _e.sibling,
                    et !== null) {
                        et.return = _e.return,
                        wn = et;
                        break
                    }
                    wn = _e.return
                }
        return ut = H0,
        H0 = !1,
        ut
    }
    function Rs(_e, et, ut) {
        var ft = et.updateQueue;
        if (ft = ft !== null ? ft.lastEffect : null,
        ft !== null) {
            var gt = ft = ft.next;
            do {
                if ((gt.tag & _e) === _e) {
                    var Et = gt.destroy;
                    gt.destroy = void 0,
                    Et !== void 0 && yu(et, ut, Et)
                }
                gt = gt.next
            } while (gt !== ft)
        }
    }
    function uo(_e, et) {
        if (et = et.updateQueue,
        et = et !== null ? et.lastEffect : null,
        et !== null) {
            var ut = et = et.next;
            do {
                if ((ut.tag & _e) === _e) {
                    var ft = ut.create;
                    ut.destroy = ft()
                }
                ut = ut.next
            } while (ut !== et)
        }
    }
    function vu(_e) {
        var et = _e.ref;
        if (et !== null) {
            var ut = _e.stateNode;
            switch (_e.tag) {
            case 5:
                _e = Mt(ut);
                break;
            default:
                _e = ut
            }
            typeof et == "function" ? et(_e) : et.current = _e
        }
    }
    function W0(_e, et, ut) {
        if (rs && typeof rs.onCommitFiberUnmount == "function")
            try {
                rs.onCommitFiberUnmount(Mo, et)
            } catch {}
        switch (et.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (_e = et.updateQueue,
            _e !== null && (_e = _e.lastEffect,
            _e !== null)) {
                var ft = _e = _e.next;
                do {
                    var gt = ft
                      , Et = gt.destroy;
                    gt = gt.tag,
                    Et !== void 0 && (gt & 2 || gt & 4) && yu(et, ut, Et),
                    ft = ft.next
                } while (ft !== _e)
            }
            break;
        case 1:
            if (qo(et, ut),
            _e = et.stateNode,
            typeof _e.componentWillUnmount == "function")
                try {
                    _e.props = et.memoizedProps,
                    _e.state = et.memoizedState,
                    _e.componentWillUnmount()
                } catch (It) {
                    Ur(et, ut, It)
                }
            break;
        case 5:
            qo(et, ut);
            break;
        case 4:
            yn ? K0(_e, et, ut) : Pt && Pt && (et = et.stateNode.containerInfo,
            ut = Yn(et),
            Jn(et, ut))
        }
    }
    function j0(_e, et, ut) {
        for (var ft = et; ; )
            if (W0(_e, ft, ut),
            ft.child === null || yn && ft.tag === 4) {
                if (ft === et)
                    break;
                for (; ft.sibling === null; ) {
                    if (ft.return === null || ft.return === et)
                        return;
                    ft = ft.return
                }
                ft.sibling.return = ft.return,
                ft = ft.sibling
            } else
                ft.child.return = ft,
                ft = ft.child
    }
    function $0(_e) {
        var et = _e.alternate;
        et !== null && (_e.alternate = null,
        $0(et)),
        _e.child = null,
        _e.deletions = null,
        _e.sibling = null,
        _e.tag === 5 && (et = _e.stateNode,
        et !== null && bn(et)),
        _e.stateNode = null,
        _e.return = null,
        _e.dependencies = null,
        _e.memoizedProps = null,
        _e.memoizedState = null,
        _e.pendingProps = null,
        _e.stateNode = null,
        _e.updateQueue = null
    }
    function X0(_e) {
        return _e.tag === 5 || _e.tag === 3 || _e.tag === 4
    }
    function q0(_e) {
        e: for (; ; ) {
            for (; _e.sibling === null; ) {
                if (_e.return === null || X0(_e.return))
                    return null;
                _e = _e.return
            }
            for (_e.sibling.return = _e.return,
            _e = _e.sibling; _e.tag !== 5 && _e.tag !== 6 && _e.tag !== 18; ) {
                if (_e.flags & 2 || _e.child === null || _e.tag === 4)
                    continue e;
                _e.child.return = _e,
                _e = _e.child
            }
            if (!(_e.flags & 2))
                return _e.stateNode
        }
    }
    function Y0(_e) {
        if (yn) {
            e: {
                for (var et = _e.return; et !== null; ) {
                    if (X0(et))
                        break e;
                    et = et.return
                }
                throw Error(g(160))
            }
            var ut = et;
            switch (ut.tag) {
            case 5:
                et = ut.stateNode,
                ut.flags & 32 && (Cn(et),
                ut.flags &= -33),
                ut = q0(_e),
                _u(_e, ut, et);
                break;
            case 3:
            case 4:
                et = ut.stateNode.containerInfo,
                ut = q0(_e),
                xu(_e, ut, et);
                break;
            default:
                throw Error(g(161))
            }
        }
    }
    function xu(_e, et, ut) {
        var ft = _e.tag;
        if (ft === 5 || ft === 6)
            _e = _e.stateNode,
            et ? Dn(ut, _e, et) : jn(ut, _e);
        else if (ft !== 4 && (_e = _e.child,
        _e !== null))
            for (xu(_e, et, ut),
            _e = _e.sibling; _e !== null; )
                xu(_e, et, ut),
                _e = _e.sibling
    }
    function _u(_e, et, ut) {
        var ft = _e.tag;
        if (ft === 5 || ft === 6)
            _e = _e.stateNode,
            et ? $n(ut, _e, et) : Tn(ut, _e);
        else if (ft !== 4 && (_e = _e.child,
        _e !== null))
            for (_u(_e, et, ut),
            _e = _e.sibling; _e !== null; )
                _u(_e, et, ut),
                _e = _e.sibling
    }
    function K0(_e, et, ut) {
        for (var ft = et, gt = !1, Et, It; ; ) {
            if (!gt) {
                gt = ft.return;
                e: for (; ; ) {
                    if (gt === null)
                        throw Error(g(160));
                    switch (Et = gt.stateNode,
                    gt.tag) {
                    case 5:
                        It = !1;
                        break e;
                    case 3:
                        Et = Et.containerInfo,
                        It = !0;
                        break e;
                    case 4:
                        Et = Et.containerInfo,
                        It = !0;
                        break e
                    }
                    gt = gt.return
                }
                gt = !0
            }
            if (ft.tag === 5 || ft.tag === 6)
                j0(_e, ft, ut),
                It ? ln(Et, ft.stateNode) : Nt(Et, ft.stateNode);
            else if (ft.tag === 18)
                It ? Wt(Et, ft.stateNode) : Zt(Et, ft.stateNode);
            else if (ft.tag === 4) {
                if (ft.child !== null) {
                    Et = ft.stateNode.containerInfo,
                    It = !0,
                    ft.child.return = ft,
                    ft = ft.child;
                    continue
                }
            } else if (W0(_e, ft, ut),
            ft.child !== null) {
                ft.child.return = ft,
                ft = ft.child;
                continue
            }
            if (ft === et)
                break;
            for (; ft.sibling === null; ) {
                if (ft.return === null || ft.return === et)
                    return;
                ft = ft.return,
                ft.tag === 4 && (gt = !1)
            }
            ft.sibling.return = ft.return,
            ft = ft.sibling
        }
    }
    function Su(_e, et) {
        if (yn) {
            switch (et.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Rs(3, et, et.return),
                uo(3, et),
                Rs(5, et, et.return);
                return;
            case 1:
                return;
            case 5:
                var ut = et.stateNode;
                if (ut != null) {
                    var ft = et.memoizedProps;
                    _e = _e !== null ? _e.memoizedProps : ft;
                    var gt = et.type
                      , Et = et.updateQueue;
                    et.updateQueue = null,
                    Et !== null && er(ut, Et, gt, _e, ft, et)
                }
                return;
            case 6:
                if (et.stateNode === null)
                    throw Error(g(162));
                ut = et.memoizedProps,
                pn(et.stateNode, _e !== null ? _e.memoizedProps : ut, ut);
                return;
            case 3:
                Qt && _e !== null && _e.memoizedState.isDehydrated && zt(et.stateNode.containerInfo);
                return;
            case 12:
                return;
            case 13:
                Yo(et);
                return;
            case 19:
                Yo(et);
                return;
            case 17:
                return
            }
            throw Error(g(163))
        }
        switch (et.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            Rs(3, et, et.return),
            uo(3, et),
            Rs(5, et, et.return);
            return;
        case 12:
            return;
        case 13:
            Yo(et);
            return;
        case 19:
            Yo(et);
            return;
        case 3:
            Qt && _e !== null && _e.memoizedState.isDehydrated && zt(et.stateNode.containerInfo);
            break;
        case 22:
        case 23:
            return
        }
        e: if (Pt) {
            switch (et.tag) {
            case 1:
            case 5:
            case 6:
                break e;
            case 3:
            case 4:
                et = et.stateNode,
                Jn(et.containerInfo, et.pendingChildren);
                break e
            }
            throw Error(g(163))
        }
    }
    function Yo(_e) {
        var et = _e.updateQueue;
        if (et !== null) {
            _e.updateQueue = null;
            var ut = _e.stateNode;
            ut === null && (ut = _e.stateNode = new Gp),
            et.forEach(function(ft) {
                var gt = Jp.bind(null, _e, ft);
                ut.has(ft) || (ut.add(ft),
                ft.then(gt, gt))
            })
        }
    }
    function Wp(_e, et) {
        for (wn = et; wn !== null; ) {
            et = wn;
            var ut = et.deletions;
            if (ut !== null)
                for (var ft = 0; ft < ut.length; ft++) {
                    var gt = ut[ft];
                    try {
                        var Et = _e;
                        yn ? K0(Et, gt, et) : j0(Et, gt, et);
                        var It = gt.alternate;
                        It !== null && (It.return = null),
                        gt.return = null
                    } catch (Nn) {
                        Ur(gt, et, Nn)
                    }
                }
            if (ut = et.child,
            et.subtreeFlags & 12854 && ut !== null)
                ut.return = et,
                wn = ut;
            else
                for (; wn !== null; ) {
                    et = wn;
                    try {
                        var Ut = et.flags;
                        if (Ut & 32 && yn && Cn(et.stateNode),
                        Ut & 512) {
                            var nn = et.alternate;
                            if (nn !== null) {
                                var xn = nn.ref;
                                xn !== null && (typeof xn == "function" ? xn(null) : xn.current = null)
                            }
                        }
                        if (Ut & 8192)
                            switch (et.tag) {
                            case 13:
                                if (et.memoizedState !== null) {
                                    var Fn = et.alternate;
                                    (Fn === null || Fn.memoizedState === null) && (Cu = Tr())
                                }
                                break;
                            case 22:
                                var Kn = et.memoizedState !== null
                                  , Wn = et.alternate
                                  , or = Wn !== null && Wn.memoizedState !== null;
                                if (ut = et,
                                yn) {
                                    e: if (ft = ut,
                                    gt = Kn,
                                    Et = null,
                                    yn)
                                        for (var On = ft; ; ) {
                                            if (On.tag === 5) {
                                                if (Et === null) {
                                                    Et = On;
                                                    var Dr = On.stateNode;
                                                    gt ? Vt(Dr) : an(On.stateNode, On.memoizedProps)
                                                }
                                            } else if (On.tag === 6) {
                                                if (Et === null) {
                                                    var Jr = On.stateNode;
                                                    gt ? hn(Jr) : un(Jr, On.memoizedProps)
                                                }
                                            } else if ((On.tag !== 22 && On.tag !== 23 || On.memoizedState === null || On === ft) && On.child !== null) {
                                                On.child.return = On,
                                                On = On.child;
                                                continue
                                            }
                                            if (On === ft)
                                                break;
                                            for (; On.sibling === null; ) {
                                                if (On.return === null || On.return === ft)
                                                    break e;
                                                Et === On && (Et = null),
                                                On = On.return
                                            }
                                            Et === On && (Et = null),
                                            On.sibling.return = On.return,
                                            On = On.sibling
                                        }
                                }
                                if (Kn && !or && ut.mode & 1) {
                                    wn = ut;
                                    for (var qt = ut.child; qt !== null; ) {
                                        for (ut = wn = qt; wn !== null; ) {
                                            ft = wn;
                                            var Gt = ft.child;
                                            switch (ft.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                Rs(4, ft, ft.return);
                                                break;
                                            case 1:
                                                qo(ft, ft.return);
                                                var Jt = ft.stateNode;
                                                if (typeof Jt.componentWillUnmount == "function") {
                                                    var Rn = ft.return;
                                                    try {
                                                        Jt.props = ft.memoizedProps,
                                                        Jt.state = ft.memoizedState,
                                                        Jt.componentWillUnmount()
                                                    } catch (Nn) {
                                                        Ur(ft, Rn, Nn)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                qo(ft, ft.return);
                                                break;
                                            case 22:
                                                if (ft.memoizedState !== null) {
                                                    J0(ut);
                                                    continue
                                                }
                                            }
                                            Gt !== null ? (Gt.return = ft,
                                            wn = Gt) : J0(ut)
                                        }
                                        qt = qt.sibling
                                    }
                                }
                            }
                        switch (Ut & 4102) {
                        case 2:
                            Y0(et),
                            et.flags &= -3;
                            break;
                        case 6:
                            Y0(et),
                            et.flags &= -3,
                            Su(et.alternate, et);
                            break;
                        case 4096:
                            et.flags &= -4097;
                            break;
                        case 4100:
                            et.flags &= -4097,
                            Su(et.alternate, et);
                            break;
                        case 4:
                            Su(et.alternate, et)
                        }
                    } catch (Nn) {
                        Ur(et, et.return, Nn)
                    }
                    if (ut = et.sibling,
                    ut !== null) {
                        ut.return = et.return,
                        wn = ut;
                        break
                    }
                    wn = et.return
                }
        }
    }
    function jp(_e, et, ut) {
        wn = _e,
        Z0(_e)
    }
    function Z0(_e, et, ut) {
        for (var ft = (_e.mode & 1) !== 0; wn !== null; ) {
            var gt = wn
              , Et = gt.child;
            if (gt.tag === 22 && ft) {
                var It = gt.memoizedState !== null || Xo;
                if (!It) {
                    var Ut = gt.alternate
                      , nn = Ut !== null && Ut.memoizedState !== null || ks;
                    Ut = Xo;
                    var xn = ks;
                    if (Xo = It,
                    (ks = nn) && !xn)
                        for (wn = gt; wn !== null; )
                            It = wn,
                            nn = It.child,
                            It.tag === 22 && It.memoizedState !== null ? _h(gt) : nn !== null ? (nn.return = It,
                            wn = nn) : _h(gt);
                    for (; Et !== null; )
                        wn = Et,
                        Z0(Et),
                        Et = Et.sibling;
                    wn = gt,
                    Xo = Ut,
                    ks = xn
                }
                Q0(_e)
            } else
                gt.subtreeFlags & 8772 && Et !== null ? (Et.return = gt,
                wn = Et) : Q0(_e)
        }
    }
    function Q0(_e) {
        for (; wn !== null; ) {
            var et = wn;
            if (et.flags & 8772) {
                var ut = et.alternate;
                try {
                    if (et.flags & 8772)
                        switch (et.tag) {
                        case 0:
                        case 11:
                        case 15:
                            ks || uo(5, et);
                            break;
                        case 1:
                            var ft = et.stateNode;
                            if (et.flags & 4 && !ks)
                                if (ut === null)
                                    ft.componentDidMount();
                                else {
                                    var gt = et.elementType === et.type ? ut.memoizedProps : ts(et.type, ut.memoizedProps);
                                    ft.componentDidUpdate(gt, ut.memoizedState, ft.__reactInternalSnapshotBeforeUpdate)
                                }
                            var Et = et.updateQueue;
                            Et !== null && $u(et, Et, ft);
                            break;
                        case 3:
                            var It = et.updateQueue;
                            if (It !== null) {
                                if (ut = null,
                                et.child !== null)
                                    switch (et.child.tag) {
                                    case 5:
                                        ut = Mt(et.child.stateNode);
                                        break;
                                    case 1:
                                        ut = et.child.stateNode
                                    }
                                $u(et, It, ut)
                            }
                            break;
                        case 5:
                            var Ut = et.stateNode;
                            ut === null && et.flags & 4 && kn(Ut, et.type, et.memoizedProps, et);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (Qt && et.memoizedState === null) {
                                var nn = et.alternate;
                                if (nn !== null) {
                                    var xn = nn.memoizedState;
                                    if (xn !== null) {
                                        var Fn = xn.dehydrated;
                                        Fn !== null && Kt(Fn)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(g(163))
                        }
                    ks || et.flags & 512 && vu(et)
                } catch (Kn) {
                    Ur(et, et.return, Kn)
                }
            }
            if (et === _e) {
                wn = null;
                break
            }
            if (ut = et.sibling,
            ut !== null) {
                ut.return = et.return,
                wn = ut;
                break
            }
            wn = et.return
        }
    }
    function J0(_e) {
        for (; wn !== null; ) {
            var et = wn;
            if (et === _e) {
                wn = null;
                break
            }
            var ut = et.sibling;
            if (ut !== null) {
                ut.return = et.return,
                wn = ut;
                break
            }
            wn = et.return
        }
    }
    function _h(_e) {
        for (; wn !== null; ) {
            var et = wn;
            try {
                switch (et.tag) {
                case 0:
                case 11:
                case 15:
                    var ut = et.return;
                    try {
                        uo(4, et)
                    } catch (nn) {
                        Ur(et, ut, nn)
                    }
                    break;
                case 1:
                    var ft = et.stateNode;
                    if (typeof ft.componentDidMount == "function") {
                        var gt = et.return;
                        try {
                            ft.componentDidMount()
                        } catch (nn) {
                            Ur(et, gt, nn)
                        }
                    }
                    var Et = et.return;
                    try {
                        vu(et)
                    } catch (nn) {
                        Ur(et, Et, nn)
                    }
                    break;
                case 5:
                    var It = et.return;
                    try {
                        vu(et)
                    } catch (nn) {
                        Ur(et, It, nn)
                    }
                }
            } catch (nn) {
                Ur(et, et.return, nn)
            }
            if (et === _e) {
                wn = null;
                break
            }
            var Ut = et.sibling;
            if (Ut !== null) {
                Ut.return = et.return,
                wn = Ut;
                break
            }
            wn = et.return
        }
    }
    var Ko = 0
      , Zo = 1
      , Qo = 2
      , Jo = 3
      , yl = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var ho = Symbol.for;
        Ko = ho("selector.component"),
        Zo = ho("selector.has_pseudo_class"),
        Qo = ho("selector.role"),
        Jo = ho("selector.test_id"),
        yl = ho("selector.text")
    }
    function Eu(_e) {
        var et = jt(_e);
        if (et != null) {
            if (typeof et.memoizedProps["data-testname"] != "string")
                throw Error(g(364));
            return et
        }
        if (_e = At(_e),
        _e === null)
            throw Error(g(362));
        return _e.stateNode.current
    }
    function Mu(_e, et) {
        switch (et.$$typeof) {
        case Ko:
            if (_e.type === et.value)
                return !0;
            break;
        case Zo:
            e: {
                et = et.value,
                _e = [_e, 0];
                for (var ut = 0; ut < _e.length; ) {
                    var ft = _e[ut++]
                      , gt = _e[ut++]
                      , Et = et[gt];
                    if (ft.tag !== 5 || !sn(ft)) {
                        for (; Et != null && Mu(ft, Et); )
                            gt++,
                            Et = et[gt];
                        if (gt === et.length) {
                            et = !0;
                            break e
                        } else
                            for (ft = ft.child; ft !== null; )
                                _e.push(ft, gt),
                                ft = ft.sibling
                    }
                }
                et = !1
            }
            return et;
        case Qo:
            if (_e.tag === 5 && cn(_e.stateNode, et.value))
                return !0;
            break;
        case yl:
            if ((_e.tag === 5 || _e.tag === 6) && (_e = on(_e),
            _e !== null && 0 <= _e.indexOf(et.value)))
                return !0;
            break;
        case Jo:
            if (_e.tag === 5 && (_e = _e.memoizedProps["data-testname"],
            typeof _e == "string" && _e.toLowerCase() === et.value.toLowerCase()))
                return !0;
            break;
        default:
            throw Error(g(365))
        }
        return !1
    }
    function bu(_e) {
        switch (_e.$$typeof) {
        case Ko:
            return "<" + (yt(_e.value) || "Unknown") + ">";
        case Zo:
            return ":has(" + (bu(_e) || "") + ")";
        case Qo:
            return '[role="' + _e.value + '"]';
        case yl:
            return '"' + _e.value + '"';
        case Jo:
            return '[data-testname="' + _e.value + '"]';
        default:
            throw Error(g(365))
        }
    }
    function _f(_e, et) {
        var ut = [];
        _e = [_e, 0];
        for (var ft = 0; ft < _e.length; ) {
            var gt = _e[ft++]
              , Et = _e[ft++]
              , It = et[Et];
            if (gt.tag !== 5 || !sn(gt)) {
                for (; It != null && Mu(gt, It); )
                    Et++,
                    It = et[Et];
                if (Et === et.length)
                    ut.push(gt);
                else
                    for (gt = gt.child; gt !== null; )
                        _e.push(gt, Et),
                        gt = gt.sibling
            }
        }
        return ut
    }
    function Au(_e, et) {
        if (!Lt)
            throw Error(g(363));
        _e = Eu(_e),
        _e = _f(_e, et),
        et = [],
        _e = Array.from(_e);
        for (var ut = 0; ut < _e.length; ) {
            var ft = _e[ut++];
            if (ft.tag === 5)
                sn(ft) || et.push(ft.stateNode);
            else
                for (ft = ft.child; ft !== null; )
                    _e.push(ft),
                    ft = ft.sibling
        }
        return et
    }
    var $p = Math.ceil
      , xl = _.ReactCurrentDispatcher
      , Tu = _.ReactCurrentOwner
      , vr = _.ReactCurrentBatchConfig
      , _i = 0
      , _r = null
      , Sr = null
      , kr = 0
      , jr = 0
      , Ks = gr(0)
      , Er = 0
      , fo = null
      , Zs = 0
      , _l = 0
      , wu = 0
      , po = null
      , Nr = null
      , Cu = 0
      , Pu = 1 / 0;
    function Qs() {
        Pu = Tr() + 500
    }
    var Sl = !1
      , ku = null
      , Ss = null
      , El = !1
      , Es = null
      , Ml = 0
      , mo = 0
      , Ru = null
      , Al = -1
      , Tl = 0;
    function Br() {
        return _i & 6 ? Tr() : Al !== -1 ? Al : Al = Tr()
    }
    function Ms(_e) {
        return _e.mode & 1 ? _i & 2 && kr !== 0 ? kr & -kr : Cp.transition !== null ? (Tl === 0 && (_e = _o,
        _o <<= 1,
        !(_o & 4194240) && (_o = 64),
        Tl = _e),
        Tl) : (_e = ir,
        _e !== 0 ? _e : tn()) : 1
    }
    function Zr(_e, et, ut) {
        if (50 < mo)
            throw mo = 0,
            Ru = null,
            Error(g(185));
        var ft = wl(_e, et);
        return ft === null ? null : (xa(ft, et, ut),
        (!(_i & 2) || ft !== _r) && (ft === _r && (!(_i & 2) && (_l |= et),
        Er === 4 && bs(ft, kr)),
        Or(ft, ut),
        et === 1 && _i === 0 && !(_e.mode & 1) && (Qs(),
        bo && as())),
        ft)
    }
    function wl(_e, et) {
        _e.lanes |= et;
        var ut = _e.alternate;
        for (ut !== null && (ut.lanes |= et),
        ut = _e,
        _e = _e.return; _e !== null; )
            _e.childLanes |= et,
            ut = _e.alternate,
            ut !== null && (ut.childLanes |= et),
            ut = _e,
            _e = _e.return;
        return ut.tag === 3 ? ut.stateNode : null
    }
    function Or(_e, et) {
        var ut = _e.callbackNode;
        xp(_e, et);
        var ft = Eo(_e, _e === _r ? kr : 0);
        if (ft === 0)
            ut !== null && zu(ut),
            _e.callbackNode = null,
            _e.callbackPriority = 0;
        else if (et = ft & -ft,
        _e.callbackPriority !== et) {
            if (ut != null && zu(ut),
            et === 1)
                _e.tag === 0 ? wp(ep.bind(null, _e)) : Gu(ep.bind(null, _e)),
                gn ? vn(function() {
                    _i === 0 && as()
                }) : Nl(Ol, as),
                ut = null;
            else {
                switch (Uu(ft)) {
                case 1:
                    ut = Ol;
                    break;
                case 4:
                    ut = Mp;
                    break;
                case 16:
                    ut = Ul;
                    break;
                case 536870912:
                    ut = bp;
                    break;
                default:
                    ut = Ul
                }
                ut = hp(ut, _d.bind(null, _e))
            }
            _e.callbackPriority = et,
            _e.callbackNode = ut
        }
    }
    function _d(_e, et) {
        if (Al = -1,
        Tl = 0,
        _i & 6)
            throw Error(g(327));
        var ut = _e.callbackNode;
        if (Ds() && _e.callbackNode !== ut)
            return null;
        var ft = Eo(_e, _e === _r ? kr : 0);
        if (ft === 0)
            return null;
        if (ft & 30 || ft & _e.expiredLanes || et)
            et = Cl(_e, ft);
        else {
            et = ft;
            var gt = _i;
            _i |= 2;
            var Et = rp();
            (_r !== _e || kr !== et) && (Qs(),
            Ls(_e, et));
            do
                try {
                    Yp();
                    break
                } catch (Ut) {
                    np(_e, Ut)
                }
            while (!0);
            Hl(),
            xl.current = Et,
            _i = gt,
            Sr !== null ? et = 0 : (_r = null,
            kr = 0,
            et = Er)
        }
        if (et !== 0) {
            if (et === 2 && (gt = Fl(_e),
            gt !== 0 && (ft = gt,
            et = Lu(_e, gt))),
            et === 1)
                throw ut = fo,
                Ls(_e, 0),
                bs(_e, ft),
                Or(_e, Tr()),
                ut;
            if (et === 6)
                bs(_e, ft);
            else {
                if (gt = _e.current.alternate,
                !(ft & 30) && !Xp(gt) && (et = Cl(_e, ft),
                et === 2 && (Et = Fl(_e),
                Et !== 0 && (ft = Et,
                et = Lu(_e, Et))),
                et === 1))
                    throw ut = fo,
                    Ls(_e, 0),
                    bs(_e, ft),
                    Or(_e, Tr()),
                    ut;
                switch (_e.finishedWork = gt,
                _e.finishedLanes = ft,
                et) {
                case 0:
                case 1:
                    throw Error(g(345));
                case 2:
                    Is(_e, Nr);
                    break;
                case 3:
                    if (bs(_e, ft),
                    (ft & 130023424) === ft && (et = Cu + 500 - Tr(),
                    10 < et)) {
                        if (Eo(_e, 0) !== 0)
                            break;
                        if (gt = _e.suspendedLanes,
                        (gt & ft) !== ft) {
                            Br(),
                            _e.pingedLanes |= _e.suspendedLanes & gt;
                            break
                        }
                        _e.timeoutHandle = Xt(Is.bind(null, _e, Nr), et);
                        break
                    }
                    Is(_e, Nr);
                    break;
                case 4:
                    if (bs(_e, ft),
                    (ft & 4194240) === ft)
                        break;
                    for (et = _e.eventTimes,
                    gt = -1; 0 < ft; ) {
                        var It = 31 - zr(ft);
                        Et = 1 << It,
                        It = et[It],
                        It > gt && (gt = It),
                        ft &= ~Et
                    }
                    if (ft = gt,
                    ft = Tr() - ft,
                    ft = (120 > ft ? 120 : 480 > ft ? 480 : 1080 > ft ? 1080 : 1920 > ft ? 1920 : 3e3 > ft ? 3e3 : 4320 > ft ? 4320 : 1960 * $p(ft / 1960)) - ft,
                    10 < ft) {
                        _e.timeoutHandle = Xt(Is.bind(null, _e, Nr), ft);
                        break
                    }
                    Is(_e, Nr);
                    break;
                case 5:
                    Is(_e, Nr);
                    break;
                default:
                    throw Error(g(329))
                }
            }
        }
        return Or(_e, Tr()),
        _e.callbackNode === ut ? _d.bind(null, _e) : null
    }
    function Lu(_e, et) {
        var ut = po;
        return _e.current.memoizedState.isDehydrated && (Ls(_e, et).flags |= 256),
        _e = Cl(_e, et),
        _e !== 2 && (et = Nr,
        Nr = ut,
        et !== null && Iu(et)),
        _e
    }
    function Iu(_e) {
        Nr === null ? Nr = _e : Nr.push.apply(Nr, _e)
    }
    function Xp(_e) {
        for (var et = _e; ; ) {
            if (et.flags & 16384) {
                var ut = et.updateQueue;
                if (ut !== null && (ut = ut.stores,
                ut !== null))
                    for (var ft = 0; ft < ut.length; ft++) {
                        var gt = ut[ft]
                          , Et = gt.getSnapshot;
                        gt = gt.value;
                        try {
                            if (!ss(Et(), gt))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (ut = et.child,
            et.subtreeFlags & 16384 && ut !== null)
                ut.return = et,
                et = ut;
            else {
                if (et === _e)
                    break;
                for (; et.sibling === null; ) {
                    if (et.return === null || et.return === _e)
                        return !0;
                    et = et.return
                }
                et.sibling.return = et.return,
                et = et.sibling
            }
        }
        return !0
    }
    function bs(_e, et) {
        for (et &= ~wu,
        et &= ~_l,
        _e.suspendedLanes |= et,
        _e.pingedLanes &= ~et,
        _e = _e.expirationTimes; 0 < et; ) {
            var ut = 31 - zr(et)
              , ft = 1 << ut;
            _e[ut] = -1,
            et &= ~ft
        }
    }
    function ep(_e) {
        if (_i & 6)
            throw Error(g(327));
        Ds();
        var et = Eo(_e, 0);
        if (!(et & 1))
            return Or(_e, Tr()),
            null;
        var ut = Cl(_e, et);
        if (_e.tag !== 0 && ut === 2) {
            var ft = Fl(_e);
            ft !== 0 && (et = ft,
            ut = Lu(_e, ft))
        }
        if (ut === 1)
            throw ut = fo,
            Ls(_e, 0),
            bs(_e, et),
            Or(_e, Tr()),
            ut;
        if (ut === 6)
            throw Error(g(345));
        return _e.finishedWork = _e.current.alternate,
        _e.finishedLanes = et,
        Is(_e, Nr),
        Or(_e, Tr()),
        null
    }
    function tp(_e) {
        Es !== null && Es.tag === 0 && !(_i & 6) && Ds();
        var et = _i;
        _i |= 1;
        var ut = vr.transition
          , ft = ir;
        try {
            if (vr.transition = null,
            ir = 1,
            _e)
                return _e()
        } finally {
            ir = ft,
            vr.transition = ut,
            _i = et,
            !(_i & 6) && as()
        }
    }
    function Du() {
        jr = Ks.current,
        Un(Ks)
    }
    function Ls(_e, et) {
        _e.finishedWork = null,
        _e.finishedLanes = 0;
        var ut = _e.timeoutHandle;
        if (ut !== Ln && (_e.timeoutHandle = Ln,
        An(ut)),
        Sr !== null)
            for (ut = Sr.return; ut !== null; ) {
                var ft = ut;
                switch (Ql(ft),
                ft.tag) {
                case 1:
                    ft = ft.type.childContextTypes,
                    ft != null && dr();
                    break;
                case 3:
                    qs(),
                    Un(ur),
                    Un(qn),
                    ru();
                    break;
                case 5:
                    nu(ft);
                    break;
                case 4:
                    qs();
                    break;
                case 13:
                    Un(mr);
                    break;
                case 19:
                    Un(mr);
                    break;
                case 10:
                    Wl(ft.type._context);
                    break;
                case 22:
                case 23:
                    Du()
                }
                ut = ut.return
            }
        if (_r = _e,
        Sr = _e = As(_e.current, null),
        kr = jr = et,
        Er = 0,
        fo = null,
        wu = _l = Zs = 0,
        Nr = po = null,
        os !== null) {
            for (et = 0; et < os.length; et++)
                if (ut = os[et],
                ft = ut.interleaved,
                ft !== null) {
                    ut.interleaved = null;
                    var gt = ft.next
                      , Et = ut.pending;
                    if (Et !== null) {
                        var It = Et.next;
                        Et.next = gt,
                        ft.next = It
                    }
                    ut.pending = ft
                }
            os = null
        }
        return _e
    }
    function np(_e, et) {
        do {
            var ut = Sr;
            try {
                if (Hl(),
                Fo.current = zo,
                Bo) {
                    for (var ft = yr.memoizedState; ft !== null; ) {
                        var gt = ft.queue;
                        gt !== null && (gt.pending = null),
                        ft = ft.next
                    }
                    Bo = !1
                }
                if (Ys = 0,
                wr = Rr = yr = null,
                io = !1,
                ro = 0,
                Tu.current = null,
                ut === null || ut.return === null) {
                    Er = 1,
                    fo = et,
                    Sr = null;
                    break
                }
                e: {
                    var Et = _e
                      , It = ut.return
                      , Ut = ut
                      , nn = et;
                    if (et = kr,
                    Ut.flags |= 32768,
                    nn !== null && typeof nn == "object" && typeof nn.then == "function") {
                        var xn = nn
                          , Fn = Ut
                          , Kn = Fn.tag;
                        if (!(Fn.mode & 1) && (Kn === 0 || Kn === 11 || Kn === 15)) {
                            var Wn = Fn.alternate;
                            Wn ? (Fn.updateQueue = Wn.updateQueue,
                            Fn.memoizedState = Wn.memoizedState,
                            Fn.lanes = Wn.lanes) : (Fn.updateQueue = null,
                            Fn.memoizedState = null)
                        }
                        var or = T0(It);
                        if (or !== null) {
                            or.flags &= -257,
                            w0(or, It, Ut, Et, et),
                            or.mode & 1 && A0(Et, xn, et),
                            et = or,
                            nn = xn;
                            var On = et.updateQueue;
                            if (On === null) {
                                var Dr = new Set;
                                Dr.add(nn),
                                et.updateQueue = Dr
                            } else
                                On.add(nn);
                            break e
                        } else {
                            if (!(et & 1)) {
                                A0(Et, xn, et),
                                Fu();
                                break e
                            }
                            nn = Error(g(426))
                        }
                    } else if (pr && Ut.mode & 1) {
                        var Jr = T0(It);
                        if (Jr !== null) {
                            !(Jr.flags & 65536) && (Jr.flags |= 256),
                            w0(Jr, It, Ut, Et, et),
                            eu(nn);
                            break e
                        }
                    }
                    Et = nn,
                    Er !== 4 && (Er = 2),
                    po === null ? po = [Et] : po.push(Et),
                    nn = hu(nn, Ut),
                    Ut = It;
                    do {
                        switch (Ut.tag) {
                        case 3:
                            Ut.flags |= 65536,
                            et &= -et,
                            Ut.lanes |= et;
                            var qt = M0(Ut, nn, et);
                            ju(Ut, qt);
                            break e;
                        case 1:
                            Et = nn;
                            var Gt = Ut.type
                              , Jt = Ut.stateNode;
                            if (!(Ut.flags & 128) && (typeof Gt.getDerivedStateFromError == "function" || Jt !== null && typeof Jt.componentDidCatch == "function" && (Ss === null || !Ss.has(Jt)))) {
                                Ut.flags |= 65536,
                                et &= -et,
                                Ut.lanes |= et;
                                var Rn = b0(Ut, Et, et);
                                ju(Ut, Rn);
                                break e
                            }
                        }
                        Ut = Ut.return
                    } while (Ut !== null)
                }
                ap(ut)
            } catch (Nn) {
                et = Nn,
                Sr === ut && ut !== null && (Sr = ut = ut.return);
                continue
            }
            break
        } while (!0)
    }
    function rp() {
        var _e = xl.current;
        return xl.current = zo,
        _e === null ? zo : _e
    }
    function Fu() {
        (Er === 0 || Er === 3 || Er === 2) && (Er = 4),
        _r === null || !(Zs & 268435455) && !(_l & 268435455) || bs(_r, kr)
    }
    function Cl(_e, et) {
        var ut = _i;
        _i |= 2;
        var ft = rp();
        _r === _e && kr === et || Ls(_e, et);
        do
            try {
                qp();
                break
            } catch (gt) {
                np(_e, gt)
            }
        while (!0);
        if (Hl(),
        _i = ut,
        xl.current = ft,
        Sr !== null)
            throw Error(g(261));
        return _r = null,
        kr = 0,
        Er
    }
    function qp() {
        for (; Sr !== null; )
            sp(Sr)
    }
    function Yp() {
        for (; Sr !== null && !Sp(); )
            sp(Sr)
    }
    function sp(_e) {
        var et = up(_e.alternate, _e, jr);
        _e.memoizedProps = _e.pendingProps,
        et === null ? ap(_e) : Sr = et,
        Tu.current = null
    }
    function ap(_e) {
        var et = _e;
        do {
            var ut = et.alternate;
            if (_e = et.return,
            et.flags & 32768) {
                if (ut = zp(ut, et),
                ut !== null) {
                    ut.flags &= 32767,
                    Sr = ut;
                    return
                }
                if (_e !== null)
                    _e.flags |= 32768,
                    _e.subtreeFlags = 0,
                    _e.deletions = null;
                else {
                    Er = 6,
                    Sr = null;
                    return
                }
            } else if (ut = Np(ut, et, jr),
            ut !== null) {
                Sr = ut;
                return
            }
            if (et = et.sibling,
            et !== null) {
                Sr = et;
                return
            }
            Sr = et = _e
        } while (et !== null);
        Er === 0 && (Er = 5)
    }
    function Is(_e, et) {
        var ut = ir
          , ft = vr.transition;
        try {
            vr.transition = null,
            ir = 1,
            Kp(_e, et, ut)
        } finally {
            vr.transition = ft,
            ir = ut
        }
        return null
    }
    function Kp(_e, et, ut) {
        do
            Ds();
        while (Es !== null);
        if (_i & 6)
            throw Error(g(327));
        var ft = _e.finishedWork
          , gt = _e.finishedLanes;
        if (ft === null)
            return null;
        if (_e.finishedWork = null,
        _e.finishedLanes = 0,
        ft === _e.current)
            throw Error(g(177));
        _e.callbackNode = null,
        _e.callbackPriority = 0;
        var Et = ft.lanes | ft.childLanes;
        if (_p(_e, Et),
        _e === _r && (Sr = _r = null,
        kr = 0),
        !(ft.subtreeFlags & 2064) && !(ft.flags & 2064) || El || (El = !0,
        hp(Ul, function() {
            return Ds(),
            null
        })),
        Et = (ft.flags & 15990) !== 0,
        ft.subtreeFlags & 15990 || Et) {
            Et = vr.transition,
            vr.transition = null;
            var It = ir;
            ir = 1;
            var Ut = _i;
            _i |= 4,
            Tu.current = null,
            Hp(_e, ft),
            Wp(_e, ft),
            wt(_e.containerInfo),
            _e.current = ft,
            jp(ft),
            Ep(),
            _i = Ut,
            ir = It,
            vr.transition = Et
        } else
            _e.current = ft;
        if (El && (El = !1,
        Es = _e,
        Ml = gt),
        Et = _e.pendingLanes,
        Et === 0 && (Ss = null),
        Ap(ft.stateNode),
        Or(_e, Tr()),
        et !== null)
            for (ut = _e.onRecoverableError,
            ft = 0; ft < et.length; ft++)
                ut(et[ft]);
        if (Sl)
            throw Sl = !1,
            _e = ku,
            ku = null,
            _e;
        return Ml & 1 && _e.tag !== 0 && Ds(),
        Et = _e.pendingLanes,
        Et & 1 ? _e === Ru ? mo++ : (mo = 0,
        Ru = _e) : mo = 0,
        as(),
        null
    }
    function Ds() {
        if (Es !== null) {
            var _e = Uu(Ml)
              , et = vr.transition
              , ut = ir;
            try {
                if (vr.transition = null,
                ir = 16 > _e ? 16 : _e,
                Es === null)
                    var ft = !1;
                else {
                    if (_e = Es,
                    Es = null,
                    Ml = 0,
                    _i & 6)
                        throw Error(g(331));
                    var gt = _i;
                    for (_i |= 4,
                    wn = _e.current; wn !== null; ) {
                        var Et = wn
                          , It = Et.child;
                        if (wn.flags & 16) {
                            var Ut = Et.deletions;
                            if (Ut !== null) {
                                for (var nn = 0; nn < Ut.length; nn++) {
                                    var xn = Ut[nn];
                                    for (wn = xn; wn !== null; ) {
                                        var Fn = wn;
                                        switch (Fn.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Rs(8, Fn, Et)
                                        }
                                        var Kn = Fn.child;
                                        if (Kn !== null)
                                            Kn.return = Fn,
                                            wn = Kn;
                                        else
                                            for (; wn !== null; ) {
                                                Fn = wn;
                                                var Wn = Fn.sibling
                                                  , or = Fn.return;
                                                if ($0(Fn),
                                                Fn === xn) {
                                                    wn = null;
                                                    break
                                                }
                                                if (Wn !== null) {
                                                    Wn.return = or,
                                                    wn = Wn;
                                                    break
                                                }
                                                wn = or
                                            }
                                    }
                                }
                                var On = Et.alternate;
                                if (On !== null) {
                                    var Dr = On.child;
                                    if (Dr !== null) {
                                        On.child = null;
                                        do {
                                            var Jr = Dr.sibling;
                                            Dr.sibling = null,
                                            Dr = Jr
                                        } while (Dr !== null)
                                    }
                                }
                                wn = Et
                            }
                        }
                        if (Et.subtreeFlags & 2064 && It !== null)
                            It.return = Et,
                            wn = It;
                        else
                            e: for (; wn !== null; ) {
                                if (Et = wn,
                                Et.flags & 2048)
                                    switch (Et.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Rs(9, Et, Et.return)
                                    }
                                var qt = Et.sibling;
                                if (qt !== null) {
                                    qt.return = Et.return,
                                    wn = qt;
                                    break e
                                }
                                wn = Et.return
                            }
                    }
                    var Gt = _e.current;
                    for (wn = Gt; wn !== null; ) {
                        It = wn;
                        var Jt = It.child;
                        if (It.subtreeFlags & 2064 && Jt !== null)
                            Jt.return = It,
                            wn = Jt;
                        else
                            e: for (It = Gt; wn !== null; ) {
                                if (Ut = wn,
                                Ut.flags & 2048)
                                    try {
                                        switch (Ut.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            uo(9, Ut)
                                        }
                                    } catch (Nn) {
                                        Ur(Ut, Ut.return, Nn)
                                    }
                                if (Ut === It) {
                                    wn = null;
                                    break e
                                }
                                var Rn = Ut.sibling;
                                if (Rn !== null) {
                                    Rn.return = Ut.return,
                                    wn = Rn;
                                    break e
                                }
                                wn = Ut.return
                            }
                    }
                    if (_i = gt,
                    as(),
                    rs && typeof rs.onPostCommitFiberRoot == "function")
                        try {
                            rs.onPostCommitFiberRoot(Mo, _e)
                        } catch {}
                    ft = !0
                }
                return ft
            } finally {
                ir = ut,
                vr.transition = et
            }
        }
        return !1
    }
    function lp(_e, et, ut) {
        et = hu(ut, et),
        et = M0(_e, et, 1),
        _s(_e, et),
        et = Br(),
        _e = wl(_e, 1),
        _e !== null && (xa(_e, 1, et),
        Or(_e, et))
    }
    function Ur(_e, et, ut) {
        if (_e.tag === 3)
            lp(_e, _e, ut);
        else
            for (; et !== null; ) {
                if (et.tag === 3) {
                    lp(et, _e, ut);
                    break
                } else if (et.tag === 1) {
                    var ft = et.stateNode;
                    if (typeof et.type.getDerivedStateFromError == "function" || typeof ft.componentDidCatch == "function" && (Ss === null || !Ss.has(ft))) {
                        _e = hu(ut, _e),
                        _e = b0(et, _e, 1),
                        _s(et, _e),
                        _e = Br(),
                        et = wl(et, 1),
                        et !== null && (xa(et, 1, _e),
                        Or(et, _e));
                        break
                    }
                }
                et = et.return
            }
    }
    function Zp(_e, et, ut) {
        var ft = _e.pingCache;
        ft !== null && ft.delete(et),
        et = Br(),
        _e.pingedLanes |= _e.suspendedLanes & ut,
        _r === _e && (kr & ut) === ut && (Er === 4 || Er === 3 && (kr & 130023424) === kr && 500 > Tr() - Cu ? Ls(_e, 0) : wu |= ut),
        Or(_e, et)
    }
    function cp(_e, et) {
        et === 0 && (_e.mode & 1 ? (et = So,
        So <<= 1,
        !(So & 130023424) && (So = 4194304)) : et = 1);
        var ut = Br();
        _e = wl(_e, et),
        _e !== null && (xa(_e, et, ut),
        Or(_e, ut))
    }
    function Qp(_e) {
        var et = _e.memoizedState
          , ut = 0;
        et !== null && (ut = et.retryLane),
        cp(_e, ut)
    }
    function Jp(_e, et) {
        var ut = 0;
        switch (_e.tag) {
        case 13:
            var ft = _e.stateNode
              , gt = _e.memoizedState;
            gt !== null && (ut = gt.retryLane);
            break;
        case 19:
            ft = _e.stateNode;
            break;
        default:
            throw Error(g(314))
        }
        ft !== null && ft.delete(et),
        cp(_e, ut)
    }
    var up;
    up = function(_e, et, ut) {
        if (_e !== null)
            if (_e.memoizedProps !== et.pendingProps || ur.current)
                Wr = !0;
            else {
                if (!(_e.lanes & ut) && !(et.flags & 128))
                    return Wr = !1,
                    Up(_e, et, ut);
                Wr = !!(_e.flags & 131072)
            }
        else
            Wr = !1,
            pr && et.flags & 1048576 && Zu(et, Lo, et.index);
        switch (et.lanes = 0,
        et.tag) {
        case 2:
            var ft = et.type;
            _e !== null && (_e.alternate = null,
            et.alternate = null,
            et.flags |= 2),
            _e = et.pendingProps;
            var gt = xr(et, qn.current);
            Gs(et, ut),
            gt = au(null, et, ft, _e, gt, ut);
            var Et = ou();
            return et.flags |= 1,
            typeof gt == "object" && gt !== null && typeof gt.render == "function" && gt.$$typeof === void 0 ? (et.tag = 1,
            et.memoizedState = null,
            et.updateQueue = null,
            Ar(ft) ? (Et = !0,
            Pr(et)) : Et = !1,
            et.memoizedState = gt.state !== null && gt.state !== void 0 ? gt.state : null,
            Xl(et),
            gt.updater = ko,
            et.stateNode = gt,
            gt._reactInternals = et,
            Kl(et, ft, _e, ut),
            et = pu(null, et, ft, !0, Et, ut)) : (et.tag = 0,
            pr && Et && Zl(et),
            Fr(null, et, gt, ut),
            et = et.child),
            et;
        case 16:
            ft = et.elementType;
            e: {
                switch (_e !== null && (_e.alternate = null,
                et.alternate = null,
                et.flags |= 2),
                _e = et.pendingProps,
                gt = ft._init,
                ft = gt(ft._payload),
                et.type = ft,
                gt = et.tag = tm(ft),
                _e = ts(ft, _e),
                gt) {
                case 0:
                    et = du(null, et, ft, _e, ut);
                    break e;
                case 1:
                    et = F0(null, et, ft, _e, ut);
                    break e;
                case 11:
                    et = k0(null, et, ft, _e, ut);
                    break e;
                case 14:
                    et = R0(null, et, ft, ts(ft.type, _e), ut);
                    break e
                }
                throw Error(g(306, ft, ""))
            }
            return et;
        case 0:
            return ft = et.type,
            gt = et.pendingProps,
            gt = et.elementType === ft ? gt : ts(ft, gt),
            du(_e, et, ft, gt, ut);
        case 1:
            return ft = et.type,
            gt = et.pendingProps,
            gt = et.elementType === ft ? gt : ts(ft, gt),
            F0(_e, et, ft, gt, ut);
        case 3:
            e: {
                if (B0(et),
                _e === null)
                    throw Error(g(387));
                ft = et.pendingProps,
                Et = et.memoizedState,
                gt = Et.element,
                Wu(_e, et),
                Po(et, ft, null, ut);
                var It = et.memoizedState;
                if (ft = It.element,
                Qt && Et.isDehydrated)
                    if (Et = {
                        element: ft,
                        isDehydrated: !1,
                        cache: It.cache,
                        transitions: It.transitions
                    },
                    et.updateQueue.baseState = Et,
                    et.memoizedState = Et,
                    et.flags & 256) {
                        gt = Error(g(423)),
                        et = V0(_e, et, ft, ut, gt);
                        break e
                    } else if (ft !== gt) {
                        gt = Error(g(424)),
                        et = V0(_e, et, ft, ut, gt);
                        break e
                    } else
                        for (Qt && (Hr = yo(et.stateNode.containerInfo),
                        Gr = et,
                        pr = !0,
                        ns = null,
                        ba = !1),
                        ut = i0(et, null, ft, ut),
                        et.child = ut; ut; )
                            ut.flags = ut.flags & -3 | 4096,
                            ut = ut.sibling;
                else {
                    if (js(),
                    ft === gt) {
                        et = ys(_e, et, ut);
                        break e
                    }
                    Fr(_e, et, ft, ut)
                }
                et = et.child
            }
            return et;
        case 5:
            return r0(et),
            _e === null && _c(et),
            ft = et.type,
            gt = et.pendingProps,
            Et = _e !== null ? _e.memoizedProps : null,
            It = gt.children,
            Yt(ft, gt) ? It = null : Et !== null && Yt(ft, Et) && (et.flags |= 32),
            D0(_e, et),
            Fr(_e, et, It, ut),
            et.child;
        case 6:
            return _e === null && _c(et),
            null;
        case 13:
            return N0(_e, et, ut);
        case 4:
            return tu(et, et.stateNode.containerInfo),
            ft = et.pendingProps,
            _e === null ? et.child = $s(et, null, ft, ut) : Fr(_e, et, ft, ut),
            et.child;
        case 11:
            return ft = et.type,
            gt = et.pendingProps,
            gt = et.elementType === ft ? gt : ts(ft, gt),
            k0(_e, et, ft, gt, ut);
        case 7:
            return Fr(_e, et, et.pendingProps, ut),
            et.child;
        case 8:
            return Fr(_e, et, et.pendingProps.children, ut),
            et.child;
        case 12:
            return Fr(_e, et, et.pendingProps.children, ut),
            et.child;
        case 10:
            e: {
                if (ft = et.type._context,
                gt = et.pendingProps,
                Et = et.memoizedProps,
                It = gt.value,
                Hu(et, ft, It),
                Et !== null)
                    if (ss(Et.value, It)) {
                        if (Et.children === gt.children && !ur.current) {
                            et = ys(_e, et, ut);
                            break e
                        }
                    } else
                        for (Et = et.child,
                        Et !== null && (Et.return = et); Et !== null; ) {
                            var Ut = Et.dependencies;
                            if (Ut !== null) {
                                It = Et.child;
                                for (var nn = Ut.firstContext; nn !== null; ) {
                                    if (nn.context === ft) {
                                        if (Et.tag === 1) {
                                            nn = ds(-1, ut & -ut),
                                            nn.tag = 2;
                                            var xn = Et.updateQueue;
                                            if (xn !== null) {
                                                xn = xn.shared;
                                                var Fn = xn.pending;
                                                Fn === null ? nn.next = nn : (nn.next = Fn.next,
                                                Fn.next = nn),
                                                xn.pending = nn
                                            }
                                        }
                                        Et.lanes |= ut,
                                        nn = Et.alternate,
                                        nn !== null && (nn.lanes |= ut),
                                        $l(Et.return, ut, et),
                                        Ut.lanes |= ut;
                                        break
                                    }
                                    nn = nn.next
                                }
                            } else if (Et.tag === 10)
                                It = Et.type === et.type ? null : Et.child;
                            else if (Et.tag === 18) {
                                if (It = Et.return,
                                It === null)
                                    throw Error(g(341));
                                It.lanes |= ut,
                                Ut = It.alternate,
                                Ut !== null && (Ut.lanes |= ut),
                                $l(It, ut, et),
                                It = Et.sibling
                            } else
                                It = Et.child;
                            if (It !== null)
                                It.return = Et;
                            else
                                for (It = Et; It !== null; ) {
                                    if (It === et) {
                                        It = null;
                                        break
                                    }
                                    if (Et = It.sibling,
                                    Et !== null) {
                                        Et.return = It.return,
                                        It = Et;
                                        break
                                    }
                                    It = It.return
                                }
                            Et = It
                        }
                Fr(_e, et, gt.children, ut),
                et = et.child
            }
            return et;
        case 9:
            return gt = et.type,
            ft = et.pendingProps.children,
            Gs(et, ut),
            gt = $r(gt),
            ft = ft(gt),
            et.flags |= 1,
            Fr(_e, et, ft, ut),
            et.child;
        case 14:
            return ft = et.type,
            gt = ts(ft, et.pendingProps),
            gt = ts(ft.type, gt),
            R0(_e, et, ft, gt, ut);
        case 15:
            return L0(_e, et, et.type, et.pendingProps, ut);
        case 17:
            return ft = et.type,
            gt = et.pendingProps,
            gt = et.elementType === ft ? gt : ts(ft, gt),
            _e !== null && (_e.alternate = null,
            et.alternate = null,
            et.flags |= 2),
            et.tag = 1,
            Ar(ft) ? (_e = !0,
            Pr(et)) : _e = !1,
            Gs(et, ut),
            Yu(et, ft, gt),
            Kl(et, ft, gt, ut),
            pu(null, et, ft, !0, _e, ut);
        case 19:
            return G0(_e, et, ut);
        case 22:
            return I0(_e, et, ut)
        }
        throw Error(g(156, et.tag))
    }
    ;
    function hp(_e, et) {
        return Nl(_e, et)
    }
    function em(_e, et, ut, ft) {
        this.tag = _e,
        this.key = ut,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = et,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = ft,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Qr(_e, et, ut, ft) {
        return new em(_e,et,ut,ft)
    }
    function Bu(_e) {
        return _e = _e.prototype,
        !(!_e || !_e.isReactComponent)
    }
    function tm(_e) {
        if (typeof _e == "function")
            return Bu(_e) ? 1 : 0;
        if (_e != null) {
            if (_e = _e.$$typeof,
            _e === lt)
                return 11;
            if (_e === ot)
                return 14
        }
        return 2
    }
    function As(_e, et) {
        var ut = _e.alternate;
        return ut === null ? (ut = Qr(_e.tag, et, _e.key, _e.mode),
        ut.elementType = _e.elementType,
        ut.type = _e.type,
        ut.stateNode = _e.stateNode,
        ut.alternate = _e,
        _e.alternate = ut) : (ut.pendingProps = et,
        ut.type = _e.type,
        ut.flags = 0,
        ut.subtreeFlags = 0,
        ut.deletions = null),
        ut.flags = _e.flags & 14680064,
        ut.childLanes = _e.childLanes,
        ut.lanes = _e.lanes,
        ut.child = _e.child,
        ut.memoizedProps = _e.memoizedProps,
        ut.memoizedState = _e.memoizedState,
        ut.updateQueue = _e.updateQueue,
        et = _e.dependencies,
        ut.dependencies = et === null ? null : {
            lanes: et.lanes,
            firstContext: et.firstContext
        },
        ut.sibling = _e.sibling,
        ut.index = _e.index,
        ut.ref = _e.ref,
        ut
    }
    function Pl(_e, et, ut, ft, gt, Et) {
        var It = 2;
        if (ft = _e,
        typeof _e == "function")
            Bu(_e) && (It = 1);
        else if (typeof _e == "string")
            It = 5;
        else
            e: switch (_e) {
            case $:
                return Fs(ut.children, gt, Et, et);
            case nt:
                It = 8,
                gt |= 8;
                break;
            case tt:
                return _e = Qr(12, ut, et, gt | 2),
                _e.elementType = tt,
                _e.lanes = Et,
                _e;
            case ct:
                return _e = Qr(13, ut, et, gt),
                _e.elementType = ct,
                _e.lanes = Et,
                _e;
            case it:
                return _e = Qr(19, ut, et, gt),
                _e.elementType = it,
                _e.lanes = Et,
                _e;
            case ht:
                return Rl(ut, gt, Et, et);
            default:
                if (typeof _e == "object" && _e !== null)
                    switch (_e.$$typeof) {
                    case rt:
                        It = 10;
                        break e;
                    case st:
                        It = 9;
                        break e;
                    case lt:
                        It = 11;
                        break e;
                    case ot:
                        It = 14;
                        break e;
                    case at:
                        It = 16,
                        ft = null;
                        break e
                    }
                throw Error(g(130, _e == null ? _e : typeof _e, ""))
            }
        return et = Qr(It, ut, et, gt),
        et.elementType = _e,
        et.type = ft,
        et.lanes = Et,
        et
    }
    function Fs(_e, et, ut, ft) {
        return _e = Qr(7, _e, ft, et),
        _e.lanes = ut,
        _e
    }
    function Rl(_e, et, ut, ft) {
        return _e = Qr(22, _e, ft, et),
        _e.elementType = ht,
        _e.lanes = ut,
        _e.stateNode = {},
        _e
    }
    function Vu(_e, et, ut) {
        return _e = Qr(6, _e, null, et),
        _e.lanes = ut,
        _e
    }
    function Nu(_e, et, ut) {
        return et = Qr(4, _e.children !== null ? _e.children : [], _e.key, et),
        et.lanes = ut,
        et.stateNode = {
            containerInfo: _e.containerInfo,
            pendingChildren: null,
            implementation: _e.implementation
        },
        et
    }
    function im(_e, et, ut, ft, gt) {
        this.tag = et,
        this.containerInfo = _e,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = Ln,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = Bl(0),
        this.expirationTimes = Bl(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Bl(0),
        this.identifierPrefix = ft,
        this.onRecoverableError = gt,
        Qt && (this.mutableSourceEagerHydrationData = null)
    }
    function fp(_e, et, ut, ft, gt, Et, It, Ut, nn) {
        return _e = new im(_e,et,ut,Ut,nn),
        et === 1 ? (et = 1,
        Et === !0 && (et |= 8)) : et = 0,
        Et = Qr(3, null, null, et),
        _e.current = Et,
        Et.stateNode = _e,
        Et.memoizedState = {
            element: ft,
            isDehydrated: ut,
            cache: null,
            transitions: null
        },
        Xl(Et),
        _e
    }
    function dp(_e) {
        if (!_e)
            return cr;
        _e = _e._reactInternals;
        e: {
            if (xt(_e) !== _e || _e.tag !== 1)
                throw Error(g(170));
            var et = _e;
            do {
                switch (et.tag) {
                case 3:
                    et = et.stateNode.context;
                    break e;
                case 1:
                    if (Ar(et.type)) {
                        et = et.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                et = et.return
            } while (et !== null);
            throw Error(g(171))
        }
        if (_e.tag === 1) {
            var ut = _e.type;
            if (Ar(ut))
                return Os(_e, ut, et)
        }
        return et
    }
    function pp(_e) {
        var et = _e._reactInternals;
        if (et === void 0)
            throw typeof _e.render == "function" ? Error(g(188)) : (_e = Object.keys(_e).join(","),
            Error(g(268, _e)));
        return _e = Rt(et),
        _e === null ? null : _e.stateNode
    }
    function mp(_e, et) {
        if (_e = _e.memoizedState,
        _e !== null && _e.dehydrated !== null) {
            var ut = _e.retryLane;
            _e.retryLane = ut !== 0 && ut < et ? ut : et
        }
    }
    function Ou(_e, et) {
        mp(_e, et),
        (_e = _e.alternate) && mp(_e, et)
    }
    function rm(_e) {
        return _e = Rt(_e),
        _e === null ? null : _e.stateNode
    }
    function sm() {
        return null
    }
    return a.attemptContinuousHydration = function(_e) {
        if (_e.tag === 13) {
            var et = Br();
            Zr(_e, 134217728, et),
            Ou(_e, 134217728)
        }
    }
    ,
    a.attemptHydrationAtCurrentPriority = function(_e) {
        if (_e.tag === 13) {
            var et = Br()
              , ut = Ms(_e);
            Zr(_e, ut, et),
            Ou(_e, ut)
        }
    }
    ,
    a.attemptSynchronousHydration = function(_e) {
        switch (_e.tag) {
        case 3:
            var et = _e.stateNode;
            if (et.current.memoizedState.isDehydrated) {
                var ut = ga(et.pendingLanes);
                ut !== 0 && (Vl(et, ut | 1),
                Or(et, Tr()),
                !(_i & 6) && (Qs(),
                as()))
            }
            break;
        case 13:
            var ft = Br();
            tp(function() {
                return Zr(_e, 1, ft)
            }),
            Ou(_e, 1)
        }
    }
    ,
    a.batchedUpdates = function(_e, et) {
        var ut = _i;
        _i |= 1;
        try {
            return _e(et)
        } finally {
            _i = ut,
            _i === 0 && (Qs(),
            bo && as())
        }
    }
    ,
    a.createComponentSelector = function(_e) {
        return {
            $$typeof: Ko,
            value: _e
        }
    }
    ,
    a.createContainer = function(_e, et, ut, ft, gt, Et, It) {
        return fp(_e, et, !1, null, ut, ft, gt, Et, It)
    }
    ,
    a.createHasPseudoClassSelector = function(_e) {
        return {
            $$typeof: Zo,
            value: _e
        }
    }
    ,
    a.createHydrationContainer = function(_e, et, ut, ft, gt, Et, It, Ut, nn) {
        return _e = fp(ut, ft, !0, _e, gt, Et, It, Ut, nn),
        _e.context = dp(null),
        ut = _e.current,
        ft = Br(),
        gt = Ms(ut),
        Et = ds(ft, gt),
        Et.callback = et ?? null,
        _s(ut, Et),
        _e.current.lanes = gt,
        xa(_e, gt, ft),
        Or(_e, ft),
        _e
    }
    ,
    a.createPortal = function(_e, et, ut) {
        var ft = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: j,
            key: ft == null ? null : "" + ft,
            children: _e,
            containerInfo: et,
            implementation: ut
        }
    }
    ,
    a.createRoleSelector = function(_e) {
        return {
            $$typeof: Qo,
            value: _e
        }
    }
    ,
    a.createTestNameSelector = function(_e) {
        return {
            $$typeof: Jo,
            value: _e
        }
    }
    ,
    a.createTextSelector = function(_e) {
        return {
            $$typeof: yl,
            value: _e
        }
    }
    ,
    a.deferredUpdates = function(_e) {
        var et = ir
          , ut = vr.transition;
        try {
            return vr.transition = null,
            ir = 16,
            _e()
        } finally {
            ir = et,
            vr.transition = ut
        }
    }
    ,
    a.discreteUpdates = function(_e, et, ut, ft, gt) {
        var Et = ir
          , It = vr.transition;
        try {
            return vr.transition = null,
            ir = 1,
            _e(et, ut, ft, gt)
        } finally {
            ir = Et,
            vr.transition = It,
            _i === 0 && Qs()
        }
    }
    ,
    a.findAllNodes = Au,
    a.findBoundingRects = function(_e, et) {
        if (!Lt)
            throw Error(g(363));
        et = Au(_e, et),
        _e = [];
        for (var ut = 0; ut < et.length; ut++)
            _e.push($t(et[ut]));
        for (et = _e.length - 1; 0 < et; et--) {
            ut = _e[et];
            for (var ft = ut.x, gt = ft + ut.width, Et = ut.y, It = Et + ut.height, Ut = et - 1; 0 <= Ut; Ut--)
                if (et !== Ut) {
                    var nn = _e[Ut]
                      , xn = nn.x
                      , Fn = xn + nn.width
                      , Kn = nn.y
                      , Wn = Kn + nn.height;
                    if (ft >= xn && Et >= Kn && gt <= Fn && It <= Wn) {
                        _e.splice(et, 1);
                        break
                    } else if (ft !== xn || ut.width !== nn.width || Wn < Et || Kn > It) {
                        if (!(Et !== Kn || ut.height !== nn.height || Fn < ft || xn > gt)) {
                            xn > ft && (nn.width += xn - ft,
                            nn.x = ft),
                            Fn < gt && (nn.width = gt - xn),
                            _e.splice(et, 1);
                            break
                        }
                    } else {
                        Kn > Et && (nn.height += Kn - Et,
                        nn.y = Et),
                        Wn < It && (nn.height = It - Kn),
                        _e.splice(et, 1);
                        break
                    }
                }
        }
        return _e
    }
    ,
    a.findHostInstance = pp,
    a.findHostInstanceWithNoPortals = function(_e) {
        return _e = bt(_e),
        _e = _e !== null ? Bt(_e) : null,
        _e === null ? null : _e.stateNode
    }
    ,
    a.findHostInstanceWithWarning = function(_e) {
        return pp(_e)
    }
    ,
    a.flushControlled = function(_e) {
        var et = _i;
        _i |= 1;
        var ut = vr.transition
          , ft = ir;
        try {
            vr.transition = null,
            ir = 1,
            _e()
        } finally {
            ir = ft,
            vr.transition = ut,
            _i = et,
            _i === 0 && (Qs(),
            as())
        }
    }
    ,
    a.flushPassiveEffects = Ds,
    a.flushSync = tp,
    a.focusWithin = function(_e, et) {
        if (!Lt)
            throw Error(g(363));
        for (_e = Eu(_e),
        et = _f(_e, et),
        et = Array.from(et),
        _e = 0; _e < et.length; ) {
            var ut = et[_e++];
            if (!sn(ut)) {
                if (ut.tag === 5 && Pn(ut.stateNode))
                    return !0;
                for (ut = ut.child; ut !== null; )
                    et.push(ut),
                    ut = ut.sibling
            }
        }
        return !1
    }
    ,
    a.getCurrentUpdatePriority = function() {
        return ir
    }
    ,
    a.getFindAllNodesFailureDescription = function(_e, et) {
        if (!Lt)
            throw Error(g(363));
        var ut = 0
          , ft = [];
        _e = [Eu(_e), 0];
        for (var gt = 0; gt < _e.length; ) {
            var Et = _e[gt++]
              , It = _e[gt++]
              , Ut = et[It];
            if ((Et.tag !== 5 || !sn(Et)) && (Mu(Et, Ut) && (ft.push(bu(Ut)),
            It++,
            It > ut && (ut = It)),
            It < et.length))
                for (Et = Et.child; Et !== null; )
                    _e.push(Et, It),
                    Et = Et.sibling
        }
        if (ut < et.length) {
            for (_e = []; ut < et.length; ut++)
                _e.push(bu(et[ut]));
            return `findAllNodes was able to match part of the selector:
  ` + (ft.join(" > ") + `

No matching component was found for:
  `) + _e.join(" > ")
        }
        return null
    }
    ,
    a.getPublicRootInstance = function(_e) {
        if (_e = _e.current,
        !_e.child)
            return null;
        switch (_e.child.tag) {
        case 5:
            return Mt(_e.child.stateNode);
        default:
            return _e.child.stateNode
        }
    }
    ,
    a.injectIntoDevTools = function(_e) {
        if (_e = {
            bundleType: _e.bundleType,
            version: _e.version,
            rendererPackageName: _e.rendererPackageName,
            rendererConfig: _e.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: _.ReactCurrentDispatcher,
            findHostInstanceByFiber: rm,
            findFiberByHostInstance: _e.findFiberByHostInstance || sm,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329"
        },
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            _e = !1;
        else {
            var et = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (et.isDisabled || !et.supportsFiber)
                _e = !0;
            else {
                try {
                    Mo = et.inject(_e),
                    rs = et
                } catch {}
                _e = !!et.checkDCE
            }
        }
        return _e
    }
    ,
    a.isAlreadyRendering = function() {
        return !1
    }
    ,
    a.observeVisibleRects = function(_e, et, ut, ft) {
        if (!Lt)
            throw Error(g(363));
        _e = Au(_e, et);
        var gt = dn(_e, ut, ft).disconnect;
        return {
            disconnect: function() {
                gt()
            }
        }
    }
    ,
    a.registerMutableSourceForHydration = function(_e, et) {
        var ut = et._getVersion;
        ut = ut(et._source),
        _e.mutableSourceEagerHydrationData == null ? _e.mutableSourceEagerHydrationData = [et, ut] : _e.mutableSourceEagerHydrationData.push(et, ut)
    }
    ,
    a.runWithPriority = function(_e, et) {
        var ut = ir;
        try {
            return ir = _e,
            et()
        } finally {
            ir = ut
        }
    }
    ,
    a.shouldError = function() {
        return null
    }
    ,
    a.shouldSuspend = function() {
        return !1
    }
    ,
    a.updateContainer = function(_e, et, ut, ft) {
        var gt = et.current
          , Et = Br()
          , It = Ms(gt);
        return ut = dp(ut),
        et.context === null ? et.context = ut : et.pendingContext = ut,
        et = ds(Et, It),
        et.payload = {
            element: _e
        },
        ft = ft === void 0 ? null : ft,
        ft !== null && (et.callback = ft),
        _s(gt, et),
        _e = Zr(gt, It, Et),
        _e !== null && Co(_e, gt, It),
        It
    }
    ,
    a
};
reactReconciler.exports = reactReconciler_production_min;
var reactReconcilerExports = reactReconciler.exports;
const Reconciler = getDefaultExportFromCjs(reactReconcilerExports)
  , catalogue = {}
  , extend = s => void Object.assign(catalogue, s);
function createRenderer(s, e) {
    function a($, {args: nt=[], attach: tt, ...rt}, st) {
        let lt = `${$[0].toUpperCase()}${$.slice(1)}`, ct;
        if ($ === "primitive") {
            if (rt.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const it = rt.object;
            ct = prepare(it, {
                type: $,
                root: st,
                attach: tt,
                primitive: !0
            })
        } else {
            const it = catalogue[lt];
            if (!it)
                throw new Error(`R3F: ${lt} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(nt))
                throw new Error("R3F: The args prop must be an array!");
            ct = prepare(new it(...nt), {
                type: $,
                root: st,
                attach: tt,
                memoizedProps: {
                    args: nt
                }
            })
        }
        return ct.__r3f.attach === void 0 && (ct instanceof BufferGeometry ? ct.__r3f.attach = "geometry" : ct instanceof Material && (ct.__r3f.attach = "material")),
        lt !== "inject" && applyProps$1(ct, rt),
        ct
    }
    function o($, nt) {
        let tt = !1;
        if (nt) {
            var rt, st;
            (rt = nt.__r3f) != null && rt.attach ? attach($, nt, nt.__r3f.attach) : nt.isObject3D && $.isObject3D && ($.add(nt),
            tt = !0),
            tt || (st = $.__r3f) == null || st.objects.push(nt),
            nt.__r3f || prepare(nt, {}),
            nt.__r3f.parent = $,
            updateInstance(nt),
            invalidateInstance(nt)
        }
    }
    function c($, nt, tt) {
        let rt = !1;
        if (nt) {
            var st, lt;
            if ((st = nt.__r3f) != null && st.attach)
                attach($, nt, nt.__r3f.attach);
            else if (nt.isObject3D && $.isObject3D) {
                nt.parent = $,
                nt.dispatchEvent({
                    type: "added"
                }),
                $.dispatchEvent({
                    type: "childadded",
                    child: nt
                });
                const ct = $.children.filter(ot => ot !== nt)
                  , it = ct.indexOf(tt);
                $.children = [...ct.slice(0, it), nt, ...ct.slice(it)],
                rt = !0
            }
            rt || (lt = $.__r3f) == null || lt.objects.push(nt),
            nt.__r3f || prepare(nt, {}),
            nt.__r3f.parent = $,
            updateInstance(nt),
            invalidateInstance(nt)
        }
    }
    function d($, nt, tt=!1) {
        $ && [...$].forEach(rt => g(nt, rt, tt))
    }
    function g($, nt, tt) {
        if (nt) {
            var rt, st, lt;
            if (nt.__r3f && (nt.__r3f.parent = null),
            (rt = $.__r3f) != null && rt.objects && ($.__r3f.objects = $.__r3f.objects.filter(ht => ht !== nt)),
            (st = nt.__r3f) != null && st.attach)
                detach($, nt, nt.__r3f.attach);
            else if (nt.isObject3D && $.isObject3D) {
                var ct;
                $.remove(nt),
                (ct = nt.__r3f) != null && ct.root && removeInteractivity(findInitialRoot(nt), nt)
            }
            const ot = (lt = nt.__r3f) == null ? void 0 : lt.primitive
              , at = !ot && (tt === void 0 ? nt.dispose !== null : tt);
            if (!ot) {
                var it;
                d((it = nt.__r3f) == null ? void 0 : it.objects, nt, at),
                d(nt.children, nt, at)
            }
            if (delete nt.__r3f,
            at && nt.dispose && nt.type !== "Scene") {
                const ht = () => {
                    try {
                        nt.dispose()
                    } catch {}
                }
                ;
                typeof IS_REACT_ACT_ENVIRONMENT > "u" ? schedulerExports.unstable_scheduleCallback(schedulerExports.unstable_IdlePriority, ht) : ht()
            }
            invalidateInstance($)
        }
    }
    function _($, nt, tt, rt) {
        var st;
        const lt = (st = $.__r3f) == null ? void 0 : st.parent;
        if (!lt)
            return;
        const ct = a(nt, tt, $.__r3f.root);
        if ($.children) {
            for (const it of $.children)
                it.__r3f && o(ct, it);
            $.children = $.children.filter(it => !it.__r3f)
        }
        $.__r3f.objects.forEach(it => o(ct, it)),
        $.__r3f.objects = [],
        $.__r3f.autoRemovedBeforeAppend || g(lt, $),
        ct.parent && (ct.__r3f.autoRemovedBeforeAppend = !0),
        o(lt, ct),
        ct.raycast && ct.__r3f.eventCount && findInitialRoot(ct).getState().internal.interaction.push(ct),
        [rt, rt.alternate].forEach(it => {
            it !== null && (it.stateNode = ct,
            it.ref && (typeof it.ref == "function" ? it.ref(ct) : it.ref.current = ct))
        }
        )
    }
    const b = () => {}
    ;
    return {
        reconciler: Reconciler({
            createInstance: a,
            removeChild: g,
            appendChild: o,
            appendInitialChild: o,
            insertBefore: c,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: ($, nt) => {
                if (!nt)
                    return;
                const tt = $.getState().scene;
                tt.__r3f && (tt.__r3f.root = $,
                o(tt, nt))
            }
            ,
            removeChildFromContainer: ($, nt) => {
                nt && g($.getState().scene, nt)
            }
            ,
            insertInContainerBefore: ($, nt, tt) => {
                if (!nt || !tt)
                    return;
                const rt = $.getState().scene;
                rt.__r3f && c(rt, nt, tt)
            }
            ,
            getRootHostContext: () => null,
            getChildHostContext: $ => $,
            finalizeInitialChildren($) {
                var nt;
                return !!((nt = $ == null ? void 0 : $.__r3f) != null ? nt : {}).handlers
            },
            prepareUpdate($, nt, tt, rt) {
                var st;
                if (((st = $ == null ? void 0 : $.__r3f) != null ? st : {}).primitive && rt.object && rt.object !== $)
                    return [!0];
                {
                    const {args: ct=[], children: it, ...ot} = rt
                      , {args: at=[], children: ht, ...pt} = tt;
                    if (!Array.isArray(ct))
                        throw new Error("R3F: the args prop must be an array!");
                    if (ct.some( (yt, vt) => yt !== at[vt]))
                        return [!0];
                    const dt = diffProps($, ot, pt, !0);
                    return dt.changes.length ? [!1, dt] : null
                }
            },
            commitUpdate($, [nt,tt], rt, st, lt, ct) {
                nt ? _($, rt, lt, ct) : applyProps$1($, tt)
            },
            commitMount($, nt, tt, rt) {
                var st;
                const lt = (st = $.__r3f) != null ? st : {};
                $.raycast && lt.handlers && lt.eventCount && findInitialRoot($).getState().internal.interaction.push($)
            },
            getPublicInstance: $ => $,
            prepareForCommit: () => null,
            preparePortalMount: $ => prepare($.getState().scene),
            resetAfterCommit: () => {}
            ,
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance($) {
                var nt;
                const {attach: tt, parent: rt} = (nt = $.__r3f) != null ? nt : {};
                tt && rt && detach(rt, $, tt),
                $.isObject3D && ($.visible = !1),
                invalidateInstance($)
            },
            unhideInstance($, nt) {
                var tt;
                const {attach: rt, parent: st} = (tt = $.__r3f) != null ? tt : {};
                rt && st && attach(st, $, rt),
                ($.isObject3D && nt.visible == null || nt.visible) && ($.visible = !0),
                invalidateInstance($)
            },
            createTextInstance: b,
            hideTextInstance: b,
            unhideTextInstance: b,
            getCurrentEventPriority: () => e ? e() : constantsExports.DefaultEventPriority,
            beforeActiveInstanceBlur: () => {}
            ,
            afterActiveInstanceBlur: () => {}
            ,
            detachDeletedInstance: () => {}
            ,
            now: typeof performance < "u" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : () => 0,
            scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: applyProps$1
    }
}
var _window$document, _window$navigator;
const hasColorSpace = s => "colorSpace"in s || "outputColorSpace"in s
  , getColorManagement = () => {
    var s;
    return (s = catalogue.ColorManagement) != null ? s : null
}
  , isOrthographicCamera = s => s && s.isOrthographicCamera
  , isRef = s => s && s.hasOwnProperty("current")
  , useIsomorphicLayoutEffect$1 = typeof window < "u" && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === "ReactNative") ? reactExports.useLayoutEffect : reactExports.useEffect;
function useMutableCallback(s) {
    const e = reactExports.useRef(s);
    return useIsomorphicLayoutEffect$1( () => void (e.current = s), [s]),
    e
}
function Block({set: s}) {
    return useIsomorphicLayoutEffect$1( () => (s(new Promise( () => null)),
    () => s(!1)), [s]),
    null
}
class ErrorBoundary extends reactExports.Component {
    constructor(...e) {
        super(...e),
        this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
ErrorBoundary.getDerivedStateFromError = () => ({
    error: !0
});
const DEFAULT = "__default"
  , DEFAULTS = new Map
  , isDiffSet = s => s && !!s.memoized && !!s.changes;
function calculateDpr(s) {
    var e;
    const a = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
    return Array.isArray(s) ? Math.min(Math.max(s[0], a), s[1]) : s
}
const getRootState = s => {
    var e;
    return (e = s.__r3f) == null ? void 0 : e.root.getState()
}
;
function findInitialRoot(s) {
    let e = s.__r3f.root;
    for (; e.getState().previousRoot; )
        e = e.getState().previousRoot;
    return e
}
const is = {
    obj: s => s === Object(s) && !is.arr(s) && typeof s != "function",
    fun: s => typeof s == "function",
    str: s => typeof s == "string",
    num: s => typeof s == "number",
    boo: s => typeof s == "boolean",
    und: s => s === void 0,
    arr: s => Array.isArray(s),
    equ(s, e, {arrays: a="shallow", objects: o="reference", strict: c=!0}={}) {
        if (typeof s != typeof e || !!s != !!e)
            return !1;
        if (is.str(s) || is.num(s) || is.boo(s))
            return s === e;
        const d = is.obj(s);
        if (d && o === "reference")
            return s === e;
        const g = is.arr(s);
        if (g && a === "reference")
            return s === e;
        if ((g || d) && s === e)
            return !0;
        let _;
        for (_ in s)
            if (!(_ in e))
                return !1;
        if (d && a === "shallow" && o === "shallow") {
            for (_ in c ? e : s)
                if (!is.equ(s[_], e[_], {
                    strict: c,
                    objects: "reference"
                }))
                    return !1
        } else
            for (_ in c ? e : s)
                if (s[_] !== e[_])
                    return !1;
        if (is.und(_)) {
            if (g && s.length === 0 && e.length === 0 || d && Object.keys(s).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (s !== e)
                return !1
        }
        return !0
    }
};
function buildGraph(s) {
    const e = {
        nodes: {},
        materials: {}
    };
    return s && s.traverse(a => {
        a.name && (e.nodes[a.name] = a),
        a.material && !e.materials[a.material.name] && (e.materials[a.material.name] = a.material)
    }
    ),
    e
}
function dispose(s) {
    s.dispose && s.type !== "Scene" && s.dispose();
    for (const e in s)
        e.dispose == null || e.dispose(),
        delete s[e]
}
function prepare(s, e) {
    const a = s;
    return a.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    },
    s
}
function resolve(s, e) {
    let a = s;
    if (e.includes("-")) {
        const o = e.split("-")
          , c = o.pop();
        return a = o.reduce( (d, g) => d[g], s),
        {
            target: a,
            key: c
        }
    } else
        return {
            target: a,
            key: e
        }
}
const INDEX_REGEX = /-\d+$/;
function attach(s, e, a) {
    if (is.str(a)) {
        if (INDEX_REGEX.test(a)) {
            const d = a.replace(INDEX_REGEX, "")
              , {target: g, key: _} = resolve(s, d);
            Array.isArray(g[_]) || (g[_] = [])
        }
        const {target: o, key: c} = resolve(s, a);
        e.__r3f.previousAttach = o[c],
        o[c] = e
    } else
        e.__r3f.previousAttach = a(s, e)
}
function detach(s, e, a) {
    var o, c;
    if (is.str(a)) {
        const {target: d, key: g} = resolve(s, a)
          , _ = e.__r3f.previousAttach;
        _ === void 0 ? delete d[g] : d[g] = _
    } else
        (o = e.__r3f) == null || o.previousAttach == null || o.previousAttach(s, e);
    (c = e.__r3f) == null || delete c.previousAttach
}
function diffProps(s, {children: e, key: a, ref: o, ...c}, {children: d, key: g, ref: _, ...b}={}, j=!1) {
    const $ = s.__r3f
      , nt = Object.entries(c)
      , tt = [];
    if (j) {
        const st = Object.keys(b);
        for (let lt = 0; lt < st.length; lt++)
            c.hasOwnProperty(st[lt]) || nt.unshift([st[lt], DEFAULT + "remove"])
    }
    nt.forEach( ([st,lt]) => {
        var ct;
        if ((ct = s.__r3f) != null && ct.primitive && st === "object" || is.equ(lt, b[st]))
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(st))
            return tt.push([st, lt, !0, []]);
        let it = [];
        st.includes("-") && (it = st.split("-")),
        tt.push([st, lt, !1, it]);
        for (const ot in c) {
            const at = c[ot];
            ot.startsWith(`${st}-`) && tt.push([ot, at, !1, ot.split("-")])
        }
    }
    );
    const rt = {
        ...c
    };
    return $ != null && $.memoizedProps && $ != null && $.memoizedProps.args && (rt.args = $.memoizedProps.args),
    $ != null && $.memoizedProps && $ != null && $.memoizedProps.attach && (rt.attach = $.memoizedProps.attach),
    {
        memoized: rt,
        changes: tt
    }
}
const __DEV__ = typeof process < "u" && !1;
function applyProps$1(s, e) {
    var a;
    const o = s.__r3f
      , c = o == null ? void 0 : o.root
      , d = c == null || c.getState == null ? void 0 : c.getState()
      , {memoized: g, changes: _} = isDiffSet(e) ? e : diffProps(s, e)
      , b = o == null ? void 0 : o.eventCount;
    s.__r3f && (s.__r3f.memoizedProps = g);
    for (let $ = 0; $ < _.length; $++) {
        let[nt,tt,rt,st] = _[$];
        if (hasColorSpace(s)) {
            const ot = "srgb"
              , at = "srgb-linear";
            nt === "encoding" ? (nt = "colorSpace",
            tt = tt === 3001 ? ot : at) : nt === "outputEncoding" && (nt = "outputColorSpace",
            tt = tt === 3001 ? ot : at)
        }
        let lt = s
          , ct = lt[nt];
        if (st.length && (ct = st.reduce( (it, ot) => it[ot], s),
        !(ct && ct.set))) {
            const [it,...ot] = st.reverse();
            lt = ot.reverse().reduce( (at, ht) => at[ht], s),
            nt = it
        }
        if (tt === DEFAULT + "remove")
            if (lt.constructor) {
                let it = DEFAULTS.get(lt.constructor);
                it || (it = new lt.constructor,
                DEFAULTS.set(lt.constructor, it)),
                tt = it[nt]
            } else
                tt = 0;
        if (rt && o)
            tt ? o.handlers[nt] = tt : delete o.handlers[nt],
            o.eventCount = Object.keys(o.handlers).length;
        else if (ct && ct.set && (ct.copy || ct instanceof Layers)) {
            if (Array.isArray(tt))
                ct.fromArray ? ct.fromArray(tt) : ct.set(...tt);
            else if (ct.copy && tt && tt.constructor && (__DEV__ ? ct.constructor.name === tt.constructor.name : ct.constructor === tt.constructor))
                ct.copy(tt);
            else if (tt !== void 0) {
                const it = ct instanceof Color;
                !it && ct.setScalar ? ct.setScalar(tt) : ct instanceof Layers && tt instanceof Layers ? ct.mask = tt.mask : ct.set(tt),
                !getColorManagement() && d && !d.linear && it && ct.convertSRGBToLinear()
            }
        } else if (lt[nt] = tt,
        lt[nt]instanceof Texture && lt[nt].format === RGBAFormat && lt[nt].type === UnsignedByteType && d) {
            const it = lt[nt];
            hasColorSpace(it) && hasColorSpace(d.gl) ? it.colorSpace = d.gl.outputColorSpace : it.encoding = d.gl.outputEncoding
        }
        invalidateInstance(s)
    }
    if (o && o.parent && s.raycast && b !== o.eventCount) {
        const $ = findInitialRoot(s).getState().internal
          , nt = $.interaction.indexOf(s);
        nt > -1 && $.interaction.splice(nt, 1),
        o.eventCount && $.interaction.push(s)
    }
    return !(_.length === 1 && _[0][0] === "onUpdate") && _.length && (a = s.__r3f) != null && a.parent && updateInstance(s),
    s
}
function invalidateInstance(s) {
    var e, a;
    const o = (e = s.__r3f) == null || (a = e.root) == null || a.getState == null ? void 0 : a.getState();
    o && o.internal.frames === 0 && o.invalidate()
}
function updateInstance(s) {
    s.onUpdate == null || s.onUpdate(s)
}
function updateCamera(s, e) {
    s.manual || (isOrthographicCamera(s) ? (s.left = e.width / -2,
    s.right = e.width / 2,
    s.top = e.height / 2,
    s.bottom = e.height / -2) : s.aspect = e.width / e.height,
    s.updateProjectionMatrix(),
    s.updateMatrixWorld())
}
function makeId(s) {
    return (s.eventObject || s.object).uuid + "/" + s.index + s.instanceId
}
function getEventPriority() {
    var s;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e)
        return constantsExports.DefaultEventPriority;
    switch ((s = e.event) == null ? void 0 : s.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
        return constantsExports.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
        return constantsExports.ContinuousEventPriority;
    default:
        return constantsExports.DefaultEventPriority
    }
}
function releaseInternalPointerCapture(s, e, a, o) {
    const c = a.get(e);
    c && (a.delete(e),
    a.size === 0 && (s.delete(o),
    c.target.releasePointerCapture(o)))
}
function removeInteractivity(s, e) {
    const {internal: a} = s.getState();
    a.interaction = a.interaction.filter(o => o !== e),
    a.initialHits = a.initialHits.filter(o => o !== e),
    a.hovered.forEach( (o, c) => {
        (o.eventObject === e || o.object === e) && a.hovered.delete(c)
    }
    ),
    a.capturedMap.forEach( (o, c) => {
        releaseInternalPointerCapture(a.capturedMap, e, o, c)
    }
    )
}
function createEvents(s) {
    function e(b) {
        const {internal: j} = s.getState()
          , $ = b.offsetX - j.initialClick[0]
          , nt = b.offsetY - j.initialClick[1];
        return Math.round(Math.sqrt($ * $ + nt * nt))
    }
    function a(b) {
        return b.filter(j => ["Move", "Over", "Enter", "Out", "Leave"].some($ => {
            var nt;
            return (nt = j.__r3f) == null ? void 0 : nt.handlers["onPointer" + $]
        }
        ))
    }
    function o(b, j) {
        const $ = s.getState()
          , nt = new Set
          , tt = []
          , rt = j ? j($.internal.interaction) : $.internal.interaction;
        for (let it = 0; it < rt.length; it++) {
            const ot = getRootState(rt[it]);
            ot && (ot.raycaster.camera = void 0)
        }
        $.previousRoot || $.events.compute == null || $.events.compute(b, $);
        function st(it) {
            const ot = getRootState(it);
            if (!ot || !ot.events.enabled || ot.raycaster.camera === null)
                return [];
            if (ot.raycaster.camera === void 0) {
                var at;
                ot.events.compute == null || ot.events.compute(b, ot, (at = ot.previousRoot) == null ? void 0 : at.getState()),
                ot.raycaster.camera === void 0 && (ot.raycaster.camera = null)
            }
            return ot.raycaster.camera ? ot.raycaster.intersectObject(it, !0) : []
        }
        let lt = rt.flatMap(st).sort( (it, ot) => {
            const at = getRootState(it.object)
              , ht = getRootState(ot.object);
            return !at || !ht ? it.distance - ot.distance : ht.events.priority - at.events.priority || it.distance - ot.distance
        }
        ).filter(it => {
            const ot = makeId(it);
            return nt.has(ot) ? !1 : (nt.add(ot),
            !0)
        }
        );
        $.events.filter && (lt = $.events.filter(lt, $));
        for (const it of lt) {
            let ot = it.object;
            for (; ot; ) {
                var ct;
                (ct = ot.__r3f) != null && ct.eventCount && tt.push({
                    ...it,
                    eventObject: ot
                }),
                ot = ot.parent
            }
        }
        if ("pointerId"in b && $.internal.capturedMap.has(b.pointerId))
            for (let it of $.internal.capturedMap.get(b.pointerId).values())
                nt.has(makeId(it.intersection)) || tt.push(it.intersection);
        return tt
    }
    function c(b, j, $, nt) {
        const tt = s.getState();
        if (b.length) {
            const rt = {
                stopped: !1
            };
            for (const st of b) {
                const lt = getRootState(st.object) || tt
                  , {raycaster: ct, pointer: it, camera: ot, internal: at} = lt
                  , ht = new Vector3(it.x,it.y,0).unproject(ot)
                  , pt = _t => {
                    var bt, Rt;
                    return (bt = (Rt = at.capturedMap.get(_t)) == null ? void 0 : Rt.has(st.eventObject)) != null ? bt : !1
                }
                  , dt = _t => {
                    const bt = {
                        intersection: st,
                        target: j.target
                    };
                    at.capturedMap.has(_t) ? at.capturedMap.get(_t).set(st.eventObject, bt) : at.capturedMap.set(_t, new Map([[st.eventObject, bt]])),
                    j.target.setPointerCapture(_t)
                }
                  , yt = _t => {
                    const bt = at.capturedMap.get(_t);
                    bt && releaseInternalPointerCapture(at.capturedMap, st.eventObject, bt, _t)
                }
                ;
                let vt = {};
                for (let _t in j) {
                    let bt = j[_t];
                    typeof bt != "function" && (vt[_t] = bt)
                }
                let xt = {
                    ...st,
                    ...vt,
                    pointer: it,
                    intersections: b,
                    stopped: rt.stopped,
                    delta: $,
                    unprojectedPoint: ht,
                    ray: ct.ray,
                    camera: ot,
                    stopPropagation() {
                        const _t = "pointerId"in j && at.capturedMap.get(j.pointerId);
                        if ((!_t || _t.has(st.eventObject)) && (xt.stopped = rt.stopped = !0,
                        at.hovered.size && Array.from(at.hovered.values()).find(bt => bt.eventObject === st.eventObject))) {
                            const bt = b.slice(0, b.indexOf(st));
                            d([...bt, st])
                        }
                    },
                    target: {
                        hasPointerCapture: pt,
                        setPointerCapture: dt,
                        releasePointerCapture: yt
                    },
                    currentTarget: {
                        hasPointerCapture: pt,
                        setPointerCapture: dt,
                        releasePointerCapture: yt
                    },
                    nativeEvent: j
                };
                if (nt(xt),
                rt.stopped === !0)
                    break
            }
        }
        return b
    }
    function d(b) {
        const {internal: j} = s.getState();
        for (const $ of j.hovered.values())
            if (!b.length || !b.find(nt => nt.object === $.object && nt.index === $.index && nt.instanceId === $.instanceId)) {
                const tt = $.eventObject.__r3f
                  , rt = tt == null ? void 0 : tt.handlers;
                if (j.hovered.delete(makeId($)),
                tt != null && tt.eventCount) {
                    const st = {
                        ...$,
                        intersections: b
                    };
                    rt.onPointerOut == null || rt.onPointerOut(st),
                    rt.onPointerLeave == null || rt.onPointerLeave(st)
                }
            }
    }
    function g(b, j) {
        for (let $ = 0; $ < j.length; $++) {
            const nt = j[$].__r3f;
            nt == null || nt.handlers.onPointerMissed == null || nt.handlers.onPointerMissed(b)
        }
    }
    function _(b) {
        switch (b) {
        case "onPointerLeave":
        case "onPointerCancel":
            return () => d([]);
        case "onLostPointerCapture":
            return j => {
                const {internal: $} = s.getState();
                "pointerId"in j && $.capturedMap.has(j.pointerId) && requestAnimationFrame( () => {
                    $.capturedMap.has(j.pointerId) && ($.capturedMap.delete(j.pointerId),
                    d([]))
                }
                )
            }
        }
        return function($) {
            const {onPointerMissed: nt, internal: tt} = s.getState();
            tt.lastEvent.current = $;
            const rt = b === "onPointerMove"
              , st = b === "onClick" || b === "onContextMenu" || b === "onDoubleClick"
              , ct = o($, rt ? a : void 0)
              , it = st ? e($) : 0;
            b === "onPointerDown" && (tt.initialClick = [$.offsetX, $.offsetY],
            tt.initialHits = ct.map(at => at.eventObject)),
            st && !ct.length && it <= 2 && (g($, tt.interaction),
            nt && nt($)),
            rt && d(ct);
            function ot(at) {
                const ht = at.eventObject
                  , pt = ht.__r3f
                  , dt = pt == null ? void 0 : pt.handlers;
                if (pt != null && pt.eventCount)
                    if (rt) {
                        if (dt.onPointerOver || dt.onPointerEnter || dt.onPointerOut || dt.onPointerLeave) {
                            const yt = makeId(at)
                              , vt = tt.hovered.get(yt);
                            vt ? vt.stopped && at.stopPropagation() : (tt.hovered.set(yt, at),
                            dt.onPointerOver == null || dt.onPointerOver(at),
                            dt.onPointerEnter == null || dt.onPointerEnter(at))
                        }
                        dt.onPointerMove == null || dt.onPointerMove(at)
                    } else {
                        const yt = dt[b];
                        yt ? (!st || tt.initialHits.includes(ht)) && (g($, tt.interaction.filter(vt => !tt.initialHits.includes(vt))),
                        yt(at)) : st && tt.initialHits.includes(ht) && g($, tt.interaction.filter(vt => !tt.initialHits.includes(vt)))
                    }
            }
            c(ct, $, it, ot)
        }
    }
    return {
        handlePointer: _
    }
}
const isRenderer = s => !!(s != null && s.render)
  , context$1 = reactExports.createContext(null)
  , createStore$1 = (s, e) => {
    const a = create$1( (_, b) => {
        const j = new Vector3
          , $ = new Vector3
          , nt = new Vector3;
        function tt(it=b().camera, ot=$, at=b().size) {
            const {width: ht, height: pt, top: dt, left: yt} = at
              , vt = ht / pt;
            ot instanceof Vector3 ? nt.copy(ot) : nt.set(...ot);
            const xt = it.getWorldPosition(j).distanceTo(nt);
            if (isOrthographicCamera(it))
                return {
                    width: ht / it.zoom,
                    height: pt / it.zoom,
                    top: dt,
                    left: yt,
                    factor: 1,
                    distance: xt,
                    aspect: vt
                };
            {
                const _t = it.fov * Math.PI / 180
                  , bt = 2 * Math.tan(_t / 2) * xt
                  , Rt = bt * (ht / pt);
                return {
                    width: Rt,
                    height: bt,
                    top: dt,
                    left: yt,
                    factor: ht / Rt,
                    distance: xt,
                    aspect: vt
                }
            }
        }
        let rt;
        const st = it => _(ot => ({
            performance: {
                ...ot.performance,
                current: it
            }
        }))
          , lt = new Vector2;
        return {
            set: _,
            get: b,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            xr: null,
            scene: null,
            invalidate: (it=1) => s(b(), it),
            advance: (it, ot) => e(it, ot, b()),
            legacy: !1,
            linear: !1,
            flat: !1,
            controls: null,
            clock: new Clock,
            pointer: lt,
            mouse: lt,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: () => {
                    const it = b();
                    rt && clearTimeout(rt),
                    it.performance.current !== it.performance.min && st(it.performance.min),
                    rt = setTimeout( () => st(b().performance.max), it.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                updateStyle: !1
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: tt
            },
            setEvents: it => _(ot => ({
                ...ot,
                events: {
                    ...ot.events,
                    ...it
                }
            })),
            setSize: (it, ot, at, ht, pt) => {
                const dt = b().camera
                  , yt = {
                    width: it,
                    height: ot,
                    top: ht || 0,
                    left: pt || 0,
                    updateStyle: at
                };
                _(vt => ({
                    size: yt,
                    viewport: {
                        ...vt.viewport,
                        ...tt(dt, $, yt)
                    }
                }))
            }
            ,
            setDpr: it => _(ot => {
                const at = calculateDpr(it);
                return {
                    viewport: {
                        ...ot.viewport,
                        dpr: at,
                        initialDpr: ot.viewport.initialDpr || at
                    }
                }
            }
            ),
            setFrameloop: (it="always") => {
                const ot = b().clock;
                ot.stop(),
                ot.elapsedTime = 0,
                it !== "never" && (ot.start(),
                ot.elapsedTime = 0),
                _( () => ({
                    frameloop: it
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                active: !1,
                priority: 0,
                frames: 0,
                lastEvent: reactExports.createRef(),
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                subscribe: (it, ot, at) => {
                    const ht = b().internal;
                    return ht.priority = ht.priority + (ot > 0 ? 1 : 0),
                    ht.subscribers.push({
                        ref: it,
                        priority: ot,
                        store: at
                    }),
                    ht.subscribers = ht.subscribers.sort( (pt, dt) => pt.priority - dt.priority),
                    () => {
                        const pt = b().internal;
                        pt != null && pt.subscribers && (pt.priority = pt.priority - (ot > 0 ? 1 : 0),
                        pt.subscribers = pt.subscribers.filter(dt => dt.ref !== it))
                    }
                }
            }
        }
    }
    )
      , o = a.getState();
    let c = o.size
      , d = o.viewport.dpr
      , g = o.camera;
    return a.subscribe( () => {
        const {camera: _, size: b, viewport: j, gl: $, set: nt} = a.getState();
        if (b.width !== c.width || b.height !== c.height || j.dpr !== d) {
            var tt;
            c = b,
            d = j.dpr,
            updateCamera(_, b),
            $.setPixelRatio(j.dpr);
            const rt = (tt = b.updateStyle) != null ? tt : typeof HTMLCanvasElement < "u" && $.domElement instanceof HTMLCanvasElement;
            $.setSize(b.width, b.height, rt)
        }
        _ !== g && (g = _,
        nt(rt => ({
            viewport: {
                ...rt.viewport,
                ...rt.viewport.getCurrentViewport(_)
            }
        })))
    }
    ),
    a.subscribe(_ => s(_)),
    a
}
;
let i$1, globalEffects = new Set, globalAfterEffects = new Set, globalTailEffects = new Set;
function run(s, e) {
    if (s.size)
        for (const {callback: a} of s.values())
            a(e)
}
function flushGlobalEffects(s, e) {
    switch (s) {
    case "before":
        return run(globalEffects, e);
    case "after":
        return run(globalAfterEffects, e);
    case "tail":
        return run(globalTailEffects, e)
    }
}
let subscribers, subscription;
function render$1(s, e, a) {
    let o = e.clock.getDelta();
    for (e.frameloop === "never" && typeof s == "number" && (o = s - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = s),
    subscribers = e.internal.subscribers,
    i$1 = 0; i$1 < subscribers.length; i$1++)
        subscription = subscribers[i$1],
        subscription.ref.current(subscription.store.getState(), o, a);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
function createLoop(s) {
    let e = !1, a = !1, o, c, d;
    function g(j) {
        c = requestAnimationFrame(g),
        e = !0,
        o = 0,
        flushGlobalEffects("before", j),
        a = !0;
        for (const nt of s.values()) {
            var $;
            d = nt.store.getState(),
            d.internal.active && (d.frameloop === "always" || d.internal.frames > 0) && !(($ = d.gl.xr) != null && $.isPresenting) && (o += render$1(j, d))
        }
        if (a = !1,
        flushGlobalEffects("after", j),
        o === 0)
            return flushGlobalEffects("tail", j),
            e = !1,
            cancelAnimationFrame(c)
    }
    function _(j, $=1) {
        var nt;
        if (!j)
            return s.forEach(tt => _(tt.store.getState(), $));
        (nt = j.gl.xr) != null && nt.isPresenting || !j.internal.active || j.frameloop === "never" || ($ > 1 ? j.internal.frames = Math.min(60, j.internal.frames + $) : a ? j.internal.frames = 2 : j.internal.frames = 1,
        e || (e = !0,
        requestAnimationFrame(g)))
    }
    function b(j, $=!0, nt, tt) {
        if ($ && flushGlobalEffects("before", j),
        nt)
            render$1(j, nt, tt);
        else
            for (const rt of s.values())
                render$1(j, rt.store.getState());
        $ && flushGlobalEffects("after", j)
    }
    return {
        loop: g,
        invalidate: _,
        advance: b
    }
}
function useStore() {
    const s = reactExports.useContext(context$1);
    if (!s)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return s
}
function useThree(s=a => a, e) {
    return useStore()(s, e)
}
function useFrame(s, e=0) {
    const a = useStore()
      , o = a.getState().internal.subscribe
      , c = useMutableCallback(s);
    return useIsomorphicLayoutEffect$1( () => o(c, e, a), [e, o, a]),
    null
}
const memoizedLoaders = new WeakMap;
function loadingFn(s, e) {
    return function(a, ...o) {
        let c = memoizedLoaders.get(a);
        return c || (c = new a,
        memoizedLoaders.set(a, c)),
        s && s(c),
        Promise.all(o.map(d => new Promise( (g, _) => c.load(d, b => {
            b.scene && Object.assign(b, buildGraph(b.scene)),
            g(b)
        }
        , e, b => _(new Error(`Could not load ${d}: ${b == null ? void 0 : b.message}`))))))
    }
}
function useLoader(s, e, a, o) {
    const c = Array.isArray(e) ? e : [e]
      , d = suspend(loadingFn(a, o), [s, ...c], {
        equal: is.equ
    });
    return Array.isArray(e) ? d : d[0]
}
useLoader.preload = function(s, e, a) {
    const o = Array.isArray(e) ? e : [e];
    return preload(loadingFn(a), [s, ...o])
}
;
useLoader.clear = function(s, e) {
    const a = Array.isArray(e) ? e : [e];
    return clear([s, ...a])
}
;
const roots = new Map
  , {invalidate, advance} = createLoop(roots)
  , {reconciler, applyProps} = createRenderer(roots, getEventPriority)
  , shallowLoose = {
    objects: "shallow",
    strict: !1
}
  , createRendererInstance = (s, e) => {
    const a = typeof s == "function" ? s(e) : s;
    return isRenderer(a) ? a : new WebGLRenderer({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...s
    })
}
;
function computeInitialSize(s, e) {
    const a = typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement;
    if (e) {
        const {width: o, height: c, top: d, left: g, updateStyle: _=a} = e;
        return {
            width: o,
            height: c,
            top: d,
            left: g,
            updateStyle: _
        }
    } else if (typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement && s.parentElement) {
        const {width: o, height: c, top: d, left: g} = s.parentElement.getBoundingClientRect();
        return {
            width: o,
            height: c,
            top: d,
            left: g,
            updateStyle: a
        }
    } else if (typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas)
        return {
            width: s.width,
            height: s.height,
            top: 0,
            left: 0,
            updateStyle: a
        };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}
function createRoot(s) {
    const e = roots.get(s)
      , a = e == null ? void 0 : e.fiber
      , o = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const c = typeof reportError == "function" ? reportError : console.error
      , d = o || createStore$1(invalidate, advance)
      , g = a || reconciler.createContainer(d, constantsExports.ConcurrentRoot, null, !1, null, "", c, null);
    e || roots.set(s, {
        fiber: g,
        store: d
    });
    let _, b = !1, j;
    return {
        configure($={}) {
            let {gl: nt, size: tt, scene: rt, events: st, onCreated: lt, shadows: ct=!1, linear: it=!1, flat: ot=!1, legacy: at=!1, orthographic: ht=!1, frameloop: pt="always", dpr: dt=[1, 2], performance: yt, raycaster: vt, camera: xt, onPointerMissed: _t} = $
              , bt = d.getState()
              , Rt = bt.gl;
            bt.gl || bt.set({
                gl: Rt = createRendererInstance(nt, s)
            });
            let Ft = bt.raycaster;
            Ft || bt.set({
                raycaster: Ft = new Raycaster
            });
            const {params: Bt, ...Dt} = vt || {};
            if (is.equ(Dt, Ft, shallowLoose) || applyProps(Ft, {
                ...Dt
            }),
            is.equ(Bt, Ft.params, shallowLoose) || applyProps(Ft, {
                params: {
                    ...Ft.params,
                    ...Bt
                }
            }),
            !bt.camera || bt.camera === j && !is.equ(j, xt, shallowLoose)) {
                j = xt;
                const wt = xt instanceof Camera
                  , Ct = wt ? xt : ht ? new OrthographicCamera(0,0,0,0,.1,1e3) : new PerspectiveCamera(75,0,.1,1e3);
                wt || (Ct.position.z = 5,
                xt && (applyProps(Ct, xt),
                ("aspect"in xt || "left"in xt || "right"in xt || "bottom"in xt || "top"in xt) && (Ct.manual = !0,
                Ct.updateProjectionMatrix())),
                !bt.camera && !(xt != null && xt.rotation) && Ct.lookAt(0, 0, 0)),
                bt.set({
                    camera: Ct
                }),
                Ft.camera = Ct
            }
            if (!bt.scene) {
                let wt;
                rt instanceof Scene ? wt = rt : (wt = new Scene,
                rt && applyProps(wt, rt)),
                bt.set({
                    scene: prepare(wt)
                })
            }
            if (!bt.xr) {
                var Mt;
                const wt = (en, Ot) => {
                    const Yt = d.getState();
                    Yt.frameloop !== "never" && advance(en, !0, Yt, Ot)
                }
                  , Ct = () => {
                    const en = d.getState();
                    en.gl.xr.enabled = en.gl.xr.isPresenting,
                    en.gl.xr.setAnimationLoop(en.gl.xr.isPresenting ? wt : null),
                    en.gl.xr.isPresenting || invalidate(en)
                }
                  , Ht = {
                    connect() {
                        const en = d.getState().gl;
                        en.xr.addEventListener("sessionstart", Ct),
                        en.xr.addEventListener("sessionend", Ct)
                    },
                    disconnect() {
                        const en = d.getState().gl;
                        en.xr.removeEventListener("sessionstart", Ct),
                        en.xr.removeEventListener("sessionend", Ct)
                    }
                };
                typeof ((Mt = Rt.xr) == null ? void 0 : Mt.addEventListener) == "function" && Ht.connect(),
                bt.set({
                    xr: Ht
                })
            }
            if (Rt.shadowMap) {
                const wt = Rt.shadowMap.enabled
                  , Ct = Rt.shadowMap.type;
                if (Rt.shadowMap.enabled = !!ct,
                is.boo(ct))
                    Rt.shadowMap.type = PCFSoftShadowMap;
                else if (is.str(ct)) {
                    var Tt;
                    const Ht = {
                        basic: BasicShadowMap,
                        percentage: PCFShadowMap,
                        soft: PCFSoftShadowMap,
                        variance: VSMShadowMap
                    };
                    Rt.shadowMap.type = (Tt = Ht[ct]) != null ? Tt : PCFSoftShadowMap
                } else
                    is.obj(ct) && Object.assign(Rt.shadowMap, ct);
                (wt !== Rt.shadowMap.enabled || Ct !== Rt.shadowMap.type) && (Rt.shadowMap.needsUpdate = !0)
            }
            const mt = getColorManagement();
            mt && ("enabled"in mt ? mt.enabled = !at : "legacyMode"in mt && (mt.legacyMode = at)),
            b || applyProps(Rt, {
                outputEncoding: it ? 3e3 : 3001,
                toneMapping: ot ? NoToneMapping : ACESFilmicToneMapping
            }),
            bt.legacy !== at && bt.set( () => ({
                legacy: at
            })),
            bt.linear !== it && bt.set( () => ({
                linear: it
            })),
            bt.flat !== ot && bt.set( () => ({
                flat: ot
            })),
            nt && !is.fun(nt) && !isRenderer(nt) && !is.equ(nt, Rt, shallowLoose) && applyProps(Rt, nt),
            st && !bt.events.handlers && bt.set({
                events: st(d)
            });
            const St = computeInitialSize(s, tt);
            return is.equ(St, bt.size, shallowLoose) || bt.setSize(St.width, St.height, St.updateStyle, St.top, St.left),
            dt && bt.viewport.dpr !== calculateDpr(dt) && bt.setDpr(dt),
            bt.frameloop !== pt && bt.setFrameloop(pt),
            bt.onPointerMissed || bt.set({
                onPointerMissed: _t
            }),
            yt && !is.equ(yt, bt.performance, shallowLoose) && bt.set(wt => ({
                performance: {
                    ...wt.performance,
                    ...yt
                }
            })),
            _ = lt,
            b = !0,
            this
        },
        render($) {
            return b || this.configure(),
            reconciler.updateContainer(jsxRuntimeExports.jsx(Provider, {
                store: d,
                children: $,
                onCreated: _,
                rootElement: s
            }), g, null, () => {}
            ),
            d
        },
        unmount() {
            unmountComponentAtNode(s)
        }
    }
}
function Provider({store: s, children: e, onCreated: a, rootElement: o}) {
    return useIsomorphicLayoutEffect$1( () => {
        const c = s.getState();
        c.set(d => ({
            internal: {
                ...d.internal,
                active: !0
            }
        })),
        a && a(c),
        s.getState().events.connected || c.events.connect == null || c.events.connect(o)
    }
    , []),
    jsxRuntimeExports.jsx(context$1.Provider, {
        value: s,
        children: e
    })
}
function unmountComponentAtNode(s, e) {
    const a = roots.get(s)
      , o = a == null ? void 0 : a.fiber;
    if (o) {
        const c = a == null ? void 0 : a.store.getState();
        c && (c.internal.active = !1),
        reconciler.updateContainer(null, o, null, () => {
            c && setTimeout( () => {
                try {
                    var d, g, _, b;
                    c.events.disconnect == null || c.events.disconnect(),
                    (d = c.gl) == null || (g = d.renderLists) == null || g.dispose == null || g.dispose(),
                    (_ = c.gl) == null || _.forceContextLoss == null || _.forceContextLoss(),
                    (b = c.gl) != null && b.xr && c.xr.disconnect(),
                    dispose(c),
                    roots.delete(s)
                } catch {}
            }
            , 500)
        }
        )
    }
}
reconciler.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: reactExports.version
});
const DOM_EVENTS = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function createPointerEvents(s) {
    const {handlePointer: e} = createEvents(s);
    return {
        priority: 1,
        enabled: !0,
        compute(a, o, c) {
            o.pointer.set(a.offsetX / o.size.width * 2 - 1, -(a.offsetY / o.size.height) * 2 + 1),
            o.raycaster.setFromCamera(o.pointer, o.camera)
        },
        connected: void 0,
        handlers: Object.keys(DOM_EVENTS).reduce( (a, o) => ({
            ...a,
            [o]: e(o)
        }), {}),
        update: () => {
            var a;
            const {events: o, internal: c} = s.getState();
            (a = c.lastEvent) != null && a.current && o.handlers && o.handlers.onPointerMove(c.lastEvent.current)
        }
        ,
        connect: a => {
            var o;
            const {set: c, events: d} = s.getState();
            d.disconnect == null || d.disconnect(),
            c(g => ({
                events: {
                    ...g.events,
                    connected: a
                }
            })),
            Object.entries((o = d.handlers) != null ? o : []).forEach( ([g,_]) => {
                const [b,j] = DOM_EVENTS[g];
                a.addEventListener(b, _, {
                    passive: j
                })
            }
            )
        }
        ,
        disconnect: () => {
            const {set: a, events: o} = s.getState();
            if (o.connected) {
                var c;
                Object.entries((c = o.handlers) != null ? c : []).forEach( ([d,g]) => {
                    if (o && o.connected instanceof HTMLElement) {
                        const [_] = DOM_EVENTS[d];
                        o.connected.removeEventListener(_, g)
                    }
                }
                ),
                a(d => ({
                    events: {
                        ...d.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
function debounce(s, e, a) {
    var o, c, d, g, _;
    e == null && (e = 100);
    function b() {
        var $ = Date.now() - g;
        $ < e && $ >= 0 ? o = setTimeout(b, e - $) : (o = null,
        a || (_ = s.apply(d, c),
        d = c = null))
    }
    var j = function() {
        d = this,
        c = arguments,
        g = Date.now();
        var $ = a && !o;
        return o || (o = setTimeout(b, e)),
        $ && (_ = s.apply(d, c),
        d = c = null),
        _
    };
    return j.clear = function() {
        o && (clearTimeout(o),
        o = null)
    }
    ,
    j.flush = function() {
        o && (_ = s.apply(d, c),
        d = c = null,
        clearTimeout(o),
        o = null)
    }
    ,
    j
}
debounce.debounce = debounce;
var debounce_1 = debounce;
const createDebounce = getDefaultExportFromCjs(debounce_1);
var __defProp$2 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (s, e, a) => e in s ? __defProp$2(s, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : s[e] = a, __spreadValues$1 = (s, e) => {
    for (var a in e || (e = {}))
        __hasOwnProp$1.call(e, a) && __defNormalProp$2(s, a, e[a]);
    if (__getOwnPropSymbols$1)
        for (var a of __getOwnPropSymbols$1(e))
            __propIsEnum$1.call(e, a) && __defNormalProp$2(s, a, e[a]);
    return s
}
, __spreadProps$1 = (s, e) => __defProps$1(s, __getOwnPropDescs$1(e)), _a, _b;
typeof window < "u" && ((_a = window.document) != null && _a.createElement || ((_b = window.navigator) == null ? void 0 : _b.product) === "ReactNative") ? reactExports.useLayoutEffect : reactExports.useEffect;
function traverseFiber(s, e, a) {
    if (!s)
        return;
    if (a(s) === !0)
        return s;
    let o = s.child;
    for (; o; ) {
        const c = traverseFiber(o, e, a);
        if (c)
            return c;
        o = o.sibling
    }
}
function wrapContext(s) {
    try {
        return Object.defineProperties(s, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return s
    }
}
const error = console.error;
console.error = function() {
    const s = [...arguments].join("");
    if (s != null && s.startsWith("Warning:") && s.includes("useContext")) {
        console.error = error;
        return
    }
    return error.apply(this, arguments)
}
;
const FiberContext = wrapContext(reactExports.createContext(null));
class FiberProvider extends reactExports.Component {
    render() {
        return reactExports.createElement(FiberContext.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
function useFiber() {
    const s = reactExports.useContext(FiberContext);
    if (s === null)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = reactExports.useId();
    return reactExports.useMemo( () => {
        for (const o of [s, s == null ? void 0 : s.alternate]) {
            if (!o)
                continue;
            const c = traverseFiber(o, !1, d => {
                let g = d.memoizedState;
                for (; g; ) {
                    if (g.memoizedState === e)
                        return !0;
                    g = g.next
                }
            }
            );
            if (c)
                return c
        }
    }
    , [s, e])
}
function useContextMap() {
    const s = useFiber()
      , [e] = reactExports.useState( () => new Map);
    e.clear();
    let a = s;
    for (; a; ) {
        if (a.type && typeof a.type == "object") {
            const c = a.type._context === void 0 && a.type.Provider === a.type ? a.type : a.type._context;
            c && c !== FiberContext && !e.has(c) && e.set(c, reactExports.useContext(wrapContext(c)))
        }
        a = a.return
    }
    return e
}
function useContextBridge() {
    const s = useContextMap();
    return reactExports.useMemo( () => Array.from(s.keys()).reduce( (e, a) => o => reactExports.createElement(e, null, reactExports.createElement(a.Provider, __spreadProps$1(__spreadValues$1({}, o), {
        value: s.get(a)
    }))), e => reactExports.createElement(FiberProvider, __spreadValues$1({}, e))), [s])
}
function useMeasure({debounce: s, scroll: e, polyfill: a, offsetSize: o}={
    debounce: 0,
    scroll: !1,
    offsetSize: !1
}) {
    const c = a || typeof window < "u" && window.ResizeObserver
      , [d,g] = reactExports.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    });
    if (!c)
        return d.width = 1280,
        d.height = 800,
        [ () => {}
        , d, () => {}
        ];
    const _ = reactExports.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: d,
        orientationHandler: null
    })
      , b = s ? typeof s == "number" ? s : s.scroll : null
      , j = s ? typeof s == "number" ? s : s.resize : null
      , $ = reactExports.useRef(!1);
    reactExports.useEffect( () => ($.current = !0,
    () => void ($.current = !1)));
    const [nt,tt,rt] = reactExports.useMemo( () => {
        const it = () => {
            if (!_.current.element)
                return;
            const {left: ot, top: at, width: ht, height: pt, bottom: dt, right: yt, x: vt, y: xt} = _.current.element.getBoundingClientRect()
              , _t = {
                left: ot,
                top: at,
                width: ht,
                height: pt,
                bottom: dt,
                right: yt,
                x: vt,
                y: xt
            };
            _.current.element instanceof HTMLElement && o && (_t.height = _.current.element.offsetHeight,
            _t.width = _.current.element.offsetWidth),
            Object.freeze(_t),
            $.current && !areBoundsEqual(_.current.lastBounds, _t) && g(_.current.lastBounds = _t)
        }
        ;
        return [it, j ? createDebounce(it, j) : it, b ? createDebounce(it, b) : it]
    }
    , [g, o, b, j]);
    function st() {
        _.current.scrollContainers && (_.current.scrollContainers.forEach(it => it.removeEventListener("scroll", rt, !0)),
        _.current.scrollContainers = null),
        _.current.resizeObserver && (_.current.resizeObserver.disconnect(),
        _.current.resizeObserver = null),
        _.current.orientationHandler && screen.orientation.removeEventListener("orientationchange", _.current.orientationHandler)
    }
    function lt() {
        _.current.element && (_.current.resizeObserver = new c(rt),
        _.current.resizeObserver.observe(_.current.element),
        e && _.current.scrollContainers && _.current.scrollContainers.forEach(it => it.addEventListener("scroll", rt, {
            capture: !0,
            passive: !0
        })),
        _.current.orientationHandler = () => {
            rt()
        }
        )
    }
    const ct = it => {
        !it || it === _.current.element || (st(),
        _.current.element = it,
        _.current.scrollContainers = findScrollContainers(it),
        lt())
    }
    ;
    return useOnWindowScroll(rt, !!e),
    useOnWindowResize(tt),
    reactExports.useEffect( () => {
        st(),
        lt()
    }
    , [e, rt, tt]),
    reactExports.useEffect( () => st, []),
    [ct, d, nt]
}
function useOnWindowResize(s) {
    reactExports.useEffect( () => {
        const e = s;
        return window.addEventListener("resize", e),
        () => void window.removeEventListener("resize", e)
    }
    , [s])
}
function useOnWindowScroll(s, e) {
    reactExports.useEffect( () => {
        if (e) {
            const a = s;
            return window.addEventListener("scroll", a, {
                capture: !0,
                passive: !0
            }),
            () => void window.removeEventListener("scroll", a, !0)
        }
    }
    , [s, e])
}
function findScrollContainers(s) {
    const e = [];
    if (!s || s === document.body)
        return e;
    const {overflow: a, overflowX: o, overflowY: c} = window.getComputedStyle(s);
    return [a, o, c].some(d => d === "auto" || d === "scroll") && e.push(s),
    [...e, ...findScrollContainers(s.parentElement)]
}
const keys = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , areBoundsEqual = (s, e) => keys.every(a => s[a] === e[a])
  , CanvasImpl = reactExports.forwardRef(function({children: e, fallback: a, resize: o, style: c, gl: d, events: g=createPointerEvents, eventSource: _, eventPrefix: b, shadows: j, linear: $, flat: nt, legacy: tt, orthographic: rt, frameloop: st, dpr: lt, performance: ct, raycaster: it, camera: ot, scene: at, onPointerMissed: ht, onCreated: pt, ...dt}, yt) {
    reactExports.useMemo( () => extend(THREE), []);
    const vt = useContextBridge()
      , [xt,_t] = useMeasure({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...o
    })
      , bt = reactExports.useRef(null)
      , Rt = reactExports.useRef(null);
    reactExports.useImperativeHandle(yt, () => bt.current);
    const Ft = useMutableCallback(ht)
      , [Bt,Dt] = reactExports.useState(!1)
      , [Mt,Tt] = reactExports.useState(!1);
    if (Bt)
        throw Bt;
    if (Mt)
        throw Mt;
    const mt = reactExports.useRef(null);
    useIsomorphicLayoutEffect$1( () => {
        const wt = bt.current;
        _t.width > 0 && _t.height > 0 && wt && (mt.current || (mt.current = createRoot(wt)),
        mt.current.configure({
            gl: d,
            events: g,
            shadows: j,
            linear: $,
            flat: nt,
            legacy: tt,
            orthographic: rt,
            frameloop: st,
            dpr: lt,
            performance: ct,
            raycaster: it,
            camera: ot,
            scene: at,
            size: _t,
            onPointerMissed: (...Ct) => Ft.current == null ? void 0 : Ft.current(...Ct),
            onCreated: Ct => {
                Ct.events.connect == null || Ct.events.connect(_ ? isRef(_) ? _.current : _ : Rt.current),
                b && Ct.setEvents({
                    compute: (Ht, en) => {
                        const Ot = Ht[b + "X"]
                          , Yt = Ht[b + "Y"];
                        en.pointer.set(Ot / en.size.width * 2 - 1, -(Yt / en.size.height) * 2 + 1),
                        en.raycaster.setFromCamera(en.pointer, en.camera)
                    }
                }),
                pt == null || pt(Ct)
            }
        }),
        mt.current.render(jsxRuntimeExports.jsx(vt, {
            children: jsxRuntimeExports.jsx(ErrorBoundary, {
                set: Tt,
                children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                    fallback: jsxRuntimeExports.jsx(Block, {
                        set: Dt
                    }),
                    children: e
                })
            })
        })))
    }
    ),
    reactExports.useEffect( () => {
        const wt = bt.current;
        if (wt)
            return () => unmountComponentAtNode(wt)
    }
    , []);
    const St = _ ? "none" : "auto";
    return jsxRuntimeExports.jsx("div", {
        ref: Rt,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: St,
            ...c
        },
        ...dt,
        children: jsxRuntimeExports.jsx("div", {
            ref: xt,
            style: {
                width: "100%",
                height: "100%"
            },
            children: jsxRuntimeExports.jsx("canvas", {
                ref: bt,
                style: {
                    display: "block"
                },
                children: a
            })
        })
    })
})
  , Canvas = reactExports.forwardRef(function(e, a) {
    return jsxRuntimeExports.jsx(FiberProvider, {
        children: jsxRuntimeExports.jsx(CanvasImpl, {
            ...e,
            ref: a
        })
    })
});
function _extends$2() {
    return _extends$2 = Object.assign ? Object.assign.bind() : function(s) {
        for (var e = 1; e < arguments.length; e++) {
            var a = arguments[e];
            for (var o in a)
                ({}).hasOwnProperty.call(a, o) && (s[o] = a[o])
        }
        return s
    }
    ,
    _extends$2.apply(null, arguments)
}
const v1 = new Vector3
  , v2 = new Vector3
  , v3 = new Vector3
  , v4 = new Vector2;
function defaultCalculatePosition(s, e, a) {
    const o = v1.setFromMatrixPosition(s.matrixWorld);
    o.project(e);
    const c = a.width / 2
      , d = a.height / 2;
    return [o.x * c + c, -(o.y * d) + d]
}
function isObjectBehindCamera(s, e) {
    const a = v1.setFromMatrixPosition(s.matrixWorld)
      , o = v2.setFromMatrixPosition(e.matrixWorld)
      , c = a.sub(o)
      , d = e.getWorldDirection(v3);
    return c.angleTo(d) > Math.PI / 2
}
function isObjectVisible(s, e, a, o) {
    const c = v1.setFromMatrixPosition(s.matrixWorld)
      , d = c.clone();
    d.project(e),
    v4.set(d.x, d.y),
    a.setFromCamera(v4, e);
    const g = a.intersectObjects(o, !0);
    if (g.length) {
        const _ = g[0].distance;
        return c.distanceTo(a.ray.origin) < _
    }
    return !0
}
function objectScale(s, e) {
    if (e instanceof OrthographicCamera)
        return e.zoom;
    if (e instanceof PerspectiveCamera) {
        const a = v1.setFromMatrixPosition(s.matrixWorld)
          , o = v2.setFromMatrixPosition(e.matrixWorld)
          , c = e.fov * Math.PI / 180
          , d = a.distanceTo(o);
        return 1 / (2 * Math.tan(c / 2) * d)
    } else
        return 1
}
function objectZIndex(s, e, a) {
    if (e instanceof PerspectiveCamera || e instanceof OrthographicCamera) {
        const o = v1.setFromMatrixPosition(s.matrixWorld)
          , c = v2.setFromMatrixPosition(e.matrixWorld)
          , d = o.distanceTo(c)
          , g = (a[1] - a[0]) / (e.far - e.near)
          , _ = a[1] - g * e.far;
        return Math.round(g * d + _)
    }
}
const epsilon = s => Math.abs(s) < 1e-10 ? 0 : s;
function getCSSMatrix(s, e, a="") {
    let o = "matrix3d(";
    for (let c = 0; c !== 16; c++)
        o += epsilon(e[c] * s.elements[c]) + (c !== 15 ? "," : ")");
    return a + o
}
const getCameraCSSMatrix = (s => e => getCSSMatrix(e, s))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1])
  , getObjectCSSMatrix = (s => (e, a) => getCSSMatrix(e, s(a), "translate(-50%,-50%)"))(s => [1 / s, 1 / s, 1 / s, 1, -1 / s, -1 / s, -1 / s, -1, 1 / s, 1 / s, 1 / s, 1, 1, 1, 1, 1]);
function isRefObject(s) {
    return s && typeof s == "object" && "current"in s
}
const Html = reactExports.forwardRef( ({children: s, eps: e=.001, style: a, className: o, prepend: c, center: d, fullscreen: g, portal: _, distanceFactor: b, sprite: j=!1, transform: $=!1, occlude: nt, onOcclude: tt, castShadow: rt, receiveShadow: st, material: lt, geometry: ct, zIndexRange: it=[16777271, 0], calculatePosition: ot=defaultCalculatePosition, as: at="div", wrapperClass: ht, pointerEvents: pt="auto", ...dt}, yt) => {
    const {gl: vt, camera: xt, scene: _t, size: bt, raycaster: Rt, events: Ft, viewport: Bt} = useThree()
      , [Dt] = reactExports.useState( () => document.createElement(at))
      , Mt = reactExports.useRef()
      , Tt = reactExports.useRef(null)
      , mt = reactExports.useRef(0)
      , St = reactExports.useRef([0, 0])
      , wt = reactExports.useRef(null)
      , Ct = reactExports.useRef(null)
      , Ht = (_ == null ? void 0 : _.current) || Ft.connected || vt.domElement.parentNode
      , en = reactExports.useRef(null)
      , Ot = reactExports.useRef(!1)
      , Yt = reactExports.useMemo( () => nt && nt !== "blending" || Array.isArray(nt) && nt.length && isRefObject(nt[0]), [nt]);
    reactExports.useLayoutEffect( () => {
        const _n = vt.domElement;
        nt && nt === "blending" ? (_n.style.zIndex = `${Math.floor(it[0] / 2)}`,
        _n.style.position = "absolute",
        _n.style.pointerEvents = "none") : (_n.style.zIndex = null,
        _n.style.position = null,
        _n.style.pointerEvents = null)
    }
    , [nt]),
    reactExports.useLayoutEffect( () => {
        if (Tt.current) {
            const _n = Mt.current = createRoot$1(Dt);
            if (_t.updateMatrixWorld(),
            $)
                Dt.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
                const yn = ot(Tt.current, xt, bt);
                Dt.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${yn[0]}px,${yn[1]}px,0);transform-origin:0 0;`
            }
            return Ht && (c ? Ht.prepend(Dt) : Ht.appendChild(Dt)),
            () => {
                Ht && Ht.removeChild(Dt),
                _n.unmount()
            }
        }
    }
    , [Ht, $]),
    reactExports.useLayoutEffect( () => {
        ht && (Dt.className = ht)
    }
    , [ht]);
    const rn = reactExports.useMemo( () => $ ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: bt.width,
        height: bt.height,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
    } : {
        position: "absolute",
        transform: d ? "translate3d(-50%,-50%,0)" : "none",
        ...g && {
            top: -bt.height / 2,
            left: -bt.width / 2,
            width: bt.width,
            height: bt.height
        },
        ...a
    }, [a, d, g, bt, $])
      , Xt = reactExports.useMemo( () => ({
        position: "absolute",
        pointerEvents: pt
    }), [pt]);
    reactExports.useLayoutEffect( () => {
        if (Ot.current = !1,
        $) {
            var _n;
            (_n = Mt.current) == null || _n.render(reactExports.createElement("div", {
                ref: wt,
                style: rn
            }, reactExports.createElement("div", {
                ref: Ct,
                style: Xt
            }, reactExports.createElement("div", {
                ref: yt,
                className: o,
                style: a,
                children: s
            }))))
        } else {
            var yn;
            (yn = Mt.current) == null || yn.render(reactExports.createElement("div", {
                ref: yt,
                style: rn,
                className: o,
                children: s
            }))
        }
    }
    );
    const An = reactExports.useRef(!0);
    useFrame(_n => {
        if (Tt.current) {
            xt.updateMatrixWorld(),
            Tt.current.updateWorldMatrix(!0, !1);
            const yn = $ ? St.current : ot(Tt.current, xt, bt);
            if ($ || Math.abs(mt.current - xt.zoom) > e || Math.abs(St.current[0] - yn[0]) > e || Math.abs(St.current[1] - yn[1]) > e) {
                const Pt = isObjectBehindCamera(Tt.current, xt);
                let Qt = !1;
                Yt && (Array.isArray(nt) ? Qt = nt.map(bn => bn.current) : nt !== "blending" && (Qt = [_t]));
                const jt = An.current;
                if (Qt) {
                    const bn = isObjectVisible(Tt.current, xt, Rt, Qt);
                    An.current = bn && !Pt
                } else
                    An.current = !Pt;
                jt !== An.current && (tt ? tt(!An.current) : Dt.style.display = An.current ? "block" : "none");
                const fn = Math.floor(it[0] / 2)
                  , tn = nt ? Yt ? [it[0], fn] : [fn - 1, 0] : it;
                if (Dt.style.zIndex = `${objectZIndex(Tt.current, xt, tn)}`,
                $) {
                    const [bn,gn] = [bt.width / 2, bt.height / 2]
                      , vn = xt.projectionMatrix.elements[5] * gn
                      , {isOrthographicCamera: Lt, top: At, left: $t, bottom: on, right: sn} = xt
                      , cn = getCameraCSSMatrix(xt.matrixWorldInverse)
                      , Pn = Lt ? `scale(${vn})translate(${epsilon(-(sn + $t) / 2)}px,${epsilon((At + on) / 2)}px)` : `translateZ(${vn}px)`;
                    let dn = Tt.current.matrixWorld;
                    j && (dn = xt.matrixWorldInverse.clone().transpose().copyPosition(dn).scale(Tt.current.scale),
                    dn.elements[3] = dn.elements[7] = dn.elements[11] = 0,
                    dn.elements[15] = 1),
                    Dt.style.width = bt.width + "px",
                    Dt.style.height = bt.height + "px",
                    Dt.style.perspective = Lt ? "" : `${vn}px`,
                    wt.current && Ct.current && (wt.current.style.transform = `${Pn}${cn}translate(${bn}px,${gn}px)`,
                    Ct.current.style.transform = getObjectCSSMatrix(dn, 1 / ((b || 10) / 400)))
                } else {
                    const bn = b === void 0 ? 1 : objectScale(Tt.current, xt) * b;
                    Dt.style.transform = `translate3d(${yn[0]}px,${yn[1]}px,0) scale(${bn})`
                }
                St.current = yn,
                mt.current = xt.zoom
            }
        }
        if (!Yt && en.current && !Ot.current)
            if ($) {
                if (wt.current) {
                    const yn = wt.current.children[0];
                    if (yn != null && yn.clientWidth && yn != null && yn.clientHeight) {
                        const {isOrthographicCamera: Pt} = xt;
                        if (Pt || ct)
                            dt.scale && (Array.isArray(dt.scale) ? dt.scale instanceof Vector3 ? en.current.scale.copy(dt.scale.clone().divideScalar(1)) : en.current.scale.set(1 / dt.scale[0], 1 / dt.scale[1], 1 / dt.scale[2]) : en.current.scale.setScalar(1 / dt.scale));
                        else {
                            const Qt = (b || 10) / 400
                              , jt = yn.clientWidth * Qt
                              , fn = yn.clientHeight * Qt;
                            en.current.scale.set(jt, fn, 1)
                        }
                        Ot.current = !0
                    }
                }
            } else {
                const yn = Dt.children[0];
                if (yn != null && yn.clientWidth && yn != null && yn.clientHeight) {
                    const Pt = 1 / Bt.factor
                      , Qt = yn.clientWidth * Pt
                      , jt = yn.clientHeight * Pt;
                    en.current.scale.set(Qt, jt, 1),
                    Ot.current = !0
                }
                en.current.lookAt(_n.camera.position)
            }
    }
    );
    const Ln = reactExports.useMemo( () => ({
        vertexShader: $ ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    }), [$]);
    return reactExports.createElement("group", _extends$2({}, dt, {
        ref: Tt
    }), nt && !Yt && reactExports.createElement("mesh", {
        castShadow: rt,
        receiveShadow: st,
        ref: en
    }, ct || reactExports.createElement("planeGeometry", null), lt || reactExports.createElement("shaderMaterial", {
        side: DoubleSide,
        vertexShader: Ln.vertexShader,
        fragmentShader: Ln.fragmentShader
    })))
}
);
function createStore(s) {
    let e;
    const a = new Set
      , o = (j, $) => {
        const nt = typeof j == "function" ? j(e) : j;
        if (nt !== e) {
            const tt = e;
            e = $ ? nt : Object.assign({}, e, nt),
            a.forEach(rt => rt(e, tt))
        }
    }
      , c = () => e
      , d = (j, $=c, nt=Object.is) => {
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let tt = $(e);
        function rt() {
            const st = $(e);
            if (!nt(tt, st)) {
                const lt = tt;
                j(tt = st, lt)
            }
        }
        return a.add(rt),
        () => a.delete(rt)
    }
      , b = {
        setState: o,
        getState: c,
        subscribe: (j, $, nt) => $ || nt ? d(j, $, nt) : (a.add(j),
        () => a.delete(j)),
        destroy: () => a.clear()
    };
    return e = s(o, c, b),
    b
}
const isSSR = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , useIsomorphicLayoutEffect = isSSR ? reactExports.useEffect : reactExports.useLayoutEffect;
function create(s) {
    const e = typeof s == "function" ? createStore(s) : s
      , a = (o=e.getState, c=Object.is) => {
        const [,d] = reactExports.useReducer(ct => ct + 1, 0)
          , g = e.getState()
          , _ = reactExports.useRef(g)
          , b = reactExports.useRef(o)
          , j = reactExports.useRef(c)
          , $ = reactExports.useRef(!1)
          , nt = reactExports.useRef();
        nt.current === void 0 && (nt.current = o(g));
        let tt, rt = !1;
        (_.current !== g || b.current !== o || j.current !== c || $.current) && (tt = o(g),
        rt = !c(nt.current, tt)),
        useIsomorphicLayoutEffect( () => {
            rt && (nt.current = tt),
            _.current = g,
            b.current = o,
            j.current = c,
            $.current = !1
        }
        );
        const st = reactExports.useRef(g);
        useIsomorphicLayoutEffect( () => {
            const ct = () => {
                try {
                    const ot = e.getState()
                      , at = b.current(ot);
                    j.current(nt.current, at) || (_.current = ot,
                    nt.current = at,
                    d())
                } catch {
                    $.current = !0,
                    d()
                }
            }
              , it = e.subscribe(ct);
            return e.getState() !== st.current && ct(),
            it
        }
        , []);
        const lt = rt ? tt : nt.current;
        return reactExports.useDebugValue(lt),
        lt
    }
    ;
    return Object.assign(a, e),
    a[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const o = [a, e];
        return {
            next() {
                const c = o.length <= 0;
                return {
                    value: o.shift(),
                    done: c
                }
            }
        }
    }
    ,
    a
}
let saveLastTotalLoaded = 0;
const useProgress = create(s => (DefaultLoadingManager.onStart = (e, a, o) => {
    s({
        active: !0,
        item: e,
        loaded: a,
        total: o,
        progress: (a - saveLastTotalLoaded) / (o - saveLastTotalLoaded) * 100
    })
}
,
DefaultLoadingManager.onLoad = () => {
    s({
        active: !1
    })
}
,
DefaultLoadingManager.onError = e => s(a => ({
    errors: [...a.errors, e]
})),
DefaultLoadingManager.onProgress = (e, a, o) => {
    a === o && (saveLastTotalLoaded = o),
    s({
        active: !0,
        item: e,
        loaded: a,
        total: o,
        progress: (a - saveLastTotalLoaded) / (o - saveLastTotalLoaded) * 100 || 100
    })
}
,
{
    errors: [],
    active: !1,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
}));
function _defineProperty$1(s, e, a) {
    return e in s ? Object.defineProperty(s, e, {
        value: a,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : s[e] = a,
    s
}
function ownKeys$1(s, e) {
    var a = Object.keys(s);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(s);
        e && (o = o.filter(function(c) {
            return Object.getOwnPropertyDescriptor(s, c).enumerable
        })),
        a.push.apply(a, o)
    }
    return a
}
function _objectSpread2(s) {
    for (var e = 1; e < arguments.length; e++) {
        var a = arguments[e] != null ? arguments[e] : {};
        e % 2 ? ownKeys$1(Object(a), !0).forEach(function(o) {
            _defineProperty$1(s, o, a[o])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(a)) : ownKeys$1(Object(a)).forEach(function(o) {
            Object.defineProperty(s, o, Object.getOwnPropertyDescriptor(a, o))
        })
    }
    return s
}
new Vector2;
new Vector2;
function _classCallCheck(s, e) {
    if (!(s instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
var Grad = function s(e, a, o) {
    var c = this;
    _classCallCheck(this, s),
    _defineProperty$1(this, "dot2", function(d, g) {
        return c.x * d + c.y * g
    }),
    _defineProperty$1(this, "dot3", function(d, g, _) {
        return c.x * d + c.y * g + c.z * _
    }),
    this.x = e,
    this.y = a,
    this.z = o
}
  , grad3 = [new Grad(1,1,0), new Grad(-1,1,0), new Grad(1,-1,0), new Grad(-1,-1,0), new Grad(1,0,1), new Grad(-1,0,1), new Grad(1,0,-1), new Grad(-1,0,-1), new Grad(0,1,1), new Grad(0,-1,1), new Grad(0,1,-1), new Grad(0,-1,-1)]
  , p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
  , perm = new Array(512)
  , gradP = new Array(512)
  , seed = function(e) {
    e > 0 && e < 1 && (e *= 65536),
    e = Math.floor(e),
    e < 256 && (e |= e << 8);
    for (var a = 0; a < 256; a++) {
        var o;
        a & 1 ? o = p[a] ^ e & 255 : o = p[a] ^ e >> 8 & 255,
        perm[a] = perm[a + 256] = o,
        gradP[a] = gradP[a + 256] = grad3[o % 12]
    }
};
seed(0);
function normalizeSeed(s) {
    if (typeof s == "number")
        s = Math.abs(s);
    else if (typeof s == "string") {
        var e = s;
        s = 0;
        for (var a = 0; a < e.length; a++)
            s = (s + (a + 1) * (e.charCodeAt(a) % 96)) % 2147483647
    }
    return s === 0 && (s = 311),
    s
}
function lcgRandom(s) {
    var e = normalizeSeed(s);
    return function() {
        var a = e * 48271 % 2147483647;
        return e = a,
        a / 2147483647
    }
}
var Generator = function s(e) {
    var a = this;
    _classCallCheck(this, s),
    _defineProperty$1(this, "seed", 0),
    _defineProperty$1(this, "init", function(o) {
        a.seed = o,
        a.value = lcgRandom(o)
    }),
    _defineProperty$1(this, "value", lcgRandom(this.seed)),
    this.init(e)
}
  , defaultGen = new Generator(Math.random())
  , defaultSphere = {
    radius: 1,
    center: [0, 0, 0]
};
function inSphere(s, e) {
    for (var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultGen, o = _objectSpread2(_objectSpread2({}, defaultSphere), e), c = o.radius, d = o.center, g = 0; g < s.length; g += 3) {
        var _ = Math.pow(a.value(), .3333333333333333)
          , b = a.value() * 2 - 1
          , j = a.value() * 2 - 1
          , $ = a.value() * 2 - 1
          , nt = Math.sqrt(b * b + j * j + $ * $);
        b = _ * b / nt,
        j = _ * j / nt,
        $ = _ * $ / nt,
        s[g] = b * c + d[0],
        s[g + 1] = j * c + d[1],
        s[g + 2] = $ * c + d[2]
    }
    return s
}
var __defProp$1 = Object.defineProperty
  , __defNormalProp$1 = (s, e, a) => e in s ? __defProp$1(s, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : s[e] = a
  , __publicField = (s, e, a) => (__defNormalProp$1(s, typeof e != "symbol" ? e + "" : e, a),
a);
const _ray = new Ray
  , _plane = new Plane
  , TILT_LIMIT = Math.cos(70 * (Math.PI / 180))
  , moduloWrapAround = (s, e) => (s % e + e) % e;
let OrbitControls$1 = class extends EventDispatcher {
    constructor(e, a) {
        super(),
        __publicField(this, "object"),
        __publicField(this, "domElement"),
        __publicField(this, "enabled", !0),
        __publicField(this, "target", new Vector3),
        __publicField(this, "minDistance", 0),
        __publicField(this, "maxDistance", 1 / 0),
        __publicField(this, "minZoom", 0),
        __publicField(this, "maxZoom", 1 / 0),
        __publicField(this, "minPolarAngle", 0),
        __publicField(this, "maxPolarAngle", Math.PI),
        __publicField(this, "minAzimuthAngle", -1 / 0),
        __publicField(this, "maxAzimuthAngle", 1 / 0),
        __publicField(this, "enableDamping", !1),
        __publicField(this, "dampingFactor", .05),
        __publicField(this, "enableZoom", !0),
        __publicField(this, "zoomSpeed", 1),
        __publicField(this, "enableRotate", !0),
        __publicField(this, "rotateSpeed", 1),
        __publicField(this, "enablePan", !0),
        __publicField(this, "panSpeed", 1),
        __publicField(this, "screenSpacePanning", !0),
        __publicField(this, "keyPanSpeed", 7),
        __publicField(this, "zoomToCursor", !1),
        __publicField(this, "autoRotate", !1),
        __publicField(this, "autoRotateSpeed", 2),
        __publicField(this, "reverseOrbit", !1),
        __publicField(this, "reverseHorizontalOrbit", !1),
        __publicField(this, "reverseVerticalOrbit", !1),
        __publicField(this, "keys", {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }),
        __publicField(this, "mouseButtons", {
            LEFT: MOUSE.ROTATE,
            MIDDLE: MOUSE.DOLLY,
            RIGHT: MOUSE.PAN
        }),
        __publicField(this, "touches", {
            ONE: TOUCH.ROTATE,
            TWO: TOUCH.DOLLY_PAN
        }),
        __publicField(this, "target0"),
        __publicField(this, "position0"),
        __publicField(this, "zoom0"),
        __publicField(this, "_domElementKeyEvents", null),
        __publicField(this, "getPolarAngle"),
        __publicField(this, "getAzimuthalAngle"),
        __publicField(this, "setPolarAngle"),
        __publicField(this, "setAzimuthalAngle"),
        __publicField(this, "getDistance"),
        __publicField(this, "listenToKeyEvents"),
        __publicField(this, "stopListenToKeyEvents"),
        __publicField(this, "saveState"),
        __publicField(this, "reset"),
        __publicField(this, "update"),
        __publicField(this, "connect"),
        __publicField(this, "dispose"),
        this.object = e,
        this.domElement = a,
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this.getPolarAngle = () => $.phi,
        this.getAzimuthalAngle = () => $.theta,
        this.setPolarAngle = Nt => {
            let ln = moduloWrapAround(Nt, 2 * Math.PI)
              , Cn = $.phi;
            Cn < 0 && (Cn += 2 * Math.PI),
            ln < 0 && (ln += 2 * Math.PI);
            let Vt = Math.abs(ln - Cn);
            2 * Math.PI - Vt < Vt && (ln < Cn ? ln += 2 * Math.PI : Cn += 2 * Math.PI),
            nt.phi = ln - Cn,
            o.update()
        }
        ,
        this.setAzimuthalAngle = Nt => {
            let ln = moduloWrapAround(Nt, 2 * Math.PI)
              , Cn = $.theta;
            Cn < 0 && (Cn += 2 * Math.PI),
            ln < 0 && (ln += 2 * Math.PI);
            let Vt = Math.abs(ln - Cn);
            2 * Math.PI - Vt < Vt && (ln < Cn ? ln += 2 * Math.PI : Cn += 2 * Math.PI),
            nt.theta = ln - Cn,
            o.update()
        }
        ,
        this.getDistance = () => o.object.position.distanceTo(o.target),
        this.listenToKeyEvents = Nt => {
            Nt.addEventListener("keydown", dn),
            this._domElementKeyEvents = Nt
        }
        ,
        this.stopListenToKeyEvents = () => {
            this._domElementKeyEvents.removeEventListener("keydown", dn),
            this._domElementKeyEvents = null
        }
        ,
        this.saveState = () => {
            o.target0.copy(o.target),
            o.position0.copy(o.object.position),
            o.zoom0 = o.object.zoom
        }
        ,
        this.reset = () => {
            o.target.copy(o.target0),
            o.object.position.copy(o.position0),
            o.object.zoom = o.zoom0,
            o.object.updateProjectionMatrix(),
            o.dispatchEvent(c),
            o.update(),
            b = _.NONE
        }
        ,
        this.update = ( () => {
            const Nt = new Vector3
              , ln = new Vector3(0,1,0)
              , Cn = new Quaternion().setFromUnitVectors(e.up, ln)
              , Vt = Cn.clone().invert()
              , hn = new Vector3
              , an = new Quaternion
              , un = 2 * Math.PI;
            return function() {
                const Hn = o.object.position;
                Cn.setFromUnitVectors(e.up, ln),
                Vt.copy(Cn).invert(),
                Nt.copy(Hn).sub(o.target),
                Nt.applyQuaternion(Cn),
                $.setFromVector3(Nt),
                o.autoRotate && b === _.NONE && Bt(Rt()),
                o.enableDamping ? ($.theta += nt.theta * o.dampingFactor,
                $.phi += nt.phi * o.dampingFactor) : ($.theta += nt.theta,
                $.phi += nt.phi);
                let Yn = o.minAzimuthAngle
                  , tr = o.maxAzimuthAngle;
                isFinite(Yn) && isFinite(tr) && (Yn < -Math.PI ? Yn += un : Yn > Math.PI && (Yn -= un),
                tr < -Math.PI ? tr += un : tr > Math.PI && (tr -= un),
                Yn <= tr ? $.theta = Math.max(Yn, Math.min(tr, $.theta)) : $.theta = $.theta > (Yn + tr) / 2 ? Math.max(Yn, $.theta) : Math.min(tr, $.theta)),
                $.phi = Math.max(o.minPolarAngle, Math.min(o.maxPolarAngle, $.phi)),
                $.makeSafe(),
                o.enableDamping === !0 ? o.target.addScaledVector(rt, o.dampingFactor) : o.target.add(rt),
                o.zoomToCursor && xt || o.object.isOrthographicCamera ? $.radius = Ht($.radius) : $.radius = Ht($.radius * tt),
                Nt.setFromSpherical($),
                Nt.applyQuaternion(Vt),
                Hn.copy(o.target).add(Nt),
                o.object.matrixAutoUpdate || o.object.updateMatrix(),
                o.object.lookAt(o.target),
                o.enableDamping === !0 ? (nt.theta *= 1 - o.dampingFactor,
                nt.phi *= 1 - o.dampingFactor,
                rt.multiplyScalar(1 - o.dampingFactor)) : (nt.set(0, 0, 0),
                rt.set(0, 0, 0));
                let hr = !1;
                if (o.zoomToCursor && xt) {
                    let Jn = null;
                    if (o.object instanceof PerspectiveCamera && o.object.isPerspectiveCamera) {
                        const Mr = Nt.length();
                        Jn = Ht(Mr * tt);
                        const br = Mr - Jn;
                        o.object.position.addScaledVector(yt, br),
                        o.object.updateMatrixWorld()
                    } else if (o.object.isOrthographicCamera) {
                        const Mr = new Vector3(vt.x,vt.y,0);
                        Mr.unproject(o.object),
                        o.object.zoom = Math.max(o.minZoom, Math.min(o.maxZoom, o.object.zoom / tt)),
                        o.object.updateProjectionMatrix(),
                        hr = !0;
                        const br = new Vector3(vt.x,vt.y,0);
                        br.unproject(o.object),
                        o.object.position.sub(br).add(Mr),
                        o.object.updateMatrixWorld(),
                        Jn = Nt.length()
                    } else
                        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                        o.zoomToCursor = !1;
                    Jn !== null && (o.screenSpacePanning ? o.target.set(0, 0, -1).transformDirection(o.object.matrix).multiplyScalar(Jn).add(o.object.position) : (_ray.origin.copy(o.object.position),
                    _ray.direction.set(0, 0, -1).transformDirection(o.object.matrix),
                    Math.abs(o.object.up.dot(_ray.direction)) < TILT_LIMIT ? e.lookAt(o.target) : (_plane.setFromNormalAndCoplanarPoint(o.object.up, o.target),
                    _ray.intersectPlane(_plane, o.target))))
                } else
                    o.object instanceof OrthographicCamera && o.object.isOrthographicCamera && (hr = tt !== 1,
                    hr && (o.object.zoom = Math.max(o.minZoom, Math.min(o.maxZoom, o.object.zoom / tt)),
                    o.object.updateProjectionMatrix()));
                return tt = 1,
                xt = !1,
                hr || hn.distanceToSquared(o.object.position) > j || 8 * (1 - an.dot(o.object.quaternion)) > j ? (o.dispatchEvent(c),
                hn.copy(o.object.position),
                an.copy(o.object.quaternion),
                hr = !1,
                !0) : !1
            }
        }
        )(),
        this.connect = Nt => {
            o.domElement = Nt,
            o.domElement.style.touchAction = "none",
            o.domElement.addEventListener("contextmenu", pn),
            o.domElement.addEventListener("pointerdown", At),
            o.domElement.addEventListener("pointercancel", on),
            o.domElement.addEventListener("wheel", Pn)
        }
        ,
        this.dispose = () => {
            var Nt, ln, Cn, Vt, hn, an;
            o.domElement && (o.domElement.style.touchAction = "auto"),
            (Nt = o.domElement) == null || Nt.removeEventListener("contextmenu", pn),
            (ln = o.domElement) == null || ln.removeEventListener("pointerdown", At),
            (Cn = o.domElement) == null || Cn.removeEventListener("pointercancel", on),
            (Vt = o.domElement) == null || Vt.removeEventListener("wheel", Pn),
            (hn = o.domElement) == null || hn.ownerDocument.removeEventListener("pointermove", $t),
            (an = o.domElement) == null || an.ownerDocument.removeEventListener("pointerup", on),
            o._domElementKeyEvents !== null && o._domElementKeyEvents.removeEventListener("keydown", dn)
        }
        ;
        const o = this
          , c = {
            type: "change"
        }
          , d = {
            type: "start"
        }
          , g = {
            type: "end"
        }
          , _ = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let b = _.NONE;
        const j = 1e-6
          , $ = new Spherical
          , nt = new Spherical;
        let tt = 1;
        const rt = new Vector3
          , st = new Vector2
          , lt = new Vector2
          , ct = new Vector2
          , it = new Vector2
          , ot = new Vector2
          , at = new Vector2
          , ht = new Vector2
          , pt = new Vector2
          , dt = new Vector2
          , yt = new Vector3
          , vt = new Vector2;
        let xt = !1;
        const _t = []
          , bt = {};
        function Rt() {
            return 2 * Math.PI / 60 / 60 * o.autoRotateSpeed
        }
        function Ft() {
            return Math.pow(.95, o.zoomSpeed)
        }
        function Bt(Nt) {
            o.reverseOrbit || o.reverseHorizontalOrbit ? nt.theta += Nt : nt.theta -= Nt
        }
        function Dt(Nt) {
            o.reverseOrbit || o.reverseVerticalOrbit ? nt.phi += Nt : nt.phi -= Nt
        }
        const Mt = ( () => {
            const Nt = new Vector3;
            return function(Cn, Vt) {
                Nt.setFromMatrixColumn(Vt, 0),
                Nt.multiplyScalar(-Cn),
                rt.add(Nt)
            }
        }
        )()
          , Tt = ( () => {
            const Nt = new Vector3;
            return function(Cn, Vt) {
                o.screenSpacePanning === !0 ? Nt.setFromMatrixColumn(Vt, 1) : (Nt.setFromMatrixColumn(Vt, 0),
                Nt.crossVectors(o.object.up, Nt)),
                Nt.multiplyScalar(Cn),
                rt.add(Nt)
            }
        }
        )()
          , mt = ( () => {
            const Nt = new Vector3;
            return function(Cn, Vt) {
                const hn = o.domElement;
                if (hn && o.object instanceof PerspectiveCamera && o.object.isPerspectiveCamera) {
                    const an = o.object.position;
                    Nt.copy(an).sub(o.target);
                    let un = Nt.length();
                    un *= Math.tan(o.object.fov / 2 * Math.PI / 180),
                    Mt(2 * Cn * un / hn.clientHeight, o.object.matrix),
                    Tt(2 * Vt * un / hn.clientHeight, o.object.matrix)
                } else
                    hn && o.object instanceof OrthographicCamera && o.object.isOrthographicCamera ? (Mt(Cn * (o.object.right - o.object.left) / o.object.zoom / hn.clientWidth, o.object.matrix),
                    Tt(Vt * (o.object.top - o.object.bottom) / o.object.zoom / hn.clientHeight, o.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    o.enablePan = !1)
            }
        }
        )();
        function St(Nt) {
            o.object instanceof PerspectiveCamera && o.object.isPerspectiveCamera || o.object instanceof OrthographicCamera && o.object.isOrthographicCamera ? tt /= Nt : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            o.enableZoom = !1)
        }
        function wt(Nt) {
            o.object instanceof PerspectiveCamera && o.object.isPerspectiveCamera || o.object instanceof OrthographicCamera && o.object.isOrthographicCamera ? tt *= Nt : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            o.enableZoom = !1)
        }
        function Ct(Nt) {
            if (!o.zoomToCursor || !o.domElement)
                return;
            xt = !0;
            const ln = o.domElement.getBoundingClientRect()
              , Cn = Nt.clientX - ln.left
              , Vt = Nt.clientY - ln.top
              , hn = ln.width
              , an = ln.height;
            vt.x = Cn / hn * 2 - 1,
            vt.y = -(Vt / an) * 2 + 1,
            yt.set(vt.x, vt.y, 1).unproject(o.object).sub(o.object.position).normalize()
        }
        function Ht(Nt) {
            return Math.max(o.minDistance, Math.min(o.maxDistance, Nt))
        }
        function en(Nt) {
            st.set(Nt.clientX, Nt.clientY)
        }
        function Ot(Nt) {
            Ct(Nt),
            ht.set(Nt.clientX, Nt.clientY)
        }
        function Yt(Nt) {
            it.set(Nt.clientX, Nt.clientY)
        }
        function rn(Nt) {
            lt.set(Nt.clientX, Nt.clientY),
            ct.subVectors(lt, st).multiplyScalar(o.rotateSpeed);
            const ln = o.domElement;
            ln && (Bt(2 * Math.PI * ct.x / ln.clientHeight),
            Dt(2 * Math.PI * ct.y / ln.clientHeight)),
            st.copy(lt),
            o.update()
        }
        function Xt(Nt) {
            pt.set(Nt.clientX, Nt.clientY),
            dt.subVectors(pt, ht),
            dt.y > 0 ? St(Ft()) : dt.y < 0 && wt(Ft()),
            ht.copy(pt),
            o.update()
        }
        function An(Nt) {
            ot.set(Nt.clientX, Nt.clientY),
            at.subVectors(ot, it).multiplyScalar(o.panSpeed),
            mt(at.x, at.y),
            it.copy(ot),
            o.update()
        }
        function Ln(Nt) {
            Ct(Nt),
            Nt.deltaY < 0 ? wt(Ft()) : Nt.deltaY > 0 && St(Ft()),
            o.update()
        }
        function _n(Nt) {
            let ln = !1;
            switch (Nt.code) {
            case o.keys.UP:
                mt(0, o.keyPanSpeed),
                ln = !0;
                break;
            case o.keys.BOTTOM:
                mt(0, -o.keyPanSpeed),
                ln = !0;
                break;
            case o.keys.LEFT:
                mt(o.keyPanSpeed, 0),
                ln = !0;
                break;
            case o.keys.RIGHT:
                mt(-o.keyPanSpeed, 0),
                ln = !0;
                break
            }
            ln && (Nt.preventDefault(),
            o.update())
        }
        function yn() {
            if (_t.length == 1)
                st.set(_t[0].pageX, _t[0].pageY);
            else {
                const Nt = .5 * (_t[0].pageX + _t[1].pageX)
                  , ln = .5 * (_t[0].pageY + _t[1].pageY);
                st.set(Nt, ln)
            }
        }
        function Pt() {
            if (_t.length == 1)
                it.set(_t[0].pageX, _t[0].pageY);
            else {
                const Nt = .5 * (_t[0].pageX + _t[1].pageX)
                  , ln = .5 * (_t[0].pageY + _t[1].pageY);
                it.set(Nt, ln)
            }
        }
        function Qt() {
            const Nt = _t[0].pageX - _t[1].pageX
              , ln = _t[0].pageY - _t[1].pageY
              , Cn = Math.sqrt(Nt * Nt + ln * ln);
            ht.set(0, Cn)
        }
        function jt() {
            o.enableZoom && Qt(),
            o.enablePan && Pt()
        }
        function fn() {
            o.enableZoom && Qt(),
            o.enableRotate && yn()
        }
        function tn(Nt) {
            if (_t.length == 1)
                lt.set(Nt.pageX, Nt.pageY);
            else {
                const Cn = Dn(Nt)
                  , Vt = .5 * (Nt.pageX + Cn.x)
                  , hn = .5 * (Nt.pageY + Cn.y);
                lt.set(Vt, hn)
            }
            ct.subVectors(lt, st).multiplyScalar(o.rotateSpeed);
            const ln = o.domElement;
            ln && (Bt(2 * Math.PI * ct.x / ln.clientHeight),
            Dt(2 * Math.PI * ct.y / ln.clientHeight)),
            st.copy(lt)
        }
        function bn(Nt) {
            if (_t.length == 1)
                ot.set(Nt.pageX, Nt.pageY);
            else {
                const ln = Dn(Nt)
                  , Cn = .5 * (Nt.pageX + ln.x)
                  , Vt = .5 * (Nt.pageY + ln.y);
                ot.set(Cn, Vt)
            }
            at.subVectors(ot, it).multiplyScalar(o.panSpeed),
            mt(at.x, at.y),
            it.copy(ot)
        }
        function gn(Nt) {
            const ln = Dn(Nt)
              , Cn = Nt.pageX - ln.x
              , Vt = Nt.pageY - ln.y
              , hn = Math.sqrt(Cn * Cn + Vt * Vt);
            pt.set(0, hn),
            dt.set(0, Math.pow(pt.y / ht.y, o.zoomSpeed)),
            St(dt.y),
            ht.copy(pt)
        }
        function vn(Nt) {
            o.enableZoom && gn(Nt),
            o.enablePan && bn(Nt)
        }
        function Lt(Nt) {
            o.enableZoom && gn(Nt),
            o.enableRotate && tn(Nt)
        }
        function At(Nt) {
            var ln, Cn;
            o.enabled !== !1 && (_t.length === 0 && ((ln = o.domElement) == null || ln.ownerDocument.addEventListener("pointermove", $t),
            (Cn = o.domElement) == null || Cn.ownerDocument.addEventListener("pointerup", on)),
            kn(Nt),
            Nt.pointerType === "touch" ? Tn(Nt) : sn(Nt))
        }
        function $t(Nt) {
            o.enabled !== !1 && (Nt.pointerType === "touch" ? jn(Nt) : cn(Nt))
        }
        function on(Nt) {
            var ln, Cn, Vt;
            er(Nt),
            _t.length === 0 && ((ln = o.domElement) == null || ln.releasePointerCapture(Nt.pointerId),
            (Cn = o.domElement) == null || Cn.ownerDocument.removeEventListener("pointermove", $t),
            (Vt = o.domElement) == null || Vt.ownerDocument.removeEventListener("pointerup", on)),
            o.dispatchEvent(g),
            b = _.NONE
        }
        function sn(Nt) {
            let ln;
            switch (Nt.button) {
            case 0:
                ln = o.mouseButtons.LEFT;
                break;
            case 1:
                ln = o.mouseButtons.MIDDLE;
                break;
            case 2:
                ln = o.mouseButtons.RIGHT;
                break;
            default:
                ln = -1
            }
            switch (ln) {
            case MOUSE.DOLLY:
                if (o.enableZoom === !1)
                    return;
                Ot(Nt),
                b = _.DOLLY;
                break;
            case MOUSE.ROTATE:
                if (Nt.ctrlKey || Nt.metaKey || Nt.shiftKey) {
                    if (o.enablePan === !1)
                        return;
                    Yt(Nt),
                    b = _.PAN
                } else {
                    if (o.enableRotate === !1)
                        return;
                    en(Nt),
                    b = _.ROTATE
                }
                break;
            case MOUSE.PAN:
                if (Nt.ctrlKey || Nt.metaKey || Nt.shiftKey) {
                    if (o.enableRotate === !1)
                        return;
                    en(Nt),
                    b = _.ROTATE
                } else {
                    if (o.enablePan === !1)
                        return;
                    Yt(Nt),
                    b = _.PAN
                }
                break;
            default:
                b = _.NONE
            }
            b !== _.NONE && o.dispatchEvent(d)
        }
        function cn(Nt) {
            if (o.enabled !== !1)
                switch (b) {
                case _.ROTATE:
                    if (o.enableRotate === !1)
                        return;
                    rn(Nt);
                    break;
                case _.DOLLY:
                    if (o.enableZoom === !1)
                        return;
                    Xt(Nt);
                    break;
                case _.PAN:
                    if (o.enablePan === !1)
                        return;
                    An(Nt);
                    break
                }
        }
        function Pn(Nt) {
            o.enabled === !1 || o.enableZoom === !1 || b !== _.NONE && b !== _.ROTATE || (Nt.preventDefault(),
            o.dispatchEvent(d),
            Ln(Nt),
            o.dispatchEvent(g))
        }
        function dn(Nt) {
            o.enabled === !1 || o.enablePan === !1 || _n(Nt)
        }
        function Tn(Nt) {
            switch ($n(Nt),
            _t.length) {
            case 1:
                switch (o.touches.ONE) {
                case TOUCH.ROTATE:
                    if (o.enableRotate === !1)
                        return;
                    yn(),
                    b = _.TOUCH_ROTATE;
                    break;
                case TOUCH.PAN:
                    if (o.enablePan === !1)
                        return;
                    Pt(),
                    b = _.TOUCH_PAN;
                    break;
                default:
                    b = _.NONE
                }
                break;
            case 2:
                switch (o.touches.TWO) {
                case TOUCH.DOLLY_PAN:
                    if (o.enableZoom === !1 && o.enablePan === !1)
                        return;
                    jt(),
                    b = _.TOUCH_DOLLY_PAN;
                    break;
                case TOUCH.DOLLY_ROTATE:
                    if (o.enableZoom === !1 && o.enableRotate === !1)
                        return;
                    fn(),
                    b = _.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    b = _.NONE
                }
                break;
            default:
                b = _.NONE
            }
            b !== _.NONE && o.dispatchEvent(d)
        }
        function jn(Nt) {
            switch ($n(Nt),
            b) {
            case _.TOUCH_ROTATE:
                if (o.enableRotate === !1)
                    return;
                tn(Nt),
                o.update();
                break;
            case _.TOUCH_PAN:
                if (o.enablePan === !1)
                    return;
                bn(Nt),
                o.update();
                break;
            case _.TOUCH_DOLLY_PAN:
                if (o.enableZoom === !1 && o.enablePan === !1)
                    return;
                vn(Nt),
                o.update();
                break;
            case _.TOUCH_DOLLY_ROTATE:
                if (o.enableZoom === !1 && o.enableRotate === !1)
                    return;
                Lt(Nt),
                o.update();
                break;
            default:
                b = _.NONE
            }
        }
        function pn(Nt) {
            o.enabled !== !1 && Nt.preventDefault()
        }
        function kn(Nt) {
            _t.push(Nt)
        }
        function er(Nt) {
            delete bt[Nt.pointerId];
            for (let ln = 0; ln < _t.length; ln++)
                if (_t[ln].pointerId == Nt.pointerId) {
                    _t.splice(ln, 1);
                    return
                }
        }
        function $n(Nt) {
            let ln = bt[Nt.pointerId];
            ln === void 0 && (ln = new Vector2,
            bt[Nt.pointerId] = ln),
            ln.set(Nt.pageX, Nt.pageY)
        }
        function Dn(Nt) {
            const ln = Nt.pointerId === _t[0].pointerId ? _t[1] : _t[0];
            return bt[ln.pointerId]
        }
        a !== void 0 && this.connect(a),
        this.update()
    }
}
;
class DecalGeometry extends BufferGeometry {
    constructor(e, a, o, c) {
        super();
        const d = []
          , g = []
          , _ = []
          , b = new Vector3
          , j = new Matrix4;
        j.makeRotationFromEuler(o),
        j.setPosition(a);
        const $ = new Matrix4;
        $.copy(j).invert(),
        nt(),
        this.setAttribute("position", new Float32BufferAttribute(d,3)),
        this.setAttribute("normal", new Float32BufferAttribute(g,3)),
        this.setAttribute("uv", new Float32BufferAttribute(_,2));
        function nt() {
            let lt, ct = [];
            const it = new Vector3
              , ot = new Vector3;
            if (e.geometry.isGeometry === !0) {
                console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");
                return
            }
            const at = e.geometry
              , ht = at.attributes.position
              , pt = at.attributes.normal;
            if (at.index !== null) {
                const dt = at.index;
                for (lt = 0; lt < dt.count; lt++)
                    it.fromBufferAttribute(ht, dt.getX(lt)),
                    ot.fromBufferAttribute(pt, dt.getX(lt)),
                    tt(ct, it, ot)
            } else
                for (lt = 0; lt < ht.count; lt++)
                    it.fromBufferAttribute(ht, lt),
                    ot.fromBufferAttribute(pt, lt),
                    tt(ct, it, ot);
            for (ct = rt(ct, b.set(1, 0, 0)),
            ct = rt(ct, b.set(-1, 0, 0)),
            ct = rt(ct, b.set(0, 1, 0)),
            ct = rt(ct, b.set(0, -1, 0)),
            ct = rt(ct, b.set(0, 0, 1)),
            ct = rt(ct, b.set(0, 0, -1)),
            lt = 0; lt < ct.length; lt++) {
                const dt = ct[lt];
                _.push(.5 + dt.position.x / c.x, .5 + dt.position.y / c.y),
                dt.position.applyMatrix4(j),
                d.push(dt.position.x, dt.position.y, dt.position.z),
                g.push(dt.normal.x, dt.normal.y, dt.normal.z)
            }
        }
        function tt(lt, ct, it) {
            ct.applyMatrix4(e.matrixWorld),
            ct.applyMatrix4($),
            it.transformDirection(e.matrixWorld),
            lt.push(new DecalVertex(ct.clone(),it.clone()))
        }
        function rt(lt, ct) {
            const it = []
              , ot = .5 * Math.abs(c.dot(ct));
            for (let at = 0; at < lt.length; at += 3) {
                let ht, pt, dt, yt = 0, vt, xt, _t, bt;
                const Rt = lt[at + 0].position.dot(ct) - ot
                  , Ft = lt[at + 1].position.dot(ct) - ot
                  , Bt = lt[at + 2].position.dot(ct) - ot;
                switch (ht = Rt > 0,
                pt = Ft > 0,
                dt = Bt > 0,
                yt = (ht ? 1 : 0) + (pt ? 1 : 0) + (dt ? 1 : 0),
                yt) {
                case 0:
                    {
                        it.push(lt[at]),
                        it.push(lt[at + 1]),
                        it.push(lt[at + 2]);
                        break
                    }
                case 1:
                    {
                        if (ht && (vt = lt[at + 1],
                        xt = lt[at + 2],
                        _t = st(lt[at], vt, ct, ot),
                        bt = st(lt[at], xt, ct, ot)),
                        pt) {
                            vt = lt[at],
                            xt = lt[at + 2],
                            _t = st(lt[at + 1], vt, ct, ot),
                            bt = st(lt[at + 1], xt, ct, ot),
                            it.push(_t),
                            it.push(xt.clone()),
                            it.push(vt.clone()),
                            it.push(xt.clone()),
                            it.push(_t.clone()),
                            it.push(bt);
                            break
                        }
                        dt && (vt = lt[at],
                        xt = lt[at + 1],
                        _t = st(lt[at + 2], vt, ct, ot),
                        bt = st(lt[at + 2], xt, ct, ot)),
                        it.push(vt.clone()),
                        it.push(xt.clone()),
                        it.push(_t),
                        it.push(bt),
                        it.push(_t.clone()),
                        it.push(xt.clone());
                        break
                    }
                case 2:
                    {
                        ht || (vt = lt[at].clone(),
                        xt = st(vt, lt[at + 1], ct, ot),
                        _t = st(vt, lt[at + 2], ct, ot),
                        it.push(vt),
                        it.push(xt),
                        it.push(_t)),
                        pt || (vt = lt[at + 1].clone(),
                        xt = st(vt, lt[at + 2], ct, ot),
                        _t = st(vt, lt[at], ct, ot),
                        it.push(vt),
                        it.push(xt),
                        it.push(_t)),
                        dt || (vt = lt[at + 2].clone(),
                        xt = st(vt, lt[at], ct, ot),
                        _t = st(vt, lt[at + 1], ct, ot),
                        it.push(vt),
                        it.push(xt),
                        it.push(_t));
                        break
                    }
                }
            }
            return it
        }
        function st(lt, ct, it, ot) {
            const at = lt.position.dot(it) - ot
              , ht = ct.position.dot(it) - ot
              , pt = at / (at - ht);
            return new DecalVertex(new Vector3(lt.position.x + pt * (ct.position.x - lt.position.x),lt.position.y + pt * (ct.position.y - lt.position.y),lt.position.z + pt * (ct.position.z - lt.position.z)),new Vector3(lt.normal.x + pt * (ct.normal.x - lt.normal.x),lt.normal.y + pt * (ct.normal.y - lt.normal.y),lt.normal.z + pt * (ct.normal.z - lt.normal.z)))
        }
    }
}
class DecalVertex {
    constructor(e, a) {
        this.position = e,
        this.normal = a
    }
    clone() {
        return new this.constructor(this.position.clone(),this.normal.clone())
    }
}
const IsObject = s => s === Object(s) && !Array.isArray(s) && typeof s != "function";
function useTexture(s, e) {
    const a = useThree(d => d.gl)
      , o = useLoader(TextureLoader, IsObject(s) ? Object.values(s) : s);
    return reactExports.useLayoutEffect( () => {
        e == null || e(o)
    }
    , [e]),
    reactExports.useEffect( () => {
        if ("initTexture"in a) {
            let d = [];
            Array.isArray(o) ? d = o : o instanceof Texture ? d = [o] : IsObject(o) && (d = Object.values(o)),
            d.forEach(g => {
                g instanceof Texture && a.initTexture(g)
            }
            )
        }
    }
    , [a, o]),
    reactExports.useMemo( () => {
        if (IsObject(s)) {
            const d = {};
            let g = 0;
            for (const _ in s)
                d[_] = o[g++];
            return d
        } else
            return o
    }
    , [s, o])
}
useTexture.preload = s => useLoader.preload(TextureLoader, s);
useTexture.clear = s => useLoader.clear(TextureLoader, s);
const getVersion = () => parseInt(REVISION.replace(/\D+/g, ""))
  , version = getVersion();
function isArray(s) {
    return Array.isArray(s)
}
function vecToArray(s=[0, 0, 0]) {
    return isArray(s) ? s : s instanceof Vector3 || s instanceof Euler ? [s.x, s.y, s.z] : [s, s, s]
}
const Decal = reactExports.forwardRef(function({debug: e, depthTest: a=!1, polygonOffsetFactor: o=-10, map: c, mesh: d, children: g, position: _, rotation: b, scale: j, ...$}, nt) {
    const tt = reactExports.useRef(null);
    reactExports.useImperativeHandle(nt, () => tt.current);
    const rt = reactExports.useRef(null);
    return reactExports.useLayoutEffect( () => {
        const st = (d == null ? void 0 : d.current) || tt.current.parent
          , lt = tt.current;
        if (!(st instanceof Mesh))
            throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');
        const ct = {
            position: new Vector3,
            rotation: new Euler,
            scale: new Vector3(1,1,1)
        };
        if (st) {
            applyProps(ct, {
                position: _,
                scale: j
            });
            const it = st.matrixWorld.clone();
            if (st.matrixWorld.identity(),
            !b || typeof b == "number") {
                const ot = new Object3D;
                ot.position.copy(ct.position),
                ot.lookAt(st.position),
                typeof b == "number" && ot.rotateZ(b),
                applyProps(ct, {
                    rotation: ot.rotation
                })
            } else
                applyProps(ct, {
                    rotation: b
                });
            return lt.geometry = new DecalGeometry(st,ct.position,ct.rotation,ct.scale),
            rt.current && (applyProps(rt.current, ct),
            rt.current.traverse(ot => ot.raycast = () => null)),
            st.matrixWorld = it,
            () => {
                lt.geometry.dispose()
            }
        }
    }
    , [d, ...vecToArray(_), ...vecToArray(j), ...vecToArray(b)]),
    reactExports.createElement("mesh", _extends$2({
        ref: tt,
        "material-transparent": !0,
        "material-polygonOffset": !0,
        "material-polygonOffsetFactor": o,
        "material-depthTest": a,
        "material-map": c
    }, $), g, e && reactExports.createElement("mesh", {
        ref: rt
    }, reactExports.createElement("boxGeometry", null), reactExports.createElement("meshNormalMaterial", {
        wireframe: !0
    }), reactExports.createElement("axesHelper", null)))
})
  , OrbitControls = reactExports.forwardRef( ({makeDefault: s, camera: e, regress: a, domElement: o, enableDamping: c=!0, keyEvents: d=!1, onChange: g, onStart: _, onEnd: b, ...j}, $) => {
    const nt = useThree(dt => dt.invalidate)
      , tt = useThree(dt => dt.camera)
      , rt = useThree(dt => dt.gl)
      , st = useThree(dt => dt.events)
      , lt = useThree(dt => dt.setEvents)
      , ct = useThree(dt => dt.set)
      , it = useThree(dt => dt.get)
      , ot = useThree(dt => dt.performance)
      , at = e || tt
      , ht = o || st.connected || rt.domElement
      , pt = reactExports.useMemo( () => new OrbitControls$1(at), [at]);
    return useFrame( () => {
        pt.enabled && pt.update()
    }
    , -1),
    reactExports.useEffect( () => (d && pt.connect(d === !0 ? ht : d),
    pt.connect(ht),
    () => void pt.dispose()), [d, ht, a, pt, nt]),
    reactExports.useEffect( () => {
        const dt = xt => {
            nt(),
            a && ot.regress(),
            g && g(xt)
        }
          , yt = xt => {
            _ && _(xt)
        }
          , vt = xt => {
            b && b(xt)
        }
        ;
        return pt.addEventListener("change", dt),
        pt.addEventListener("start", yt),
        pt.addEventListener("end", vt),
        () => {
            pt.removeEventListener("start", yt),
            pt.removeEventListener("end", vt),
            pt.removeEventListener("change", dt)
        }
    }
    , [g, _, b, pt, nt, lt]),
    reactExports.useEffect( () => {
        if (s) {
            const dt = it().controls;
            return ct({
                controls: pt
            }),
            () => ct({
                controls: dt
            })
        }
    }
    , [s, pt]),
    reactExports.createElement("primitive", _extends$2({
        ref: $,
        object: pt,
        enableDamping: c
    }, j))
}
)
  , opaque_fragment = version >= 154 ? "opaque_fragment" : "output_fragment";
class PointMaterialImpl extends PointsMaterial {
    constructor(e) {
        super(e),
        this.onBeforeCompile = (a, o) => {
            const {isWebGL2: c} = o.capabilities;
            a.fragmentShader = a.fragmentShader.replace(`#include <${opaque_fragment}>`, `
        ${c ? `#include <${opaque_fragment}>` : `#extension GL_OES_standard_derivatives : enable
#include <${opaque_fragment}>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <${version >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
      `)
        }
    }
}
const PointMaterial = reactExports.forwardRef( (s, e) => {
    const [a] = reactExports.useState( () => new PointMaterialImpl(null));
    return reactExports.createElement("primitive", _extends$2({}, s, {
        object: a,
        ref: e,
        attach: "material"
    }))
}
)
  , Float = reactExports.forwardRef( ({children: s, enabled: e=!0, speed: a=1, rotationIntensity: o=1, floatIntensity: c=1, floatingRange: d=[-.1, .1], autoInvalidate: g=!1, ..._}, b) => {
    const j = reactExports.useRef(null);
    reactExports.useImperativeHandle(b, () => j.current, []);
    const $ = reactExports.useRef(Math.random() * 1e4);
    return useFrame(nt => {
        var tt, rt;
        if (!e || a === 0)
            return;
        g && nt.invalidate();
        const st = $.current + nt.clock.getElapsedTime();
        j.current.rotation.x = Math.cos(st / 4 * a) / 8 * o,
        j.current.rotation.y = Math.sin(st / 4 * a) / 8 * o,
        j.current.rotation.z = Math.sin(st / 4 * a) / 20 * o;
        let lt = Math.sin(st / 4 * a) / 10;
        lt = MathUtils.mapLinear(lt, -.1, .1, (tt = d == null ? void 0 : d[0]) !== null && tt !== void 0 ? tt : -.1, (rt = d == null ? void 0 : d[1]) !== null && rt !== void 0 ? rt : .1),
        j.current.position.y = lt * c,
        j.current.updateMatrix()
    }
    ),
    reactExports.createElement("group", _, reactExports.createElement("group", {
        ref: j,
        matrixAutoUpdate: !1
    }, s))
}
);
let i, positionRef;
const context = reactExports.createContext(null)
  , parentMatrix = new Matrix4
  , position = new Vector3
  , PointsInstances = reactExports.forwardRef( ({children: s, range: e, limit: a=1e3, ...o}, c) => {
    const d = reactExports.useRef(null);
    reactExports.useImperativeHandle(c, () => d.current, []);
    const [g,_] = reactExports.useState([])
      , [[b,j,$]] = reactExports.useState( () => [new Float32Array(a * 3), Float32Array.from({
        length: a * 3
    }, () => 1), Float32Array.from({
        length: a
    }, () => 1)]);
    reactExports.useEffect( () => {
        d.current.geometry.attributes.position.needsUpdate = !0
    }
    ),
    useFrame( () => {
        for (d.current.updateMatrix(),
        d.current.updateMatrixWorld(),
        parentMatrix.copy(d.current.matrixWorld).invert(),
        d.current.geometry.drawRange.count = Math.min(a, e !== void 0 ? e : a, g.length),
        i = 0; i < g.length; i++)
            positionRef = g[i].current,
            positionRef.getWorldPosition(position).applyMatrix4(parentMatrix),
            position.toArray(b, i * 3),
            d.current.geometry.attributes.position.needsUpdate = !0,
            positionRef.matrixWorldNeedsUpdate = !0,
            positionRef.color.toArray(j, i * 3),
            d.current.geometry.attributes.color.needsUpdate = !0,
            $.set([positionRef.size], i),
            d.current.geometry.attributes.size.needsUpdate = !0
    }
    );
    const nt = reactExports.useMemo( () => ({
        getParent: () => d,
        subscribe: tt => (_(rt => [...rt, tt]),
        () => _(rt => rt.filter(st => st.current !== tt.current)))
    }), []);
    return reactExports.createElement("points", _extends$2({
        userData: {
            instances: g
        },
        matrixAutoUpdate: !1,
        ref: d,
        raycast: () => null
    }, o), reactExports.createElement("bufferGeometry", null, reactExports.createElement("bufferAttribute", {
        attach: "attributes-position",
        count: b.length / 3,
        array: b,
        itemSize: 3,
        usage: DynamicDrawUsage
    }), reactExports.createElement("bufferAttribute", {
        attach: "attributes-color",
        count: j.length / 3,
        array: j,
        itemSize: 3,
        usage: DynamicDrawUsage
    }), reactExports.createElement("bufferAttribute", {
        attach: "attributes-size",
        count: $.length,
        array: $,
        itemSize: 1,
        usage: DynamicDrawUsage
    })), reactExports.createElement(context.Provider, {
        value: nt
    }, s))
}
)
  , PointsBuffer = reactExports.forwardRef( ({children: s, positions: e, colors: a, sizes: o, stride: c=3, ...d}, g) => {
    const _ = reactExports.useRef(null);
    return reactExports.useImperativeHandle(g, () => _.current, []),
    useFrame( () => {
        const b = _.current.geometry.attributes;
        b.position.needsUpdate = !0,
        a && (b.color.needsUpdate = !0),
        o && (b.size.needsUpdate = !0)
    }
    ),
    reactExports.createElement("points", _extends$2({
        ref: _
    }, d), reactExports.createElement("bufferGeometry", null, reactExports.createElement("bufferAttribute", {
        attach: "attributes-position",
        count: e.length / c,
        array: e,
        itemSize: c,
        usage: DynamicDrawUsage
    }), a && reactExports.createElement("bufferAttribute", {
        attach: "attributes-color",
        count: a.length / c,
        array: a,
        itemSize: 3,
        usage: DynamicDrawUsage
    }), o && reactExports.createElement("bufferAttribute", {
        attach: "attributes-size",
        count: o.length / c,
        array: o,
        itemSize: 1,
        usage: DynamicDrawUsage
    })), s)
}
)
  , Points = reactExports.forwardRef( (s, e) => s.positions instanceof Float32Array ? reactExports.createElement(PointsBuffer, _extends$2({}, s, {
    ref: e
})) : reactExports.createElement(PointsInstances, _extends$2({}, s, {
    ref: e
})));
function Preload({all: s, scene: e, camera: a}) {
    const o = useThree( ({gl: g}) => g)
      , c = useThree( ({camera: g}) => g)
      , d = useThree( ({scene: g}) => g);
    return reactExports.useLayoutEffect( () => {
        const g = [];
        s && (e || d).traverse(j => {
            j.visible === !1 && (g.push(j),
            j.visible = !0)
        }
        ),
        o.compile(e || d, a || c);
        const _ = new WebGLCubeRenderTarget(128);
        new CubeCamera(.01,1e5,_).update(o, e || d),
        _.dispose(),
        g.forEach(j => j.visible = !1)
    }
    , []),
    null
}
const Loader = () => {
    const {progress: s} = useProgress();
    return jsxRuntimeExports.jsxs(Html, {
        as: "div",
        center: !0,
        style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column"
        },
        children: [jsxRuntimeExports.jsx("span", {
            className: "canvas-loader"
        }), jsxRuntimeExports.jsxs("p", {
            style: {
                fontSize: 14,
                color: "#F1F1F1",
                fontWeight: 800,
                marginTop: 40
            },
            children: [s.toFixed(2), "%"]
        })]
    })
}
  , Ball = s => {
    const [e] = useTexture([s.imgUrl]);
    return jsxRuntimeExports.jsxs(Float, {
        speed: 2.5,
        rotationIntensity: 1.5,
        floatIntensity: 2,
        children: [jsxRuntimeExports.jsx("ambientLight", {
            intensity: .25
        }), jsxRuntimeExports.jsx("directionalLight", {
            position: [0, 0, .05]
        }), jsxRuntimeExports.jsxs("mesh", {
            castShadow: !0,
            receiveShadow: !0,
            scale: 2.8,
            children: [jsxRuntimeExports.jsx("icosahedronGeometry", {
                args: [1, 2]
            }), jsxRuntimeExports.jsx("meshStandardMaterial", {
                color: "#12bcad",
                polygonOffset: !0,
                polygonOffsetFactor: -5,
                flatShading: !0
            }), jsxRuntimeExports.jsx(Decal, {
                position: [0, 0, 1],
                rotation: [2 * Math.PI, 0, 6.25],
                flatShading: !0,
                map: e
            })]
        })]
    })
}
  , Ball1Canvas = ({icon: s}) => jsxRuntimeExports.jsxs(Canvas, {
    frameloop: "always",
    gl: {
        preserveDrawingBuffer: !0
    },
    children: [jsxRuntimeExports.jsxs(reactExports.Suspense, {
        fallback: jsxRuntimeExports.jsx(Loader, {}),
        children: [jsxRuntimeExports.jsx(OrbitControls, {
            enableZoom: !1,
            position0: 0
        }), jsxRuntimeExports.jsx(Ball, {
            imgUrl: s
        })]
    }), jsxRuntimeExports.jsx(Preload, {
        all: !0
    })]
})
  , menu = "data:image/svg+xml,%3csvg%20width='20'%20height='12'%20viewBox='0%200%2020%2012'%20fill='%23FFF'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%202L19%202C19.2652%202%2019.5196%201.89464%2019.7071%201.70711C19.8946%201.51957%2020%201.26522%2020%201C20%200.734784%2019.8946%200.480429%2019.7071%200.292892C19.5196%200.105356%2019.2652%200%2019%200L9%200C8.73478%200%208.48043%200.105356%208.29289%200.292892C8.10536%200.480429%208%200.734784%208%201C8%201.26522%208.10536%201.51957%208.29289%201.70711C8.48043%201.89464%208.73478%202%209%202ZM19%2010L1%2010C0.734784%2010%200.480429%2010.1054%200.292892%2010.2929C0.105356%2010.4804%200%2010.7348%200%2011C0%2011.2652%200.105356%2011.5196%200.292892%2011.7071C0.480429%2011.8946%200.734784%2012%201%2012L19%2012C19.2652%2012%2019.5196%2011.8946%2019.7071%2011.7071C19.8946%2011.5196%2020%2011.2652%2020%2011C20%2010.7348%2019.8946%2010.4804%2019.7071%2010.2929C19.5196%2010.1054%2019.2652%2010%2019%2010V10ZM1%207L19%207C19.2652%207%2019.5196%206.89464%2019.7071%206.70711C19.8946%206.51957%2020%206.26522%2020%206C20%205.73478%2019.8946%205.48043%2019.7071%205.29289C19.5196%205.10536%2019.2652%205%2019%205L1%205C0.734784%205%200.480429%205.10536%200.292892%205.29289C0.105356%205.48043%200%205.73478%200%206C0%206.26522%200.105356%206.51957%200.292892%206.70711C0.480429%206.89464%200.734784%207%201%207Z'%20fill='%23FFFFFF'/%3e%3c/svg%3e"
  , close = "data:image/svg+xml,%3csvg%20width='18'%20height='18'%20viewBox='0%200%2018%2018'%20fill='%23FFF'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M10.4099%209L16.7099%202.71C16.8982%202.5217%2017.004%202.2663%2017.004%202C17.004%201.7337%2016.8982%201.47831%2016.7099%201.29C16.5216%201.1017%2016.2662%200.995911%2015.9999%200.995911C15.7336%200.995911%2015.4782%201.1017%2015.2899%201.29L8.99994%207.59L2.70994%201.29C2.52164%201.1017%202.26624%200.995911%201.99994%200.995911C1.73364%200.995911%201.47824%201.1017%201.28994%201.29C1.10164%201.47831%200.995847%201.7337%200.995847%202C0.995847%202.2663%201.10164%202.5217%201.28994%202.71L7.58994%209L1.28994%2015.29C1.19621%2015.383%201.12182%2015.4936%201.07105%2015.6154C1.02028%2015.7373%200.994141%2015.868%200.994141%2016C0.994141%2016.132%201.02028%2016.2627%201.07105%2016.3846C1.12182%2016.5064%201.19621%2016.617%201.28994%2016.71C1.3829%2016.8037%201.4935%2016.8781%201.61536%2016.9289C1.73722%2016.9797%201.86793%2017.0058%201.99994%2017.0058C2.13195%2017.0058%202.26266%2016.9797%202.38452%2016.9289C2.50638%2016.8781%202.61698%2016.8037%202.70994%2016.71L8.99994%2010.41L15.2899%2016.71C15.3829%2016.8037%2015.4935%2016.8781%2015.6154%2016.9289C15.7372%2016.9797%2015.8679%2017.0058%2015.9999%2017.0058C16.132%2017.0058%2016.2627%2016.9797%2016.3845%2016.9289C16.5064%2016.8781%2016.617%2016.8037%2016.7099%2016.71C16.8037%2016.617%2016.8781%2016.5064%2016.9288%2016.3846C16.9796%2016.2627%2017.0057%2016.132%2017.0057%2016C17.0057%2015.868%2016.9796%2015.7373%2016.9288%2015.6154C16.8781%2015.4936%2016.8037%2015.383%2016.7099%2015.29L10.4099%209Z'%20fill='%23FFFFFF'/%3e%3c/svg%3e"
  , portfolio = "/assets/portfolio-30z9OfXC.png"
  , redportfolio = "/assets/sairedanon-p8n6M3Rr.png"
  , saket = "/assets/saket-sRVSFeMh.png"
  , qrcode = "/assets/Qr-code-ByjcgePM.png"
  , ether = "/assets/ether-BVVkNAj5.png"
  , earth = "/assets/earthproject-GCGU5RYS.png"
  , stmary = "/assets/sms-logo-Ciop3e6Y.png"
  , bash = "/assets/bash-DNxVsG4g.png"
  , solar = "/assets/solar_iot-bhiTuu71.png"
  , linked = "/assets/linkedin-BSx0SxhA.png"
  , loading1 = "/assets/loadinglogo1-XxtLheYO.png"
  , sailogo = "/assets/Sai-Logo-anlEfULE.png"
  , profilePic = "/assets/profile-pic-PHj7h52r.jpg";
var DefaultContext = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , IconContext = React.createContext && React.createContext(DefaultContext)
  , _excluded = ["attr", "size", "title"];
function _objectWithoutProperties(s, e) {
    if (s == null)
        return {};
    var a = _objectWithoutPropertiesLoose$1(s, e), o, c;
    if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(s);
        for (c = 0; c < d.length; c++)
            o = d[c],
            !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(s, o) && (a[o] = s[o])
    }
    return a
}
function _objectWithoutPropertiesLoose$1(s, e) {
    if (s == null)
        return {};
    var a = {};
    for (var o in s)
        if (Object.prototype.hasOwnProperty.call(s, o)) {
            if (e.indexOf(o) >= 0)
                continue;
            a[o] = s[o]
        }
    return a
}
function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(s) {
        for (var e = 1; e < arguments.length; e++) {
            var a = arguments[e];
            for (var o in a)
                Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o])
        }
        return s
    }
    ,
    _extends$1.apply(this, arguments)
}
function ownKeys(s, e) {
    var a = Object.keys(s);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(s);
        e && (o = o.filter(function(c) {
            return Object.getOwnPropertyDescriptor(s, c).enumerable
        })),
        a.push.apply(a, o)
    }
    return a
}
function _objectSpread(s) {
    for (var e = 1; e < arguments.length; e++) {
        var a = arguments[e] != null ? arguments[e] : {};
        e % 2 ? ownKeys(Object(a), !0).forEach(function(o) {
            _defineProperty(s, o, a[o])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(a)) : ownKeys(Object(a)).forEach(function(o) {
            Object.defineProperty(s, o, Object.getOwnPropertyDescriptor(a, o))
        })
    }
    return s
}
function _defineProperty(s, e, a) {
    return e = _toPropertyKey(e),
    e in s ? Object.defineProperty(s, e, {
        value: a,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : s[e] = a,
    s
}
function _toPropertyKey(s) {
    var e = _toPrimitive(s, "string");
    return typeof e == "symbol" ? e : e + ""
}
function _toPrimitive(s, e) {
    if (typeof s != "object" || !s)
        return s;
    var a = s[Symbol.toPrimitive];
    if (a !== void 0) {
        var o = a.call(s, e || "default");
        if (typeof o != "object")
            return o;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(s)
}
function Tree2Element(s) {
    return s && s.map( (e, a) => React.createElement(e.tag, _objectSpread({
        key: a
    }, e.attr), Tree2Element(e.child)))
}
function GenIcon(s) {
    return e => React.createElement(IconBase, _extends$1({
        attr: _objectSpread({}, s.attr)
    }, e), Tree2Element(s.child))
}
function IconBase(s) {
    var e = a => {
        var {attr: o, size: c, title: d} = s, g = _objectWithoutProperties(s, _excluded), _ = c || a.size || "1em", b;
        return a.className && (b = a.className),
        s.className && (b = (b ? b + " " : "") + s.className),
        React.createElement("svg", _extends$1({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, a.attr, o, g, {
            className: b,
            style: _objectSpread(_objectSpread({
                color: s.color || a.color
            }, a.style), s.style),
            height: _,
            width: _,
            xmlns: "http://www.w3.org/2000/svg"
        }), d && React.createElement("title", null, d), s.children)
    }
    ;
    return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, a => e(a)) : e(DefaultContext)
}
function AiFillGithub(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 1024 1024"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"
            },
            child: []
        }]
    })(s)
}
function AiFillHtml5(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 1024 1024"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M145.2 96l66 746.6L512 928l299.6-85.4L878.9 96H145.2zm595 177.1l-4.8 47.2-1.7 19.5H382.3l8.2 94.2h335.1l-3.3 24.3-21.2 242.2-1.7 16.2-187 51.6v.3h-1.2l-.3.1v-.1h-.1l-188.6-52L310.8 572h91.1l6.5 73.2 102.4 27.7h.4l102-27.6 11.4-118.6H510.9v-.1H306l-22.8-253.5-1.7-24.3h460.3l-1.6 24.3z"
            },
            child: []
        }]
    })(s)
}
function AiFillInstagram(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 1024 1024"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M512 378.7c-73.4 0-133.3 59.9-133.3 133.3S438.6 645.3 512 645.3 645.3 585.4 645.3 512 585.4 378.7 512 378.7zM911.8 512c0-55.2.5-109.9-2.6-165-3.1-64-17.7-120.8-64.5-167.6-46.9-46.9-103.6-61.4-167.6-64.5-55.2-3.1-109.9-2.6-165-2.6-55.2 0-109.9-.5-165 2.6-64 3.1-120.8 17.7-167.6 64.5C132.6 226.3 118.1 283 115 347c-3.1 55.2-2.6 109.9-2.6 165s-.5 109.9 2.6 165c3.1 64 17.7 120.8 64.5 167.6 46.9 46.9 103.6 61.4 167.6 64.5 55.2 3.1 109.9 2.6 165 2.6 55.2 0 109.9.5 165-2.6 64-3.1 120.8-17.7 167.6-64.5 46.9-46.9 61.4-103.6 64.5-167.6 3.2-55.1 2.6-109.8 2.6-165zM512 717.1c-113.5 0-205.1-91.6-205.1-205.1S398.5 306.9 512 306.9 717.1 398.5 717.1 512 625.5 717.1 512 717.1zm213.5-370.7c-26.5 0-47.9-21.4-47.9-47.9s21.4-47.9 47.9-47.9 47.9 21.4 47.9 47.9a47.84 47.84 0 0 1-47.9 47.9z"
            },
            child: []
        }]
    })(s)
}
function AiFillLinkedin(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 1024 1024"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"
            },
            child: []
        }]
    })(s)
}
function AiFillMail(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 1024 1024"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 0 1 194 256h648.8a7.2 7.2 0 0 1 4.4 12.9z"
            },
            child: []
        }]
    })(s)
}
function SiAnsible(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M10.617 11.473l4.686 3.695-3.102-7.662zM12 0C5.371 0 0 5.371 0 12s5.371 12 12 12 12-5.371 12-12S18.629 0 12 0zm5.797 17.305c-.011.471-.403.842-.875.83-.236 0-.416-.09-.664-.293l-6.19-5-2.079 5.203H6.191L11.438 5.44c.124-.314.427-.52.764-.506.326-.014.63.189.742.506l4.774 11.494c.045.111.08.234.08.348-.001.009-.001.009-.001.023z"
            },
            child: []
        }]
    })(s)
}
function SiArduino(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M18.087 6.146c-.3 0-.607.017-.907.069-2.532.367-4.23 2.239-5.18 3.674-.95-1.435-2.648-3.307-5.18-3.674a6.49 6.49 0 0 0-.907-.069C2.648 6.146 0 8.77 0 12s2.656 5.854 5.913 5.854c.3 0 .607-.017.916-.069 2.531-.376 4.23-2.247 5.18-3.683.949 1.436 2.647 3.307 5.18 3.683.299.043.607.069.915.069C21.344 17.854 24 15.23 24 12s-2.656-5.854-5.913-5.854zM6.53 15.734a3.837 3.837 0 0 1-.625.043c-2.148 0-3.889-1.7-3.889-3.777 0-2.085 1.749-3.777 3.898-3.777.208 0 .416.017.624.043 2.39.35 3.847 2.768 4.347 3.734-.508.974-1.974 3.384-4.355 3.734zm11.558.043c-.208 0-.416-.017-.624-.043-2.39-.35-3.856-2.768-4.347-3.734.491-.966 1.957-3.384 4.347-3.734.208-.026.416-.043.624-.043 2.149 0 3.89 1.7 3.89 3.777 0 2.085-1.75 3.777-3.89 3.777zm1.65-4.404v1.134h-1.205v1.182h-1.156v-1.182H16.17v-1.134h1.206V10.19h1.156v1.183h1.206zM4.246 12.498H7.82v-1.125H4.245v1.125z"
            },
            child: []
        }]
    })(s)
}
function SiCplusplus(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M22.394 6c-.167-.29-.398-.543-.652-.69L12.926.22c-.509-.294-1.34-.294-1.848 0L2.26 5.31c-.508.293-.923 1.013-.923 1.6v10.18c0 .294.104.62.271.91.167.29.398.543.652.69l8.816 5.09c.508.293 1.34.293 1.848 0l8.816-5.09c.254-.147.485-.4.652-.69.167-.29.27-.616.27-.91V6.91c.003-.294-.1-.62-.268-.91zM12 19.11c-3.92 0-7.109-3.19-7.109-7.11 0-3.92 3.19-7.11 7.11-7.11a7.133 7.133 0 016.156 3.553l-3.076 1.78a3.567 3.567 0 00-3.08-1.78A3.56 3.56 0 008.444 12 3.56 3.56 0 0012 15.555a3.57 3.57 0 003.08-1.778l3.078 1.78A7.135 7.135 0 0112 19.11zm7.11-6.715h-.79v.79h-.79v-.79h-.79v-.79h.79v-.79h.79v.79h.79zm2.962 0h-.79v.79h-.79v-.79h-.79v-.79h.79v-.79h.79v.79h.79z"
            },
            child: []
        }]
    })(s)
}
function SiCss3(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438L1.5 0zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53L18.59 4.414z"
            },
            child: []
        }]
    })(s)
}
function SiDocker(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M13.983 11.078h2.119a.186.186 0 00.186-.185V9.006a.186.186 0 00-.186-.186h-2.119a.185.185 0 00-.185.185v1.888c0 .102.083.185.185.185m-2.954-5.43h2.118a.186.186 0 00.186-.186V3.574a.186.186 0 00-.186-.185h-2.118a.185.185 0 00-.185.185v1.888c0 .102.082.185.185.185m0 2.716h2.118a.187.187 0 00.186-.186V6.29a.186.186 0 00-.186-.185h-2.118a.185.185 0 00-.185.185v1.887c0 .102.082.185.185.186m-2.93 0h2.12a.186.186 0 00.184-.186V6.29a.185.185 0 00-.185-.185H8.1a.185.185 0 00-.185.185v1.887c0 .102.083.185.185.186m-2.964 0h2.119a.186.186 0 00.185-.186V6.29a.185.185 0 00-.185-.185H5.136a.186.186 0 00-.186.185v1.887c0 .102.084.185.186.186m5.893 2.715h2.118a.186.186 0 00.186-.185V9.006a.186.186 0 00-.186-.186h-2.118a.185.185 0 00-.185.185v1.888c0 .102.082.185.185.185m-2.93 0h2.12a.185.185 0 00.184-.185V9.006a.185.185 0 00-.184-.186h-2.12a.185.185 0 00-.184.185v1.888c0 .102.083.185.185.185m-2.964 0h2.119a.185.185 0 00.185-.185V9.006a.185.185 0 00-.184-.186h-2.12a.186.186 0 00-.186.186v1.887c0 .102.084.185.186.185m-2.92 0h2.12a.185.185 0 00.184-.185V9.006a.185.185 0 00-.184-.186h-2.12a.185.185 0 00-.184.185v1.888c0 .102.082.185.185.185M23.763 9.89c-.065-.051-.672-.51-1.954-.51-.338.001-.676.03-1.01.087-.248-1.7-1.653-2.53-1.716-2.566l-.344-.199-.226.327c-.284.438-.49.922-.612 1.43-.23.97-.09 1.882.403 2.661-.595.332-1.55.413-1.744.42H.751a.751.751 0 00-.75.748 11.376 11.376 0 00.692 4.062c.545 1.428 1.355 2.48 2.41 3.124 1.18.723 3.1 1.137 5.275 1.137.983.003 1.963-.086 2.93-.266a12.248 12.248 0 003.823-1.389c.98-.567 1.86-1.288 2.61-2.136 1.252-1.418 1.998-2.997 2.553-4.4h.221c1.372 0 2.215-.549 2.68-1.009.309-.293.55-.65.707-1.046l.098-.288Z"
            },
            child: []
        }]
    })(s)
}
function SiGit(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M23.546 10.93L13.067.452c-.604-.603-1.582-.603-2.188 0L8.708 2.627l2.76 2.76c.645-.215 1.379-.07 1.889.441.516.515.658 1.258.438 1.9l2.658 2.66c.645-.223 1.387-.078 1.9.435.721.72.721 1.884 0 2.604-.719.719-1.881.719-2.6 0-.539-.541-.674-1.337-.404-1.996L12.86 8.955v6.525c.176.086.342.203.488.348.713.721.713 1.883 0 2.6-.719.721-1.889.721-2.609 0-.719-.719-.719-1.879 0-2.598.182-.18.387-.316.605-.406V8.835c-.217-.091-.424-.222-.6-.401-.545-.545-.676-1.342-.396-2.009L7.636 3.7.45 10.881c-.6.605-.6 1.584 0 2.189l10.48 10.477c.604.604 1.582.604 2.186 0l10.43-10.43c.605-.603.605-1.582 0-2.187"
            },
            child: []
        }]
    })(s)
}
function SiGnubash(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M21.038,4.9l-7.577-4.498C13.009,0.134,12.505,0,12,0c-0.505,0-1.009,0.134-1.462,0.403L2.961,4.9 C2.057,5.437,1.5,6.429,1.5,7.503v8.995c0,1.073,0.557,2.066,1.462,2.603l7.577,4.497C10.991,23.866,11.495,24,12,24 c0.505,0,1.009-0.134,1.461-0.402l7.577-4.497c0.904-0.537,1.462-1.529,1.462-2.603V7.503C22.5,6.429,21.943,5.437,21.038,4.9z M15.17,18.946l0.013,0.646c0.001,0.078-0.05,0.167-0.111,0.198l-0.383,0.22c-0.061,0.031-0.111-0.007-0.112-0.085L14.57,19.29 c-0.328,0.136-0.66,0.169-0.872,0.084c-0.04-0.016-0.057-0.075-0.041-0.142l0.139-0.584c0.011-0.046,0.036-0.092,0.069-0.121 c0.012-0.011,0.024-0.02,0.036-0.026c0.022-0.011,0.043-0.014,0.062-0.006c0.229,0.077,0.521,0.041,0.802-0.101 c0.357-0.181,0.596-0.545,0.592-0.907c-0.003-0.328-0.181-0.465-0.613-0.468c-0.55,0.001-1.064-0.107-1.072-0.917 c-0.007-0.667,0.34-1.361,0.889-1.8l-0.007-0.652c-0.001-0.08,0.048-0.168,0.111-0.2l0.37-0.236 c0.061-0.031,0.111,0.007,0.112,0.087l0.006,0.653c0.273-0.109,0.511-0.138,0.726-0.088c0.047,0.012,0.067,0.076,0.048,0.151 l-0.144,0.578c-0.011,0.044-0.036,0.088-0.065,0.116c-0.012,0.012-0.025,0.021-0.038,0.028c-0.019,0.01-0.038,0.013-0.057,0.009 c-0.098-0.022-0.332-0.073-0.699,0.113c-0.385,0.195-0.52,0.53-0.517,0.778c0.003,0.297,0.155,0.387,0.681,0.396 c0.7,0.012,1.003,0.318,1.01,1.023C16.105,17.747,15.736,18.491,15.17,18.946z M19.143,17.859c0,0.06-0.008,0.116-0.058,0.145 l-1.916,1.164c-0.05,0.029-0.09,0.004-0.09-0.056v-0.494c0-0.06,0.037-0.093,0.087-0.122l1.887-1.129 c0.05-0.029,0.09-0.004,0.09,0.056V17.859z M20.459,6.797l-7.168,4.427c-0.894,0.523-1.553,1.109-1.553,2.187v8.833 c0,0.645,0.26,1.063,0.66,1.184c-0.131,0.023-0.264,0.039-0.398,0.039c-0.42,0-0.833-0.114-1.197-0.33L3.226,18.64 c-0.741-0.44-1.201-1.261-1.201-2.142V7.503c0-0.881,0.46-1.702,1.201-2.142l7.577-4.498c0.363-0.216,0.777-0.33,1.197-0.33 c0.419,0,0.833,0.114,1.197,0.33l7.577,4.498c0.624,0.371,1.046,1.013,1.164,1.732C21.686,6.557,21.12,6.411,20.459,6.797z"
            },
            child: []
        }]
    })(s)
}
function SiJavascript(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z"
            },
            child: []
        }]
    })(s)
}
function SiJenkins(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M2.872 24h-.975a3.866 3.866 0 01-.07-.197c-.215-.666-.594-1.49-.692-2.154-.146-.984.78-1.039 1.374-1.465.915-.66 1.635-1.025 2.627-1.62.295-.179 1.182-.624 1.281-.829.201-.408-.345-.982-.49-1.3-.225-.507-.345-.937-.376-1.435-.824-.13-1.455-.627-1.844-1.185-.63-.925-1.066-2.635-.525-3.936.045-.103.254-.305.285-.463.06-.308-.105-.72-.12-1.048-.06-1.692.284-3.15 1.425-3.66.463-1.84 2.113-2.453 3.673-3.367.58-.342 1.224-.562 1.89-.807 2.372-.877 6.027-.712 7.994.783.836.633 2.176 1.97 2.656 2.939 1.262 2.555 1.17 6.825.287 9.934-.12.421-.29 1.032-.533 1.533-.168.35-.689 1.05-.625 1.36.064.314 1.19 1.17 1.432 1.395.434.422 1.26.975 1.324 1.5.07.557-.248 1.336-.41 1.875-.217.721-.436 1.441-.654 2.131H2.87zm11.104-3.54c-.545-.3-1.361-.622-2.065-.757-.87-.164-.78 1.188-.75 1.994.03.643.36 1.316.51 1.744.076.197.09.41.256.449.3.068 1.29-.326 1.575-.479.6-.328 1.064-.844 1.574-1.189.016-.17.016-.34.03-.508a2.648 2.648 0 00-1.095-.277c.314-.15.75-.15 1.035-.332l.016-.193c-.496-.03-.69-.254-1.021-.436zm7.454 2.935a17.78 17.78 0 00.465-1.752c.06-.287.215-.918.178-1.176-.059-.459-.684-.799-1.004-1.086-.584-.525-.95-.975-1.56-1.469-.249.375-.78.615-.983.914 1.447-.689 1.71 2.625 1.141 3.69.09.329.391.45.514.735l-.086.166h1.29c.013 0 .03 0 .044.014zm-6.634-.012c-.05-.074-.1-.135-.15-.209l-.301.195h.45zm2.77 0c.008-.209.018-.404.03-.598-.53.029-.825-.48-1.196-.527-.324-.045-.6.361-1.02.195-.095.105-.183.227-.284.316.154.18.295.375.424.584h.815c.014-.164.135-.285.3-.285.165 0 .284.121.284.27h.66zm2.116 0c-.314-.479-.947-.898-1.68-.555l-.03.541h1.71zm-8.51 0l-.104-.344c-.225-.72-.36-1.26-.405-1.68-.914-.436-1.875-.87-2.654-1.426-.15-.105-1.109-1.35-1.23-1.305-1.739.676-3.359 1.86-4.814 2.984.256.557.48 1.141.69 1.74h8.505zm8.265-2.113c-.029-.512-.164-1.56-.48-1.74-.66-.39-1.846.78-2.34.943.045.15.135.271.15.48.285-.074.645-.029.898.092-.299.03-.629.03-.824.164-.074.195.016.48-.029.764.69.197 1.5.303 2.385.332.164-.227.225-.645.211-1.082zm-4.08-.36c-.044.375.046.51.12.943 1.26.391 1.034-1.74-.135-.959zM8.76 19.5c-.45.457 1.27 1.082 1.814 1.115 0-.29.165-.564.135-.77-.65-.118-1.502-.042-1.945-.347zm5.565.215c0 .043-.061.03-.068.064.58.451 1.014.545 1.802.51.354-.262.67-.563 1.043-.807-.855.074-1.931.607-2.774.23zm3.42-17.726c-1.606-.906-4.35-1.591-6.076-.731-1.38.692-3.27 1.84-3.899 3.292.6 1.402-.166 2.686-.226 4.109-.018.757.36 1.42.391 2.242-.2.338-.825.38-1.26.356-.146-.729-.4-1.549-1.155-1.63-1.064-.116-1.845.764-1.89 1.683-.06 1.08.833 2.864 2.085 2.745.488-.046.608-.54 1.139-.54.285.57-.445.75-.523 1.154-.016.105.06.511.104.705.233.944.744 2.16 1.245 2.88.635.9 1.884 1.051 3.229 1.141.24-.525 1.125-.48 1.706-.346-.691-.27-1.336-.945-1.875-1.529-.615-.676-1.23-1.41-1.261-2.28 1.155 1.604 2.1 3 4.2 3.704 1.59.525 3.45-.254 4.664-1.109.51-.359.811-.93 1.17-1.439 1.35-1.936 1.98-4.71 1.846-7.394-.06-1.111-.06-2.221-.436-2.955-.389-.781-1.695-1.471-2.475-.781-.15-.764.63-1.23 1.545-.96-.66-.854-1.336-1.858-2.266-2.384zM13.58 14.896c.615 1.544 2.724 1.363 4.505 1.323-.084.194-.256.435-.465.515-.57.232-2.145.408-2.937-.012-.506-.27-.824-.873-1.102-1.227-.137-.172-.795-.608-.012-.609zm.164-.87c.893.464 2.52.517 3.731.48.066.267.066.593.068.913-1.55.08-3.386-.304-3.794-1.395h-.005zm6.675-.586c-.473.9-1.145 1.897-2.539 1.928-.023-.284-.045-.735 0-.904 1.064-.103 1.727-.646 2.543-1.017zm-.649-.667c-1.02.66-2.154 1.375-3.824 1.21-.351-.31-.485-1-.14-1.458.181.313.06.885.57.97.944.165 2.038-.579 2.73-.84.42-.713-.046-.976-.42-1.433-.782-.93-1.83-2.1-1.802-3.51.314-.224.346.346.391.45.404.96 1.424 2.175 2.174 3 .18.21.48.39.51.524.092.39-.254.854-.209 1.11zm-13.439-.675c-.314-.184-.393-.99-.768-1.01-.535-.03-.438 1.05-.436 1.68-.37-.33-.435-1.365-.164-1.89-.308-.15-.445.164-.618.284.22-1.59 2.34-.734 1.99.96zM4.713 5.995c-.685.756-.54 2.174-.459 3.188 1.244-.785 2.898.06 2.883 1.394.595-.016.223-.744.115-1.215-.353-1.528.592-3.187.041-4.59-1.064.084-1.939.52-2.578 1.215zm9.12 1.113c.307.562.404 1.148.84 1.57.195.19.574.424.387.95-.045.121-.365.391-.551.45-.674.195-2.254.03-1.721-.81.563.015 1.314.36 1.732-.045-.314-.524-.885-1.53-.674-2.13zm6.198-.013h.068c.33.668.6 1.375 1.004 1.965-.27.628-2.053 1.19-2.023.057.39-.17 1.05-.035 1.395-.25-.193-.556-.48-1.006-.434-1.771zm-6.927-1.617c-1.422-.33-2.131.592-2.56 1.553-.384-.094-.231-.615-.135-.883.255-.701 1.28-1.633 2.119-1.506.359.057.848.386.576.834zM9.642 1.593c-1.56.44-3.56 1.574-4.2 2.974.495-.07.84-.321 1.33-.351.186-.016.428.074.641.015.424-.104.78-1.065 1.102-1.41.31-.345.685-.496.94-.81.167-.09.409-.074.42-.33-.073-.075-.15-.135-.232-.105v.017z"
            },
            child: []
        }]
    })(s)
}
function SiKubernetes(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M10.204 14.35l.007.01-.999 2.413a5.171 5.171 0 0 1-2.075-2.597l2.578-.437.004.005a.44.44 0 0 1 .484.606zm-.833-2.129a.44.44 0 0 0 .173-.756l.002-.011L7.585 9.7a5.143 5.143 0 0 0-.73 3.255l2.514-.725.002-.009zm1.145-1.98a.44.44 0 0 0 .699-.337l.01-.005.15-2.62a5.144 5.144 0 0 0-3.01 1.442l2.147 1.523.004-.002zm.76 2.75l.723.349.722-.347.18-.78-.5-.623h-.804l-.5.623.179.779zm1.5-3.095a.44.44 0 0 0 .7.336l.008.003 2.134-1.513a5.188 5.188 0 0 0-2.992-1.442l.148 2.615.002.001zm10.876 5.97l-5.773 7.181a1.6 1.6 0 0 1-1.248.594l-9.261.003a1.6 1.6 0 0 1-1.247-.596l-5.776-7.18a1.583 1.583 0 0 1-.307-1.34L2.1 5.573c.108-.47.425-.864.863-1.073L11.305.513a1.606 1.606 0 0 1 1.385 0l8.345 3.985c.438.209.755.604.863 1.073l2.062 8.955c.108.47-.005.963-.308 1.34zm-3.289-2.057c-.042-.01-.103-.026-.145-.034-.174-.033-.315-.025-.479-.038-.35-.037-.638-.067-.895-.148-.105-.04-.18-.165-.216-.216l-.201-.059a6.45 6.45 0 0 0-.105-2.332 6.465 6.465 0 0 0-.936-2.163c.052-.047.15-.133.177-.159.008-.09.001-.183.094-.282.197-.185.444-.338.743-.522.142-.084.273-.137.415-.242.032-.024.076-.062.11-.089.24-.191.295-.52.123-.736-.172-.216-.506-.236-.745-.045-.034.027-.08.062-.111.088-.134.116-.217.23-.33.35-.246.25-.45.458-.673.609-.097.056-.239.037-.303.033l-.19.135a6.545 6.545 0 0 0-4.146-2.003l-.012-.223c-.065-.062-.143-.115-.163-.25-.022-.268.015-.557.057-.905.023-.163.061-.298.068-.475.001-.04-.001-.099-.001-.142 0-.306-.224-.555-.5-.555-.275 0-.499.249-.499.555l.001.014c0 .041-.002.092 0 .128.006.177.044.312.067.475.042.348.078.637.056.906a.545.545 0 0 1-.162.258l-.012.211a6.424 6.424 0 0 0-4.166 2.003 8.373 8.373 0 0 1-.18-.128c-.09.012-.18.04-.297-.029-.223-.15-.427-.358-.673-.608-.113-.12-.195-.234-.329-.349-.03-.026-.077-.062-.111-.088a.594.594 0 0 0-.348-.132.481.481 0 0 0-.398.176c-.172.216-.117.546.123.737l.007.005.104.083c.142.105.272.159.414.242.299.185.546.338.743.522.076.082.09.226.1.288l.16.143a6.462 6.462 0 0 0-1.02 4.506l-.208.06c-.055.072-.133.184-.215.217-.257.081-.546.11-.895.147-.164.014-.305.006-.48.039-.037.007-.09.02-.133.03l-.004.002-.007.002c-.295.071-.484.342-.423.608.061.267.349.429.645.365l.007-.001.01-.003.129-.029c.17-.046.294-.113.448-.172.33-.118.604-.217.87-.256.112-.009.23.069.288.101l.217-.037a6.5 6.5 0 0 0 2.88 3.596l-.09.218c.033.084.069.199.044.282-.097.252-.263.517-.452.813-.091.136-.185.242-.268.399-.02.037-.045.095-.064.134-.128.275-.034.591.213.71.248.12.556-.007.69-.282v-.002c.02-.039.046-.09.062-.127.07-.162.094-.301.144-.458.132-.332.205-.68.387-.897.05-.06.13-.082.215-.105l.113-.205a6.453 6.453 0 0 0 4.609.012l.106.192c.086.028.18.042.256.155.136.232.229.507.342.84.05.156.074.295.145.457.016.037.043.09.062.129.133.276.442.402.69.282.247-.118.341-.435.213-.71-.02-.039-.045-.096-.065-.134-.083-.156-.177-.261-.268-.398-.19-.296-.346-.541-.443-.793-.04-.13.007-.21.038-.294-.018-.022-.059-.144-.083-.202a6.499 6.499 0 0 0 2.88-3.622c.064.01.176.03.213.038.075-.05.144-.114.28-.104.266.039.54.138.87.256.154.06.277.128.448.173.036.01.088.019.13.028l.009.003.007.001c.297.064.584-.098.645-.365.06-.266-.128-.537-.423-.608zM16.4 9.701l-1.95 1.746v.005a.44.44 0 0 0 .173.757l.003.01 2.526.728a5.199 5.199 0 0 0-.108-1.674A5.208 5.208 0 0 0 16.4 9.7zm-4.013 5.325a.437.437 0 0 0-.404-.232.44.44 0 0 0-.372.233h-.002l-1.268 2.292a5.164 5.164 0 0 0 3.326.003l-1.27-2.296h-.01zm1.888-1.293a.44.44 0 0 0-.27.036.44.44 0 0 0-.214.572l-.003.004 1.01 2.438a5.15 5.15 0 0 0 2.081-2.615l-2.6-.44-.004.005z"
            },
            child: []
        }]
    })(s)
}
function SiLinux(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M12.504 0c-.155 0-.315.008-.48.021-4.226.333-3.105 4.807-3.17 6.298-.076 1.092-.3 1.953-1.05 3.02-.885 1.051-2.127 2.75-2.716 4.521-.278.832-.41 1.684-.287 2.489a.424.424 0 00-.11.135c-.26.268-.45.6-.663.839-.199.199-.485.267-.797.4-.313.136-.658.269-.864.68-.09.189-.136.394-.132.602 0 .199.027.4.055.536.058.399.116.728.04.97-.249.68-.28 1.145-.106 1.484.174.334.535.47.94.601.81.2 1.91.135 2.774.6.926.466 1.866.67 2.616.47.526-.116.97-.464 1.208-.946.587-.003 1.23-.269 2.26-.334.699-.058 1.574.267 2.577.2.025.134.063.198.114.333l.003.003c.391.778 1.113 1.132 1.884 1.071.771-.06 1.592-.536 2.257-1.306.631-.765 1.683-1.084 2.378-1.503.348-.199.629-.469.649-.853.023-.4-.2-.811-.714-1.376v-.097l-.003-.003c-.17-.2-.25-.535-.338-.926-.085-.401-.182-.786-.492-1.046h-.003c-.059-.054-.123-.067-.188-.135a.357.357 0 00-.19-.064c.431-1.278.264-2.55-.173-3.694-.533-1.41-1.465-2.638-2.175-3.483-.796-1.005-1.576-1.957-1.56-3.368.026-2.152.236-6.133-3.544-6.139zm.529 3.405h.013c.213 0 .396.062.584.198.19.135.33.332.438.533.105.259.158.459.166.724 0-.02.006-.04.006-.06v.105a.086.086 0 01-.004-.021l-.004-.024a1.807 1.807 0 01-.15.706.953.953 0 01-.213.335.71.71 0 00-.088-.042c-.104-.045-.198-.064-.284-.133a1.312 1.312 0 00-.22-.066c.05-.06.146-.133.183-.198.053-.128.082-.264.088-.402v-.02a1.21 1.21 0 00-.061-.4c-.045-.134-.101-.2-.183-.333-.084-.066-.167-.132-.267-.132h-.016c-.093 0-.176.03-.262.132a.8.8 0 00-.205.334 1.18 1.18 0 00-.09.4v.019c.002.089.008.179.02.267-.193-.067-.438-.135-.607-.202a1.635 1.635 0 01-.018-.2v-.02a1.772 1.772 0 01.15-.768c.082-.22.232-.406.43-.533a.985.985 0 01.594-.2zm-2.962.059h.036c.142 0 .27.048.399.135.146.129.264.288.344.465.09.199.14.4.153.667v.004c.007.134.006.2-.002.266v.08c-.03.007-.056.018-.083.024-.152.055-.274.135-.393.2.012-.09.013-.18.003-.267v-.015c-.012-.133-.04-.2-.082-.333a.613.613 0 00-.166-.267.248.248 0 00-.183-.064h-.021c-.071.006-.13.04-.186.132a.552.552 0 00-.12.27.944.944 0 00-.023.33v.015c.012.135.037.2.08.334.046.134.098.2.166.268.01.009.02.018.034.024-.07.057-.117.07-.176.136a.304.304 0 01-.131.068 2.62 2.62 0 01-.275-.402 1.772 1.772 0 01-.155-.667 1.759 1.759 0 01.08-.668 1.43 1.43 0 01.283-.535c.128-.133.26-.2.418-.2zm1.37 1.706c.332 0 .733.065 1.216.399.293.2.523.269 1.052.468h.003c.255.136.405.266.478.399v-.131a.571.571 0 01.016.47c-.123.31-.516.643-1.063.842v.002c-.268.135-.501.333-.775.465-.276.135-.588.292-1.012.267a1.139 1.139 0 01-.448-.067 3.566 3.566 0 01-.322-.198c-.195-.135-.363-.332-.612-.465v-.005h-.005c-.4-.246-.616-.512-.686-.71-.07-.268-.005-.47.193-.6.224-.135.38-.271.483-.336.104-.074.143-.102.176-.131h.002v-.003c.169-.202.436-.47.839-.601.139-.036.294-.065.466-.065zm2.8 2.142c.358 1.417 1.196 3.475 1.735 4.473.286.534.855 1.659 1.102 3.024.156-.005.33.018.513.064.646-1.671-.546-3.467-1.089-3.966-.22-.2-.232-.335-.123-.335.59.534 1.365 1.572 1.646 2.757.13.535.16 1.104.021 1.67.067.028.135.06.205.067 1.032.534 1.413.938 1.23 1.537v-.043c-.06-.003-.12 0-.18 0h-.016c.151-.467-.182-.825-1.065-1.224-.915-.4-1.646-.336-1.77.465-.008.043-.013.066-.018.135-.068.023-.139.053-.209.064-.43.268-.662.669-.793 1.187-.13.533-.17 1.156-.205 1.869v.003c-.02.334-.17.838-.319 1.35-1.5 1.072-3.58 1.538-5.348.334a2.645 2.645 0 00-.402-.533 1.45 1.45 0 00-.275-.333c.182 0 .338-.03.465-.067a.615.615 0 00.314-.334c.108-.267 0-.697-.345-1.163-.345-.467-.931-.995-1.788-1.521-.63-.4-.986-.87-1.15-1.396-.165-.534-.143-1.085-.015-1.645.245-1.07.873-2.11 1.274-2.763.107-.065.037.135-.408.974-.396.751-1.14 2.497-.122 3.854a8.123 8.123 0 01.647-2.876c.564-1.278 1.743-3.504 1.836-5.268.048.036.217.135.289.202.218.133.38.333.59.465.21.201.477.335.876.335.039.003.075.006.11.006.412 0 .73-.134.997-.268.29-.134.52-.334.74-.4h.005c.467-.135.835-.402 1.044-.7zm2.185 8.958c.037.6.343 1.245.882 1.377.588.134 1.434-.333 1.791-.765l.211-.01c.315-.007.577.01.847.268l.003.003c.208.199.305.53.391.876.085.4.154.78.409 1.066.486.527.645.906.636 1.14l.003-.007v.018l-.003-.012c-.015.262-.185.396-.498.595-.63.401-1.746.712-2.457 1.57-.618.737-1.37 1.14-2.036 1.191-.664.053-1.237-.2-1.574-.898l-.005-.003c-.21-.4-.12-1.025.056-1.69.176-.668.428-1.344.463-1.897.037-.714.076-1.335.195-1.814.12-.465.308-.797.641-.984l.045-.022zm-10.814.049h.01c.053 0 .105.005.157.014.376.055.706.333 1.023.752l.91 1.664.003.003c.243.533.754 1.064 1.189 1.637.434.598.77 1.131.729 1.57v.006c-.057.744-.48 1.148-1.125 1.294-.645.135-1.52.002-2.395-.464-.968-.536-2.118-.469-2.857-.602-.369-.066-.61-.2-.723-.4-.11-.2-.113-.602.123-1.23v-.004l.002-.003c.117-.334.03-.752-.027-1.118-.055-.401-.083-.71.043-.94.16-.334.396-.4.69-.533.294-.135.64-.202.915-.47h.002v-.002c.256-.268.445-.601.668-.838.19-.201.38-.336.663-.336zm7.159-9.074c-.435.201-.945.535-1.488.535-.542 0-.97-.267-1.28-.466-.154-.134-.28-.268-.373-.335-.164-.134-.144-.333-.074-.333.109.016.129.134.199.2.096.066.215.2.36.333.292.2.68.467 1.167.467.485 0 1.053-.267 1.398-.466.195-.135.445-.334.648-.467.156-.136.149-.267.279-.267.128.016.034.134-.147.332a8.097 8.097 0 01-.69.468zm-1.082-1.583V5.64c-.006-.02.013-.042.029-.05.074-.043.18-.027.26.004.063 0 .16.067.15.135-.006.049-.085.066-.135.066-.055 0-.092-.043-.141-.068-.052-.018-.146-.008-.163-.065zm-.551 0c-.02.058-.113.049-.166.066-.047.025-.086.068-.14.068-.05 0-.13-.02-.136-.068-.01-.066.088-.133.15-.133.08-.031.184-.047.259-.005.019.009.036.03.03.05v.02h.003z"
            },
            child: []
        }]
    })(s)
}
function SiMysql(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M16.405 5.501c-.115 0-.193.014-.274.033v.013h.014c.054.104.146.18.214.273.054.107.1.214.154.32l.014-.015c.094-.066.14-.172.14-.333-.04-.047-.046-.094-.08-.14-.04-.067-.126-.1-.18-.153zM5.77 18.695h-.927a50.854 50.854 0 00-.27-4.41h-.008l-1.41 4.41H2.45l-1.4-4.41h-.01a72.892 72.892 0 00-.195 4.41H0c.055-1.966.192-3.81.41-5.53h1.15l1.335 4.064h.008l1.347-4.064h1.095c.242 2.015.384 3.86.428 5.53zm4.017-4.08c-.378 2.045-.876 3.533-1.492 4.46-.482.716-1.01 1.073-1.583 1.073-.153 0-.34-.046-.566-.138v-.494c.11.017.24.026.386.026.268 0 .483-.075.647-.222.197-.18.295-.382.295-.605 0-.155-.077-.47-.23-.944L6.23 14.615h.91l.727 2.36c.164.536.233.91.205 1.123.4-1.064.678-2.227.835-3.483zm12.325 4.08h-2.63v-5.53h.885v4.85h1.745zm-3.32.135l-1.016-.5c.09-.076.177-.158.255-.25.433-.506.648-1.258.648-2.253 0-1.83-.718-2.746-2.155-2.746-.704 0-1.254.232-1.65.697-.43.508-.646 1.256-.646 2.245 0 .972.19 1.686.574 2.14.35.41.877.615 1.583.615.264 0 .506-.033.725-.098l1.325.772.36-.622zM15.5 17.588c-.225-.36-.337-.94-.337-1.736 0-1.393.424-2.09 1.27-2.09.443 0 .77.167.977.5.224.362.336.936.336 1.723 0 1.404-.424 2.108-1.27 2.108-.445 0-.77-.167-.978-.5zm-1.658-.425c0 .47-.172.856-.516 1.156-.344.3-.803.45-1.384.45-.543 0-1.064-.172-1.573-.515l.237-.476c.438.22.833.328 1.19.328.332 0 .593-.073.783-.22a.754.754 0 00.3-.615c0-.33-.23-.61-.648-.845-.388-.213-1.163-.657-1.163-.657-.422-.307-.632-.636-.632-1.177 0-.45.157-.81.47-1.085.315-.278.72-.415 1.22-.415.512 0 .98.136 1.4.41l-.213.476a2.726 2.726 0 00-1.064-.23c-.283 0-.502.068-.654.206a.685.685 0 00-.248.524c0 .328.234.61.666.85.393.215 1.187.67 1.187.67.433.305.648.63.648 1.168zm9.382-5.852c-.535-.014-.95.04-1.297.188-.1.04-.26.04-.274.167.055.053.063.14.11.214.08.134.218.313.346.407.14.11.28.216.427.31.26.16.555.255.81.416.145.094.293.213.44.313.073.05.12.14.214.172v-.02c-.046-.06-.06-.147-.105-.214-.067-.067-.134-.127-.2-.193a3.223 3.223 0 00-.695-.675c-.214-.146-.682-.35-.77-.595l-.013-.014c.146-.013.32-.066.46-.106.227-.06.435-.047.67-.106.106-.027.213-.06.32-.094v-.06c-.12-.12-.21-.283-.334-.395a8.867 8.867 0 00-1.104-.823c-.21-.134-.476-.22-.697-.334-.08-.04-.214-.06-.26-.127-.12-.146-.19-.34-.275-.514a17.69 17.69 0 01-.547-1.163c-.12-.262-.193-.523-.34-.763-.69-1.137-1.437-1.826-2.586-2.5-.247-.14-.543-.2-.856-.274-.167-.008-.334-.02-.5-.027-.11-.047-.216-.174-.31-.235-.38-.24-1.364-.76-1.644-.072-.18.434.267.862.422 1.082.115.153.26.328.34.5.047.116.06.235.107.356.106.294.207.622.347.897.073.14.153.287.247.413.054.073.146.107.167.227-.094.136-.1.334-.154.5-.24.757-.146 1.693.194 2.25.107.166.362.534.703.393.3-.12.234-.5.32-.835.02-.08.007-.133.048-.187v.015c.094.188.188.367.274.555.206.328.566.668.867.895.16.12.287.328.487.402v-.02h-.015c-.043-.058-.1-.086-.154-.133a3.445 3.445 0 01-.35-.4 8.76 8.76 0 01-.747-1.218c-.11-.21-.202-.436-.29-.643-.04-.08-.04-.2-.107-.24-.1.146-.247.273-.32.453-.127.288-.14.642-.188 1.01-.027.007-.014 0-.027.014-.214-.052-.287-.274-.367-.46-.2-.475-.233-1.238-.06-1.785.047-.14.247-.582.167-.716-.042-.127-.174-.2-.247-.303a2.478 2.478 0 01-.24-.427c-.16-.374-.24-.788-.414-1.162-.08-.173-.22-.354-.334-.513-.127-.18-.267-.307-.368-.52-.033-.073-.08-.194-.027-.274.014-.054.042-.075.094-.09.088-.072.335.022.422.062.247.1.455.194.662.334.094.066.195.193.315.226h.14c.214.047.455.014.655.073.355.114.675.28.962.46a5.953 5.953 0 012.085 2.286c.08.154.115.295.188.455.14.33.313.663.455.982.14.315.275.636.476.897.1.14.502.213.682.286.133.06.34.115.46.188.23.14.454.3.67.454.11.076.443.243.463.378z"
            },
            child: []
        }]
    })(s)
}
function SiNetlify(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M6.49 19.04h-.23L5.13 17.9v-.23l1.73-1.71h1.2l.15.15v1.2L6.5 19.04ZM5.13 6.31V6.1l1.13-1.13h.23L8.2 6.68v1.2l-.15.15h-1.2L5.13 6.31Zm9.96 9.09h-1.65l-.14-.13v-3.83c0-.68-.27-1.2-1.1-1.23-.42 0-.9 0-1.43.02l-.07.08v4.96l-.14.14H8.9l-.13-.14V8.73l.13-.14h3.7a2.6 2.6 0 0 1 2.61 2.6v4.08l-.13.14Zm-8.37-2.44H.14L0 12.82v-1.64l.14-.14h6.58l.14.14v1.64l-.14.14Zm17.14 0h-6.58l-.14-.14v-1.64l.14-.14h6.58l.14.14v1.64l-.14.14ZM11.05 6.55V1.64l.14-.14h1.65l.14.14v4.9l-.14.14h-1.65l-.14-.13Zm0 15.81v-4.9l.14-.14h1.65l.14.13v4.91l-.14.14h-1.65l-.14-.14Z"
            },
            child: []
        }]
    })(s)
}
function SiPython(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M14.25.18l.9.2.73.26.59.3.45.32.34.34.25.34.16.33.1.3.04.26.02.2-.01.13V8.5l-.05.63-.13.55-.21.46-.26.38-.3.31-.33.25-.35.19-.35.14-.33.1-.3.07-.26.04-.21.02H8.77l-.69.05-.59.14-.5.22-.41.27-.33.32-.27.35-.2.36-.15.37-.1.35-.07.32-.04.27-.02.21v3.06H3.17l-.21-.03-.28-.07-.32-.12-.35-.18-.36-.26-.36-.36-.35-.46-.32-.59-.28-.73-.21-.88-.14-1.05-.05-1.23.06-1.22.16-1.04.24-.87.32-.71.36-.57.4-.44.42-.33.42-.24.4-.16.36-.1.32-.05.24-.01h.16l.06.01h8.16v-.83H6.18l-.01-2.75-.02-.37.05-.34.11-.31.17-.28.25-.26.31-.23.38-.2.44-.18.51-.15.58-.12.64-.1.71-.06.77-.04.84-.02 1.27.05zm-6.3 1.98l-.23.33-.08.41.08.41.23.34.33.22.41.09.41-.09.33-.22.23-.34.08-.41-.08-.41-.23-.33-.33-.22-.41-.09-.41.09zm13.09 3.95l.28.06.32.12.35.18.36.27.36.35.35.47.32.59.28.73.21.88.14 1.04.05 1.23-.06 1.23-.16 1.04-.24.86-.32.71-.36.57-.4.45-.42.33-.42.24-.4.16-.36.09-.32.05-.24.02-.16-.01h-8.22v.82h5.84l.01 2.76.02.36-.05.34-.11.31-.17.29-.25.25-.31.24-.38.2-.44.17-.51.15-.58.13-.64.09-.71.07-.77.04-.84.01-1.27-.04-1.07-.14-.9-.2-.73-.25-.59-.3-.45-.33-.34-.34-.25-.34-.16-.33-.1-.3-.04-.25-.02-.2.01-.13v-5.34l.05-.64.13-.54.21-.46.26-.38.3-.32.33-.24.35-.2.35-.14.33-.1.3-.06.26-.04.21-.02.13-.01h5.84l.69-.05.59-.14.5-.21.41-.28.33-.32.27-.35.2-.36.15-.36.1-.35.07-.32.04-.28.02-.21V6.07h2.09l.14.01zm-6.47 14.25l-.23.33-.08.41.08.41.23.33.33.23.41.08.41-.08.33-.23.23-.33.08-.41-.08-.41-.23-.33-.33-.23-.41-.08-.41.08z"
            },
            child: []
        }]
    })(s)
}
function SiRaspberrypi(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "m19.8955 10.8961-.1726-.3028c.0068-2.1746-1.0022-3.061-2.1788-3.7348.356-.0938.7237-.1711.8245-.6182.6118-.1566.7397-.4398.8011-.7398.16-.1066.6955-.4061.6394-.9211.2998-.2069.4669-.4725.3819-.8487.3222-.3515.407-.6419.2702-.9096.3868-.4805.2152-.7295.05-.9817.2897-.5254.0341-1.0887-.7758-.9944-.3221-.4733-1.0244-.3659-1.133-.3637-.1215-.1519-.2819-.2821-.7755-.219-.3197-.2851-.6771-.2364-1.0458-.0964-.4378-.3403-.7275-.0675-1.0584.0356-.53-.1706-.6513.0631-.9117.1583-.5781-.1203-.7538.1416-1.0309.4182l-.3224-.0063c-.8719.5061-1.305 1.5366-1.4585 2.0664-.1536-.5299-.5858-1.5604-1.4575-2.0664l-.3223.0063C9.942.5014 9.7663.2394 9.1883.3597 8.9279.2646 8.807.0309 8.2766.2015c-.2172-.0677-.417-.2084-.6522-.2012l.0004.0002C7.5017.0041 7.369.049 7.2185.166c-.3688-.1401-.7262-.1887-1.0459.0964-.4936-.0631-.654.0671-.7756.219C5.2887.4791 4.5862.3717 4.264.845c-.8096-.0943-1.0655.4691-.7756.9944-.1653.2521-.3366.5013.05.9819-.1367.2677-.0519.5581.2703.9096-.085.3763.0822.6418.3819.8487-.0561.515.4795.8144.6394.9211.0614.3001.1894.5832.8011.7398.1008.4472.4685.5244.8245.6183-1.1766.6737-2.1856 1.56-2.1788 3.7348l-.1724.3028c-1.3491.8082-2.5629 3.4056-.6648 5.5167.124.6609.3319 1.1355.5171 1.6609.2769 2.117 2.0841 3.1082 2.5608 3.2255.6984.524 1.4423 1.0212 2.449 1.3696.949.964 1.977 1.3314 3.0107 1.3308.0152 0 .0306.0002.0457 0 1.0337.0006 2.0618-.3668 3.0107-1.3308 1.0067-.3483 1.7506-.8456 2.4491-1.3696.4766-.1173 2.2838-1.1085 2.5607-3.2255.1851-.5253.3931-1 .517-1.6609 1.8981-2.1113.6843-4.7089-.6649-5.517zm-1.0386-.3715c-.0704.8759-4.6354-3.0504-3.8472-3.1808 2.1391-.3558 3.9191.896 3.8472 3.1808zm-2.0155 4.3649c-1.1481.7409-2.8025.2626-3.6953-1.0681-.8928-1.3306-.6858-3.0101.4623-3.7509 1.1481-.7409 2.8025-.2627 3.6953 1.068.8927 1.3307.6858 3.0101-.4623 3.751zM13.6591 1.3721c.0396.1967.0843.321.1354.3577.2537-.272.4611-.5506.7878-.8123.0011.1537-.0776.3205.1169.4425.1752-.2356.4119-.4459.7263-.6244-.1514.2611-.026.3404.0554.4486.24-.2059.4681-.4144.9109-.5759-.121.1474-.2902.2914-.1108.4607.2473-.1544.496-.3086 1.0833-.4183-.1323.1475-.4059.295-.2401.4426.3104-.1186.6539-.2047 1.034-.2546-.182.1496-.3337.2963-.1846.4122.3323-.1022.7899-.2398 1.2372-.1212l-.2832.2849c-.0314.0382.6623.0297 1.1202.0364-.167.2321-.3375.4562-.437.8548.0454.0459.2723.0204.4862 0-.2194.4618-.6004.5783-.6893.776.134.1015.32.075.5232.006-.158.3254-.4892.5484-.7509.8123.0662.047.1818.075.4555.0425-.2418.257-.5339.492-.8802.7032.0614.0708.2722.0681.4678.0727-.3136.3069-.7173.466-1.0955.6668.1885.1288.3234.0988.4678.097-.2676.2198-.7225.3342-1.1448.4668.0803.1249.1607.1589.3324.194-.447.2473-1.0873.1343-1.2679.2607.0435.1243.1665.2053.3139.2728-.7197.0418-2.6879-.0262-3.0652-1.5156.7367-.8094 2.0813-1.7593 4.394-2.934-1.7994.6022-3.4229 1.405-4.7817 2.5096-1.5978-.7436-.4965-2.6197.283-3.3645zm-1.6126 5.3718c1.1329-.0123 2.5356.8325 2.53 1.6286-.005.7027-.9851 1.2715-2.5213 1.2607-1.5043-.0177-2.5172-.7148-2.5137-1.3957.003-.5603 1.2282-1.5263 2.505-1.4936zm-5.7646-.6006c.1717-.0351.252-.0692.3323-.194-.4223-.1327-.8772-.247-1.1448-.4668.1444.0018.2792.0318.4678-.097-.3783-.2008-.782-.3599-1.0956-.6668.1955-.0048.4064-.002.4677-.0728-.3462-.2113-.6383-.4463-.8801-.7033.2738.0325.3893.0045.4555-.0425-.2617-.264-.593-.487-.7509-.8123.2032.069.3892.0954.5232-.006-.089-.1977-.47-.3142-.6894-.776.214.0204.4409.0459.4863 0-.0994-.3985-.2698-.6226-.4369-.8547.4579-.0067 1.1516.0018 1.1202-.0364l-.2831-.2849c.4472-.1186.9049.019 1.2371.1213.1492-.1159-.0026-.2626-.1847-.4123.3801.05.7236.1361 1.034.2547.1659-.1476-.1076-.2951-.24-.4426.5872.1097.8361.2639 1.0833.4183.1794-.1694.0103-.3133-.1108-.4607.4428.1615.6709.37.911.5759.0814-.1082.2068-.1875.0554-.4486.3143.1785.5511.3888.7263.6244.1945-.122.1159-.2888.1169-.4426.3267.2618.534.5404.7879.8124.0511-.0366.0959-.161.1354-.3577.7794.7448 1.8807 2.6208.2831 3.3646-1.3589-1.1039-2.9817-1.9064-4.78-2.5086 2.3115 1.174 3.6556 2.1239 4.392 2.9328-.3773 1.4895-2.3455 1.5575-3.0651 1.5157.1473-.0676.2703-.1485.3139-.2728-.1806-.1264-.8209-.0134-1.2679-.2607zm2.8175 1.1334c.7881.1304-3.7769 4.0567-3.8472 3.1809-.0719-2.2846 1.7079-3.5367 3.8472-3.1809zm-4.847 8.7567c-1.1094-.8789-1.4668-3.4529.5901-4.6097 1.2394-.3273.4184 5.051-.5901 4.6097zm4.2656 4.5989c-.6257.3719-2.1452.2187-3.2252-1.3095-.7283-1.2823-.6345-2.5872-.123-2.9705.7648-.4589 1.9464.1609 2.8559 1.2003.7923.9405 1.1536 2.5927.4923 3.0797zm-1.2415-5.6086c-1.1481-.7409-1.3551-2.4203-.4623-3.7511.8928-1.3307 2.5472-1.8089 3.6952-1.068 1.1481.7409 1.3551 2.4203.4623 3.7509-.8926 1.3308-2.5471 1.809-3.6952 1.0682zm4.7948 8.2279c-1.3763.0584-2.7258-1.1105-2.7081-1.5157-.0206-.594 1.6758-1.0578 2.782-1.0306 1.1131-.0479 2.6068.3531 2.6097.8851.0184.5166-1.3547 1.6838-2.6836 1.6612zm2.7584-5.8578c.0081 1.3899-1.226 2.5225-2.7562 2.5299-1.5302.0073-2.7773-1.1135-2.7854-2.5033v-.0265c-.008-1.3899 1.2259-2.5226 2.7562-2.5299 1.5302-.0073 2.7773 1.1134 2.7853 2.5033a.7794.7794 0 0 1 .0001.0265zm3.855 2.0029c-1.186 1.6208-2.7916 1.684-3.3896 1.2325-.6255-.5811-.148-2.3854.7094-3.3747v-.0003c.9812-1.0912 2.0302-1.8037 2.7609-1.2469.4919.4828.7805 2.3008-.0807 3.3894zm1.0724-3.4301c-1.0086.4413-1.8298-4.9372-.5901-4.61 2.0568 1.1569 1.6994 3.731.5901 4.61zm-.0256-8.3279h.2985v-.5304h.2986c.1502 0 .2053.0624.2262.2052.0152.1088.0113.2395.0477.3253h.2984c-.0533-.0763-.0515-.2358-.0571-.3213-.0097-.1373-.0513-.2796-.1977-.3176v-.0037c.1502-.061.2149-.1807.2149-.341 0-.2048-.1539-.3738-.3974-.3738h-.732v1.3573zm.2985-1.1255h.3269c.1333 0 .2054.0573.2054.188 0 .1369-.0721.1942-.2054.1942H20.03v-.3822zm-1.0337.4633c0 .7009.5682 1.2694 1.2695 1.2694s1.2695-.5684 1.2695-1.2694c0-.7013-.5683-1.2697-1.2695-1.2697-.7013 0-1.2695.5684-1.2695 1.2697zm2.3275 0c0 .5845-.4737 1.058-1.058 1.058s-1.058-.4735-1.058-1.058c0-.5849.4737-1.058 1.058-1.058s1.058.4731 1.058 1.058z"
            },
            child: []
        }]
    })(s)
}
function SiReact(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z"
            },
            child: []
        }]
    })(s)
}
function SiSolidity(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M4.409 6.608L7.981.255l3.572 6.353H4.409zM8.411 0l3.569 6.348L15.552 0H8.411zm4.036 17.392l3.572 6.354 3.575-6.354h-7.147zm-.608-10.284h-7.43l3.715 6.605 3.715-6.605zm.428-.25h7.428L15.982.255l-3.715 6.603zM15.589 24l-3.569-6.349L8.448 24h7.141zm-3.856-6.858H4.306l3.712 6.603 3.715-6.603zm.428-.25h7.433l-3.718-6.605-3.715 6.605z"
            },
            child: []
        }]
    })(s)
}
function SiTailwindcss(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M12.001,4.8c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 C13.666,10.618,15.027,12,18.001,12c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C16.337,6.182,14.976,4.8,12.001,4.8z M6.001,12c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 c1.177,1.194,2.538,2.576,5.512,2.576c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C10.337,13.382,8.976,12,6.001,12z"
            },
            child: []
        }]
    })(s)
}
function SiTerraform(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M1.44 0v7.575l6.561 3.79V3.787zm21.12 4.227l-6.561 3.791v7.574l6.56-3.787zM8.72 4.23v7.575l6.561 3.787V8.018zm0 8.405v7.575L15.28 24v-7.578z"
            },
            child: []
        }]
    })(s)
}
function SiTypescript(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M1.125 0C.502 0 0 .502 0 1.125v21.75C0 23.498.502 24 1.125 24h21.75c.623 0 1.125-.502 1.125-1.125V1.125C24 .502 23.498 0 22.875 0zm17.363 9.75c.612 0 1.154.037 1.627.111a6.38 6.38 0 0 1 1.306.34v2.458a3.95 3.95 0 0 0-.643-.361 5.093 5.093 0 0 0-.717-.26 5.453 5.453 0 0 0-1.426-.2c-.3 0-.573.028-.819.086a2.1 2.1 0 0 0-.623.242c-.17.104-.3.229-.393.374a.888.888 0 0 0-.14.49c0 .196.053.373.156.529.104.156.252.304.443.444s.423.276.696.41c.273.135.582.274.926.416.47.197.892.407 1.266.628.374.222.695.473.963.753.268.279.472.598.614.957.142.359.214.776.214 1.253 0 .657-.125 1.21-.373 1.656a3.033 3.033 0 0 1-1.012 1.085 4.38 4.38 0 0 1-1.487.596c-.566.12-1.163.18-1.79.18a9.916 9.916 0 0 1-1.84-.164 5.544 5.544 0 0 1-1.512-.493v-2.63a5.033 5.033 0 0 0 3.237 1.2c.333 0 .624-.03.872-.09.249-.06.456-.144.623-.25.166-.108.29-.234.373-.38a1.023 1.023 0 0 0-.074-1.089 2.12 2.12 0 0 0-.537-.5 5.597 5.597 0 0 0-.807-.444 27.72 27.72 0 0 0-1.007-.436c-.918-.383-1.602-.852-2.053-1.405-.45-.553-.676-1.222-.676-2.005 0-.614.123-1.141.369-1.582.246-.441.58-.804 1.004-1.089a4.494 4.494 0 0 1 1.47-.629 7.536 7.536 0 0 1 1.77-.201zm-15.113.188h9.563v2.166H9.506v9.646H6.789v-9.646H3.375z"
            },
            child: []
        }]
    })(s)
}
function SiVite(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            role: "img",
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "m8.286 10.578.512-8.657a.306.306 0 0 1 .247-.282L17.377.006a.306.306 0 0 1 .353.385l-1.558 5.403a.306.306 0 0 0 .352.385l2.388-.46a.306.306 0 0 1 .332.438l-6.79 13.55-.123.19a.294.294 0 0 1-.252.14c-.177 0-.35-.152-.305-.369l1.095-5.301a.306.306 0 0 0-.388-.355l-1.433.435a.306.306 0 0 1-.389-.354l.69-3.375a.306.306 0 0 0-.37-.36l-2.32.536a.306.306 0 0 1-.374-.316zm14.976-7.926L17.284 3.74l-.544 1.887 2.077-.4a.8.8 0 0 1 .84.369.8.8 0 0 1 .034.783L12.9 19.93l-.013.025-.015.023-.122.19a.801.801 0 0 1-.672.37.826.826 0 0 1-.634-.302.8.8 0 0 1-.16-.67l1.029-4.981-1.12.34a.81.81 0 0 1-.86-.262.802.802 0 0 1-.165-.67l.63-3.08-2.027.468a.808.808 0 0 1-.768-.233.81.81 0 0 1-.217-.6l.389-6.57-7.44-1.33a.612.612 0 0 0-.64.906L11.58 23.691a.612.612 0 0 0 1.066-.004l11.26-20.135a.612.612 0 0 0-.644-.9z"
            },
            child: []
        }]
    })(s)
}
function FaHardHat(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M480 288c0-80.25-49.28-148.92-119.19-177.62L320 192V80a16 16 0 0 0-16-16h-96a16 16 0 0 0-16 16v112l-40.81-81.62C81.28 139.08 32 207.75 32 288v64h448zm16 96H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h480a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"
            },
            child: []
        }]
    })(s)
}
function TbBrandThreejs(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M8 22l-5 -19l19 5.5z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M12.573 17.58l-6.152 -1.576l8.796 -9.466l1.914 6.64"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M12.573 17.58l-1.573 -6.58l6.13 2.179"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M9.527 4.893l1.473 6.107l-6.31 -1.564z"
            },
            child: []
        }]
    })(s)
}
function LiaAws(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            viewBox: "0 0 32 32"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M 6.5839844 9.0097656 C 5.2239844 9.0097656 3.8432813 9.5400781 3.6132812 9.8300781 C 3.5532812 9.9500781 3.4141406 10.919922 3.7441406 10.919922 C 3.8541406 10.919922 3.9046094 10.939062 4.2246094 10.789062 C 5.4246094 10.319062 6.1849219 10.330078 6.2949219 10.330078 C 7.6449219 10.200078 8.4246875 11.120547 8.3046875 12.310547 L 8.3046875 13.009766 C 7.1646875 12.739766 6.5133594 12.730469 6.1933594 12.730469 C 4.5333594 12.630469 3 13.505688 3 15.429688 C 3 17.539687 4.8832812 17.990937 5.6132812 17.960938 C 6.7032812 17.970938 7.7435937 17.480859 8.4335938 16.630859 C 8.9835938 17.860859 9.33375 17.779297 9.34375 17.779297 C 9.44375 17.779297 9.5235156 17.739453 9.6035156 17.689453 L 10.173828 17.289062 C 10.273828 17.229063 10.353281 17.129766 10.363281 17.009766 C 10.353281 16.719766 9.8330469 16.269766 9.8730469 15.259766 L 9.8730469 12.140625 C 9.9330469 11.280625 9.6542187 10.439062 9.0742188 9.7890625 C 8.3842188 9.2090625 7.4739844 8.9297656 6.5839844 9.0097656 z M 25.957031 9.0097656 C 23.957031 9.0097656 22.807891 10.259297 22.837891 11.529297 C 22.837891 13.269297 24.596875 13.820859 24.796875 13.880859 C 26.486875 14.410859 26.7175 14.430078 27.1875 14.830078 C 27.5875 15.240078 27.537266 16.040625 26.947266 16.390625 C 26.777266 16.490625 26.046484 16.929844 24.396484 16.589844 C 23.846484 16.479844 23.557422 16.350156 23.107422 16.160156 C 22.987422 16.120156 22.707031 16.049922 22.707031 16.419922 L 22.707031 16.910156 C 22.707031 17.140156 22.846641 17.349219 23.056641 17.449219 C 24.106641 17.979219 25.366719 18 25.636719 18 C 25.676719 18 27.976094 18.001219 28.746094 16.449219 C 28.905094 16.129219 29.316875 14.960937 28.546875 13.960938 C 27.906875 13.210938 27.356797 13.130859 25.716797 12.630859 C 25.576797 12.590859 24.366953 12.279687 24.376953 11.429688 C 24.316953 10.339688 25.797422 10.280781 26.107422 10.300781 C 27.357422 10.280781 27.976406 10.749297 28.316406 10.779297 C 28.466406 10.779297 28.537109 10.690234 28.537109 10.490234 L 28.537109 10.029297 C 28.547109 9.9192969 28.507266 9.8107031 28.447266 9.7207031 C 28.047266 9.2007031 26.517031 9.0097656 25.957031 9.0097656 z M 10.777344 9.2597656 C 10.667344 9.2797656 10.587422 9.39 10.607422 9.5 C 10.627422 9.63 10.647266 9.760625 10.697266 9.890625 L 12.9375 17.279297 C 12.9875 17.519297 13.146094 17.780234 13.496094 17.740234 L 14.316406 17.740234 C 14.816406 17.790234 14.886484 17.309766 14.896484 17.259766 L 16.367188 11.099609 L 17.857422 17.269531 C 17.867422 17.319531 17.937734 17.8 18.427734 17.75 L 19.257812 17.75 C 19.617812 17.79 19.787891 17.529062 19.837891 17.289062 C 22.357891 9.1790625 22.187031 9.7303906 22.207031 9.6503906 C 22.247031 9.2303906 22.006797 9.2595313 21.966797 9.2695312 L 21.076172 9.2695312 C 20.626172 9.2195313 20.537578 9.6304688 20.517578 9.7304688 L 18.857422 16.140625 L 17.357422 9.7304688 C 17.287422 9.2404687 16.887109 9.2595313 16.787109 9.2695312 L 16.017578 9.2695312 C 15.577578 9.2295313 15.4675 9.5804687 15.4375 9.7304688 L 13.947266 16.050781 L 12.347656 9.7304688 C 12.307656 9.5304687 12.177109 9.2197656 11.787109 9.2597656 L 10.777344 9.2597656 z M 6.5234375 13.890625 C 7.2434375 13.900625 7.8649219 14.009375 8.2949219 14.109375 C 8.2949219 14.609375 8.313125 14.889844 8.203125 15.339844 C 8.063125 15.819844 7.444375 16.690937 5.984375 16.710938 C 5.144375 16.750937 4.5945313 16.089844 4.6445312 15.339844 C 4.5945313 14.139844 5.8334375 13.840625 6.5234375 13.890625 z M 29.041016 20.001953 C 28.107641 20.014953 27.005922 20.224047 26.169922 20.810547 C 25.911922 20.989547 25.957141 21.238078 26.244141 21.205078 C 27.184141 21.092078 29.276391 20.838406 29.650391 21.316406 C 30.025391 21.794406 29.235719 23.766437 28.886719 24.648438 C 28.778719 24.911437 29.007047 25.020312 29.248047 24.820312 C 30.812047 23.510312 31.218438 20.764141 30.898438 20.369141 C 30.737937 20.171641 29.974391 19.988953 29.041016 20.001953 z M 1.2167969 21.001953 C 0.99873437 21.031953 0.9048125 21.308344 1.1328125 21.527344 C 5.0498125 25.201344 10.225656 27 15.972656 27 C 20.071656 27 24.830234 25.662578 28.115234 23.142578 C 28.658234 22.723578 28.195672 22.09575 27.638672 22.34375 C 23.955672 23.96875 19.955453 24.751953 16.314453 24.751953 C 10.918453 24.751953 5.69475 23.625406 1.46875 21.066406 C 1.37625 21.010406 1.2894844 20.991953 1.2167969 21.001953 z"
            },
            child: []
        }]
    })(s)
}
const resumeLink = "https://drive.google.com/file/d/1N08aHY2C56NHf-s-0RuBkOE9sPjjxKYG/view?usp=sharing"
  , repoLink = "https://github.com/SAI127001?tab=repositories"
  , callToAction = "https://www.linkedin.com/in/terukula-sai"
  , navLinks = [{
    id: "skills",
    title: "Skills"
}, {
    id: "education",
    title: "Education"
}, {
    id: "projects",
    title: "Projects"
}, {
    id: "contactMe",
    title: "Contact"
}]
  , educationList = [{
    id: "education-3",
    icon: saket,
    title: "Saket College of Art's, Science & Commerce",
    university: "( University of Mumbai )",
    degree: "Degree : Bachelor of Science",
    content1: "Information Technology",
    duration: "2021 - 2024"
}, {
    id: "education-2",
    icon: saket,
    title: "Saket College of Art's, Science & Commerce",
    university: "( Maharashtra HSC Board )",
    degree: "Stream : Commerce (11th & 12th)",
    content1: "Major : Maths & Information Technology",
    duration: "2019 - 2021"
}, {
    id: "education-1",
    icon: stmary,
    title: "St Mary's High School, Kalyan             ",
    university: "( Maharashtra SSC Board )",
    content1: "1st to 10th",
    duration: "2009 - 2019"
}]
  , skills = [{
    title: "Tools",
    items: [{
        id: "t-1",
        icon: SiDocker,
        name: "Docker"
    }, {
        id: "t-2",
        icon: SiGit,
        name: "Git"
    }, {
        id: "t-3",
        icon: AiFillGithub,
        name: "GitHub"
    }, {
        id: "t-4",
        icon: SiJenkins,
        name: "Jenkins"
    }, {
        id: "t-5",
        icon: SiTerraform,
        name: "Terraform"
    }, {
        id: "t-6",
        icon: SiNetlify,
        name: "Netlify"
    }]
}, {
    title: "Programming Languages",
    items: [{
        id: "pl-1",
        icon: SiGnubash,
        name: "BASH"
    }, {
        id: "pl-2",
        icon: SiPython,
        name: "Python"
    }, {
        id: "pl-3",
        icon: SiCplusplus,
        name: "C++"
    }]
}, {
    title: "Frameworks",
    items: [{
        id: "f-1",
        icon: SiKubernetes,
        name: "Kubernetes"
    }, {
        id: "f-2",
        icon: SiAnsible,
        name: "Ansible"
    }]
}, {
    title: "Database",
    items: [{
        id: "d-1",
        icon: SiMysql,
        name: "MySQL"
    }]
}, {
    title: "Others",
    items: [{
        id: "O-1",
        icon: SiLinux,
        name: "Linux"
    }, {
        id: "o-2",
        icon: LiaAws,
        name: "AWS"
    }, {
        id: "o-3",
        icon: SiRaspberrypi,
        name: "Rasberry Pi"
    }]
}]
  , experiences = []
  , projects = [{
    id: "project-1",
    title: "Decentalized Transaction application",
    github: "https://github.com/SAI127001/Decentralized-Transaction-Application",
    link: "https://terukulasai-final-year-project.netlify.app/",
    image: ether,
    content: "This project is made using React-vite, solidity, tailwincss. It enable user to exchange Ehtereum from one address to another.",
    stack: [{
        id: "icon-1",
        icon: SiReact,
        name: "React"
    }, {
        id: "icon-2",
        icon: SiTailwindcss,
        name: "TailwindCSS"
    }, {
        id: "icon-3",
        icon: SiVite,
        name: "Vite"
    }, {
        id: "icon-4",
        icon: SiSolidity,
        name: "Solidity"
    }, {
        id: "icon-5",
        icon: FaHardHat,
        name: "Hardhat"
    }]
}, {
    id: "project-2",
    title: "QR Code Generator",
    github: "https://github.com/SAI127001/Qr-Code-Generator",
    link: "https://qr-generator-sai.netlify.app/",
    image: qrcode,
    content: "Simple QR Generator is made using React, one can generate Qr by pasteing the link or entering the desire characters.",
    stack: [{
        id: "icon-1",
        icon: SiReact,
        name: "React"
    }, {
        id: "icon-2",
        icon: SiTailwindcss,
        name: "TailwindCSS"
    }, {
        id: "icon-3",
        icon: SiVite,
        name: "Vite"
    }]
}, {
    id: "project-3",
    title: "Ethical Hacker Portfolio Template",
    github: "https://github.com/SAI127001/Ethical-Hacker-Portfolio-template",
    link: "https://ethical-hacker-template-sai.netlify.app/",
    image: portfolio,
    content: "This portfolio is suitable for the person who are interested in ethical hacking. This project is created using HTML, CSS and JS. Easy to customize according to the preferences.",
    stack: [{
        id: "icon-1",
        icon: AiFillHtml5,
        name: "HTML"
    }, {
        id: "icon-2",
        icon: SiCss3,
        name: "CSS"
    }, {
        id: "icon-3",
        icon: SiJavascript,
        name: "Javascript"
    }]
}, {
    id: "project-4",
    title: "3D Earth Model",
    github: "https://github.com/SAI127001/3D-Earth-using-React-and-Three-js",
    link: "https://sai3dearth.netlify.app/",
    image: earth,
    content: "3D Earth in infinite space, made it using React + vite and 3Js. You can use it in your project as a module. Images used in this project are of large size, one can optimize it by compressing the size of the images.",
    stack: [{
        id: "icon-1",
        icon: SiReact,
        name: "React"
    }, {
        id: "icon-2",
        icon: SiVite,
        name: "Vite"
    }, {
        id: "icon-3",
        icon: TbBrandThreejs,
        name: "Three JS"
    }]
}, {
    id: "project-5",
    title: "Terminal Based Portfolio",
    github: "https://github.com/SAI127001/Terminal-Based-Portfolio",
    link: "https://terminal-based-portfolio69.netlify.app/",
    image: bash,
    content: "Terminal based Portfolio made using Typescript and Tailwindcss. Enter help command to get the usage list.",
    stack: [{
        id: "icon-1",
        icon: SiTypescript,
        name: "TypeScript"
    }, {
        id: "icon-2",
        icon: SiVite,
        name: "Vite"
    }, {
        id: "icon-3",
        icon: SiTailwindcss,
        name: "Tailwind CSS"
    }]
}, {
    id: "project-6",
    title: "Solar Energy Monitoring System(IoT Based)",
    github: "https://github.com/SAI127001/IoT-Based-Solar-Energy-Monitoring-System",
    image: solar,
    content: "Solar Energy Monitoring System is based on IoT. It uses arduino in it and display the solar readings on the display.",
    stack: [{
        id: "icon-1",
        icon: SiArduino,
        name: "Arduino"
    }, {
        id: "icon-2",
        icon: SiCplusplus,
        name: "C++"
    }]
}, {
    id: "project-7",
    title: "Red Hat Hacker Portfolio Template",
    github: "https://github.com/SAI127001/Red-Hat-Hacker-Portfolio-Template",
    link: "https://red-hat-hacker-template-sai.netlify.app/",
    image: redportfolio,
    content: "Elevate your cybersecurity profile with this streamlined portfolio template. Showcase exploits, projects, and skills succinctly. Perfect for ethical hackers at any career stage.",
    stack: [{
        id: "icon-1",
        icon: AiFillHtml5,
        name: "HTML"
    }, {
        id: "icon-2",
        icon: SiCss3,
        name: "CSS"
    }, {
        id: "icon-3",
        icon: SiJavascript,
        name: "Javascript"
    }]
}]
  , socialMedia = [{
    id: "social-media-1",
    icon: AiFillLinkedin,
    link: "https://www.linkedin.com/in/terukula-sai"
}, {
    id: "social-media-2",
    icon: AiFillGithub,
    link: "https://github.com/SAI127001"
}, {
    id: "social-media-3",
    icon: AiFillMail,
    link: "mailto:codesai127.0.0.1@gmail.com"
}, {
    id: "social-media-5",
    icon: AiFillInstagram,
    link: "https://www.instagram.com/sai_127.0.0.1/"
}]
  , aboutMe = {
    name: "Terukula Sai",
    tagLine: "Automation is the art of translating complex systems into simple, repeatable processes.",
    intro: "DevOps Engineer from India: Bridging the Gap Between Developers and Operations While Crafting the Future of Seamless Deployments."
}
  , Navbar = () => {
    const [s,e] = reactExports.useState(!1);
    return jsxRuntimeExports.jsxs("div", {
        className: "nav-border border dark:border-gray-600 box-border bg-black shadow-md shadow-black bg-opacity-50 p-1 mt-7",
        children: [" ", jsxRuntimeExports.jsxs("nav", {
            className: "w-full flex justify-between items-center navbar",
            children: [jsxRuntimeExports.jsx("a", {
                href: "#home",
                children: jsxRuntimeExports.jsx("img", {
                    src: sailogo,
                    alt: "Terukula Sai ",
                    className: "mb-1 w-[100%] h-[100px]"
                })
            }), jsxRuntimeExports.jsx("ul", {
                className: "list-none sm:flex hidden justify-end items-center flex-1 mb-5 mr-5",
                children: navLinks.map( (a, o) => jsxRuntimeExports.jsx("li", {
                    className: `font-poppins
              font-normal
              cursor-pointer
              text-[20px]
              ${o === navLinks.length - 1 ? "mr-0" : "mr-10"}
              text-white hover:text-teal-200`,
                    children: jsxRuntimeExports.jsx("a", {
                        href: `#${a.id}`,
                        children: a.title
                    })
                }, a.id))
            }), jsxRuntimeExports.jsxs("div", {
                className: "sm:hidden flex flex-1 justify-end items-center",
                children: [jsxRuntimeExports.jsx("img", {
                    src: s ? close : menu,
                    alt: "menu",
                    className: "w-[30px] h-[27px] mr-5 mb-3 object-contain",
                    onClick: () => e(a => !a)
                }), jsxRuntimeExports.jsx("div", {
                    className: `${s ? "flex" : "hidden"} p-6 bg-black shadow-md shadow-black bg-opacity-50
          absolute top-20 right-0 mx-4 my-2
          min-w-[140px] rounded-xl sidebar`,
                    children: jsxRuntimeExports.jsx("ul", {
                        className: "list-none flex flex-col justify-end items-center flex-1",
                        children: navLinks.map( (a, o) => jsxRuntimeExports.jsx("li", {
                            className: `font-poppins
                  font-normal
                  cursor-pointer
                  text-[16px]
                  ${o === navLinks.length - 1 ? "mb-0" : "mb-4"}
                  text-white`,
                            children: jsxRuntimeExports.jsx("a", {
                                href: `#${a.id}`,
                                children: a.title
                            })
                        }, a.id))
                    })
                })]
            })]
        })]
    })
}
  , CustomCursor = () => {
    const [s,e] = reactExports.useState({
        x: 0,
        y: 0
    })
      , [a,o] = reactExports.useState(!1);
    reactExports.useEffect( () => {
        const d = _ => {
            e({
                x: _.clientX,
                y: _.clientY
            })
        }
          , g = () => {
            o(window.innerWidth <= 768)
        }
        ;
        return window.addEventListener("mousemove", d),
        window.addEventListener("resize", g),
        g(),
        () => {
            window.removeEventListener("mousemove", d),
            window.removeEventListener("resize", g)
        }
    }
    , []);
    const c = {
        position: "fixed",
        top: 0,
        left: 0,
        width: "20px",
        height: "20px",
        borderRadius: "50%",
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        transform: "translate(-50%, -50%)",
        pointerEvents: "none",
        zIndex: 9999,
        transition: "transform 0.1s ease, width 0.1s ease, height 0.1s ease, background-color 0.1s ease"
    };
    return a ? null : jsxRuntimeExports.jsx("div", {
        style: {
            ...c,
            left: s.x,
            top: s.y
        }
    })
}
  , LetsConnect = () => jsxRuntimeExports.jsx("div", {
    className: `${styles.flexCenter} w-[100px] h-[100px] lets-btn rounded-full bg-black-gradient p-[2px] cursor-pointer `,
    onClick: () => window.open(callToAction),
    children: jsxRuntimeExports.jsxs("div", {
        className: `${styles.flexCenter} flex-col bg-primary w-[20%] h-[20%] rounded-full`,
        children: [jsxRuntimeExports.jsx("div", {
            className: `${styles.flexStart} flex-row`
        }), jsxRuntimeExports.jsx("div", {
            className: `${styles.flexStart} flex-row`,
            children: jsxRuntimeExports.jsx("p", {
                className: "font-poppins font-medium text-[18px] leading-[23px]",
                children: jsxRuntimeExports.jsx("span", {
                    className: "text-white text-[30px] hover:text-black",
                    children: jsxRuntimeExports.jsx(Ball1Canvas, {
                        icon: linked
                    })
                })
            })
        })]
    })
});
var lottie$1 = {
    exports: {}
};
(function(module, exports) {
    typeof navigator < "u" && function(s, e) {
        module.exports = e()
    }(commonjsGlobal, function() {
        var svgNS = "http://www.w3.org/2000/svg"
          , locationHref = ""
          , _useWebWorker = !1
          , initialDefaultFrame = -999999
          , setWebWorker = function(e) {
            _useWebWorker = !!e
        }
          , getWebWorker = function() {
            return _useWebWorker
        }
          , setLocationHref = function(e) {
            locationHref = e
        }
          , getLocationHref = function() {
            return locationHref
        };
        function createTag(s) {
            return document.createElement(s)
        }
        function extendPrototype(s, e) {
            var a, o = s.length, c;
            for (a = 0; a < o; a += 1) {
                c = s[a].prototype;
                for (var d in c)
                    Object.prototype.hasOwnProperty.call(c, d) && (e.prototype[d] = c[d])
            }
        }
        function getDescriptor(s, e) {
            return Object.getOwnPropertyDescriptor(s, e)
        }
        function createProxyFunction(s) {
            function e() {}
            return e.prototype = s,
            e
        }
        var audioControllerFactory = function() {
            function s(e) {
                this.audios = [],
                this.audioFactory = e,
                this._volume = 1,
                this._isMuted = !1
            }
            return s.prototype = {
                addAudio: function(a) {
                    this.audios.push(a)
                },
                pause: function() {
                    var a, o = this.audios.length;
                    for (a = 0; a < o; a += 1)
                        this.audios[a].pause()
                },
                resume: function() {
                    var a, o = this.audios.length;
                    for (a = 0; a < o; a += 1)
                        this.audios[a].resume()
                },
                setRate: function(a) {
                    var o, c = this.audios.length;
                    for (o = 0; o < c; o += 1)
                        this.audios[o].setRate(a)
                },
                createAudio: function(a) {
                    return this.audioFactory ? this.audioFactory(a) : window.Howl ? new window.Howl({
                        src: [a]
                    }) : {
                        isPlaying: !1,
                        play: function() {
                            this.isPlaying = !0
                        },
                        seek: function() {
                            this.isPlaying = !1
                        },
                        playing: function() {},
                        rate: function() {},
                        setVolume: function() {}
                    }
                },
                setAudioFactory: function(a) {
                    this.audioFactory = a
                },
                setVolume: function(a) {
                    this._volume = a,
                    this._updateVolume()
                },
                mute: function() {
                    this._isMuted = !0,
                    this._updateVolume()
                },
                unmute: function() {
                    this._isMuted = !1,
                    this._updateVolume()
                },
                getVolume: function() {
                    return this._volume
                },
                _updateVolume: function() {
                    var a, o = this.audios.length;
                    for (a = 0; a < o; a += 1)
                        this.audios[a].volume(this._volume * (this._isMuted ? 0 : 1))
                }
            },
            function() {
                return new s
            }
        }()
          , createTypedArray = function() {
            function s(a, o) {
                var c = 0, d = [], g;
                switch (a) {
                case "int16":
                case "uint8c":
                    g = 1;
                    break;
                default:
                    g = 1.1;
                    break
                }
                for (c = 0; c < o; c += 1)
                    d.push(g);
                return d
            }
            function e(a, o) {
                return a === "float32" ? new Float32Array(o) : a === "int16" ? new Int16Array(o) : a === "uint8c" ? new Uint8ClampedArray(o) : s(a, o)
            }
            return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? e : s
        }();
        function createSizedArray(s) {
            return Array.apply(null, {
                length: s
            })
        }
        function _typeof$6(s) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function(a) {
                return typeof a
            }
            : _typeof$6 = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            _typeof$6(s)
        }
        var subframeEnabled = !0
          , expressionsPlugin = null
          , expressionsInterfaces = null
          , idPrefix$1 = ""
          , isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          , bmPow = Math.pow
          , bmSqrt = Math.sqrt
          , bmFloor = Math.floor
          , bmMax = Math.max
          , bmMin = Math.min
          , BMMath = {};
        (function() {
            var s = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], e, a = s.length;
            for (e = 0; e < a; e += 1)
                BMMath[s[e]] = Math[s[e]]
        }
        )(),
        BMMath.random = Math.random,
        BMMath.abs = function(s) {
            var e = _typeof$6(s);
            if (e === "object" && s.length) {
                var a = createSizedArray(s.length), o, c = s.length;
                for (o = 0; o < c; o += 1)
                    a[o] = Math.abs(s[o]);
                return a
            }
            return Math.abs(s)
        }
        ;
        var defaultCurveSegments = 150
          , degToRads = Math.PI / 180
          , roundCorner = .5519;
        function styleDiv(s) {
            s.style.position = "absolute",
            s.style.top = 0,
            s.style.left = 0,
            s.style.display = "block",
            s.style.transformOrigin = "0 0",
            s.style.webkitTransformOrigin = "0 0",
            s.style.backfaceVisibility = "visible",
            s.style.webkitBackfaceVisibility = "visible",
            s.style.transformStyle = "preserve-3d",
            s.style.webkitTransformStyle = "preserve-3d",
            s.style.mozTransformStyle = "preserve-3d"
        }
        function BMEnterFrameEvent(s, e, a, o) {
            this.type = s,
            this.currentTime = e,
            this.totalTime = a,
            this.direction = o < 0 ? -1 : 1
        }
        function BMCompleteEvent(s, e) {
            this.type = s,
            this.direction = e < 0 ? -1 : 1
        }
        function BMCompleteLoopEvent(s, e, a, o) {
            this.type = s,
            this.currentLoop = a,
            this.totalLoops = e,
            this.direction = o < 0 ? -1 : 1
        }
        function BMSegmentStartEvent(s, e, a) {
            this.type = s,
            this.firstFrame = e,
            this.totalFrames = a
        }
        function BMDestroyEvent(s, e) {
            this.type = s,
            this.target = e
        }
        function BMRenderFrameErrorEvent(s, e) {
            this.type = "renderFrameError",
            this.nativeError = s,
            this.currentTime = e
        }
        function BMConfigErrorEvent(s) {
            this.type = "configError",
            this.nativeError = s
        }
        var createElementID = function() {
            var s = 0;
            return function() {
                return s += 1,
                idPrefix$1 + "__lottie_element_" + s
            }
        }();
        function HSVtoRGB(s, e, a) {
            var o, c, d, g, _, b, j, $;
            switch (g = Math.floor(s * 6),
            _ = s * 6 - g,
            b = a * (1 - e),
            j = a * (1 - _ * e),
            $ = a * (1 - (1 - _) * e),
            g % 6) {
            case 0:
                o = a,
                c = $,
                d = b;
                break;
            case 1:
                o = j,
                c = a,
                d = b;
                break;
            case 2:
                o = b,
                c = a,
                d = $;
                break;
            case 3:
                o = b,
                c = j,
                d = a;
                break;
            case 4:
                o = $,
                c = b,
                d = a;
                break;
            case 5:
                o = a,
                c = b,
                d = j;
                break
            }
            return [o, c, d]
        }
        function RGBtoHSV(s, e, a) {
            var o = Math.max(s, e, a), c = Math.min(s, e, a), d = o - c, g, _ = o === 0 ? 0 : d / o, b = o / 255;
            switch (o) {
            case c:
                g = 0;
                break;
            case s:
                g = e - a + d * (e < a ? 6 : 0),
                g /= 6 * d;
                break;
            case e:
                g = a - s + d * 2,
                g /= 6 * d;
                break;
            case a:
                g = s - e + d * 4,
                g /= 6 * d;
                break
            }
            return [g, _, b]
        }
        function addSaturationToRGB(s, e) {
            var a = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
            return a[1] += e,
            a[1] > 1 ? a[1] = 1 : a[1] <= 0 && (a[1] = 0),
            HSVtoRGB(a[0], a[1], a[2])
        }
        function addBrightnessToRGB(s, e) {
            var a = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
            return a[2] += e,
            a[2] > 1 ? a[2] = 1 : a[2] < 0 && (a[2] = 0),
            HSVtoRGB(a[0], a[1], a[2])
        }
        function addHueToRGB(s, e) {
            var a = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
            return a[0] += e / 360,
            a[0] > 1 ? a[0] -= 1 : a[0] < 0 && (a[0] += 1),
            HSVtoRGB(a[0], a[1], a[2])
        }
        var rgbToHex = function() {
            var s = [], e, a;
            for (e = 0; e < 256; e += 1)
                a = e.toString(16),
                s[e] = a.length === 1 ? "0" + a : a;
            return function(o, c, d) {
                return o < 0 && (o = 0),
                c < 0 && (c = 0),
                d < 0 && (d = 0),
                "#" + s[o] + s[c] + s[d]
            }
        }()
          , setSubframeEnabled = function(e) {
            subframeEnabled = !!e
        }
          , getSubframeEnabled = function() {
            return subframeEnabled
        }
          , setExpressionsPlugin = function(e) {
            expressionsPlugin = e
        }
          , getExpressionsPlugin = function() {
            return expressionsPlugin
        }
          , setExpressionInterfaces = function(e) {
            expressionsInterfaces = e
        }
          , getExpressionInterfaces = function() {
            return expressionsInterfaces
        }
          , setDefaultCurveSegments = function(e) {
            defaultCurveSegments = e
        }
          , getDefaultCurveSegments = function() {
            return defaultCurveSegments
        }
          , setIdPrefix = function(e) {
            idPrefix$1 = e
        };
        function createNS(s) {
            return document.createElementNS(svgNS, s)
        }
        function _typeof$5(s) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function(a) {
                return typeof a
            }
            : _typeof$5 = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            _typeof$5(s)
        }
        var dataManager = function() {
            var s = 1, e = [], a, o, c = {
                onmessage: function() {},
                postMessage: function(rt) {
                    a({
                        data: rt
                    })
                }
            }, d = {
                postMessage: function(rt) {
                    c.onmessage({
                        data: rt
                    })
                }
            };
            function g(tt) {
                if (window.Worker && window.Blob && getWebWorker()) {
                    var rt = new Blob(["var _workerSelf = self; self.onmessage = ", tt.toString()],{
                        type: "text/javascript"
                    })
                      , st = URL.createObjectURL(rt);
                    return new Worker(st)
                }
                return a = tt,
                c
            }
            function _() {
                o || (o = g(function(rt) {
                    function st() {
                        function ct(Dt, Mt) {
                            var Tt, mt, St = Dt.length, wt, Ct, Ht, en;
                            for (mt = 0; mt < St; mt += 1)
                                if (Tt = Dt[mt],
                                "ks"in Tt && !Tt.completed) {
                                    if (Tt.completed = !0,
                                    Tt.hasMask) {
                                        var Ot = Tt.masksProperties;
                                        for (Ct = Ot.length,
                                        wt = 0; wt < Ct; wt += 1)
                                            if (Ot[wt].pt.k.i)
                                                pt(Ot[wt].pt.k);
                                            else
                                                for (en = Ot[wt].pt.k.length,
                                                Ht = 0; Ht < en; Ht += 1)
                                                    Ot[wt].pt.k[Ht].s && pt(Ot[wt].pt.k[Ht].s[0]),
                                                    Ot[wt].pt.k[Ht].e && pt(Ot[wt].pt.k[Ht].e[0])
                                    }
                                    Tt.ty === 0 ? (Tt.layers = at(Tt.refId, Mt),
                                    ct(Tt.layers, Mt)) : Tt.ty === 4 ? ht(Tt.shapes) : Tt.ty === 5 && Ft(Tt)
                                }
                        }
                        function it(Dt, Mt) {
                            if (Dt) {
                                var Tt = 0
                                  , mt = Dt.length;
                                for (Tt = 0; Tt < mt; Tt += 1)
                                    Dt[Tt].t === 1 && (Dt[Tt].data.layers = at(Dt[Tt].data.refId, Mt),
                                    ct(Dt[Tt].data.layers, Mt))
                            }
                        }
                        function ot(Dt, Mt) {
                            for (var Tt = 0, mt = Mt.length; Tt < mt; ) {
                                if (Mt[Tt].id === Dt)
                                    return Mt[Tt];
                                Tt += 1
                            }
                            return null
                        }
                        function at(Dt, Mt) {
                            var Tt = ot(Dt, Mt);
                            return Tt ? Tt.layers.__used ? JSON.parse(JSON.stringify(Tt.layers)) : (Tt.layers.__used = !0,
                            Tt.layers) : null
                        }
                        function ht(Dt) {
                            var Mt, Tt = Dt.length, mt, St;
                            for (Mt = Tt - 1; Mt >= 0; Mt -= 1)
                                if (Dt[Mt].ty === "sh")
                                    if (Dt[Mt].ks.k.i)
                                        pt(Dt[Mt].ks.k);
                                    else
                                        for (St = Dt[Mt].ks.k.length,
                                        mt = 0; mt < St; mt += 1)
                                            Dt[Mt].ks.k[mt].s && pt(Dt[Mt].ks.k[mt].s[0]),
                                            Dt[Mt].ks.k[mt].e && pt(Dt[Mt].ks.k[mt].e[0]);
                                else
                                    Dt[Mt].ty === "gr" && ht(Dt[Mt].it)
                        }
                        function pt(Dt) {
                            var Mt, Tt = Dt.i.length;
                            for (Mt = 0; Mt < Tt; Mt += 1)
                                Dt.i[Mt][0] += Dt.v[Mt][0],
                                Dt.i[Mt][1] += Dt.v[Mt][1],
                                Dt.o[Mt][0] += Dt.v[Mt][0],
                                Dt.o[Mt][1] += Dt.v[Mt][1]
                        }
                        function dt(Dt, Mt) {
                            var Tt = Mt ? Mt.split(".") : [100, 100, 100];
                            return Dt[0] > Tt[0] ? !0 : Tt[0] > Dt[0] ? !1 : Dt[1] > Tt[1] ? !0 : Tt[1] > Dt[1] ? !1 : Dt[2] > Tt[2] ? !0 : Tt[2] > Dt[2] ? !1 : null
                        }
                        var yt = function() {
                            var Dt = [4, 4, 14];
                            function Mt(mt) {
                                var St = mt.t.d;
                                mt.t.d = {
                                    k: [{
                                        s: St,
                                        t: 0
                                    }]
                                }
                            }
                            function Tt(mt) {
                                var St, wt = mt.length;
                                for (St = 0; St < wt; St += 1)
                                    mt[St].ty === 5 && Mt(mt[St])
                            }
                            return function(mt) {
                                if (dt(Dt, mt.v) && (Tt(mt.layers),
                                mt.assets)) {
                                    var St, wt = mt.assets.length;
                                    for (St = 0; St < wt; St += 1)
                                        mt.assets[St].layers && Tt(mt.assets[St].layers)
                                }
                            }
                        }()
                          , vt = function() {
                            var Dt = [4, 7, 99];
                            return function(Mt) {
                                if (Mt.chars && !dt(Dt, Mt.v)) {
                                    var Tt, mt = Mt.chars.length;
                                    for (Tt = 0; Tt < mt; Tt += 1) {
                                        var St = Mt.chars[Tt];
                                        St.data && St.data.shapes && (ht(St.data.shapes),
                                        St.data.ip = 0,
                                        St.data.op = 99999,
                                        St.data.st = 0,
                                        St.data.sr = 1,
                                        St.data.ks = {
                                            p: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            s: {
                                                k: [100, 100],
                                                a: 0
                                            },
                                            a: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            r: {
                                                k: 0,
                                                a: 0
                                            },
                                            o: {
                                                k: 100,
                                                a: 0
                                            }
                                        },
                                        Mt.chars[Tt].t || (St.data.shapes.push({
                                            ty: "no"
                                        }),
                                        St.data.shapes[0].it.push({
                                            p: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            s: {
                                                k: [100, 100],
                                                a: 0
                                            },
                                            a: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            r: {
                                                k: 0,
                                                a: 0
                                            },
                                            o: {
                                                k: 100,
                                                a: 0
                                            },
                                            sk: {
                                                k: 0,
                                                a: 0
                                            },
                                            sa: {
                                                k: 0,
                                                a: 0
                                            },
                                            ty: "tr"
                                        })))
                                    }
                                }
                            }
                        }()
                          , xt = function() {
                            var Dt = [5, 7, 15];
                            function Mt(mt) {
                                var St = mt.t.p;
                                typeof St.a == "number" && (St.a = {
                                    a: 0,
                                    k: St.a
                                }),
                                typeof St.p == "number" && (St.p = {
                                    a: 0,
                                    k: St.p
                                }),
                                typeof St.r == "number" && (St.r = {
                                    a: 0,
                                    k: St.r
                                })
                            }
                            function Tt(mt) {
                                var St, wt = mt.length;
                                for (St = 0; St < wt; St += 1)
                                    mt[St].ty === 5 && Mt(mt[St])
                            }
                            return function(mt) {
                                if (dt(Dt, mt.v) && (Tt(mt.layers),
                                mt.assets)) {
                                    var St, wt = mt.assets.length;
                                    for (St = 0; St < wt; St += 1)
                                        mt.assets[St].layers && Tt(mt.assets[St].layers)
                                }
                            }
                        }()
                          , _t = function() {
                            var Dt = [4, 1, 9];
                            function Mt(mt) {
                                var St, wt = mt.length, Ct, Ht;
                                for (St = 0; St < wt; St += 1)
                                    if (mt[St].ty === "gr")
                                        Mt(mt[St].it);
                                    else if (mt[St].ty === "fl" || mt[St].ty === "st")
                                        if (mt[St].c.k && mt[St].c.k[0].i)
                                            for (Ht = mt[St].c.k.length,
                                            Ct = 0; Ct < Ht; Ct += 1)
                                                mt[St].c.k[Ct].s && (mt[St].c.k[Ct].s[0] /= 255,
                                                mt[St].c.k[Ct].s[1] /= 255,
                                                mt[St].c.k[Ct].s[2] /= 255,
                                                mt[St].c.k[Ct].s[3] /= 255),
                                                mt[St].c.k[Ct].e && (mt[St].c.k[Ct].e[0] /= 255,
                                                mt[St].c.k[Ct].e[1] /= 255,
                                                mt[St].c.k[Ct].e[2] /= 255,
                                                mt[St].c.k[Ct].e[3] /= 255);
                                        else
                                            mt[St].c.k[0] /= 255,
                                            mt[St].c.k[1] /= 255,
                                            mt[St].c.k[2] /= 255,
                                            mt[St].c.k[3] /= 255
                            }
                            function Tt(mt) {
                                var St, wt = mt.length;
                                for (St = 0; St < wt; St += 1)
                                    mt[St].ty === 4 && Mt(mt[St].shapes)
                            }
                            return function(mt) {
                                if (dt(Dt, mt.v) && (Tt(mt.layers),
                                mt.assets)) {
                                    var St, wt = mt.assets.length;
                                    for (St = 0; St < wt; St += 1)
                                        mt.assets[St].layers && Tt(mt.assets[St].layers)
                                }
                            }
                        }()
                          , bt = function() {
                            var Dt = [4, 4, 18];
                            function Mt(mt) {
                                var St, wt = mt.length, Ct, Ht;
                                for (St = wt - 1; St >= 0; St -= 1)
                                    if (mt[St].ty === "sh")
                                        if (mt[St].ks.k.i)
                                            mt[St].ks.k.c = mt[St].closed;
                                        else
                                            for (Ht = mt[St].ks.k.length,
                                            Ct = 0; Ct < Ht; Ct += 1)
                                                mt[St].ks.k[Ct].s && (mt[St].ks.k[Ct].s[0].c = mt[St].closed),
                                                mt[St].ks.k[Ct].e && (mt[St].ks.k[Ct].e[0].c = mt[St].closed);
                                    else
                                        mt[St].ty === "gr" && Mt(mt[St].it)
                            }
                            function Tt(mt) {
                                var St, wt, Ct = mt.length, Ht, en, Ot, Yt;
                                for (wt = 0; wt < Ct; wt += 1) {
                                    if (St = mt[wt],
                                    St.hasMask) {
                                        var rn = St.masksProperties;
                                        for (en = rn.length,
                                        Ht = 0; Ht < en; Ht += 1)
                                            if (rn[Ht].pt.k.i)
                                                rn[Ht].pt.k.c = rn[Ht].cl;
                                            else
                                                for (Yt = rn[Ht].pt.k.length,
                                                Ot = 0; Ot < Yt; Ot += 1)
                                                    rn[Ht].pt.k[Ot].s && (rn[Ht].pt.k[Ot].s[0].c = rn[Ht].cl),
                                                    rn[Ht].pt.k[Ot].e && (rn[Ht].pt.k[Ot].e[0].c = rn[Ht].cl)
                                    }
                                    St.ty === 4 && Mt(St.shapes)
                                }
                            }
                            return function(mt) {
                                if (dt(Dt, mt.v) && (Tt(mt.layers),
                                mt.assets)) {
                                    var St, wt = mt.assets.length;
                                    for (St = 0; St < wt; St += 1)
                                        mt.assets[St].layers && Tt(mt.assets[St].layers)
                                }
                            }
                        }();
                        function Rt(Dt) {
                            Dt.__complete || (_t(Dt),
                            yt(Dt),
                            vt(Dt),
                            xt(Dt),
                            bt(Dt),
                            ct(Dt.layers, Dt.assets),
                            it(Dt.chars, Dt.assets),
                            Dt.__complete = !0)
                        }
                        function Ft(Dt) {
                            Dt.t.a.length === 0 && "m"in Dt.t.p
                        }
                        var Bt = {};
                        return Bt.completeData = Rt,
                        Bt.checkColors = _t,
                        Bt.checkChars = vt,
                        Bt.checkPathProperties = xt,
                        Bt.checkShapes = bt,
                        Bt.completeLayers = ct,
                        Bt
                    }
                    if (d.dataManager || (d.dataManager = st()),
                    d.assetLoader || (d.assetLoader = function() {
                        function ct(ot) {
                            var at = ot.getResponseHeader("content-type");
                            return at && ot.responseType === "json" && at.indexOf("json") !== -1 || ot.response && _typeof$5(ot.response) === "object" ? ot.response : ot.response && typeof ot.response == "string" ? JSON.parse(ot.response) : ot.responseText ? JSON.parse(ot.responseText) : null
                        }
                        function it(ot, at, ht, pt) {
                            var dt, yt = new XMLHttpRequest;
                            try {
                                yt.responseType = "json"
                            } catch {}
                            yt.onreadystatechange = function() {
                                if (yt.readyState === 4)
                                    if (yt.status === 200)
                                        dt = ct(yt),
                                        ht(dt);
                                    else
                                        try {
                                            dt = ct(yt),
                                            ht(dt)
                                        } catch (vt) {
                                            pt && pt(vt)
                                        }
                            }
                            ;
                            try {
                                yt.open(["G", "E", "T"].join(""), ot, !0)
                            } catch {
                                yt.open(["G", "E", "T"].join(""), at + "/" + ot, !0)
                            }
                            yt.send()
                        }
                        return {
                            load: it
                        }
                    }()),
                    rt.data.type === "loadAnimation")
                        d.assetLoader.load(rt.data.path, rt.data.fullPath, function(ct) {
                            d.dataManager.completeData(ct),
                            d.postMessage({
                                id: rt.data.id,
                                payload: ct,
                                status: "success"
                            })
                        }, function() {
                            d.postMessage({
                                id: rt.data.id,
                                status: "error"
                            })
                        });
                    else if (rt.data.type === "complete") {
                        var lt = rt.data.animation;
                        d.dataManager.completeData(lt),
                        d.postMessage({
                            id: rt.data.id,
                            payload: lt,
                            status: "success"
                        })
                    } else
                        rt.data.type === "loadData" && d.assetLoader.load(rt.data.path, rt.data.fullPath, function(ct) {
                            d.postMessage({
                                id: rt.data.id,
                                payload: ct,
                                status: "success"
                            })
                        }, function() {
                            d.postMessage({
                                id: rt.data.id,
                                status: "error"
                            })
                        })
                }),
                o.onmessage = function(tt) {
                    var rt = tt.data
                      , st = rt.id
                      , lt = e[st];
                    e[st] = null,
                    rt.status === "success" ? lt.onComplete(rt.payload) : lt.onError && lt.onError()
                }
                )
            }
            function b(tt, rt) {
                s += 1;
                var st = "processId_" + s;
                return e[st] = {
                    onComplete: tt,
                    onError: rt
                },
                st
            }
            function j(tt, rt, st) {
                _();
                var lt = b(rt, st);
                o.postMessage({
                    type: "loadAnimation",
                    path: tt,
                    fullPath: window.location.origin + window.location.pathname,
                    id: lt
                })
            }
            function $(tt, rt, st) {
                _();
                var lt = b(rt, st);
                o.postMessage({
                    type: "loadData",
                    path: tt,
                    fullPath: window.location.origin + window.location.pathname,
                    id: lt
                })
            }
            function nt(tt, rt, st) {
                _();
                var lt = b(rt, st);
                o.postMessage({
                    type: "complete",
                    animation: tt,
                    id: lt
                })
            }
            return {
                loadAnimation: j,
                loadData: $,
                completeAnimation: nt
            }
        }()
          , ImagePreloader = function() {
            var s = function() {
                var it = createTag("canvas");
                it.width = 1,
                it.height = 1;
                var ot = it.getContext("2d");
                return ot.fillStyle = "rgba(0,0,0,0)",
                ot.fillRect(0, 0, 1, 1),
                it
            }();
            function e() {
                this.loadedAssets += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function a() {
                this.loadedFootagesCount += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function o(it, ot, at) {
                var ht = "";
                if (it.e)
                    ht = it.p;
                else if (ot) {
                    var pt = it.p;
                    pt.indexOf("images/") !== -1 && (pt = pt.split("/")[1]),
                    ht = ot + pt
                } else
                    ht = at,
                    ht += it.u ? it.u : "",
                    ht += it.p;
                return ht
            }
            function c(it) {
                var ot = 0
                  , at = setInterval((function() {
                    var ht = it.getBBox();
                    (ht.width || ot > 500) && (this._imageLoaded(),
                    clearInterval(at)),
                    ot += 1
                }
                ).bind(this), 50)
            }
            function d(it) {
                var ot = o(it, this.assetsPath, this.path)
                  , at = createNS("image");
                isSafari ? this.testImageLoaded(at) : at.addEventListener("load", this._imageLoaded, !1),
                at.addEventListener("error", (function() {
                    ht.img = s,
                    this._imageLoaded()
                }
                ).bind(this), !1),
                at.setAttributeNS("http://www.w3.org/1999/xlink", "href", ot),
                this._elementHelper.append ? this._elementHelper.append(at) : this._elementHelper.appendChild(at);
                var ht = {
                    img: at,
                    assetData: it
                };
                return ht
            }
            function g(it) {
                var ot = o(it, this.assetsPath, this.path)
                  , at = createTag("img");
                at.crossOrigin = "anonymous",
                at.addEventListener("load", this._imageLoaded, !1),
                at.addEventListener("error", (function() {
                    ht.img = s,
                    this._imageLoaded()
                }
                ).bind(this), !1),
                at.src = ot;
                var ht = {
                    img: at,
                    assetData: it
                };
                return ht
            }
            function _(it) {
                var ot = {
                    assetData: it
                }
                  , at = o(it, this.assetsPath, this.path);
                return dataManager.loadData(at, (function(ht) {
                    ot.img = ht,
                    this._footageLoaded()
                }
                ).bind(this), (function() {
                    ot.img = {},
                    this._footageLoaded()
                }
                ).bind(this)),
                ot
            }
            function b(it, ot) {
                this.imagesLoadedCb = ot;
                var at, ht = it.length;
                for (at = 0; at < ht; at += 1)
                    it[at].layers || (!it[at].t || it[at].t === "seq" ? (this.totalImages += 1,
                    this.images.push(this._createImageData(it[at]))) : it[at].t === 3 && (this.totalFootages += 1,
                    this.images.push(this.createFootageData(it[at]))))
            }
            function j(it) {
                this.path = it || ""
            }
            function $(it) {
                this.assetsPath = it || ""
            }
            function nt(it) {
                for (var ot = 0, at = this.images.length; ot < at; ) {
                    if (this.images[ot].assetData === it)
                        return this.images[ot].img;
                    ot += 1
                }
                return null
            }
            function tt() {
                this.imagesLoadedCb = null,
                this.images.length = 0
            }
            function rt() {
                return this.totalImages === this.loadedAssets
            }
            function st() {
                return this.totalFootages === this.loadedFootagesCount
            }
            function lt(it, ot) {
                it === "svg" ? (this._elementHelper = ot,
                this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
            }
            function ct() {
                this._imageLoaded = e.bind(this),
                this._footageLoaded = a.bind(this),
                this.testImageLoaded = c.bind(this),
                this.createFootageData = _.bind(this),
                this.assetsPath = "",
                this.path = "",
                this.totalImages = 0,
                this.totalFootages = 0,
                this.loadedAssets = 0,
                this.loadedFootagesCount = 0,
                this.imagesLoadedCb = null,
                this.images = []
            }
            return ct.prototype = {
                loadAssets: b,
                setAssetsPath: $,
                setPath: j,
                loadedImages: rt,
                loadedFootages: st,
                destroy: tt,
                getAsset: nt,
                createImgData: g,
                createImageData: d,
                imageLoaded: e,
                footageLoaded: a,
                setCacheType: lt
            },
            ct
        }();
        function BaseEvent() {}
        BaseEvent.prototype = {
            triggerEvent: function(e, a) {
                if (this._cbs[e])
                    for (var o = this._cbs[e], c = 0; c < o.length; c += 1)
                        o[c](a)
            },
            addEventListener: function(e, a) {
                return this._cbs[e] || (this._cbs[e] = []),
                this._cbs[e].push(a),
                (function() {
                    this.removeEventListener(e, a)
                }
                ).bind(this)
            },
            removeEventListener: function(e, a) {
                if (!a)
                    this._cbs[e] = null;
                else if (this._cbs[e]) {
                    for (var o = 0, c = this._cbs[e].length; o < c; )
                        this._cbs[e][o] === a && (this._cbs[e].splice(o, 1),
                        o -= 1,
                        c -= 1),
                        o += 1;
                    this._cbs[e].length || (this._cbs[e] = null)
                }
            }
        };
        var markerParser = function() {
            function s(e) {
                for (var a = e.split(`\r
`), o = {}, c, d = 0, g = 0; g < a.length; g += 1)
                    c = a[g].split(":"),
                    c.length === 2 && (o[c[0]] = c[1].trim(),
                    d += 1);
                if (d === 0)
                    throw new Error;
                return o
            }
            return function(e) {
                for (var a = [], o = 0; o < e.length; o += 1) {
                    var c = e[o]
                      , d = {
                        time: c.tm,
                        duration: c.dr
                    };
                    try {
                        d.payload = JSON.parse(e[o].cm)
                    } catch {
                        try {
                            d.payload = s(e[o].cm)
                        } catch {
                            d.payload = {
                                name: e[o].cm
                            }
                        }
                    }
                    a.push(d)
                }
                return a
            }
        }()
          , ProjectInterface = function() {
            function s(e) {
                this.compositions.push(e)
            }
            return function() {
                function e(a) {
                    for (var o = 0, c = this.compositions.length; o < c; ) {
                        if (this.compositions[o].data && this.compositions[o].data.nm === a)
                            return this.compositions[o].prepareFrame && this.compositions[o].data.xt && this.compositions[o].prepareFrame(this.currentFrame),
                            this.compositions[o].compInterface;
                        o += 1
                    }
                    return null
                }
                return e.compositions = [],
                e.currentFrame = 0,
                e.registerComposition = s,
                e
            }
        }()
          , renderers = {}
          , registerRenderer = function(e, a) {
            renderers[e] = a
        };
        function getRenderer(s) {
            return renderers[s]
        }
        function getRegisteredRenderer() {
            if (renderers.canvas)
                return "canvas";
            for (var s in renderers)
                if (renderers[s])
                    return s;
            return ""
        }
        function _typeof$4(s) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function(a) {
                return typeof a
            }
            : _typeof$4 = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            _typeof$4(s)
        }
        var AnimationItem = function() {
            this._cbs = [],
            this.name = "",
            this.path = "",
            this.isLoaded = !1,
            this.currentFrame = 0,
            this.currentRawFrame = 0,
            this.firstFrame = 0,
            this.totalFrames = 0,
            this.frameRate = 0,
            this.frameMult = 0,
            this.playSpeed = 1,
            this.playDirection = 1,
            this.playCount = 0,
            this.animationData = {},
            this.assets = [],
            this.isPaused = !0,
            this.autoplay = !1,
            this.loop = !0,
            this.renderer = null,
            this.animationID = createElementID(),
            this.assetsPath = "",
            this.timeCompleted = 0,
            this.segmentPos = 0,
            this.isSubframeEnabled = getSubframeEnabled(),
            this.segments = [],
            this._idle = !0,
            this._completedLoop = !1,
            this.projectInterface = ProjectInterface(),
            this.imagePreloader = new ImagePreloader,
            this.audioController = audioControllerFactory(),
            this.markers = [],
            this.configAnimation = this.configAnimation.bind(this),
            this.onSetupError = this.onSetupError.bind(this),
            this.onSegmentComplete = this.onSegmentComplete.bind(this),
            this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame",0,0,0),
            this.expressionsPlugin = getExpressionsPlugin()
        };
        extendPrototype([BaseEvent], AnimationItem),
        AnimationItem.prototype.setParams = function(s) {
            (s.wrapper || s.container) && (this.wrapper = s.wrapper || s.container);
            var e = "svg";
            s.animType ? e = s.animType : s.renderer && (e = s.renderer);
            var a = getRenderer(e);
            this.renderer = new a(this,s.rendererSettings),
            this.imagePreloader.setCacheType(e, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            this.animType = e,
            s.loop === "" || s.loop === null || s.loop === void 0 || s.loop === !0 ? this.loop = !0 : s.loop === !1 ? this.loop = !1 : this.loop = parseInt(s.loop, 10),
            this.autoplay = "autoplay"in s ? s.autoplay : !0,
            this.name = s.name ? s.name : "",
            this.autoloadSegments = Object.prototype.hasOwnProperty.call(s, "autoloadSegments") ? s.autoloadSegments : !0,
            this.assetsPath = s.assetsPath,
            this.initialSegment = s.initialSegment,
            s.audioFactory && this.audioController.setAudioFactory(s.audioFactory),
            s.animationData ? this.setupAnimation(s.animationData) : s.path && (s.path.lastIndexOf("\\") !== -1 ? this.path = s.path.substr(0, s.path.lastIndexOf("\\") + 1) : this.path = s.path.substr(0, s.path.lastIndexOf("/") + 1),
            this.fileName = s.path.substr(s.path.lastIndexOf("/") + 1),
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")),
            dataManager.loadAnimation(s.path, this.configAnimation, this.onSetupError))
        }
        ,
        AnimationItem.prototype.onSetupError = function() {
            this.trigger("data_failed")
        }
        ,
        AnimationItem.prototype.setupAnimation = function(s) {
            dataManager.completeAnimation(s, this.configAnimation)
        }
        ,
        AnimationItem.prototype.setData = function(s, e) {
            e && _typeof$4(e) !== "object" && (e = JSON.parse(e));
            var a = {
                wrapper: s,
                animationData: e
            }
              , o = s.attributes;
            a.path = o.getNamedItem("data-animation-path") ? o.getNamedItem("data-animation-path").value : o.getNamedItem("data-bm-path") ? o.getNamedItem("data-bm-path").value : o.getNamedItem("bm-path") ? o.getNamedItem("bm-path").value : "",
            a.animType = o.getNamedItem("data-anim-type") ? o.getNamedItem("data-anim-type").value : o.getNamedItem("data-bm-type") ? o.getNamedItem("data-bm-type").value : o.getNamedItem("bm-type") ? o.getNamedItem("bm-type").value : o.getNamedItem("data-bm-renderer") ? o.getNamedItem("data-bm-renderer").value : o.getNamedItem("bm-renderer") ? o.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
            var c = o.getNamedItem("data-anim-loop") ? o.getNamedItem("data-anim-loop").value : o.getNamedItem("data-bm-loop") ? o.getNamedItem("data-bm-loop").value : o.getNamedItem("bm-loop") ? o.getNamedItem("bm-loop").value : "";
            c === "false" ? a.loop = !1 : c === "true" ? a.loop = !0 : c !== "" && (a.loop = parseInt(c, 10));
            var d = o.getNamedItem("data-anim-autoplay") ? o.getNamedItem("data-anim-autoplay").value : o.getNamedItem("data-bm-autoplay") ? o.getNamedItem("data-bm-autoplay").value : o.getNamedItem("bm-autoplay") ? o.getNamedItem("bm-autoplay").value : !0;
            a.autoplay = d !== "false",
            a.name = o.getNamedItem("data-name") ? o.getNamedItem("data-name").value : o.getNamedItem("data-bm-name") ? o.getNamedItem("data-bm-name").value : o.getNamedItem("bm-name") ? o.getNamedItem("bm-name").value : "";
            var g = o.getNamedItem("data-anim-prerender") ? o.getNamedItem("data-anim-prerender").value : o.getNamedItem("data-bm-prerender") ? o.getNamedItem("data-bm-prerender").value : o.getNamedItem("bm-prerender") ? o.getNamedItem("bm-prerender").value : "";
            g === "false" && (a.prerender = !1),
            a.path ? this.setParams(a) : this.trigger("destroy")
        }
        ,
        AnimationItem.prototype.includeLayers = function(s) {
            s.op > this.animationData.op && (this.animationData.op = s.op,
            this.totalFrames = Math.floor(s.op - this.animationData.ip));
            var e = this.animationData.layers, a, o = e.length, c = s.layers, d, g = c.length;
            for (d = 0; d < g; d += 1)
                for (a = 0; a < o; ) {
                    if (e[a].id === c[d].id) {
                        e[a] = c[d];
                        break
                    }
                    a += 1
                }
            if ((s.chars || s.fonts) && (this.renderer.globalData.fontManager.addChars(s.chars),
            this.renderer.globalData.fontManager.addFonts(s.fonts, this.renderer.globalData.defs)),
            s.assets)
                for (o = s.assets.length,
                a = 0; a < o; a += 1)
                    this.animationData.assets.push(s.assets[a]);
            this.animationData.__complete = !1,
            dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
        }
        ,
        AnimationItem.prototype.onSegmentComplete = function(s) {
            this.animationData = s;
            var e = getExpressionsPlugin();
            e && e.initExpressions(this),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.loadNextSegment = function() {
            var s = this.animationData.segments;
            if (!s || s.length === 0 || !this.autoloadSegments) {
                this.trigger("data_ready"),
                this.timeCompleted = this.totalFrames;
                return
            }
            var e = s.shift();
            this.timeCompleted = e.time * this.frameRate;
            var a = this.path + this.fileName + "_" + this.segmentPos + ".json";
            this.segmentPos += 1,
            dataManager.loadData(a, this.includeLayers.bind(this), (function() {
                this.trigger("data_failed")
            }
            ).bind(this))
        }
        ,
        AnimationItem.prototype.loadSegments = function() {
            var s = this.animationData.segments;
            s || (this.timeCompleted = this.totalFrames),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.imagesLoaded = function() {
            this.trigger("loaded_images"),
            this.checkLoaded()
        }
        ,
        AnimationItem.prototype.preloadImages = function() {
            this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
        }
        ,
        AnimationItem.prototype.configAnimation = function(s) {
            if (this.renderer)
                try {
                    this.animationData = s,
                    this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]),
                    this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip),
                    this.firstFrame = Math.round(this.animationData.ip)),
                    this.renderer.configAnimation(s),
                    s.assets || (s.assets = []),
                    this.assets = this.animationData.assets,
                    this.frameRate = this.animationData.fr,
                    this.frameMult = this.animationData.fr / 1e3,
                    this.renderer.searchExtraCompositions(s.assets),
                    this.markers = markerParser(s.markers || []),
                    this.trigger("config_ready"),
                    this.preloadImages(),
                    this.loadSegments(),
                    this.updaFrameModifier(),
                    this.waitForFontsLoaded(),
                    this.isPaused && this.audioController.pause()
                } catch (e) {
                    this.triggerConfigError(e)
                }
        }
        ,
        AnimationItem.prototype.waitForFontsLoaded = function() {
            this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
        }
        ,
        AnimationItem.prototype.checkLoaded = function() {
            if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
                this.isLoaded = !0;
                var s = getExpressionsPlugin();
                s && s.initExpressions(this),
                this.renderer.initItems(),
                setTimeout((function() {
                    this.trigger("DOMLoaded")
                }
                ).bind(this), 0),
                this.gotoFrame(),
                this.autoplay && this.play()
            }
        }
        ,
        AnimationItem.prototype.resize = function(s, e) {
            var a = typeof s == "number" ? s : void 0
              , o = typeof e == "number" ? e : void 0;
            this.renderer.updateContainerSize(a, o)
        }
        ,
        AnimationItem.prototype.setSubframe = function(s) {
            this.isSubframeEnabled = !!s
        }
        ,
        AnimationItem.prototype.gotoFrame = function() {
            this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame,
            this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame")
        }
        ,
        AnimationItem.prototype.renderFrame = function() {
            if (!(this.isLoaded === !1 || !this.renderer))
                try {
                    this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                    this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                } catch (s) {
                    this.triggerRenderFrameError(s)
                }
        }
        ,
        AnimationItem.prototype.play = function(s) {
            s && this.name !== s || this.isPaused === !0 && (this.isPaused = !1,
            this.trigger("_play"),
            this.audioController.resume(),
            this._idle && (this._idle = !1,
            this.trigger("_active")))
        }
        ,
        AnimationItem.prototype.pause = function(s) {
            s && this.name !== s || this.isPaused === !1 && (this.isPaused = !0,
            this.trigger("_pause"),
            this._idle = !0,
            this.trigger("_idle"),
            this.audioController.pause())
        }
        ,
        AnimationItem.prototype.togglePause = function(s) {
            s && this.name !== s || (this.isPaused === !0 ? this.play() : this.pause())
        }
        ,
        AnimationItem.prototype.stop = function(s) {
            s && this.name !== s || (this.pause(),
            this.playCount = 0,
            this._completedLoop = !1,
            this.setCurrentRawFrameValue(0))
        }
        ,
        AnimationItem.prototype.getMarkerData = function(s) {
            for (var e, a = 0; a < this.markers.length; a += 1)
                if (e = this.markers[a],
                e.payload && e.payload.name === s)
                    return e;
            return null
        }
        ,
        AnimationItem.prototype.goToAndStop = function(s, e, a) {
            if (!(a && this.name !== a)) {
                var o = Number(s);
                if (isNaN(o)) {
                    var c = this.getMarkerData(s);
                    c && this.goToAndStop(c.time, !0)
                } else
                    e ? this.setCurrentRawFrameValue(s) : this.setCurrentRawFrameValue(s * this.frameModifier);
                this.pause()
            }
        }
        ,
        AnimationItem.prototype.goToAndPlay = function(s, e, a) {
            if (!(a && this.name !== a)) {
                var o = Number(s);
                if (isNaN(o)) {
                    var c = this.getMarkerData(s);
                    c && (c.duration ? this.playSegments([c.time, c.time + c.duration], !0) : this.goToAndStop(c.time, !0))
                } else
                    this.goToAndStop(o, e, a);
                this.play()
            }
        }
        ,
        AnimationItem.prototype.advanceTime = function(s) {
            if (!(this.isPaused === !0 || this.isLoaded === !1)) {
                var e = this.currentRawFrame + s * this.frameModifier
                  , a = !1;
                e >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (a = !0,
                e = this.totalFrames - 1) : e >= this.totalFrames ? (this.playCount += 1,
                this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames),
                this._completedLoop = !0,
                this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(e) : e < 0 ? this.checkSegments(e % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames),
                this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (a = !0,
                e = 0)) : this.setCurrentRawFrameValue(e),
                a && (this.setCurrentRawFrameValue(e),
                this.pause(),
                this.trigger("complete"))
            }
        }
        ,
        AnimationItem.prototype.adjustSegment = function(s, e) {
            this.playCount = 0,
            s[1] < s[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)),
            this.totalFrames = s[0] - s[1],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = s[1],
            this.setCurrentRawFrameValue(this.totalFrames - .001 - e)) : s[1] > s[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)),
            this.totalFrames = s[1] - s[0],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = s[0],
            this.setCurrentRawFrameValue(.001 + e)),
            this.trigger("segmentStart")
        }
        ,
        AnimationItem.prototype.setSegment = function(s, e) {
            var a = -1;
            this.isPaused && (this.currentRawFrame + this.firstFrame < s ? a = s : this.currentRawFrame + this.firstFrame > e && (a = e - s)),
            this.firstFrame = s,
            this.totalFrames = e - s,
            this.timeCompleted = this.totalFrames,
            a !== -1 && this.goToAndStop(a, !0)
        }
        ,
        AnimationItem.prototype.playSegments = function(s, e) {
            if (e && (this.segments.length = 0),
            _typeof$4(s[0]) === "object") {
                var a, o = s.length;
                for (a = 0; a < o; a += 1)
                    this.segments.push(s[a])
            } else
                this.segments.push(s);
            this.segments.length && e && this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play()
        }
        ,
        AnimationItem.prototype.resetSegments = function(s) {
            this.segments.length = 0,
            this.segments.push([this.animationData.ip, this.animationData.op]),
            s && this.checkSegments(0)
        }
        ,
        AnimationItem.prototype.checkSegments = function(s) {
            return this.segments.length ? (this.adjustSegment(this.segments.shift(), s),
            !0) : !1
        }
        ,
        AnimationItem.prototype.destroy = function(s) {
            s && this.name !== s || !this.renderer || (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            this._cbs = null,
            this.onEnterFrame = null,
            this.onLoopComplete = null,
            this.onComplete = null,
            this.onSegmentStart = null,
            this.onDestroy = null,
            this.renderer = null,
            this.expressionsPlugin = null,
            this.imagePreloader = null,
            this.projectInterface = null)
        }
        ,
        AnimationItem.prototype.setCurrentRawFrameValue = function(s) {
            this.currentRawFrame = s,
            this.gotoFrame()
        }
        ,
        AnimationItem.prototype.setSpeed = function(s) {
            this.playSpeed = s,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setDirection = function(s) {
            this.playDirection = s < 0 ? -1 : 1,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setLoop = function(s) {
            this.loop = s
        }
        ,
        AnimationItem.prototype.setVolume = function(s, e) {
            e && this.name !== e || this.audioController.setVolume(s)
        }
        ,
        AnimationItem.prototype.getVolume = function() {
            return this.audioController.getVolume()
        }
        ,
        AnimationItem.prototype.mute = function(s) {
            s && this.name !== s || this.audioController.mute()
        }
        ,
        AnimationItem.prototype.unmute = function(s) {
            s && this.name !== s || this.audioController.unmute()
        }
        ,
        AnimationItem.prototype.updaFrameModifier = function() {
            this.frameModifier = this.frameMult * this.playSpeed * this.playDirection,
            this.audioController.setRate(this.playSpeed * this.playDirection)
        }
        ,
        AnimationItem.prototype.getPath = function() {
            return this.path
        }
        ,
        AnimationItem.prototype.getAssetsPath = function(s) {
            var e = "";
            if (s.e)
                e = s.p;
            else if (this.assetsPath) {
                var a = s.p;
                a.indexOf("images/") !== -1 && (a = a.split("/")[1]),
                e = this.assetsPath + a
            } else
                e = this.path,
                e += s.u ? s.u : "",
                e += s.p;
            return e
        }
        ,
        AnimationItem.prototype.getAssetData = function(s) {
            for (var e = 0, a = this.assets.length; e < a; ) {
                if (s === this.assets[e].id)
                    return this.assets[e];
                e += 1
            }
            return null
        }
        ,
        AnimationItem.prototype.hide = function() {
            this.renderer.hide()
        }
        ,
        AnimationItem.prototype.show = function() {
            this.renderer.show()
        }
        ,
        AnimationItem.prototype.getDuration = function(s) {
            return s ? this.totalFrames : this.totalFrames / this.frameRate
        }
        ,
        AnimationItem.prototype.updateDocumentData = function(s, e, a) {
            try {
                var o = this.renderer.getElementByPath(s);
                o.updateDocumentData(e, a)
            } catch {}
        }
        ,
        AnimationItem.prototype.trigger = function(s) {
            if (this._cbs && this._cbs[s])
                switch (s) {
                case "enterFrame":
                    this.triggerEvent(s, new BMEnterFrameEvent(s,this.currentFrame,this.totalFrames,this.frameModifier));
                    break;
                case "drawnFrame":
                    this.drawnFrameEvent.currentTime = this.currentFrame,
                    this.drawnFrameEvent.totalTime = this.totalFrames,
                    this.drawnFrameEvent.direction = this.frameModifier,
                    this.triggerEvent(s, this.drawnFrameEvent);
                    break;
                case "loopComplete":
                    this.triggerEvent(s, new BMCompleteLoopEvent(s,this.loop,this.playCount,this.frameMult));
                    break;
                case "complete":
                    this.triggerEvent(s, new BMCompleteEvent(s,this.frameMult));
                    break;
                case "segmentStart":
                    this.triggerEvent(s, new BMSegmentStartEvent(s,this.firstFrame,this.totalFrames));
                    break;
                case "destroy":
                    this.triggerEvent(s, new BMDestroyEvent(s,this));
                    break;
                default:
                    this.triggerEvent(s)
                }
            s === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(s,this.currentFrame,this.totalFrames,this.frameMult)),
            s === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(s,this.loop,this.playCount,this.frameMult)),
            s === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(s,this.frameMult)),
            s === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(s,this.firstFrame,this.totalFrames)),
            s === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(s,this))
        }
        ,
        AnimationItem.prototype.triggerRenderFrameError = function(s) {
            var e = new BMRenderFrameErrorEvent(s,this.currentFrame);
            this.triggerEvent("error", e),
            this.onError && this.onError.call(this, e)
        }
        ,
        AnimationItem.prototype.triggerConfigError = function(s) {
            var e = new BMConfigErrorEvent(s,this.currentFrame);
            this.triggerEvent("error", e),
            this.onError && this.onError.call(this, e)
        }
        ;
        var animationManager = function() {
            var s = {}
              , e = []
              , a = 0
              , o = 0
              , c = 0
              , d = !0
              , g = !1;
            function _(Mt) {
                for (var Tt = 0, mt = Mt.target; Tt < o; )
                    e[Tt].animation === mt && (e.splice(Tt, 1),
                    Tt -= 1,
                    o -= 1,
                    mt.isPaused || nt()),
                    Tt += 1
            }
            function b(Mt, Tt) {
                if (!Mt)
                    return null;
                for (var mt = 0; mt < o; ) {
                    if (e[mt].elem === Mt && e[mt].elem !== null)
                        return e[mt].animation;
                    mt += 1
                }
                var St = new AnimationItem;
                return tt(St, Mt),
                St.setData(Mt, Tt),
                St
            }
            function j() {
                var Mt, Tt = e.length, mt = [];
                for (Mt = 0; Mt < Tt; Mt += 1)
                    mt.push(e[Mt].animation);
                return mt
            }
            function $() {
                c += 1,
                _t()
            }
            function nt() {
                c -= 1
            }
            function tt(Mt, Tt) {
                Mt.addEventListener("destroy", _),
                Mt.addEventListener("_active", $),
                Mt.addEventListener("_idle", nt),
                e.push({
                    elem: Tt,
                    animation: Mt
                }),
                o += 1
            }
            function rt(Mt) {
                var Tt = new AnimationItem;
                return tt(Tt, null),
                Tt.setParams(Mt),
                Tt
            }
            function st(Mt, Tt) {
                var mt;
                for (mt = 0; mt < o; mt += 1)
                    e[mt].animation.setSpeed(Mt, Tt)
            }
            function lt(Mt, Tt) {
                var mt;
                for (mt = 0; mt < o; mt += 1)
                    e[mt].animation.setDirection(Mt, Tt)
            }
            function ct(Mt) {
                var Tt;
                for (Tt = 0; Tt < o; Tt += 1)
                    e[Tt].animation.play(Mt)
            }
            function it(Mt) {
                var Tt = Mt - a, mt;
                for (mt = 0; mt < o; mt += 1)
                    e[mt].animation.advanceTime(Tt);
                a = Mt,
                c && !g ? window.requestAnimationFrame(it) : d = !0
            }
            function ot(Mt) {
                a = Mt,
                window.requestAnimationFrame(it)
            }
            function at(Mt) {
                var Tt;
                for (Tt = 0; Tt < o; Tt += 1)
                    e[Tt].animation.pause(Mt)
            }
            function ht(Mt, Tt, mt) {
                var St;
                for (St = 0; St < o; St += 1)
                    e[St].animation.goToAndStop(Mt, Tt, mt)
            }
            function pt(Mt) {
                var Tt;
                for (Tt = 0; Tt < o; Tt += 1)
                    e[Tt].animation.stop(Mt)
            }
            function dt(Mt) {
                var Tt;
                for (Tt = 0; Tt < o; Tt += 1)
                    e[Tt].animation.togglePause(Mt)
            }
            function yt(Mt) {
                var Tt;
                for (Tt = o - 1; Tt >= 0; Tt -= 1)
                    e[Tt].animation.destroy(Mt)
            }
            function vt(Mt, Tt, mt) {
                var St = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), wt, Ct = St.length;
                for (wt = 0; wt < Ct; wt += 1)
                    mt && St[wt].setAttribute("data-bm-type", mt),
                    b(St[wt], Mt);
                if (Tt && Ct === 0) {
                    mt || (mt = "svg");
                    var Ht = document.getElementsByTagName("body")[0];
                    Ht.innerText = "";
                    var en = createTag("div");
                    en.style.width = "100%",
                    en.style.height = "100%",
                    en.setAttribute("data-bm-type", mt),
                    Ht.appendChild(en),
                    b(en, Mt)
                }
            }
            function xt() {
                var Mt;
                for (Mt = 0; Mt < o; Mt += 1)
                    e[Mt].animation.resize()
            }
            function _t() {
                !g && c && d && (window.requestAnimationFrame(ot),
                d = !1)
            }
            function bt() {
                g = !0
            }
            function Rt() {
                g = !1,
                _t()
            }
            function Ft(Mt, Tt) {
                var mt;
                for (mt = 0; mt < o; mt += 1)
                    e[mt].animation.setVolume(Mt, Tt)
            }
            function Bt(Mt) {
                var Tt;
                for (Tt = 0; Tt < o; Tt += 1)
                    e[Tt].animation.mute(Mt)
            }
            function Dt(Mt) {
                var Tt;
                for (Tt = 0; Tt < o; Tt += 1)
                    e[Tt].animation.unmute(Mt)
            }
            return s.registerAnimation = b,
            s.loadAnimation = rt,
            s.setSpeed = st,
            s.setDirection = lt,
            s.play = ct,
            s.pause = at,
            s.stop = pt,
            s.togglePause = dt,
            s.searchAnimations = vt,
            s.resize = xt,
            s.goToAndStop = ht,
            s.destroy = yt,
            s.freeze = bt,
            s.unfreeze = Rt,
            s.setVolume = Ft,
            s.mute = Bt,
            s.unmute = Dt,
            s.getRegisteredAnimations = j,
            s
        }()
          , BezierFactory = function() {
            var s = {};
            s.getBezierEasing = a;
            var e = {};
            function a(ot, at, ht, pt, dt) {
                var yt = dt || ("bez_" + ot + "_" + at + "_" + ht + "_" + pt).replace(/\./g, "p");
                if (e[yt])
                    return e[yt];
                var vt = new it([ot, at, ht, pt]);
                return e[yt] = vt,
                vt
            }
            var o = 4
              , c = .001
              , d = 1e-7
              , g = 10
              , _ = 11
              , b = 1 / (_ - 1)
              , j = typeof Float32Array == "function";
            function $(ot, at) {
                return 1 - 3 * at + 3 * ot
            }
            function nt(ot, at) {
                return 3 * at - 6 * ot
            }
            function tt(ot) {
                return 3 * ot
            }
            function rt(ot, at, ht) {
                return (($(at, ht) * ot + nt(at, ht)) * ot + tt(at)) * ot
            }
            function st(ot, at, ht) {
                return 3 * $(at, ht) * ot * ot + 2 * nt(at, ht) * ot + tt(at)
            }
            function lt(ot, at, ht, pt, dt) {
                var yt, vt, xt = 0;
                do
                    vt = at + (ht - at) / 2,
                    yt = rt(vt, pt, dt) - ot,
                    yt > 0 ? ht = vt : at = vt;
                while (Math.abs(yt) > d && ++xt < g);
                return vt
            }
            function ct(ot, at, ht, pt) {
                for (var dt = 0; dt < o; ++dt) {
                    var yt = st(at, ht, pt);
                    if (yt === 0)
                        return at;
                    var vt = rt(at, ht, pt) - ot;
                    at -= vt / yt
                }
                return at
            }
            function it(ot) {
                this._p = ot,
                this._mSampleValues = j ? new Float32Array(_) : new Array(_),
                this._precomputed = !1,
                this.get = this.get.bind(this)
            }
            return it.prototype = {
                get: function(at) {
                    var ht = this._p[0]
                      , pt = this._p[1]
                      , dt = this._p[2]
                      , yt = this._p[3];
                    return this._precomputed || this._precompute(),
                    ht === pt && dt === yt ? at : at === 0 ? 0 : at === 1 ? 1 : rt(this._getTForX(at), pt, yt)
                },
                _precompute: function() {
                    var at = this._p[0]
                      , ht = this._p[1]
                      , pt = this._p[2]
                      , dt = this._p[3];
                    this._precomputed = !0,
                    (at !== ht || pt !== dt) && this._calcSampleValues()
                },
                _calcSampleValues: function() {
                    for (var at = this._p[0], ht = this._p[2], pt = 0; pt < _; ++pt)
                        this._mSampleValues[pt] = rt(pt * b, at, ht)
                },
                _getTForX: function(at) {
                    for (var ht = this._p[0], pt = this._p[2], dt = this._mSampleValues, yt = 0, vt = 1, xt = _ - 1; vt !== xt && dt[vt] <= at; ++vt)
                        yt += b;
                    --vt;
                    var _t = (at - dt[vt]) / (dt[vt + 1] - dt[vt])
                      , bt = yt + _t * b
                      , Rt = st(bt, ht, pt);
                    return Rt >= c ? ct(at, bt, ht, pt) : Rt === 0 ? bt : lt(at, yt, yt + b, ht, pt)
                }
            },
            s
        }()
          , pooling = function() {
            function s(e) {
                return e.concat(createSizedArray(e.length))
            }
            return {
                double: s
            }
        }()
          , poolFactory = function() {
            return function(s, e, a) {
                var o = 0
                  , c = s
                  , d = createSizedArray(c)
                  , g = {
                    newElement: _,
                    release: b
                };
                function _() {
                    var j;
                    return o ? (o -= 1,
                    j = d[o]) : j = e(),
                    j
                }
                function b(j) {
                    o === c && (d = pooling.double(d),
                    c *= 2),
                    a && a(j),
                    d[o] = j,
                    o += 1
                }
                return g
            }
        }()
          , bezierLengthPool = function() {
            function s() {
                return {
                    addedLength: 0,
                    percents: createTypedArray("float32", getDefaultCurveSegments()),
                    lengths: createTypedArray("float32", getDefaultCurveSegments())
                }
            }
            return poolFactory(8, s)
        }()
          , segmentsLengthPool = function() {
            function s() {
                return {
                    lengths: [],
                    totalLength: 0
                }
            }
            function e(a) {
                var o, c = a.lengths.length;
                for (o = 0; o < c; o += 1)
                    bezierLengthPool.release(a.lengths[o]);
                a.lengths.length = 0
            }
            return poolFactory(8, s, e)
        }();
        function bezFunction() {
            var s = Math;
            function e(tt, rt, st, lt, ct, it) {
                var ot = tt * lt + rt * ct + st * it - ct * lt - it * tt - st * rt;
                return ot > -.001 && ot < .001
            }
            function a(tt, rt, st, lt, ct, it, ot, at, ht) {
                if (st === 0 && it === 0 && ht === 0)
                    return e(tt, rt, lt, ct, ot, at);
                var pt = s.sqrt(s.pow(lt - tt, 2) + s.pow(ct - rt, 2) + s.pow(it - st, 2)), dt = s.sqrt(s.pow(ot - tt, 2) + s.pow(at - rt, 2) + s.pow(ht - st, 2)), yt = s.sqrt(s.pow(ot - lt, 2) + s.pow(at - ct, 2) + s.pow(ht - it, 2)), vt;
                return pt > dt ? pt > yt ? vt = pt - dt - yt : vt = yt - dt - pt : yt > dt ? vt = yt - dt - pt : vt = dt - pt - yt,
                vt > -1e-4 && vt < 1e-4
            }
            var o = function() {
                return function(tt, rt, st, lt) {
                    var ct = getDefaultCurveSegments(), it, ot, at, ht, pt, dt = 0, yt, vt = [], xt = [], _t = bezierLengthPool.newElement();
                    for (at = st.length,
                    it = 0; it < ct; it += 1) {
                        for (pt = it / (ct - 1),
                        yt = 0,
                        ot = 0; ot < at; ot += 1)
                            ht = bmPow(1 - pt, 3) * tt[ot] + 3 * bmPow(1 - pt, 2) * pt * st[ot] + 3 * (1 - pt) * bmPow(pt, 2) * lt[ot] + bmPow(pt, 3) * rt[ot],
                            vt[ot] = ht,
                            xt[ot] !== null && (yt += bmPow(vt[ot] - xt[ot], 2)),
                            xt[ot] = vt[ot];
                        yt && (yt = bmSqrt(yt),
                        dt += yt),
                        _t.percents[it] = pt,
                        _t.lengths[it] = dt
                    }
                    return _t.addedLength = dt,
                    _t
                }
            }();
            function c(tt) {
                var rt = segmentsLengthPool.newElement(), st = tt.c, lt = tt.v, ct = tt.o, it = tt.i, ot, at = tt._length, ht = rt.lengths, pt = 0;
                for (ot = 0; ot < at - 1; ot += 1)
                    ht[ot] = o(lt[ot], lt[ot + 1], ct[ot], it[ot + 1]),
                    pt += ht[ot].addedLength;
                return st && at && (ht[ot] = o(lt[ot], lt[0], ct[ot], it[0]),
                pt += ht[ot].addedLength),
                rt.totalLength = pt,
                rt
            }
            function d(tt) {
                this.segmentLength = 0,
                this.points = new Array(tt)
            }
            function g(tt, rt) {
                this.partialLength = tt,
                this.point = rt
            }
            var _ = function() {
                var tt = {};
                return function(rt, st, lt, ct) {
                    var it = (rt[0] + "_" + rt[1] + "_" + st[0] + "_" + st[1] + "_" + lt[0] + "_" + lt[1] + "_" + ct[0] + "_" + ct[1]).replace(/\./g, "p");
                    if (!tt[it]) {
                        var ot = getDefaultCurveSegments(), at, ht, pt, dt, yt, vt = 0, xt, _t, bt = null;
                        rt.length === 2 && (rt[0] !== st[0] || rt[1] !== st[1]) && e(rt[0], rt[1], st[0], st[1], rt[0] + lt[0], rt[1] + lt[1]) && e(rt[0], rt[1], st[0], st[1], st[0] + ct[0], st[1] + ct[1]) && (ot = 2);
                        var Rt = new d(ot);
                        for (pt = lt.length,
                        at = 0; at < ot; at += 1) {
                            for (_t = createSizedArray(pt),
                            yt = at / (ot - 1),
                            xt = 0,
                            ht = 0; ht < pt; ht += 1)
                                dt = bmPow(1 - yt, 3) * rt[ht] + 3 * bmPow(1 - yt, 2) * yt * (rt[ht] + lt[ht]) + 3 * (1 - yt) * bmPow(yt, 2) * (st[ht] + ct[ht]) + bmPow(yt, 3) * st[ht],
                                _t[ht] = dt,
                                bt !== null && (xt += bmPow(_t[ht] - bt[ht], 2));
                            xt = bmSqrt(xt),
                            vt += xt,
                            Rt.points[at] = new g(xt,_t),
                            bt = _t
                        }
                        Rt.segmentLength = vt,
                        tt[it] = Rt
                    }
                    return tt[it]
                }
            }();
            function b(tt, rt) {
                var st = rt.percents
                  , lt = rt.lengths
                  , ct = st.length
                  , it = bmFloor((ct - 1) * tt)
                  , ot = tt * rt.addedLength
                  , at = 0;
                if (it === ct - 1 || it === 0 || ot === lt[it])
                    return st[it];
                for (var ht = lt[it] > ot ? -1 : 1, pt = !0; pt; )
                    if (lt[it] <= ot && lt[it + 1] > ot ? (at = (ot - lt[it]) / (lt[it + 1] - lt[it]),
                    pt = !1) : it += ht,
                    it < 0 || it >= ct - 1) {
                        if (it === ct - 1)
                            return st[it];
                        pt = !1
                    }
                return st[it] + (st[it + 1] - st[it]) * at
            }
            function j(tt, rt, st, lt, ct, it) {
                var ot = b(ct, it)
                  , at = 1 - ot
                  , ht = s.round((at * at * at * tt[0] + (ot * at * at + at * ot * at + at * at * ot) * st[0] + (ot * ot * at + at * ot * ot + ot * at * ot) * lt[0] + ot * ot * ot * rt[0]) * 1e3) / 1e3
                  , pt = s.round((at * at * at * tt[1] + (ot * at * at + at * ot * at + at * at * ot) * st[1] + (ot * ot * at + at * ot * ot + ot * at * ot) * lt[1] + ot * ot * ot * rt[1]) * 1e3) / 1e3;
                return [ht, pt]
            }
            var $ = createTypedArray("float32", 8);
            function nt(tt, rt, st, lt, ct, it, ot) {
                ct < 0 ? ct = 0 : ct > 1 && (ct = 1);
                var at = b(ct, ot);
                it = it > 1 ? 1 : it;
                var ht = b(it, ot), pt, dt = tt.length, yt = 1 - at, vt = 1 - ht, xt = yt * yt * yt, _t = at * yt * yt * 3, bt = at * at * yt * 3, Rt = at * at * at, Ft = yt * yt * vt, Bt = at * yt * vt + yt * at * vt + yt * yt * ht, Dt = at * at * vt + yt * at * ht + at * yt * ht, Mt = at * at * ht, Tt = yt * vt * vt, mt = at * vt * vt + yt * ht * vt + yt * vt * ht, St = at * ht * vt + yt * ht * ht + at * vt * ht, wt = at * ht * ht, Ct = vt * vt * vt, Ht = ht * vt * vt + vt * ht * vt + vt * vt * ht, en = ht * ht * vt + vt * ht * ht + ht * vt * ht, Ot = ht * ht * ht;
                for (pt = 0; pt < dt; pt += 1)
                    $[pt * 4] = s.round((xt * tt[pt] + _t * st[pt] + bt * lt[pt] + Rt * rt[pt]) * 1e3) / 1e3,
                    $[pt * 4 + 1] = s.round((Ft * tt[pt] + Bt * st[pt] + Dt * lt[pt] + Mt * rt[pt]) * 1e3) / 1e3,
                    $[pt * 4 + 2] = s.round((Tt * tt[pt] + mt * st[pt] + St * lt[pt] + wt * rt[pt]) * 1e3) / 1e3,
                    $[pt * 4 + 3] = s.round((Ct * tt[pt] + Ht * st[pt] + en * lt[pt] + Ot * rt[pt]) * 1e3) / 1e3;
                return $
            }
            return {
                getSegmentsLength: c,
                getNewSegment: nt,
                getPointInSegment: j,
                buildBezierData: _,
                pointOnLine2D: e,
                pointOnLine3D: a
            }
        }
        var bez = bezFunction()
          , initFrame = initialDefaultFrame
          , mathAbs = Math.abs;
        function interpolateValue(s, e) {
            var a = this.offsetTime, o;
            this.propType === "multidimensional" && (o = createTypedArray("float32", this.pv.length));
            for (var c = e.lastIndex, d = c, g = this.keyframes.length - 1, _ = !0, b, j, $; _; ) {
                if (b = this.keyframes[d],
                j = this.keyframes[d + 1],
                d === g - 1 && s >= j.t - a) {
                    b.h && (b = j),
                    c = 0;
                    break
                }
                if (j.t - a > s) {
                    c = d;
                    break
                }
                d < g - 1 ? d += 1 : (c = 0,
                _ = !1)
            }
            $ = this.keyframesMetadata[d] || {};
            var nt, tt, rt, st, lt, ct, it = j.t - a, ot = b.t - a, at;
            if (b.to) {
                $.bezierData || ($.bezierData = bez.buildBezierData(b.s, j.s || b.e, b.to, b.ti));
                var ht = $.bezierData;
                if (s >= it || s < ot) {
                    var pt = s >= it ? ht.points.length - 1 : 0;
                    for (tt = ht.points[pt].point.length,
                    nt = 0; nt < tt; nt += 1)
                        o[nt] = ht.points[pt].point[nt]
                } else {
                    $.__fnct ? ct = $.__fnct : (ct = BezierFactory.getBezierEasing(b.o.x, b.o.y, b.i.x, b.i.y, b.n).get,
                    $.__fnct = ct),
                    rt = ct((s - ot) / (it - ot));
                    var dt = ht.segmentLength * rt, yt, vt = e.lastFrame < s && e._lastKeyframeIndex === d ? e._lastAddedLength : 0;
                    for (lt = e.lastFrame < s && e._lastKeyframeIndex === d ? e._lastPoint : 0,
                    _ = !0,
                    st = ht.points.length; _; ) {
                        if (vt += ht.points[lt].partialLength,
                        dt === 0 || rt === 0 || lt === ht.points.length - 1) {
                            for (tt = ht.points[lt].point.length,
                            nt = 0; nt < tt; nt += 1)
                                o[nt] = ht.points[lt].point[nt];
                            break
                        } else if (dt >= vt && dt < vt + ht.points[lt + 1].partialLength) {
                            for (yt = (dt - vt) / ht.points[lt + 1].partialLength,
                            tt = ht.points[lt].point.length,
                            nt = 0; nt < tt; nt += 1)
                                o[nt] = ht.points[lt].point[nt] + (ht.points[lt + 1].point[nt] - ht.points[lt].point[nt]) * yt;
                            break
                        }
                        lt < st - 1 ? lt += 1 : _ = !1
                    }
                    e._lastPoint = lt,
                    e._lastAddedLength = vt - ht.points[lt].partialLength,
                    e._lastKeyframeIndex = d
                }
            } else {
                var xt, _t, bt, Rt, Ft;
                if (g = b.s.length,
                at = j.s || b.e,
                this.sh && b.h !== 1)
                    if (s >= it)
                        o[0] = at[0],
                        o[1] = at[1],
                        o[2] = at[2];
                    else if (s <= ot)
                        o[0] = b.s[0],
                        o[1] = b.s[1],
                        o[2] = b.s[2];
                    else {
                        var Bt = createQuaternion(b.s)
                          , Dt = createQuaternion(at)
                          , Mt = (s - ot) / (it - ot);
                        quaternionToEuler(o, slerp(Bt, Dt, Mt))
                    }
                else
                    for (d = 0; d < g; d += 1)
                        b.h !== 1 && (s >= it ? rt = 1 : s < ot ? rt = 0 : (b.o.x.constructor === Array ? ($.__fnct || ($.__fnct = []),
                        $.__fnct[d] ? ct = $.__fnct[d] : (xt = b.o.x[d] === void 0 ? b.o.x[0] : b.o.x[d],
                        _t = b.o.y[d] === void 0 ? b.o.y[0] : b.o.y[d],
                        bt = b.i.x[d] === void 0 ? b.i.x[0] : b.i.x[d],
                        Rt = b.i.y[d] === void 0 ? b.i.y[0] : b.i.y[d],
                        ct = BezierFactory.getBezierEasing(xt, _t, bt, Rt).get,
                        $.__fnct[d] = ct)) : $.__fnct ? ct = $.__fnct : (xt = b.o.x,
                        _t = b.o.y,
                        bt = b.i.x,
                        Rt = b.i.y,
                        ct = BezierFactory.getBezierEasing(xt, _t, bt, Rt).get,
                        b.keyframeMetadata = ct),
                        rt = ct((s - ot) / (it - ot)))),
                        at = j.s || b.e,
                        Ft = b.h === 1 ? b.s[d] : b.s[d] + (at[d] - b.s[d]) * rt,
                        this.propType === "multidimensional" ? o[d] = Ft : o = Ft
            }
            return e.lastIndex = c,
            o
        }
        function slerp(s, e, a) {
            var o = [], c = s[0], d = s[1], g = s[2], _ = s[3], b = e[0], j = e[1], $ = e[2], nt = e[3], tt, rt, st, lt, ct;
            return rt = c * b + d * j + g * $ + _ * nt,
            rt < 0 && (rt = -rt,
            b = -b,
            j = -j,
            $ = -$,
            nt = -nt),
            1 - rt > 1e-6 ? (tt = Math.acos(rt),
            st = Math.sin(tt),
            lt = Math.sin((1 - a) * tt) / st,
            ct = Math.sin(a * tt) / st) : (lt = 1 - a,
            ct = a),
            o[0] = lt * c + ct * b,
            o[1] = lt * d + ct * j,
            o[2] = lt * g + ct * $,
            o[3] = lt * _ + ct * nt,
            o
        }
        function quaternionToEuler(s, e) {
            var a = e[0]
              , o = e[1]
              , c = e[2]
              , d = e[3]
              , g = Math.atan2(2 * o * d - 2 * a * c, 1 - 2 * o * o - 2 * c * c)
              , _ = Math.asin(2 * a * o + 2 * c * d)
              , b = Math.atan2(2 * a * d - 2 * o * c, 1 - 2 * a * a - 2 * c * c);
            s[0] = g / degToRads,
            s[1] = _ / degToRads,
            s[2] = b / degToRads
        }
        function createQuaternion(s) {
            var e = s[0] * degToRads
              , a = s[1] * degToRads
              , o = s[2] * degToRads
              , c = Math.cos(e / 2)
              , d = Math.cos(a / 2)
              , g = Math.cos(o / 2)
              , _ = Math.sin(e / 2)
              , b = Math.sin(a / 2)
              , j = Math.sin(o / 2)
              , $ = c * d * g - _ * b * j
              , nt = _ * b * g + c * d * j
              , tt = _ * d * g + c * b * j
              , rt = c * b * g - _ * d * j;
            return [nt, tt, rt, $]
        }
        function getValueAtCurrentTime() {
            var s = this.comp.renderedFrame - this.offsetTime
              , e = this.keyframes[0].t - this.offsetTime
              , a = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            if (!(s === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= a && s >= a || this._caching.lastFrame < e && s < e))) {
                this._caching.lastFrame >= s && (this._caching._lastKeyframeIndex = -1,
                this._caching.lastIndex = 0);
                var o = this.interpolateValue(s, this._caching);
                this.pv = o
            }
            return this._caching.lastFrame = s,
            this.pv
        }
        function setVValue(s) {
            var e;
            if (this.propType === "unidimensional")
                e = s * this.mult,
                mathAbs(this.v - e) > 1e-5 && (this.v = e,
                this._mdf = !0);
            else
                for (var a = 0, o = this.v.length; a < o; )
                    e = s[a] * this.mult,
                    mathAbs(this.v[a] - e) > 1e-5 && (this.v[a] = e,
                    this._mdf = !0),
                    a += 1
        }
        function processEffectsSequence() {
            if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
                if (this.lock) {
                    this.setVValue(this.pv);
                    return
                }
                this.lock = !0,
                this._mdf = this._isFirstFrame;
                var s, e = this.effectsSequence.length, a = this.kf ? this.pv : this.data.k;
                for (s = 0; s < e; s += 1)
                    a = this.effectsSequence[s](a);
                this.setVValue(a),
                this._isFirstFrame = !1,
                this.lock = !1,
                this.frameId = this.elem.globalData.frameId
            }
        }
        function addEffect(s) {
            this.effectsSequence.push(s),
            this.container.addDynamicProperty(this)
        }
        function ValueProperty(s, e, a, o) {
            this.propType = "unidimensional",
            this.mult = a || 1,
            this.data = e,
            this.v = a ? e.k * a : e.k,
            this.pv = e.k,
            this._mdf = !1,
            this.elem = s,
            this.container = o,
            this.comp = s.comp,
            this.k = !1,
            this.kf = !1,
            this.vel = 0,
            this.effectsSequence = [],
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function MultiDimensionalProperty(s, e, a, o) {
            this.propType = "multidimensional",
            this.mult = a || 1,
            this.data = e,
            this._mdf = !1,
            this.elem = s,
            this.container = o,
            this.comp = s.comp,
            this.k = !1,
            this.kf = !1,
            this.frameId = -1;
            var c, d = e.k.length;
            for (this.v = createTypedArray("float32", d),
            this.pv = createTypedArray("float32", d),
            this.vel = createTypedArray("float32", d),
            c = 0; c < d; c += 1)
                this.v[c] = e.k[c] * this.mult,
                this.pv[c] = e.k[c];
            this._isFirstFrame = !0,
            this.effectsSequence = [],
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function KeyframedValueProperty(s, e, a, o) {
            this.propType = "unidimensional",
            this.keyframes = e.k,
            this.keyframesMetadata = [],
            this.offsetTime = s.data.st,
            this.frameId = -1,
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1
            },
            this.k = !0,
            this.kf = !0,
            this.data = e,
            this.mult = a || 1,
            this.elem = s,
            this.container = o,
            this.comp = s.comp,
            this.v = initFrame,
            this.pv = initFrame,
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.addEffect = addEffect
        }
        function KeyframedMultidimensionalProperty(s, e, a, o) {
            this.propType = "multidimensional";
            var c, d = e.k.length, g, _, b, j;
            for (c = 0; c < d - 1; c += 1)
                e.k[c].to && e.k[c].s && e.k[c + 1] && e.k[c + 1].s && (g = e.k[c].s,
                _ = e.k[c + 1].s,
                b = e.k[c].to,
                j = e.k[c].ti,
                (g.length === 2 && !(g[0] === _[0] && g[1] === _[1]) && bez.pointOnLine2D(g[0], g[1], _[0], _[1], g[0] + b[0], g[1] + b[1]) && bez.pointOnLine2D(g[0], g[1], _[0], _[1], _[0] + j[0], _[1] + j[1]) || g.length === 3 && !(g[0] === _[0] && g[1] === _[1] && g[2] === _[2]) && bez.pointOnLine3D(g[0], g[1], g[2], _[0], _[1], _[2], g[0] + b[0], g[1] + b[1], g[2] + b[2]) && bez.pointOnLine3D(g[0], g[1], g[2], _[0], _[1], _[2], _[0] + j[0], _[1] + j[1], _[2] + j[2])) && (e.k[c].to = null,
                e.k[c].ti = null),
                g[0] === _[0] && g[1] === _[1] && b[0] === 0 && b[1] === 0 && j[0] === 0 && j[1] === 0 && (g.length === 2 || g[2] === _[2] && b[2] === 0 && j[2] === 0) && (e.k[c].to = null,
                e.k[c].ti = null));
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.data = e,
            this.keyframes = e.k,
            this.keyframesMetadata = [],
            this.offsetTime = s.data.st,
            this.k = !0,
            this.kf = !0,
            this._isFirstFrame = !0,
            this.mult = a || 1,
            this.elem = s,
            this.container = o,
            this.comp = s.comp,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.frameId = -1;
            var $ = e.k[0].s.length;
            for (this.v = createTypedArray("float32", $),
            this.pv = createTypedArray("float32", $),
            c = 0; c < $; c += 1)
                this.v[c] = initFrame,
                this.pv[c] = initFrame;
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray("float32", $)
            },
            this.addEffect = addEffect
        }
        var PropertyFactory = function() {
            function s(a, o, c, d, g) {
                o.sid && (o = a.globalData.slotManager.getProp(o));
                var _;
                if (!o.k.length)
                    _ = new ValueProperty(a,o,d,g);
                else if (typeof o.k[0] == "number")
                    _ = new MultiDimensionalProperty(a,o,d,g);
                else
                    switch (c) {
                    case 0:
                        _ = new KeyframedValueProperty(a,o,d,g);
                        break;
                    case 1:
                        _ = new KeyframedMultidimensionalProperty(a,o,d,g);
                        break
                    }
                return _.effectsSequence.length && g.addDynamicProperty(_),
                _
            }
            var e = {
                getProp: s
            };
            return e
        }();
        function DynamicPropertyContainer() {}
        DynamicPropertyContainer.prototype = {
            addDynamicProperty: function(e) {
                this.dynamicProperties.indexOf(e) === -1 && (this.dynamicProperties.push(e),
                this.container.addDynamicProperty(this),
                this._isAnimated = !0)
            },
            iterateDynamicProperties: function() {
                this._mdf = !1;
                var e, a = this.dynamicProperties.length;
                for (e = 0; e < a; e += 1)
                    this.dynamicProperties[e].getValue(),
                    this.dynamicProperties[e]._mdf && (this._mdf = !0)
            },
            initDynamicPropertyContainer: function(e) {
                this.container = e,
                this.dynamicProperties = [],
                this._mdf = !1,
                this._isAnimated = !1
            }
        };
        var pointPool = function() {
            function s() {
                return createTypedArray("float32", 2)
            }
            return poolFactory(8, s)
        }();
        function ShapePath() {
            this.c = !1,
            this._length = 0,
            this._maxLength = 8,
            this.v = createSizedArray(this._maxLength),
            this.o = createSizedArray(this._maxLength),
            this.i = createSizedArray(this._maxLength)
        }
        ShapePath.prototype.setPathData = function(s, e) {
            this.c = s,
            this.setLength(e);
            for (var a = 0; a < e; )
                this.v[a] = pointPool.newElement(),
                this.o[a] = pointPool.newElement(),
                this.i[a] = pointPool.newElement(),
                a += 1
        }
        ,
        ShapePath.prototype.setLength = function(s) {
            for (; this._maxLength < s; )
                this.doubleArrayLength();
            this._length = s
        }
        ,
        ShapePath.prototype.doubleArrayLength = function() {
            this.v = this.v.concat(createSizedArray(this._maxLength)),
            this.i = this.i.concat(createSizedArray(this._maxLength)),
            this.o = this.o.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2
        }
        ,
        ShapePath.prototype.setXYAt = function(s, e, a, o, c) {
            var d;
            switch (this._length = Math.max(this._length, o + 1),
            this._length >= this._maxLength && this.doubleArrayLength(),
            a) {
            case "v":
                d = this.v;
                break;
            case "i":
                d = this.i;
                break;
            case "o":
                d = this.o;
                break;
            default:
                d = [];
                break
            }
            (!d[o] || d[o] && !c) && (d[o] = pointPool.newElement()),
            d[o][0] = s,
            d[o][1] = e
        }
        ,
        ShapePath.prototype.setTripleAt = function(s, e, a, o, c, d, g, _) {
            this.setXYAt(s, e, "v", g, _),
            this.setXYAt(a, o, "o", g, _),
            this.setXYAt(c, d, "i", g, _)
        }
        ,
        ShapePath.prototype.reverse = function() {
            var s = new ShapePath;
            s.setPathData(this.c, this._length);
            var e = this.v
              , a = this.o
              , o = this.i
              , c = 0;
            this.c && (s.setTripleAt(e[0][0], e[0][1], o[0][0], o[0][1], a[0][0], a[0][1], 0, !1),
            c = 1);
            var d = this._length - 1, g = this._length, _;
            for (_ = c; _ < g; _ += 1)
                s.setTripleAt(e[d][0], e[d][1], o[d][0], o[d][1], a[d][0], a[d][1], _, !1),
                d -= 1;
            return s
        }
        ,
        ShapePath.prototype.length = function() {
            return this._length
        }
        ;
        var shapePool = function() {
            function s() {
                return new ShapePath
            }
            function e(c) {
                var d = c._length, g;
                for (g = 0; g < d; g += 1)
                    pointPool.release(c.v[g]),
                    pointPool.release(c.i[g]),
                    pointPool.release(c.o[g]),
                    c.v[g] = null,
                    c.i[g] = null,
                    c.o[g] = null;
                c._length = 0,
                c.c = !1
            }
            function a(c) {
                var d = o.newElement(), g, _ = c._length === void 0 ? c.v.length : c._length;
                for (d.setLength(_),
                d.c = c.c,
                g = 0; g < _; g += 1)
                    d.setTripleAt(c.v[g][0], c.v[g][1], c.o[g][0], c.o[g][1], c.i[g][0], c.i[g][1], g);
                return d
            }
            var o = poolFactory(4, s, e);
            return o.clone = a,
            o
        }();
        function ShapeCollection() {
            this._length = 0,
            this._maxLength = 4,
            this.shapes = createSizedArray(this._maxLength)
        }
        ShapeCollection.prototype.addShape = function(s) {
            this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2),
            this.shapes[this._length] = s,
            this._length += 1
        }
        ,
        ShapeCollection.prototype.releaseShapes = function() {
            var s;
            for (s = 0; s < this._length; s += 1)
                shapePool.release(this.shapes[s]);
            this._length = 0
        }
        ;
        var shapeCollectionPool = function() {
            var s = {
                newShapeCollection: c,
                release: d
            }
              , e = 0
              , a = 4
              , o = createSizedArray(a);
            function c() {
                var g;
                return e ? (e -= 1,
                g = o[e]) : g = new ShapeCollection,
                g
            }
            function d(g) {
                var _, b = g._length;
                for (_ = 0; _ < b; _ += 1)
                    shapePool.release(g.shapes[_]);
                g._length = 0,
                e === a && (o = pooling.double(o),
                a *= 2),
                o[e] = g,
                e += 1
            }
            return s
        }()
          , ShapePropertyFactory = function() {
            var s = -999999;
            function e(it, ot, at) {
                var ht = at.lastIndex, pt, dt, yt, vt, xt, _t, bt, Rt, Ft, Bt = this.keyframes;
                if (it < Bt[0].t - this.offsetTime)
                    pt = Bt[0].s[0],
                    yt = !0,
                    ht = 0;
                else if (it >= Bt[Bt.length - 1].t - this.offsetTime)
                    pt = Bt[Bt.length - 1].s ? Bt[Bt.length - 1].s[0] : Bt[Bt.length - 2].e[0],
                    yt = !0;
                else {
                    for (var Dt = ht, Mt = Bt.length - 1, Tt = !0, mt, St, wt; Tt && (mt = Bt[Dt],
                    St = Bt[Dt + 1],
                    !(St.t - this.offsetTime > it)); )
                        Dt < Mt - 1 ? Dt += 1 : Tt = !1;
                    if (wt = this.keyframesMetadata[Dt] || {},
                    yt = mt.h === 1,
                    ht = Dt,
                    !yt) {
                        if (it >= St.t - this.offsetTime)
                            Rt = 1;
                        else if (it < mt.t - this.offsetTime)
                            Rt = 0;
                        else {
                            var Ct;
                            wt.__fnct ? Ct = wt.__fnct : (Ct = BezierFactory.getBezierEasing(mt.o.x, mt.o.y, mt.i.x, mt.i.y).get,
                            wt.__fnct = Ct),
                            Rt = Ct((it - (mt.t - this.offsetTime)) / (St.t - this.offsetTime - (mt.t - this.offsetTime)))
                        }
                        dt = St.s ? St.s[0] : mt.e[0]
                    }
                    pt = mt.s[0]
                }
                for (_t = ot._length,
                bt = pt.i[0].length,
                at.lastIndex = ht,
                vt = 0; vt < _t; vt += 1)
                    for (xt = 0; xt < bt; xt += 1)
                        Ft = yt ? pt.i[vt][xt] : pt.i[vt][xt] + (dt.i[vt][xt] - pt.i[vt][xt]) * Rt,
                        ot.i[vt][xt] = Ft,
                        Ft = yt ? pt.o[vt][xt] : pt.o[vt][xt] + (dt.o[vt][xt] - pt.o[vt][xt]) * Rt,
                        ot.o[vt][xt] = Ft,
                        Ft = yt ? pt.v[vt][xt] : pt.v[vt][xt] + (dt.v[vt][xt] - pt.v[vt][xt]) * Rt,
                        ot.v[vt][xt] = Ft
            }
            function a() {
                var it = this.comp.renderedFrame - this.offsetTime
                  , ot = this.keyframes[0].t - this.offsetTime
                  , at = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
                  , ht = this._caching.lastFrame;
                return ht !== s && (ht < ot && it < ot || ht > at && it > at) || (this._caching.lastIndex = ht < it ? this._caching.lastIndex : 0,
                this.interpolateShape(it, this.pv, this._caching)),
                this._caching.lastFrame = it,
                this.pv
            }
            function o() {
                this.paths = this.localShapeCollection
            }
            function c(it, ot) {
                if (it._length !== ot._length || it.c !== ot.c)
                    return !1;
                var at, ht = it._length;
                for (at = 0; at < ht; at += 1)
                    if (it.v[at][0] !== ot.v[at][0] || it.v[at][1] !== ot.v[at][1] || it.o[at][0] !== ot.o[at][0] || it.o[at][1] !== ot.o[at][1] || it.i[at][0] !== ot.i[at][0] || it.i[at][1] !== ot.i[at][1])
                        return !1;
                return !0
            }
            function d(it) {
                c(this.v, it) || (this.v = shapePool.clone(it),
                this.localShapeCollection.releaseShapes(),
                this.localShapeCollection.addShape(this.v),
                this._mdf = !0,
                this.paths = this.localShapeCollection)
            }
            function g() {
                if (this.elem.globalData.frameId !== this.frameId) {
                    if (!this.effectsSequence.length) {
                        this._mdf = !1;
                        return
                    }
                    if (this.lock) {
                        this.setVValue(this.pv);
                        return
                    }
                    this.lock = !0,
                    this._mdf = !1;
                    var it;
                    this.kf ? it = this.pv : this.data.ks ? it = this.data.ks.k : it = this.data.pt.k;
                    var ot, at = this.effectsSequence.length;
                    for (ot = 0; ot < at; ot += 1)
                        it = this.effectsSequence[ot](it);
                    this.setVValue(it),
                    this.lock = !1,
                    this.frameId = this.elem.globalData.frameId
                }
            }
            function _(it, ot, at) {
                this.propType = "shape",
                this.comp = it.comp,
                this.container = it,
                this.elem = it,
                this.data = ot,
                this.k = !1,
                this.kf = !1,
                this._mdf = !1;
                var ht = at === 3 ? ot.pt.k : ot.ks.k;
                this.v = shapePool.clone(ht),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.reset = o,
                this.effectsSequence = []
            }
            function b(it) {
                this.effectsSequence.push(it),
                this.container.addDynamicProperty(this)
            }
            _.prototype.interpolateShape = e,
            _.prototype.getValue = g,
            _.prototype.setVValue = d,
            _.prototype.addEffect = b;
            function j(it, ot, at) {
                this.propType = "shape",
                this.comp = it.comp,
                this.elem = it,
                this.container = it,
                this.offsetTime = it.data.st,
                this.keyframes = at === 3 ? ot.pt.k : ot.ks.k,
                this.keyframesMetadata = [],
                this.k = !0,
                this.kf = !0;
                var ht = this.keyframes[0].s[0].i.length;
                this.v = shapePool.newElement(),
                this.v.setPathData(this.keyframes[0].s[0].c, ht),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.lastFrame = s,
                this.reset = o,
                this._caching = {
                    lastFrame: s,
                    lastIndex: 0
                },
                this.effectsSequence = [a.bind(this)]
            }
            j.prototype.getValue = g,
            j.prototype.interpolateShape = e,
            j.prototype.setVValue = d,
            j.prototype.addEffect = b;
            var $ = function() {
                var it = roundCorner;
                function ot(at, ht) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 4),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.paths = this.localShapeCollection,
                    this.localShapeCollection.addShape(this.v),
                    this.d = ht.d,
                    this.elem = at,
                    this.comp = at.comp,
                    this.frameId = -1,
                    this.initDynamicPropertyContainer(at),
                    this.p = PropertyFactory.getProp(at, ht.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(at, ht.s, 1, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertEllToPath())
                }
                return ot.prototype = {
                    reset: o,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertEllToPath())
                    },
                    convertEllToPath: function() {
                        var ht = this.p.v[0]
                          , pt = this.p.v[1]
                          , dt = this.s.v[0] / 2
                          , yt = this.s.v[1] / 2
                          , vt = this.d !== 3
                          , xt = this.v;
                        xt.v[0][0] = ht,
                        xt.v[0][1] = pt - yt,
                        xt.v[1][0] = vt ? ht + dt : ht - dt,
                        xt.v[1][1] = pt,
                        xt.v[2][0] = ht,
                        xt.v[2][1] = pt + yt,
                        xt.v[3][0] = vt ? ht - dt : ht + dt,
                        xt.v[3][1] = pt,
                        xt.i[0][0] = vt ? ht - dt * it : ht + dt * it,
                        xt.i[0][1] = pt - yt,
                        xt.i[1][0] = vt ? ht + dt : ht - dt,
                        xt.i[1][1] = pt - yt * it,
                        xt.i[2][0] = vt ? ht + dt * it : ht - dt * it,
                        xt.i[2][1] = pt + yt,
                        xt.i[3][0] = vt ? ht - dt : ht + dt,
                        xt.i[3][1] = pt + yt * it,
                        xt.o[0][0] = vt ? ht + dt * it : ht - dt * it,
                        xt.o[0][1] = pt - yt,
                        xt.o[1][0] = vt ? ht + dt : ht - dt,
                        xt.o[1][1] = pt + yt * it,
                        xt.o[2][0] = vt ? ht - dt * it : ht + dt * it,
                        xt.o[2][1] = pt + yt,
                        xt.o[3][0] = vt ? ht - dt : ht + dt,
                        xt.o[3][1] = pt - yt * it
                    }
                },
                extendPrototype([DynamicPropertyContainer], ot),
                ot
            }()
              , nt = function() {
                function it(ot, at) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 0),
                    this.elem = ot,
                    this.comp = ot.comp,
                    this.data = at,
                    this.frameId = -1,
                    this.d = at.d,
                    this.initDynamicPropertyContainer(ot),
                    at.sy === 1 ? (this.ir = PropertyFactory.getProp(ot, at.ir, 0, 0, this),
                    this.is = PropertyFactory.getProp(ot, at.is, 0, .01, this),
                    this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath,
                    this.pt = PropertyFactory.getProp(ot, at.pt, 0, 0, this),
                    this.p = PropertyFactory.getProp(ot, at.p, 1, 0, this),
                    this.r = PropertyFactory.getProp(ot, at.r, 0, degToRads, this),
                    this.or = PropertyFactory.getProp(ot, at.or, 0, 0, this),
                    this.os = PropertyFactory.getProp(ot, at.os, 0, .01, this),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertToPath())
                }
                return it.prototype = {
                    reset: o,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertToPath())
                    },
                    convertStarToPath: function() {
                        var at = Math.floor(this.pt.v) * 2, ht = Math.PI * 2 / at, pt = !0, dt = this.or.v, yt = this.ir.v, vt = this.os.v, xt = this.is.v, _t = 2 * Math.PI * dt / (at * 2), bt = 2 * Math.PI * yt / (at * 2), Rt, Ft, Bt, Dt, Mt = -Math.PI / 2;
                        Mt += this.r.v;
                        var Tt = this.data.d === 3 ? -1 : 1;
                        for (this.v._length = 0,
                        Rt = 0; Rt < at; Rt += 1) {
                            Ft = pt ? dt : yt,
                            Bt = pt ? vt : xt,
                            Dt = pt ? _t : bt;
                            var mt = Ft * Math.cos(Mt)
                              , St = Ft * Math.sin(Mt)
                              , wt = mt === 0 && St === 0 ? 0 : St / Math.sqrt(mt * mt + St * St)
                              , Ct = mt === 0 && St === 0 ? 0 : -mt / Math.sqrt(mt * mt + St * St);
                            mt += +this.p.v[0],
                            St += +this.p.v[1],
                            this.v.setTripleAt(mt, St, mt - wt * Dt * Bt * Tt, St - Ct * Dt * Bt * Tt, mt + wt * Dt * Bt * Tt, St + Ct * Dt * Bt * Tt, Rt, !0),
                            pt = !pt,
                            Mt += ht * Tt
                        }
                    },
                    convertPolygonToPath: function() {
                        var at = Math.floor(this.pt.v), ht = Math.PI * 2 / at, pt = this.or.v, dt = this.os.v, yt = 2 * Math.PI * pt / (at * 4), vt, xt = -Math.PI * .5, _t = this.data.d === 3 ? -1 : 1;
                        for (xt += this.r.v,
                        this.v._length = 0,
                        vt = 0; vt < at; vt += 1) {
                            var bt = pt * Math.cos(xt)
                              , Rt = pt * Math.sin(xt)
                              , Ft = bt === 0 && Rt === 0 ? 0 : Rt / Math.sqrt(bt * bt + Rt * Rt)
                              , Bt = bt === 0 && Rt === 0 ? 0 : -bt / Math.sqrt(bt * bt + Rt * Rt);
                            bt += +this.p.v[0],
                            Rt += +this.p.v[1],
                            this.v.setTripleAt(bt, Rt, bt - Ft * yt * dt * _t, Rt - Bt * yt * dt * _t, bt + Ft * yt * dt * _t, Rt + Bt * yt * dt * _t, vt, !0),
                            xt += ht * _t
                        }
                        this.paths.length = 0,
                        this.paths[0] = this.v
                    }
                },
                extendPrototype([DynamicPropertyContainer], it),
                it
            }()
              , tt = function() {
                function it(ot, at) {
                    this.v = shapePool.newElement(),
                    this.v.c = !0,
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.elem = ot,
                    this.comp = ot.comp,
                    this.frameId = -1,
                    this.d = at.d,
                    this.initDynamicPropertyContainer(ot),
                    this.p = PropertyFactory.getProp(ot, at.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(ot, at.s, 1, 0, this),
                    this.r = PropertyFactory.getProp(ot, at.r, 0, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertRectToPath())
                }
                return it.prototype = {
                    convertRectToPath: function() {
                        var at = this.p.v[0]
                          , ht = this.p.v[1]
                          , pt = this.s.v[0] / 2
                          , dt = this.s.v[1] / 2
                          , yt = bmMin(pt, dt, this.r.v)
                          , vt = yt * (1 - roundCorner);
                        this.v._length = 0,
                        this.d === 2 || this.d === 1 ? (this.v.setTripleAt(at + pt, ht - dt + yt, at + pt, ht - dt + yt, at + pt, ht - dt + vt, 0, !0),
                        this.v.setTripleAt(at + pt, ht + dt - yt, at + pt, ht + dt - vt, at + pt, ht + dt - yt, 1, !0),
                        yt !== 0 ? (this.v.setTripleAt(at + pt - yt, ht + dt, at + pt - yt, ht + dt, at + pt - vt, ht + dt, 2, !0),
                        this.v.setTripleAt(at - pt + yt, ht + dt, at - pt + vt, ht + dt, at - pt + yt, ht + dt, 3, !0),
                        this.v.setTripleAt(at - pt, ht + dt - yt, at - pt, ht + dt - yt, at - pt, ht + dt - vt, 4, !0),
                        this.v.setTripleAt(at - pt, ht - dt + yt, at - pt, ht - dt + vt, at - pt, ht - dt + yt, 5, !0),
                        this.v.setTripleAt(at - pt + yt, ht - dt, at - pt + yt, ht - dt, at - pt + vt, ht - dt, 6, !0),
                        this.v.setTripleAt(at + pt - yt, ht - dt, at + pt - vt, ht - dt, at + pt - yt, ht - dt, 7, !0)) : (this.v.setTripleAt(at - pt, ht + dt, at - pt + vt, ht + dt, at - pt, ht + dt, 2),
                        this.v.setTripleAt(at - pt, ht - dt, at - pt, ht - dt + vt, at - pt, ht - dt, 3))) : (this.v.setTripleAt(at + pt, ht - dt + yt, at + pt, ht - dt + vt, at + pt, ht - dt + yt, 0, !0),
                        yt !== 0 ? (this.v.setTripleAt(at + pt - yt, ht - dt, at + pt - yt, ht - dt, at + pt - vt, ht - dt, 1, !0),
                        this.v.setTripleAt(at - pt + yt, ht - dt, at - pt + vt, ht - dt, at - pt + yt, ht - dt, 2, !0),
                        this.v.setTripleAt(at - pt, ht - dt + yt, at - pt, ht - dt + yt, at - pt, ht - dt + vt, 3, !0),
                        this.v.setTripleAt(at - pt, ht + dt - yt, at - pt, ht + dt - vt, at - pt, ht + dt - yt, 4, !0),
                        this.v.setTripleAt(at - pt + yt, ht + dt, at - pt + yt, ht + dt, at - pt + vt, ht + dt, 5, !0),
                        this.v.setTripleAt(at + pt - yt, ht + dt, at + pt - vt, ht + dt, at + pt - yt, ht + dt, 6, !0),
                        this.v.setTripleAt(at + pt, ht + dt - yt, at + pt, ht + dt - yt, at + pt, ht + dt - vt, 7, !0)) : (this.v.setTripleAt(at - pt, ht - dt, at - pt + vt, ht - dt, at - pt, ht - dt, 1, !0),
                        this.v.setTripleAt(at - pt, ht + dt, at - pt, ht + dt - vt, at - pt, ht + dt, 2, !0),
                        this.v.setTripleAt(at + pt, ht + dt, at + pt - vt, ht + dt, at + pt, ht + dt, 3, !0)))
                    },
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertRectToPath())
                    },
                    reset: o
                },
                extendPrototype([DynamicPropertyContainer], it),
                it
            }();
            function rt(it, ot, at) {
                var ht;
                if (at === 3 || at === 4) {
                    var pt = at === 3 ? ot.pt : ot.ks
                      , dt = pt.k;
                    dt.length ? ht = new j(it,ot,at) : ht = new _(it,ot,at)
                } else
                    at === 5 ? ht = new tt(it,ot) : at === 6 ? ht = new $(it,ot) : at === 7 && (ht = new nt(it,ot));
                return ht.k && it.addDynamicProperty(ht),
                ht
            }
            function st() {
                return _
            }
            function lt() {
                return j
            }
            var ct = {};
            return ct.getShapeProp = rt,
            ct.getConstructorFunction = st,
            ct.getKeyframedConstructorFunction = lt,
            ct
        }();
        /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */
        var Matrix = function() {
            var s = Math.cos
              , e = Math.sin
              , a = Math.tan
              , o = Math.round;
            function c() {
                return this.props[0] = 1,
                this.props[1] = 0,
                this.props[2] = 0,
                this.props[3] = 0,
                this.props[4] = 0,
                this.props[5] = 1,
                this.props[6] = 0,
                this.props[7] = 0,
                this.props[8] = 0,
                this.props[9] = 0,
                this.props[10] = 1,
                this.props[11] = 0,
                this.props[12] = 0,
                this.props[13] = 0,
                this.props[14] = 0,
                this.props[15] = 1,
                this
            }
            function d(mt) {
                if (mt === 0)
                    return this;
                var St = s(mt)
                  , wt = e(mt);
                return this._t(St, -wt, 0, 0, wt, St, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function g(mt) {
                if (mt === 0)
                    return this;
                var St = s(mt)
                  , wt = e(mt);
                return this._t(1, 0, 0, 0, 0, St, -wt, 0, 0, wt, St, 0, 0, 0, 0, 1)
            }
            function _(mt) {
                if (mt === 0)
                    return this;
                var St = s(mt)
                  , wt = e(mt);
                return this._t(St, 0, wt, 0, 0, 1, 0, 0, -wt, 0, St, 0, 0, 0, 0, 1)
            }
            function b(mt) {
                if (mt === 0)
                    return this;
                var St = s(mt)
                  , wt = e(mt);
                return this._t(St, -wt, 0, 0, wt, St, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function j(mt, St) {
                return this._t(1, St, mt, 1, 0, 0)
            }
            function $(mt, St) {
                return this.shear(a(mt), a(St))
            }
            function nt(mt, St) {
                var wt = s(St)
                  , Ct = e(St);
                return this._t(wt, Ct, 0, 0, -Ct, wt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, a(mt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(wt, -Ct, 0, 0, Ct, wt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function tt(mt, St, wt) {
                return !wt && wt !== 0 && (wt = 1),
                mt === 1 && St === 1 && wt === 1 ? this : this._t(mt, 0, 0, 0, 0, St, 0, 0, 0, 0, wt, 0, 0, 0, 0, 1)
            }
            function rt(mt, St, wt, Ct, Ht, en, Ot, Yt, rn, Xt, An, Ln, _n, yn, Pt, Qt) {
                return this.props[0] = mt,
                this.props[1] = St,
                this.props[2] = wt,
                this.props[3] = Ct,
                this.props[4] = Ht,
                this.props[5] = en,
                this.props[6] = Ot,
                this.props[7] = Yt,
                this.props[8] = rn,
                this.props[9] = Xt,
                this.props[10] = An,
                this.props[11] = Ln,
                this.props[12] = _n,
                this.props[13] = yn,
                this.props[14] = Pt,
                this.props[15] = Qt,
                this
            }
            function st(mt, St, wt) {
                return wt = wt || 0,
                mt !== 0 || St !== 0 || wt !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, mt, St, wt, 1) : this
            }
            function lt(mt, St, wt, Ct, Ht, en, Ot, Yt, rn, Xt, An, Ln, _n, yn, Pt, Qt) {
                var jt = this.props;
                if (mt === 1 && St === 0 && wt === 0 && Ct === 0 && Ht === 0 && en === 1 && Ot === 0 && Yt === 0 && rn === 0 && Xt === 0 && An === 1 && Ln === 0)
                    return jt[12] = jt[12] * mt + jt[15] * _n,
                    jt[13] = jt[13] * en + jt[15] * yn,
                    jt[14] = jt[14] * An + jt[15] * Pt,
                    jt[15] *= Qt,
                    this._identityCalculated = !1,
                    this;
                var fn = jt[0]
                  , tn = jt[1]
                  , bn = jt[2]
                  , gn = jt[3]
                  , vn = jt[4]
                  , Lt = jt[5]
                  , At = jt[6]
                  , $t = jt[7]
                  , on = jt[8]
                  , sn = jt[9]
                  , cn = jt[10]
                  , Pn = jt[11]
                  , dn = jt[12]
                  , Tn = jt[13]
                  , jn = jt[14]
                  , pn = jt[15];
                return jt[0] = fn * mt + tn * Ht + bn * rn + gn * _n,
                jt[1] = fn * St + tn * en + bn * Xt + gn * yn,
                jt[2] = fn * wt + tn * Ot + bn * An + gn * Pt,
                jt[3] = fn * Ct + tn * Yt + bn * Ln + gn * Qt,
                jt[4] = vn * mt + Lt * Ht + At * rn + $t * _n,
                jt[5] = vn * St + Lt * en + At * Xt + $t * yn,
                jt[6] = vn * wt + Lt * Ot + At * An + $t * Pt,
                jt[7] = vn * Ct + Lt * Yt + At * Ln + $t * Qt,
                jt[8] = on * mt + sn * Ht + cn * rn + Pn * _n,
                jt[9] = on * St + sn * en + cn * Xt + Pn * yn,
                jt[10] = on * wt + sn * Ot + cn * An + Pn * Pt,
                jt[11] = on * Ct + sn * Yt + cn * Ln + Pn * Qt,
                jt[12] = dn * mt + Tn * Ht + jn * rn + pn * _n,
                jt[13] = dn * St + Tn * en + jn * Xt + pn * yn,
                jt[14] = dn * wt + Tn * Ot + jn * An + pn * Pt,
                jt[15] = dn * Ct + Tn * Yt + jn * Ln + pn * Qt,
                this._identityCalculated = !1,
                this
            }
            function ct(mt) {
                var St = mt.props;
                return this.transform(St[0], St[1], St[2], St[3], St[4], St[5], St[6], St[7], St[8], St[9], St[10], St[11], St[12], St[13], St[14], St[15])
            }
            function it() {
                return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1),
                this._identityCalculated = !0),
                this._identity
            }
            function ot(mt) {
                for (var St = 0; St < 16; ) {
                    if (mt.props[St] !== this.props[St])
                        return !1;
                    St += 1
                }
                return !0
            }
            function at(mt) {
                var St;
                for (St = 0; St < 16; St += 1)
                    mt.props[St] = this.props[St];
                return mt
            }
            function ht(mt) {
                var St;
                for (St = 0; St < 16; St += 1)
                    this.props[St] = mt[St]
            }
            function pt(mt, St, wt) {
                return {
                    x: mt * this.props[0] + St * this.props[4] + wt * this.props[8] + this.props[12],
                    y: mt * this.props[1] + St * this.props[5] + wt * this.props[9] + this.props[13],
                    z: mt * this.props[2] + St * this.props[6] + wt * this.props[10] + this.props[14]
                }
            }
            function dt(mt, St, wt) {
                return mt * this.props[0] + St * this.props[4] + wt * this.props[8] + this.props[12]
            }
            function yt(mt, St, wt) {
                return mt * this.props[1] + St * this.props[5] + wt * this.props[9] + this.props[13]
            }
            function vt(mt, St, wt) {
                return mt * this.props[2] + St * this.props[6] + wt * this.props[10] + this.props[14]
            }
            function xt() {
                var mt = this.props[0] * this.props[5] - this.props[1] * this.props[4]
                  , St = this.props[5] / mt
                  , wt = -this.props[1] / mt
                  , Ct = -this.props[4] / mt
                  , Ht = this.props[0] / mt
                  , en = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / mt
                  , Ot = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / mt
                  , Yt = new Matrix;
                return Yt.props[0] = St,
                Yt.props[1] = wt,
                Yt.props[4] = Ct,
                Yt.props[5] = Ht,
                Yt.props[12] = en,
                Yt.props[13] = Ot,
                Yt
            }
            function _t(mt) {
                var St = this.getInverseMatrix();
                return St.applyToPointArray(mt[0], mt[1], mt[2] || 0)
            }
            function bt(mt) {
                var St, wt = mt.length, Ct = [];
                for (St = 0; St < wt; St += 1)
                    Ct[St] = _t(mt[St]);
                return Ct
            }
            function Rt(mt, St, wt) {
                var Ct = createTypedArray("float32", 6);
                if (this.isIdentity())
                    Ct[0] = mt[0],
                    Ct[1] = mt[1],
                    Ct[2] = St[0],
                    Ct[3] = St[1],
                    Ct[4] = wt[0],
                    Ct[5] = wt[1];
                else {
                    var Ht = this.props[0]
                      , en = this.props[1]
                      , Ot = this.props[4]
                      , Yt = this.props[5]
                      , rn = this.props[12]
                      , Xt = this.props[13];
                    Ct[0] = mt[0] * Ht + mt[1] * Ot + rn,
                    Ct[1] = mt[0] * en + mt[1] * Yt + Xt,
                    Ct[2] = St[0] * Ht + St[1] * Ot + rn,
                    Ct[3] = St[0] * en + St[1] * Yt + Xt,
                    Ct[4] = wt[0] * Ht + wt[1] * Ot + rn,
                    Ct[5] = wt[0] * en + wt[1] * Yt + Xt
                }
                return Ct
            }
            function Ft(mt, St, wt) {
                var Ct;
                return this.isIdentity() ? Ct = [mt, St, wt] : Ct = [mt * this.props[0] + St * this.props[4] + wt * this.props[8] + this.props[12], mt * this.props[1] + St * this.props[5] + wt * this.props[9] + this.props[13], mt * this.props[2] + St * this.props[6] + wt * this.props[10] + this.props[14]],
                Ct
            }
            function Bt(mt, St) {
                if (this.isIdentity())
                    return mt + "," + St;
                var wt = this.props;
                return Math.round((mt * wt[0] + St * wt[4] + wt[12]) * 100) / 100 + "," + Math.round((mt * wt[1] + St * wt[5] + wt[13]) * 100) / 100
            }
            function Dt() {
                for (var mt = 0, St = this.props, wt = "matrix3d(", Ct = 1e4; mt < 16; )
                    wt += o(St[mt] * Ct) / Ct,
                    wt += mt === 15 ? ")" : ",",
                    mt += 1;
                return wt
            }
            function Mt(mt) {
                var St = 1e4;
                return mt < 1e-6 && mt > 0 || mt > -1e-6 && mt < 0 ? o(mt * St) / St : mt
            }
            function Tt() {
                var mt = this.props
                  , St = Mt(mt[0])
                  , wt = Mt(mt[1])
                  , Ct = Mt(mt[4])
                  , Ht = Mt(mt[5])
                  , en = Mt(mt[12])
                  , Ot = Mt(mt[13]);
                return "matrix(" + St + "," + wt + "," + Ct + "," + Ht + "," + en + "," + Ot + ")"
            }
            return function() {
                this.reset = c,
                this.rotate = d,
                this.rotateX = g,
                this.rotateY = _,
                this.rotateZ = b,
                this.skew = $,
                this.skewFromAxis = nt,
                this.shear = j,
                this.scale = tt,
                this.setTransform = rt,
                this.translate = st,
                this.transform = lt,
                this.multiply = ct,
                this.applyToPoint = pt,
                this.applyToX = dt,
                this.applyToY = yt,
                this.applyToZ = vt,
                this.applyToPointArray = Ft,
                this.applyToTriplePoints = Rt,
                this.applyToPointStringified = Bt,
                this.toCSS = Dt,
                this.to2dCSS = Tt,
                this.clone = at,
                this.cloneFromProps = ht,
                this.equals = ot,
                this.inversePoints = bt,
                this.inversePoint = _t,
                this.getInverseMatrix = xt,
                this._t = this.transform,
                this.isIdentity = it,
                this._identity = !0,
                this._identityCalculated = !1,
                this.props = createTypedArray("float32", 16),
                this.reset()
            }
        }();
        function _typeof$3(s) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function(a) {
                return typeof a
            }
            : _typeof$3 = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            _typeof$3(s)
        }
        var lottie = {};
        function setLocation(s) {
            setLocationHref(s)
        }
        function searchAnimations() {
            animationManager.searchAnimations()
        }
        function setSubframeRendering(s) {
            setSubframeEnabled(s)
        }
        function setPrefix(s) {
            setIdPrefix(s)
        }
        function loadAnimation(s) {
            return animationManager.loadAnimation(s)
        }
        function setQuality(s) {
            if (typeof s == "string")
                switch (s) {
                case "high":
                    setDefaultCurveSegments(200);
                    break;
                default:
                case "medium":
                    setDefaultCurveSegments(50);
                    break;
                case "low":
                    setDefaultCurveSegments(10);
                    break
                }
            else
                !isNaN(s) && s > 1 && setDefaultCurveSegments(s)
        }
        function inBrowser() {
            return typeof navigator < "u"
        }
        function installPlugin(s, e) {
            s === "expressions" && setExpressionsPlugin(e)
        }
        function getFactory(s) {
            switch (s) {
            case "propertyFactory":
                return PropertyFactory;
            case "shapePropertyFactory":
                return ShapePropertyFactory;
            case "matrix":
                return Matrix;
            default:
                return null
            }
        }
        lottie.play = animationManager.play,
        lottie.pause = animationManager.pause,
        lottie.setLocationHref = setLocation,
        lottie.togglePause = animationManager.togglePause,
        lottie.setSpeed = animationManager.setSpeed,
        lottie.setDirection = animationManager.setDirection,
        lottie.stop = animationManager.stop,
        lottie.searchAnimations = searchAnimations,
        lottie.registerAnimation = animationManager.registerAnimation,
        lottie.loadAnimation = loadAnimation,
        lottie.setSubframeRendering = setSubframeRendering,
        lottie.resize = animationManager.resize,
        lottie.goToAndStop = animationManager.goToAndStop,
        lottie.destroy = animationManager.destroy,
        lottie.setQuality = setQuality,
        lottie.inBrowser = inBrowser,
        lottie.installPlugin = installPlugin,
        lottie.freeze = animationManager.freeze,
        lottie.unfreeze = animationManager.unfreeze,
        lottie.setVolume = animationManager.setVolume,
        lottie.mute = animationManager.mute,
        lottie.unmute = animationManager.unmute,
        lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations,
        lottie.useWebWorker = setWebWorker,
        lottie.setIDPrefix = setPrefix,
        lottie.__getFactory = getFactory,
        lottie.version = "5.12.2";
        function checkReady() {
            document.readyState === "complete" && (clearInterval(readyStateCheckInterval),
            searchAnimations())
        }
        function getQueryVariable(s) {
            for (var e = queryString.split("&"), a = 0; a < e.length; a += 1) {
                var o = e[a].split("=");
                if (decodeURIComponent(o[0]) == s)
                    return decodeURIComponent(o[1])
            }
            return null
        }
        var queryString = "";
        {
            var scripts = document.getElementsByTagName("script")
              , index = scripts.length - 1
              , myScript = scripts[index] || {
                src: ""
            };
            queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "",
            getQueryVariable("renderer")
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        try {
            _typeof$3(exports) !== "object" && (window.bodymovin = lottie)
        } catch (s) {}
        var ShapeModifiers = function() {
            var s = {}
              , e = {};
            s.registerModifier = a,
            s.getModifier = o;
            function a(c, d) {
                e[c] || (e[c] = d)
            }
            function o(c, d, g) {
                return new e[c](d,g)
            }
            return s
        }();
        function ShapeModifier() {}
        ShapeModifier.prototype.initModifierProperties = function() {}
        ,
        ShapeModifier.prototype.addShapeToModifier = function() {}
        ,
        ShapeModifier.prototype.addShape = function(s) {
            if (!this.closed) {
                s.sh.container.addDynamicProperty(s.sh);
                var e = {
                    shape: s.sh,
                    data: s,
                    localShapeCollection: shapeCollectionPool.newShapeCollection()
                };
                this.shapes.push(e),
                this.addShapeToModifier(e),
                this._isAnimated && s.setAsAnimated()
            }
        }
        ,
        ShapeModifier.prototype.init = function(s, e) {
            this.shapes = [],
            this.elem = s,
            this.initDynamicPropertyContainer(s),
            this.initModifierProperties(s, e),
            this.frameId = initialDefaultFrame,
            this.closed = !1,
            this.k = !1,
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        ShapeModifier.prototype.processKeys = function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
        function TrimModifier() {}
        extendPrototype([ShapeModifier], TrimModifier),
        TrimModifier.prototype.initModifierProperties = function(s, e) {
            this.s = PropertyFactory.getProp(s, e.s, 0, .01, this),
            this.e = PropertyFactory.getProp(s, e.e, 0, .01, this),
            this.o = PropertyFactory.getProp(s, e.o, 0, 0, this),
            this.sValue = 0,
            this.eValue = 0,
            this.getValue = this.processKeys,
            this.m = e.m,
            this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
        }
        ,
        TrimModifier.prototype.addShapeToModifier = function(s) {
            s.pathsData = []
        }
        ,
        TrimModifier.prototype.calculateShapeEdges = function(s, e, a, o, c) {
            var d = [];
            e <= 1 ? d.push({
                s,
                e
            }) : s >= 1 ? d.push({
                s: s - 1,
                e: e - 1
            }) : (d.push({
                s,
                e: 1
            }),
            d.push({
                s: 0,
                e: e - 1
            }));
            var g = [], _, b = d.length, j;
            for (_ = 0; _ < b; _ += 1)
                if (j = d[_],
                !(j.e * c < o || j.s * c > o + a)) {
                    var $, nt;
                    j.s * c <= o ? $ = 0 : $ = (j.s * c - o) / a,
                    j.e * c >= o + a ? nt = 1 : nt = (j.e * c - o) / a,
                    g.push([$, nt])
                }
            return g.length || g.push([0, 0]),
            g
        }
        ,
        TrimModifier.prototype.releasePathsData = function(s) {
            var e, a = s.length;
            for (e = 0; e < a; e += 1)
                segmentsLengthPool.release(s[e]);
            return s.length = 0,
            s
        }
        ,
        TrimModifier.prototype.processShapes = function(s) {
            var e, a;
            if (this._mdf || s) {
                var o = this.o.v % 360 / 360;
                if (o < 0 && (o += 1),
                this.s.v > 1 ? e = 1 + o : this.s.v < 0 ? e = 0 + o : e = this.s.v + o,
                this.e.v > 1 ? a = 1 + o : this.e.v < 0 ? a = 0 + o : a = this.e.v + o,
                e > a) {
                    var c = e;
                    e = a,
                    a = c
                }
                e = Math.round(e * 1e4) * 1e-4,
                a = Math.round(a * 1e4) * 1e-4,
                this.sValue = e,
                this.eValue = a
            } else
                e = this.sValue,
                a = this.eValue;
            var d, g, _ = this.shapes.length, b, j, $, nt, tt, rt = 0;
            if (a === e)
                for (g = 0; g < _; g += 1)
                    this.shapes[g].localShapeCollection.releaseShapes(),
                    this.shapes[g].shape._mdf = !0,
                    this.shapes[g].shape.paths = this.shapes[g].localShapeCollection,
                    this._mdf && (this.shapes[g].pathsData.length = 0);
            else if (a === 1 && e === 0 || a === 0 && e === 1) {
                if (this._mdf)
                    for (g = 0; g < _; g += 1)
                        this.shapes[g].pathsData.length = 0,
                        this.shapes[g].shape._mdf = !0
            } else {
                var st = [], lt, ct;
                for (g = 0; g < _; g += 1)
                    if (lt = this.shapes[g],
                    !lt.shape._mdf && !this._mdf && !s && this.m !== 2)
                        lt.shape.paths = lt.localShapeCollection;
                    else {
                        if (d = lt.shape.paths,
                        j = d._length,
                        tt = 0,
                        !lt.shape._mdf && lt.pathsData.length)
                            tt = lt.totalShapeLength;
                        else {
                            for ($ = this.releasePathsData(lt.pathsData),
                            b = 0; b < j; b += 1)
                                nt = bez.getSegmentsLength(d.shapes[b]),
                                $.push(nt),
                                tt += nt.totalLength;
                            lt.totalShapeLength = tt,
                            lt.pathsData = $
                        }
                        rt += tt,
                        lt.shape._mdf = !0
                    }
                var it = e, ot = a, at = 0, ht;
                for (g = _ - 1; g >= 0; g -= 1)
                    if (lt = this.shapes[g],
                    lt.shape._mdf) {
                        for (ct = lt.localShapeCollection,
                        ct.releaseShapes(),
                        this.m === 2 && _ > 1 ? (ht = this.calculateShapeEdges(e, a, lt.totalShapeLength, at, rt),
                        at += lt.totalShapeLength) : ht = [[it, ot]],
                        j = ht.length,
                        b = 0; b < j; b += 1) {
                            it = ht[b][0],
                            ot = ht[b][1],
                            st.length = 0,
                            ot <= 1 ? st.push({
                                s: lt.totalShapeLength * it,
                                e: lt.totalShapeLength * ot
                            }) : it >= 1 ? st.push({
                                s: lt.totalShapeLength * (it - 1),
                                e: lt.totalShapeLength * (ot - 1)
                            }) : (st.push({
                                s: lt.totalShapeLength * it,
                                e: lt.totalShapeLength
                            }),
                            st.push({
                                s: 0,
                                e: lt.totalShapeLength * (ot - 1)
                            }));
                            var pt = this.addShapes(lt, st[0]);
                            if (st[0].s !== st[0].e) {
                                if (st.length > 1) {
                                    var dt = lt.shape.paths.shapes[lt.shape.paths._length - 1];
                                    if (dt.c) {
                                        var yt = pt.pop();
                                        this.addPaths(pt, ct),
                                        pt = this.addShapes(lt, st[1], yt)
                                    } else
                                        this.addPaths(pt, ct),
                                        pt = this.addShapes(lt, st[1])
                                }
                                this.addPaths(pt, ct)
                            }
                        }
                        lt.shape.paths = ct
                    }
            }
        }
        ,
        TrimModifier.prototype.addPaths = function(s, e) {
            var a, o = s.length;
            for (a = 0; a < o; a += 1)
                e.addShape(s[a])
        }
        ,
        TrimModifier.prototype.addSegment = function(s, e, a, o, c, d, g) {
            c.setXYAt(e[0], e[1], "o", d),
            c.setXYAt(a[0], a[1], "i", d + 1),
            g && c.setXYAt(s[0], s[1], "v", d),
            c.setXYAt(o[0], o[1], "v", d + 1)
        }
        ,
        TrimModifier.prototype.addSegmentFromArray = function(s, e, a, o) {
            e.setXYAt(s[1], s[5], "o", a),
            e.setXYAt(s[2], s[6], "i", a + 1),
            o && e.setXYAt(s[0], s[4], "v", a),
            e.setXYAt(s[3], s[7], "v", a + 1)
        }
        ,
        TrimModifier.prototype.addShapes = function(s, e, a) {
            var o = s.pathsData, c = s.shape.paths.shapes, d, g = s.shape.paths._length, _, b, j = 0, $, nt, tt, rt, st = [], lt, ct = !0;
            for (a ? (nt = a._length,
            lt = a._length) : (a = shapePool.newElement(),
            nt = 0,
            lt = 0),
            st.push(a),
            d = 0; d < g; d += 1) {
                for (tt = o[d].lengths,
                a.c = c[d].c,
                b = c[d].c ? tt.length : tt.length + 1,
                _ = 1; _ < b; _ += 1)
                    if ($ = tt[_ - 1],
                    j + $.addedLength < e.s)
                        j += $.addedLength,
                        a.c = !1;
                    else if (j > e.e) {
                        a.c = !1;
                        break
                    } else
                        e.s <= j && e.e >= j + $.addedLength ? (this.addSegment(c[d].v[_ - 1], c[d].o[_ - 1], c[d].i[_], c[d].v[_], a, nt, ct),
                        ct = !1) : (rt = bez.getNewSegment(c[d].v[_ - 1], c[d].v[_], c[d].o[_ - 1], c[d].i[_], (e.s - j) / $.addedLength, (e.e - j) / $.addedLength, tt[_ - 1]),
                        this.addSegmentFromArray(rt, a, nt, ct),
                        ct = !1,
                        a.c = !1),
                        j += $.addedLength,
                        nt += 1;
                if (c[d].c && tt.length) {
                    if ($ = tt[_ - 1],
                    j <= e.e) {
                        var it = tt[_ - 1].addedLength;
                        e.s <= j && e.e >= j + it ? (this.addSegment(c[d].v[_ - 1], c[d].o[_ - 1], c[d].i[0], c[d].v[0], a, nt, ct),
                        ct = !1) : (rt = bez.getNewSegment(c[d].v[_ - 1], c[d].v[0], c[d].o[_ - 1], c[d].i[0], (e.s - j) / it, (e.e - j) / it, tt[_ - 1]),
                        this.addSegmentFromArray(rt, a, nt, ct),
                        ct = !1,
                        a.c = !1)
                    } else
                        a.c = !1;
                    j += $.addedLength,
                    nt += 1
                }
                if (a._length && (a.setXYAt(a.v[lt][0], a.v[lt][1], "i", lt),
                a.setXYAt(a.v[a._length - 1][0], a.v[a._length - 1][1], "o", a._length - 1)),
                j > e.e)
                    break;
                d < g - 1 && (a = shapePool.newElement(),
                ct = !0,
                st.push(a),
                nt = 0)
            }
            return st
        }
        ;
        function PuckerAndBloatModifier() {}
        extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        PuckerAndBloatModifier.prototype.initModifierProperties = function(s, e) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(s, e.a, 0, null, this),
            this._isAnimated = !!this.amount.effectsSequence.length
        }
        ,
        PuckerAndBloatModifier.prototype.processPath = function(s, e) {
            var a = e / 100
              , o = [0, 0]
              , c = s._length
              , d = 0;
            for (d = 0; d < c; d += 1)
                o[0] += s.v[d][0],
                o[1] += s.v[d][1];
            o[0] /= c,
            o[1] /= c;
            var g = shapePool.newElement();
            g.c = s.c;
            var _, b, j, $, nt, tt;
            for (d = 0; d < c; d += 1)
                _ = s.v[d][0] + (o[0] - s.v[d][0]) * a,
                b = s.v[d][1] + (o[1] - s.v[d][1]) * a,
                j = s.o[d][0] + (o[0] - s.o[d][0]) * -a,
                $ = s.o[d][1] + (o[1] - s.o[d][1]) * -a,
                nt = s.i[d][0] + (o[0] - s.i[d][0]) * -a,
                tt = s.i[d][1] + (o[1] - s.i[d][1]) * -a,
                g.setTripleAt(_, b, j, $, nt, tt, d);
            return g
        }
        ,
        PuckerAndBloatModifier.prototype.processShapes = function(s) {
            var e, a, o = this.shapes.length, c, d, g = this.amount.v;
            if (g !== 0) {
                var _, b;
                for (a = 0; a < o; a += 1) {
                    if (_ = this.shapes[a],
                    b = _.localShapeCollection,
                    !(!_.shape._mdf && !this._mdf && !s))
                        for (b.releaseShapes(),
                        _.shape._mdf = !0,
                        e = _.shape.paths.shapes,
                        d = _.shape.paths._length,
                        c = 0; c < d; c += 1)
                            b.addShape(this.processPath(e[c], g));
                    _.shape.paths = _.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        var TransformPropertyFactory = function() {
            var s = [0, 0];
            function e(b) {
                var j = this._mdf;
                this.iterateDynamicProperties(),
                this._mdf = this._mdf || j,
                this.a && b.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.s && b.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk && b.skewFromAxis(-this.sk.v, this.sa.v),
                this.r ? b.rotate(-this.r.v) : b.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                this.data.p.s ? this.data.p.z ? b.translate(this.px.v, this.py.v, -this.pz.v) : b.translate(this.px.v, this.py.v, 0) : b.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
            }
            function a(b) {
                if (this.elem.globalData.frameId !== this.frameId) {
                    if (this._isDirty && (this.precalculateMatrix(),
                    this._isDirty = !1),
                    this.iterateDynamicProperties(),
                    this._mdf || b) {
                        var j;
                        if (this.v.cloneFromProps(this.pre.props),
                        this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                        this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                        this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v),
                        this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                        this.autoOriented) {
                            var $, nt;
                            if (j = this.elem.globalData.frameRate,
                            this.p && this.p.keyframes && this.p.getValueAtTime)
                                this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? ($ = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / j, 0),
                                nt = this.p.getValueAtTime(this.p.keyframes[0].t / j, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? ($ = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / j, 0),
                                nt = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / j, 0)) : ($ = this.p.pv,
                                nt = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / j, this.p.offsetTime));
                            else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                $ = [],
                                nt = [];
                                var tt = this.px
                                  , rt = this.py;
                                tt._caching.lastFrame + tt.offsetTime <= tt.keyframes[0].t ? ($[0] = tt.getValueAtTime((tt.keyframes[0].t + .01) / j, 0),
                                $[1] = rt.getValueAtTime((rt.keyframes[0].t + .01) / j, 0),
                                nt[0] = tt.getValueAtTime(tt.keyframes[0].t / j, 0),
                                nt[1] = rt.getValueAtTime(rt.keyframes[0].t / j, 0)) : tt._caching.lastFrame + tt.offsetTime >= tt.keyframes[tt.keyframes.length - 1].t ? ($[0] = tt.getValueAtTime(tt.keyframes[tt.keyframes.length - 1].t / j, 0),
                                $[1] = rt.getValueAtTime(rt.keyframes[rt.keyframes.length - 1].t / j, 0),
                                nt[0] = tt.getValueAtTime((tt.keyframes[tt.keyframes.length - 1].t - .01) / j, 0),
                                nt[1] = rt.getValueAtTime((rt.keyframes[rt.keyframes.length - 1].t - .01) / j, 0)) : ($ = [tt.pv, rt.pv],
                                nt[0] = tt.getValueAtTime((tt._caching.lastFrame + tt.offsetTime - .01) / j, tt.offsetTime),
                                nt[1] = rt.getValueAtTime((rt._caching.lastFrame + rt.offsetTime - .01) / j, rt.offsetTime))
                            } else
                                nt = s,
                                $ = nt;
                            this.v.rotate(-Math.atan2($[1] - nt[1], $[0] - nt[0]))
                        }
                        this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                    }
                    this.frameId = this.elem.globalData.frameId
                }
            }
            function o() {
                if (this.appliedTransformations = 0,
                this.pre.reset(),
                !this.a.effectsSequence.length)
                    this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    this.appliedTransformations = 1;
                else
                    return;
                if (!this.s.effectsSequence.length)
                    this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    this.appliedTransformations = 2;
                else
                    return;
                if (this.sk)
                    if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length)
                        this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                        this.appliedTransformations = 3;
                    else
                        return;
                this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v),
                this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                this.appliedTransformations = 4)
            }
            function c() {}
            function d(b) {
                this._addDynamicProperty(b),
                this.elem.addDynamicProperty(b),
                this._isDirty = !0
            }
            function g(b, j, $) {
                if (this.elem = b,
                this.frameId = -1,
                this.propType = "transform",
                this.data = j,
                this.v = new Matrix,
                this.pre = new Matrix,
                this.appliedTransformations = 0,
                this.initDynamicPropertyContainer($ || b),
                j.p && j.p.s ? (this.px = PropertyFactory.getProp(b, j.p.x, 0, 0, this),
                this.py = PropertyFactory.getProp(b, j.p.y, 0, 0, this),
                j.p.z && (this.pz = PropertyFactory.getProp(b, j.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(b, j.p || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                j.rx) {
                    if (this.rx = PropertyFactory.getProp(b, j.rx, 0, degToRads, this),
                    this.ry = PropertyFactory.getProp(b, j.ry, 0, degToRads, this),
                    this.rz = PropertyFactory.getProp(b, j.rz, 0, degToRads, this),
                    j.or.k[0].ti) {
                        var nt, tt = j.or.k.length;
                        for (nt = 0; nt < tt; nt += 1)
                            j.or.k[nt].to = null,
                            j.or.k[nt].ti = null
                    }
                    this.or = PropertyFactory.getProp(b, j.or, 1, degToRads, this),
                    this.or.sh = !0
                } else
                    this.r = PropertyFactory.getProp(b, j.r || {
                        k: 0
                    }, 0, degToRads, this);
                j.sk && (this.sk = PropertyFactory.getProp(b, j.sk, 0, degToRads, this),
                this.sa = PropertyFactory.getProp(b, j.sa, 0, degToRads, this)),
                this.a = PropertyFactory.getProp(b, j.a || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                this.s = PropertyFactory.getProp(b, j.s || {
                    k: [100, 100, 100]
                }, 1, .01, this),
                j.o ? this.o = PropertyFactory.getProp(b, j.o, 0, .01, b) : this.o = {
                    _mdf: !1,
                    v: 1
                },
                this._isDirty = !0,
                this.dynamicProperties.length || this.getValue(!0)
            }
            g.prototype = {
                applyToMatrix: e,
                getValue: a,
                precalculateMatrix: o,
                autoOrient: c
            },
            extendPrototype([DynamicPropertyContainer], g),
            g.prototype.addDynamicProperty = d,
            g.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
            function _(b, j, $) {
                return new g(b,j,$)
            }
            return {
                getTransformProperty: _
            }
        }();
        function RepeaterModifier() {}
        extendPrototype([ShapeModifier], RepeaterModifier),
        RepeaterModifier.prototype.initModifierProperties = function(s, e) {
            this.getValue = this.processKeys,
            this.c = PropertyFactory.getProp(s, e.c, 0, null, this),
            this.o = PropertyFactory.getProp(s, e.o, 0, null, this),
            this.tr = TransformPropertyFactory.getTransformProperty(s, e.tr, this),
            this.so = PropertyFactory.getProp(s, e.tr.so, 0, .01, this),
            this.eo = PropertyFactory.getProp(s, e.tr.eo, 0, .01, this),
            this.data = e,
            this.dynamicProperties.length || this.getValue(!0),
            this._isAnimated = !!this.dynamicProperties.length,
            this.pMatrix = new Matrix,
            this.rMatrix = new Matrix,
            this.sMatrix = new Matrix,
            this.tMatrix = new Matrix,
            this.matrix = new Matrix
        }
        ,
        RepeaterModifier.prototype.applyTransforms = function(s, e, a, o, c, d) {
            var g = d ? -1 : 1
              , _ = o.s.v[0] + (1 - o.s.v[0]) * (1 - c)
              , b = o.s.v[1] + (1 - o.s.v[1]) * (1 - c);
            s.translate(o.p.v[0] * g * c, o.p.v[1] * g * c, o.p.v[2]),
            e.translate(-o.a.v[0], -o.a.v[1], o.a.v[2]),
            e.rotate(-o.r.v * g * c),
            e.translate(o.a.v[0], o.a.v[1], o.a.v[2]),
            a.translate(-o.a.v[0], -o.a.v[1], o.a.v[2]),
            a.scale(d ? 1 / _ : _, d ? 1 / b : b),
            a.translate(o.a.v[0], o.a.v[1], o.a.v[2])
        }
        ,
        RepeaterModifier.prototype.init = function(s, e, a, o) {
            for (this.elem = s,
            this.arr = e,
            this.pos = a,
            this.elemsData = o,
            this._currentCopies = 0,
            this._elements = [],
            this._groups = [],
            this.frameId = -1,
            this.initDynamicPropertyContainer(s),
            this.initModifierProperties(s, e[a]); a > 0; )
                a -= 1,
                this._elements.unshift(e[a]);
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        RepeaterModifier.prototype.resetElements = function(s) {
            var e, a = s.length;
            for (e = 0; e < a; e += 1)
                s[e]._processed = !1,
                s[e].ty === "gr" && this.resetElements(s[e].it)
        }
        ,
        RepeaterModifier.prototype.cloneElements = function(s) {
            var e = JSON.parse(JSON.stringify(s));
            return this.resetElements(e),
            e
        }
        ,
        RepeaterModifier.prototype.changeGroupRender = function(s, e) {
            var a, o = s.length;
            for (a = 0; a < o; a += 1)
                s[a]._render = e,
                s[a].ty === "gr" && this.changeGroupRender(s[a].it, e)
        }
        ,
        RepeaterModifier.prototype.processShapes = function(s) {
            var e, a, o, c, d, g = !1;
            if (this._mdf || s) {
                var _ = Math.ceil(this.c.v);
                if (this._groups.length < _) {
                    for (; this._groups.length < _; ) {
                        var b = {
                            it: this.cloneElements(this._elements),
                            ty: "gr"
                        };
                        b.it.push({
                            a: {
                                a: 0,
                                ix: 1,
                                k: [0, 0]
                            },
                            nm: "Transform",
                            o: {
                                a: 0,
                                ix: 7,
                                k: 100
                            },
                            p: {
                                a: 0,
                                ix: 2,
                                k: [0, 0]
                            },
                            r: {
                                a: 1,
                                ix: 6,
                                k: [{
                                    s: 0,
                                    e: 0,
                                    t: 0
                                }, {
                                    s: 0,
                                    e: 0,
                                    t: 1
                                }]
                            },
                            s: {
                                a: 0,
                                ix: 3,
                                k: [100, 100]
                            },
                            sa: {
                                a: 0,
                                ix: 5,
                                k: 0
                            },
                            sk: {
                                a: 0,
                                ix: 4,
                                k: 0
                            },
                            ty: "tr"
                        }),
                        this.arr.splice(0, 0, b),
                        this._groups.splice(0, 0, b),
                        this._currentCopies += 1
                    }
                    this.elem.reloadShapes(),
                    g = !0
                }
                d = 0;
                var j;
                for (o = 0; o <= this._groups.length - 1; o += 1) {
                    if (j = d < _,
                    this._groups[o]._render = j,
                    this.changeGroupRender(this._groups[o].it, j),
                    !j) {
                        var $ = this.elemsData[o].it
                          , nt = $[$.length - 1];
                        nt.transform.op.v !== 0 ? (nt.transform.op._mdf = !0,
                        nt.transform.op.v = 0) : nt.transform.op._mdf = !1
                    }
                    d += 1
                }
                this._currentCopies = _;
                var tt = this.o.v
                  , rt = tt % 1
                  , st = tt > 0 ? Math.floor(tt) : Math.ceil(tt)
                  , lt = this.pMatrix.props
                  , ct = this.rMatrix.props
                  , it = this.sMatrix.props;
                this.pMatrix.reset(),
                this.rMatrix.reset(),
                this.sMatrix.reset(),
                this.tMatrix.reset(),
                this.matrix.reset();
                var ot = 0;
                if (tt > 0) {
                    for (; ot < st; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        ot += 1;
                    rt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, rt, !1),
                    ot += rt)
                } else if (tt < 0) {
                    for (; ot > st; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0),
                        ot -= 1;
                    rt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -rt, !0),
                    ot -= rt)
                }
                o = this.data.m === 1 ? 0 : this._currentCopies - 1,
                c = this.data.m === 1 ? 1 : -1,
                d = this._currentCopies;
                for (var at, ht; d; ) {
                    if (e = this.elemsData[o].it,
                    a = e[e.length - 1].transform.mProps.v.props,
                    ht = a.length,
                    e[e.length - 1].transform.mProps._mdf = !0,
                    e[e.length - 1].transform.op._mdf = !0,
                    e[e.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (o / (this._currentCopies - 1)),
                    ot !== 0) {
                        for ((o !== 0 && c === 1 || o !== this._currentCopies - 1 && c === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        this.matrix.transform(ct[0], ct[1], ct[2], ct[3], ct[4], ct[5], ct[6], ct[7], ct[8], ct[9], ct[10], ct[11], ct[12], ct[13], ct[14], ct[15]),
                        this.matrix.transform(it[0], it[1], it[2], it[3], it[4], it[5], it[6], it[7], it[8], it[9], it[10], it[11], it[12], it[13], it[14], it[15]),
                        this.matrix.transform(lt[0], lt[1], lt[2], lt[3], lt[4], lt[5], lt[6], lt[7], lt[8], lt[9], lt[10], lt[11], lt[12], lt[13], lt[14], lt[15]),
                        at = 0; at < ht; at += 1)
                            a[at] = this.matrix.props[at];
                        this.matrix.reset()
                    } else
                        for (this.matrix.reset(),
                        at = 0; at < ht; at += 1)
                            a[at] = this.matrix.props[at];
                    ot += 1,
                    d -= 1,
                    o += c
                }
            } else
                for (d = this._currentCopies,
                o = 0,
                c = 1; d; )
                    e = this.elemsData[o].it,
                    a = e[e.length - 1].transform.mProps.v.props,
                    e[e.length - 1].transform.mProps._mdf = !1,
                    e[e.length - 1].transform.op._mdf = !1,
                    d -= 1,
                    o += c;
            return g
        }
        ,
        RepeaterModifier.prototype.addShape = function() {}
        ;
        function RoundCornersModifier() {}
        extendPrototype([ShapeModifier], RoundCornersModifier),
        RoundCornersModifier.prototype.initModifierProperties = function(s, e) {
            this.getValue = this.processKeys,
            this.rd = PropertyFactory.getProp(s, e.r, 0, null, this),
            this._isAnimated = !!this.rd.effectsSequence.length
        }
        ,
        RoundCornersModifier.prototype.processPath = function(s, e) {
            var a = shapePool.newElement();
            a.c = s.c;
            var o, c = s._length, d, g, _, b, j, $, nt = 0, tt, rt, st, lt, ct, it;
            for (o = 0; o < c; o += 1)
                d = s.v[o],
                _ = s.o[o],
                g = s.i[o],
                d[0] === _[0] && d[1] === _[1] && d[0] === g[0] && d[1] === g[1] ? (o === 0 || o === c - 1) && !s.c ? (a.setTripleAt(d[0], d[1], _[0], _[1], g[0], g[1], nt),
                nt += 1) : (o === 0 ? b = s.v[c - 1] : b = s.v[o - 1],
                j = Math.sqrt(Math.pow(d[0] - b[0], 2) + Math.pow(d[1] - b[1], 2)),
                $ = j ? Math.min(j / 2, e) / j : 0,
                ct = d[0] + (b[0] - d[0]) * $,
                tt = ct,
                it = d[1] - (d[1] - b[1]) * $,
                rt = it,
                st = tt - (tt - d[0]) * roundCorner,
                lt = rt - (rt - d[1]) * roundCorner,
                a.setTripleAt(tt, rt, st, lt, ct, it, nt),
                nt += 1,
                o === c - 1 ? b = s.v[0] : b = s.v[o + 1],
                j = Math.sqrt(Math.pow(d[0] - b[0], 2) + Math.pow(d[1] - b[1], 2)),
                $ = j ? Math.min(j / 2, e) / j : 0,
                st = d[0] + (b[0] - d[0]) * $,
                tt = st,
                lt = d[1] + (b[1] - d[1]) * $,
                rt = lt,
                ct = tt - (tt - d[0]) * roundCorner,
                it = rt - (rt - d[1]) * roundCorner,
                a.setTripleAt(tt, rt, st, lt, ct, it, nt),
                nt += 1) : (a.setTripleAt(s.v[o][0], s.v[o][1], s.o[o][0], s.o[o][1], s.i[o][0], s.i[o][1], nt),
                nt += 1);
            return a
        }
        ,
        RoundCornersModifier.prototype.processShapes = function(s) {
            var e, a, o = this.shapes.length, c, d, g = this.rd.v;
            if (g !== 0) {
                var _, b;
                for (a = 0; a < o; a += 1) {
                    if (_ = this.shapes[a],
                    b = _.localShapeCollection,
                    !(!_.shape._mdf && !this._mdf && !s))
                        for (b.releaseShapes(),
                        _.shape._mdf = !0,
                        e = _.shape.paths.shapes,
                        d = _.shape.paths._length,
                        c = 0; c < d; c += 1)
                            b.addShape(this.processPath(e[c], g));
                    _.shape.paths = _.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function floatEqual(s, e) {
            return Math.abs(s - e) * 1e5 <= Math.min(Math.abs(s), Math.abs(e))
        }
        function floatZero(s) {
            return Math.abs(s) <= 1e-5
        }
        function lerp(s, e, a) {
            return s * (1 - a) + e * a
        }
        function lerpPoint(s, e, a) {
            return [lerp(s[0], e[0], a), lerp(s[1], e[1], a)]
        }
        function quadRoots(s, e, a) {
            if (s === 0)
                return [];
            var o = e * e - 4 * s * a;
            if (o < 0)
                return [];
            var c = -e / (2 * s);
            if (o === 0)
                return [c];
            var d = Math.sqrt(o) / (2 * s);
            return [c - d, c + d]
        }
        function polynomialCoefficients(s, e, a, o) {
            return [-s + 3 * e - 3 * a + o, 3 * s - 6 * e + 3 * a, -3 * s + 3 * e, s]
        }
        function singlePoint(s) {
            return new PolynomialBezier(s,s,s,s,!1)
        }
        function PolynomialBezier(s, e, a, o, c) {
            c && pointEqual(s, e) && (e = lerpPoint(s, o, 1 / 3)),
            c && pointEqual(a, o) && (a = lerpPoint(s, o, 2 / 3));
            var d = polynomialCoefficients(s[0], e[0], a[0], o[0])
              , g = polynomialCoefficients(s[1], e[1], a[1], o[1]);
            this.a = [d[0], g[0]],
            this.b = [d[1], g[1]],
            this.c = [d[2], g[2]],
            this.d = [d[3], g[3]],
            this.points = [s, e, a, o]
        }
        PolynomialBezier.prototype.point = function(s) {
            return [((this.a[0] * s + this.b[0]) * s + this.c[0]) * s + this.d[0], ((this.a[1] * s + this.b[1]) * s + this.c[1]) * s + this.d[1]]
        }
        ,
        PolynomialBezier.prototype.derivative = function(s) {
            return [(3 * s * this.a[0] + 2 * this.b[0]) * s + this.c[0], (3 * s * this.a[1] + 2 * this.b[1]) * s + this.c[1]]
        }
        ,
        PolynomialBezier.prototype.tangentAngle = function(s) {
            var e = this.derivative(s);
            return Math.atan2(e[1], e[0])
        }
        ,
        PolynomialBezier.prototype.normalAngle = function(s) {
            var e = this.derivative(s);
            return Math.atan2(e[0], e[1])
        }
        ,
        PolynomialBezier.prototype.inflectionPoints = function() {
            var s = this.a[1] * this.b[0] - this.a[0] * this.b[1];
            if (floatZero(s))
                return [];
            var e = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / s
              , a = e * e - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / s;
            if (a < 0)
                return [];
            var o = Math.sqrt(a);
            return floatZero(o) ? o > 0 && o < 1 ? [e] : [] : [e - o, e + o].filter(function(c) {
                return c > 0 && c < 1
            })
        }
        ,
        PolynomialBezier.prototype.split = function(s) {
            if (s <= 0)
                return [singlePoint(this.points[0]), this];
            if (s >= 1)
                return [this, singlePoint(this.points[this.points.length - 1])];
            var e = lerpPoint(this.points[0], this.points[1], s)
              , a = lerpPoint(this.points[1], this.points[2], s)
              , o = lerpPoint(this.points[2], this.points[3], s)
              , c = lerpPoint(e, a, s)
              , d = lerpPoint(a, o, s)
              , g = lerpPoint(c, d, s);
            return [new PolynomialBezier(this.points[0],e,c,g,!0), new PolynomialBezier(g,d,o,this.points[3],!0)]
        }
        ;
        function extrema(s, e) {
            var a = s.points[0][e]
              , o = s.points[s.points.length - 1][e];
            if (a > o) {
                var c = o;
                o = a,
                a = c
            }
            for (var d = quadRoots(3 * s.a[e], 2 * s.b[e], s.c[e]), g = 0; g < d.length; g += 1)
                if (d[g] > 0 && d[g] < 1) {
                    var _ = s.point(d[g])[e];
                    _ < a ? a = _ : _ > o && (o = _)
                }
            return {
                min: a,
                max: o
            }
        }
        PolynomialBezier.prototype.bounds = function() {
            return {
                x: extrema(this, 0),
                y: extrema(this, 1)
            }
        }
        ,
        PolynomialBezier.prototype.boundingBox = function() {
            var s = this.bounds();
            return {
                left: s.x.min,
                right: s.x.max,
                top: s.y.min,
                bottom: s.y.max,
                width: s.x.max - s.x.min,
                height: s.y.max - s.y.min,
                cx: (s.x.max + s.x.min) / 2,
                cy: (s.y.max + s.y.min) / 2
            }
        }
        ;
        function intersectData(s, e, a) {
            var o = s.boundingBox();
            return {
                cx: o.cx,
                cy: o.cy,
                width: o.width,
                height: o.height,
                bez: s,
                t: (e + a) / 2,
                t1: e,
                t2: a
            }
        }
        function splitData(s) {
            var e = s.bez.split(.5);
            return [intersectData(e[0], s.t1, s.t), intersectData(e[1], s.t, s.t2)]
        }
        function boxIntersect(s, e) {
            return Math.abs(s.cx - e.cx) * 2 < s.width + e.width && Math.abs(s.cy - e.cy) * 2 < s.height + e.height
        }
        function intersectsImpl(s, e, a, o, c, d) {
            if (boxIntersect(s, e)) {
                if (a >= d || s.width <= o && s.height <= o && e.width <= o && e.height <= o) {
                    c.push([s.t, e.t]);
                    return
                }
                var g = splitData(s)
                  , _ = splitData(e);
                intersectsImpl(g[0], _[0], a + 1, o, c, d),
                intersectsImpl(g[0], _[1], a + 1, o, c, d),
                intersectsImpl(g[1], _[0], a + 1, o, c, d),
                intersectsImpl(g[1], _[1], a + 1, o, c, d)
            }
        }
        PolynomialBezier.prototype.intersections = function(s, e, a) {
            e === void 0 && (e = 2),
            a === void 0 && (a = 7);
            var o = [];
            return intersectsImpl(intersectData(this, 0, 1), intersectData(s, 0, 1), 0, e, o, a),
            o
        }
        ,
        PolynomialBezier.shapeSegment = function(s, e) {
            var a = (e + 1) % s.length();
            return new PolynomialBezier(s.v[e],s.o[e],s.i[a],s.v[a],!0)
        }
        ,
        PolynomialBezier.shapeSegmentInverted = function(s, e) {
            var a = (e + 1) % s.length();
            return new PolynomialBezier(s.v[a],s.i[a],s.o[e],s.v[e],!0)
        }
        ;
        function crossProduct(s, e) {
            return [s[1] * e[2] - s[2] * e[1], s[2] * e[0] - s[0] * e[2], s[0] * e[1] - s[1] * e[0]]
        }
        function lineIntersection(s, e, a, o) {
            var c = [s[0], s[1], 1]
              , d = [e[0], e[1], 1]
              , g = [a[0], a[1], 1]
              , _ = [o[0], o[1], 1]
              , b = crossProduct(crossProduct(c, d), crossProduct(g, _));
            return floatZero(b[2]) ? null : [b[0] / b[2], b[1] / b[2]]
        }
        function polarOffset(s, e, a) {
            return [s[0] + Math.cos(e) * a, s[1] - Math.sin(e) * a]
        }
        function pointDistance(s, e) {
            return Math.hypot(s[0] - e[0], s[1] - e[1])
        }
        function pointEqual(s, e) {
            return floatEqual(s[0], e[0]) && floatEqual(s[1], e[1])
        }
        function ZigZagModifier() {}
        extendPrototype([ShapeModifier], ZigZagModifier),
        ZigZagModifier.prototype.initModifierProperties = function(s, e) {
            this.getValue = this.processKeys,
            this.amplitude = PropertyFactory.getProp(s, e.s, 0, null, this),
            this.frequency = PropertyFactory.getProp(s, e.r, 0, null, this),
            this.pointsType = PropertyFactory.getProp(s, e.pt, 0, null, this),
            this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0
        }
        ;
        function setPoint(s, e, a, o, c, d, g) {
            var _ = a - Math.PI / 2
              , b = a + Math.PI / 2
              , j = e[0] + Math.cos(a) * o * c
              , $ = e[1] - Math.sin(a) * o * c;
            s.setTripleAt(j, $, j + Math.cos(_) * d, $ - Math.sin(_) * d, j + Math.cos(b) * g, $ - Math.sin(b) * g, s.length())
        }
        function getPerpendicularVector(s, e) {
            var a = [e[0] - s[0], e[1] - s[1]]
              , o = -Math.PI * .5
              , c = [Math.cos(o) * a[0] - Math.sin(o) * a[1], Math.sin(o) * a[0] + Math.cos(o) * a[1]];
            return c
        }
        function getProjectingAngle(s, e) {
            var a = e === 0 ? s.length() - 1 : e - 1
              , o = (e + 1) % s.length()
              , c = s.v[a]
              , d = s.v[o]
              , g = getPerpendicularVector(c, d);
            return Math.atan2(0, 1) - Math.atan2(g[1], g[0])
        }
        function zigZagCorner(s, e, a, o, c, d, g) {
            var _ = getProjectingAngle(e, a)
              , b = e.v[a % e._length]
              , j = e.v[a === 0 ? e._length - 1 : a - 1]
              , $ = e.v[(a + 1) % e._length]
              , nt = d === 2 ? Math.sqrt(Math.pow(b[0] - j[0], 2) + Math.pow(b[1] - j[1], 2)) : 0
              , tt = d === 2 ? Math.sqrt(Math.pow(b[0] - $[0], 2) + Math.pow(b[1] - $[1], 2)) : 0;
            setPoint(s, e.v[a % e._length], _, g, o, tt / ((c + 1) * 2), nt / ((c + 1) * 2))
        }
        function zigZagSegment(s, e, a, o, c, d) {
            for (var g = 0; g < o; g += 1) {
                var _ = (g + 1) / (o + 1)
                  , b = c === 2 ? Math.sqrt(Math.pow(e.points[3][0] - e.points[0][0], 2) + Math.pow(e.points[3][1] - e.points[0][1], 2)) : 0
                  , j = e.normalAngle(_)
                  , $ = e.point(_);
                setPoint(s, $, j, d, a, b / ((o + 1) * 2), b / ((o + 1) * 2)),
                d = -d
            }
            return d
        }
        ZigZagModifier.prototype.processPath = function(s, e, a, o) {
            var c = s._length
              , d = shapePool.newElement();
            if (d.c = s.c,
            s.c || (c -= 1),
            c === 0)
                return d;
            var g = -1
              , _ = PolynomialBezier.shapeSegment(s, 0);
            zigZagCorner(d, s, 0, e, a, o, g);
            for (var b = 0; b < c; b += 1)
                g = zigZagSegment(d, _, e, a, o, -g),
                b === c - 1 && !s.c ? _ = null : _ = PolynomialBezier.shapeSegment(s, (b + 1) % c),
                zigZagCorner(d, s, b + 1, e, a, o, g);
            return d
        }
        ,
        ZigZagModifier.prototype.processShapes = function(s) {
            var e, a, o = this.shapes.length, c, d, g = this.amplitude.v, _ = Math.max(0, Math.round(this.frequency.v)), b = this.pointsType.v;
            if (g !== 0) {
                var j, $;
                for (a = 0; a < o; a += 1) {
                    if (j = this.shapes[a],
                    $ = j.localShapeCollection,
                    !(!j.shape._mdf && !this._mdf && !s))
                        for ($.releaseShapes(),
                        j.shape._mdf = !0,
                        e = j.shape.paths.shapes,
                        d = j.shape.paths._length,
                        c = 0; c < d; c += 1)
                            $.addShape(this.processPath(e[c], g, _, b));
                    j.shape.paths = j.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function linearOffset(s, e, a) {
            var o = Math.atan2(e[0] - s[0], e[1] - s[1]);
            return [polarOffset(s, o, a), polarOffset(e, o, a)]
        }
        function offsetSegment(s, e) {
            var a, o, c, d, g, _, b;
            b = linearOffset(s.points[0], s.points[1], e),
            a = b[0],
            o = b[1],
            b = linearOffset(s.points[1], s.points[2], e),
            c = b[0],
            d = b[1],
            b = linearOffset(s.points[2], s.points[3], e),
            g = b[0],
            _ = b[1];
            var j = lineIntersection(a, o, c, d);
            j === null && (j = o);
            var $ = lineIntersection(g, _, c, d);
            return $ === null && ($ = g),
            new PolynomialBezier(a,j,$,_)
        }
        function joinLines(s, e, a, o, c) {
            var d = e.points[3]
              , g = a.points[0];
            if (o === 3 || pointEqual(d, g))
                return d;
            if (o === 2) {
                var _ = -e.tangentAngle(1)
                  , b = -a.tangentAngle(0) + Math.PI
                  , j = lineIntersection(d, polarOffset(d, _ + Math.PI / 2, 100), g, polarOffset(g, _ + Math.PI / 2, 100))
                  , $ = j ? pointDistance(j, d) : pointDistance(d, g) / 2
                  , nt = polarOffset(d, _, 2 * $ * roundCorner);
                return s.setXYAt(nt[0], nt[1], "o", s.length() - 1),
                nt = polarOffset(g, b, 2 * $ * roundCorner),
                s.setTripleAt(g[0], g[1], g[0], g[1], nt[0], nt[1], s.length()),
                g
            }
            var tt = pointEqual(d, e.points[2]) ? e.points[0] : e.points[2]
              , rt = pointEqual(g, a.points[1]) ? a.points[3] : a.points[1]
              , st = lineIntersection(tt, d, g, rt);
            return st && pointDistance(st, d) < c ? (s.setTripleAt(st[0], st[1], st[0], st[1], st[0], st[1], s.length()),
            st) : d
        }
        function getIntersection(s, e) {
            var a = s.intersections(e);
            return a.length && floatEqual(a[0][0], 1) && a.shift(),
            a.length ? a[0] : null
        }
        function pruneSegmentIntersection(s, e) {
            var a = s.slice()
              , o = e.slice()
              , c = getIntersection(s[s.length - 1], e[0]);
            return c && (a[s.length - 1] = s[s.length - 1].split(c[0])[0],
            o[0] = e[0].split(c[1])[1]),
            s.length > 1 && e.length > 1 && (c = getIntersection(s[0], e[e.length - 1]),
            c) ? [[s[0].split(c[0])[0]], [e[e.length - 1].split(c[1])[1]]] : [a, o]
        }
        function pruneIntersections(s) {
            for (var e, a = 1; a < s.length; a += 1)
                e = pruneSegmentIntersection(s[a - 1], s[a]),
                s[a - 1] = e[0],
                s[a] = e[1];
            return s.length > 1 && (e = pruneSegmentIntersection(s[s.length - 1], s[0]),
            s[s.length - 1] = e[0],
            s[0] = e[1]),
            s
        }
        function offsetSegmentSplit(s, e) {
            var a = s.inflectionPoints(), o, c, d, g;
            if (a.length === 0)
                return [offsetSegment(s, e)];
            if (a.length === 1 || floatEqual(a[1], 1))
                return d = s.split(a[0]),
                o = d[0],
                c = d[1],
                [offsetSegment(o, e), offsetSegment(c, e)];
            d = s.split(a[0]),
            o = d[0];
            var _ = (a[1] - a[0]) / (1 - a[0]);
            return d = d[1].split(_),
            g = d[0],
            c = d[1],
            [offsetSegment(o, e), offsetSegment(g, e), offsetSegment(c, e)]
        }
        function OffsetPathModifier() {}
        extendPrototype([ShapeModifier], OffsetPathModifier),
        OffsetPathModifier.prototype.initModifierProperties = function(s, e) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(s, e.a, 0, null, this),
            this.miterLimit = PropertyFactory.getProp(s, e.ml, 0, null, this),
            this.lineJoin = e.lj,
            this._isAnimated = this.amount.effectsSequence.length !== 0
        }
        ,
        OffsetPathModifier.prototype.processPath = function(s, e, a, o) {
            var c = shapePool.newElement();
            c.c = s.c;
            var d = s.length();
            s.c || (d -= 1);
            var g, _, b, j = [];
            for (g = 0; g < d; g += 1)
                b = PolynomialBezier.shapeSegment(s, g),
                j.push(offsetSegmentSplit(b, e));
            if (!s.c)
                for (g = d - 1; g >= 0; g -= 1)
                    b = PolynomialBezier.shapeSegmentInverted(s, g),
                    j.push(offsetSegmentSplit(b, e));
            j = pruneIntersections(j);
            var $ = null
              , nt = null;
            for (g = 0; g < j.length; g += 1) {
                var tt = j[g];
                for (nt && ($ = joinLines(c, nt, tt[0], a, o)),
                nt = tt[tt.length - 1],
                _ = 0; _ < tt.length; _ += 1)
                    b = tt[_],
                    $ && pointEqual(b.points[0], $) ? c.setXYAt(b.points[1][0], b.points[1][1], "o", c.length() - 1) : c.setTripleAt(b.points[0][0], b.points[0][1], b.points[1][0], b.points[1][1], b.points[0][0], b.points[0][1], c.length()),
                    c.setTripleAt(b.points[3][0], b.points[3][1], b.points[3][0], b.points[3][1], b.points[2][0], b.points[2][1], c.length()),
                    $ = b.points[3]
            }
            return j.length && joinLines(c, nt, j[0][0], a, o),
            c
        }
        ,
        OffsetPathModifier.prototype.processShapes = function(s) {
            var e, a, o = this.shapes.length, c, d, g = this.amount.v, _ = this.miterLimit.v, b = this.lineJoin;
            if (g !== 0) {
                var j, $;
                for (a = 0; a < o; a += 1) {
                    if (j = this.shapes[a],
                    $ = j.localShapeCollection,
                    !(!j.shape._mdf && !this._mdf && !s))
                        for ($.releaseShapes(),
                        j.shape._mdf = !0,
                        e = j.shape.paths.shapes,
                        d = j.shape.paths._length,
                        c = 0; c < d; c += 1)
                            $.addShape(this.processPath(e[c], g, b, _));
                    j.shape.paths = j.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function getFontProperties(s) {
            for (var e = s.fStyle ? s.fStyle.split(" ") : [], a = "normal", o = "normal", c = e.length, d, g = 0; g < c; g += 1)
                switch (d = e[g].toLowerCase(),
                d) {
                case "italic":
                    o = "italic";
                    break;
                case "bold":
                    a = "700";
                    break;
                case "black":
                    a = "900";
                    break;
                case "medium":
                    a = "500";
                    break;
                case "regular":
                case "normal":
                    a = "400";
                    break;
                case "light":
                case "thin":
                    a = "200";
                    break
                }
            return {
                style: o,
                weight: s.fWeight || a
            }
        }
        var FontManager = function() {
            var s = 5e3
              , e = {
                w: 0,
                size: 0,
                shapes: [],
                data: {
                    shapes: []
                }
            }
              , a = [];
            a = a.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
            var o = 127988
              , c = 917631
              , d = 917601
              , g = 917626
              , _ = 65039
              , b = 8205
              , j = 127462
              , $ = 127487
              , nt = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
            function tt(Mt) {
                var Tt = Mt.split(","), mt, St = Tt.length, wt = [];
                for (mt = 0; mt < St; mt += 1)
                    Tt[mt] !== "sans-serif" && Tt[mt] !== "monospace" && wt.push(Tt[mt]);
                return wt.join(",")
            }
            function rt(Mt, Tt) {
                var mt = createTag("span");
                mt.setAttribute("aria-hidden", !0),
                mt.style.fontFamily = Tt;
                var St = createTag("span");
                St.innerText = "giItT1WQy@!-/#",
                mt.style.position = "absolute",
                mt.style.left = "-10000px",
                mt.style.top = "-10000px",
                mt.style.fontSize = "300px",
                mt.style.fontVariant = "normal",
                mt.style.fontStyle = "normal",
                mt.style.fontWeight = "normal",
                mt.style.letterSpacing = "0",
                mt.appendChild(St),
                document.body.appendChild(mt);
                var wt = St.offsetWidth;
                return St.style.fontFamily = tt(Mt) + ", " + Tt,
                {
                    node: St,
                    w: wt,
                    parent: mt
                }
            }
            function st() {
                var Mt, Tt = this.fonts.length, mt, St, wt = Tt;
                for (Mt = 0; Mt < Tt; Mt += 1)
                    this.fonts[Mt].loaded ? wt -= 1 : this.fonts[Mt].fOrigin === "n" || this.fonts[Mt].origin === 0 ? this.fonts[Mt].loaded = !0 : (mt = this.fonts[Mt].monoCase.node,
                    St = this.fonts[Mt].monoCase.w,
                    mt.offsetWidth !== St ? (wt -= 1,
                    this.fonts[Mt].loaded = !0) : (mt = this.fonts[Mt].sansCase.node,
                    St = this.fonts[Mt].sansCase.w,
                    mt.offsetWidth !== St && (wt -= 1,
                    this.fonts[Mt].loaded = !0)),
                    this.fonts[Mt].loaded && (this.fonts[Mt].sansCase.parent.parentNode.removeChild(this.fonts[Mt].sansCase.parent),
                    this.fonts[Mt].monoCase.parent.parentNode.removeChild(this.fonts[Mt].monoCase.parent)));
                wt !== 0 && Date.now() - this.initTime < s ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
            }
            function lt(Mt, Tt) {
                var mt = document.body && Tt ? "svg" : "canvas", St, wt = getFontProperties(Mt);
                if (mt === "svg") {
                    var Ct = createNS("text");
                    Ct.style.fontSize = "100px",
                    Ct.setAttribute("font-family", Mt.fFamily),
                    Ct.setAttribute("font-style", wt.style),
                    Ct.setAttribute("font-weight", wt.weight),
                    Ct.textContent = "1",
                    Mt.fClass ? (Ct.style.fontFamily = "inherit",
                    Ct.setAttribute("class", Mt.fClass)) : Ct.style.fontFamily = Mt.fFamily,
                    Tt.appendChild(Ct),
                    St = Ct
                } else {
                    var Ht = new OffscreenCanvas(500,500).getContext("2d");
                    Ht.font = wt.style + " " + wt.weight + " 100px " + Mt.fFamily,
                    St = Ht
                }
                function en(Ot) {
                    return mt === "svg" ? (St.textContent = Ot,
                    St.getComputedTextLength()) : St.measureText(Ot).width
                }
                return {
                    measureText: en
                }
            }
            function ct(Mt, Tt) {
                if (!Mt) {
                    this.isLoaded = !0;
                    return
                }
                if (this.chars) {
                    this.isLoaded = !0,
                    this.fonts = Mt.list;
                    return
                }
                if (!document.body) {
                    this.isLoaded = !0,
                    Mt.list.forEach(function(An) {
                        An.helper = lt(An),
                        An.cache = {}
                    }),
                    this.fonts = Mt.list;
                    return
                }
                var mt = Mt.list, St, wt = mt.length, Ct = wt;
                for (St = 0; St < wt; St += 1) {
                    var Ht = !0, en, Ot;
                    if (mt[St].loaded = !1,
                    mt[St].monoCase = rt(mt[St].fFamily, "monospace"),
                    mt[St].sansCase = rt(mt[St].fFamily, "sans-serif"),
                    !mt[St].fPath)
                        mt[St].loaded = !0,
                        Ct -= 1;
                    else if (mt[St].fOrigin === "p" || mt[St].origin === 3) {
                        if (en = document.querySelectorAll('style[f-forigin="p"][f-family="' + mt[St].fFamily + '"], style[f-origin="3"][f-family="' + mt[St].fFamily + '"]'),
                        en.length > 0 && (Ht = !1),
                        Ht) {
                            var Yt = createTag("style");
                            Yt.setAttribute("f-forigin", mt[St].fOrigin),
                            Yt.setAttribute("f-origin", mt[St].origin),
                            Yt.setAttribute("f-family", mt[St].fFamily),
                            Yt.type = "text/css",
                            Yt.innerText = "@font-face {font-family: " + mt[St].fFamily + "; font-style: normal; src: url('" + mt[St].fPath + "');}",
                            Tt.appendChild(Yt)
                        }
                    } else if (mt[St].fOrigin === "g" || mt[St].origin === 1) {
                        for (en = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'),
                        Ot = 0; Ot < en.length; Ot += 1)
                            en[Ot].href.indexOf(mt[St].fPath) !== -1 && (Ht = !1);
                        if (Ht) {
                            var rn = createTag("link");
                            rn.setAttribute("f-forigin", mt[St].fOrigin),
                            rn.setAttribute("f-origin", mt[St].origin),
                            rn.type = "text/css",
                            rn.rel = "stylesheet",
                            rn.href = mt[St].fPath,
                            document.body.appendChild(rn)
                        }
                    } else if (mt[St].fOrigin === "t" || mt[St].origin === 2) {
                        for (en = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'),
                        Ot = 0; Ot < en.length; Ot += 1)
                            mt[St].fPath === en[Ot].src && (Ht = !1);
                        if (Ht) {
                            var Xt = createTag("link");
                            Xt.setAttribute("f-forigin", mt[St].fOrigin),
                            Xt.setAttribute("f-origin", mt[St].origin),
                            Xt.setAttribute("rel", "stylesheet"),
                            Xt.setAttribute("href", mt[St].fPath),
                            Tt.appendChild(Xt)
                        }
                    }
                    mt[St].helper = lt(mt[St], Tt),
                    mt[St].cache = {},
                    this.fonts.push(mt[St])
                }
                Ct === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
            }
            function it(Mt) {
                if (Mt) {
                    this.chars || (this.chars = []);
                    var Tt, mt = Mt.length, St, wt = this.chars.length, Ct;
                    for (Tt = 0; Tt < mt; Tt += 1) {
                        for (St = 0,
                        Ct = !1; St < wt; )
                            this.chars[St].style === Mt[Tt].style && this.chars[St].fFamily === Mt[Tt].fFamily && this.chars[St].ch === Mt[Tt].ch && (Ct = !0),
                            St += 1;
                        Ct || (this.chars.push(Mt[Tt]),
                        wt += 1)
                    }
                }
            }
            function ot(Mt, Tt, mt) {
                for (var St = 0, wt = this.chars.length; St < wt; ) {
                    if (this.chars[St].ch === Mt && this.chars[St].style === Tt && this.chars[St].fFamily === mt)
                        return this.chars[St];
                    St += 1
                }
                return (typeof Mt == "string" && Mt.charCodeAt(0) !== 13 || !Mt) && console && console.warn && !this._warned && (this._warned = !0,
                console.warn("Missing character from exported characters list: ", Mt, Tt, mt)),
                e
            }
            function at(Mt, Tt, mt) {
                var St = this.getFontByName(Tt)
                  , wt = Mt;
                if (!St.cache[wt]) {
                    var Ct = St.helper;
                    if (Mt === " ") {
                        var Ht = Ct.measureText("|" + Mt + "|")
                          , en = Ct.measureText("||");
                        St.cache[wt] = (Ht - en) / 100
                    } else
                        St.cache[wt] = Ct.measureText(Mt) / 100
                }
                return St.cache[wt] * mt
            }
            function ht(Mt) {
                for (var Tt = 0, mt = this.fonts.length; Tt < mt; ) {
                    if (this.fonts[Tt].fName === Mt)
                        return this.fonts[Tt];
                    Tt += 1
                }
                return this.fonts[0]
            }
            function pt(Mt) {
                var Tt = 0
                  , mt = Mt.charCodeAt(0);
                if (mt >= 55296 && mt <= 56319) {
                    var St = Mt.charCodeAt(1);
                    St >= 56320 && St <= 57343 && (Tt = (mt - 55296) * 1024 + St - 56320 + 65536)
                }
                return Tt
            }
            function dt(Mt, Tt) {
                var mt = Mt.toString(16) + Tt.toString(16);
                return nt.indexOf(mt) !== -1
            }
            function yt(Mt) {
                return Mt === b
            }
            function vt(Mt) {
                return Mt === _
            }
            function xt(Mt) {
                var Tt = pt(Mt);
                return Tt >= j && Tt <= $
            }
            function _t(Mt) {
                return xt(Mt.substr(0, 2)) && xt(Mt.substr(2, 2))
            }
            function bt(Mt) {
                return a.indexOf(Mt) !== -1
            }
            function Rt(Mt, Tt) {
                var mt = pt(Mt.substr(Tt, 2));
                if (mt !== o)
                    return !1;
                var St = 0;
                for (Tt += 2; St < 5; ) {
                    if (mt = pt(Mt.substr(Tt, 2)),
                    mt < d || mt > g)
                        return !1;
                    St += 1,
                    Tt += 2
                }
                return pt(Mt.substr(Tt, 2)) === c
            }
            function Ft() {
                this.isLoaded = !0
            }
            var Bt = function() {
                this.fonts = [],
                this.chars = null,
                this.typekitLoaded = 0,
                this.isLoaded = !1,
                this._warned = !1,
                this.initTime = Date.now(),
                this.setIsLoadedBinded = this.setIsLoaded.bind(this),
                this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
            };
            Bt.isModifier = dt,
            Bt.isZeroWidthJoiner = yt,
            Bt.isFlagEmoji = _t,
            Bt.isRegionalCode = xt,
            Bt.isCombinedCharacter = bt,
            Bt.isRegionalFlag = Rt,
            Bt.isVariationSelector = vt,
            Bt.BLACK_FLAG_CODE_POINT = o;
            var Dt = {
                addChars: it,
                addFonts: ct,
                getCharData: ot,
                getFontByName: ht,
                measureText: at,
                checkLoadedFonts: st,
                setIsLoaded: Ft
            };
            return Bt.prototype = Dt,
            Bt
        }();
        function SlotManager(s) {
            this.animationData = s
        }
        SlotManager.prototype.getProp = function(s) {
            return this.animationData.slots && this.animationData.slots[s.sid] ? Object.assign(s, this.animationData.slots[s.sid].p) : s
        }
        ;
        function slotFactory(s) {
            return new SlotManager(s)
        }
        function RenderableElement() {}
        RenderableElement.prototype = {
            initRenderable: function() {
                this.isInRange = !1,
                this.hidden = !1,
                this.isTransparent = !1,
                this.renderableComponents = []
            },
            addRenderableComponent: function(e) {
                this.renderableComponents.indexOf(e) === -1 && this.renderableComponents.push(e)
            },
            removeRenderableComponent: function(e) {
                this.renderableComponents.indexOf(e) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(e), 1)
            },
            prepareRenderableFrame: function(e) {
                this.checkLayerLimits(e)
            },
            checkTransparency: function() {
                this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0,
                this.hide()) : this.isTransparent && (this.isTransparent = !1,
                this.show())
            },
            checkLayerLimits: function(e) {
                this.data.ip - this.data.st <= e && this.data.op - this.data.st > e ? this.isInRange !== !0 && (this.globalData._mdf = !0,
                this._mdf = !0,
                this.isInRange = !0,
                this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0,
                this.isInRange = !1,
                this.hide())
            },
            renderRenderable: function() {
                var e, a = this.renderableComponents.length;
                for (e = 0; e < a; e += 1)
                    this.renderableComponents[e].renderFrame(this._isFirstFrame)
            },
            sourceRectAtTime: function() {
                return {
                    top: 0,
                    left: 0,
                    width: 100,
                    height: 100
                }
            },
            getLayerSize: function() {
                return this.data.ty === 5 ? {
                    w: this.data.textData.width,
                    h: this.data.textData.height
                } : {
                    w: this.data.width,
                    h: this.data.height
                }
            }
        };
        var getBlendMode = function() {
            var s = {
                0: "source-over",
                1: "multiply",
                2: "screen",
                3: "overlay",
                4: "darken",
                5: "lighten",
                6: "color-dodge",
                7: "color-burn",
                8: "hard-light",
                9: "soft-light",
                10: "difference",
                11: "exclusion",
                12: "hue",
                13: "saturation",
                14: "color",
                15: "luminosity"
            };
            return function(e) {
                return s[e] || ""
            }
        }();
        function SliderEffect(s, e, a) {
            this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
        }
        function AngleEffect(s, e, a) {
            this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
        }
        function ColorEffect(s, e, a) {
            this.p = PropertyFactory.getProp(e, s.v, 1, 0, a)
        }
        function PointEffect(s, e, a) {
            this.p = PropertyFactory.getProp(e, s.v, 1, 0, a)
        }
        function LayerIndexEffect(s, e, a) {
            this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
        }
        function MaskIndexEffect(s, e, a) {
            this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
        }
        function CheckboxEffect(s, e, a) {
            this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
        }
        function NoValueEffect() {
            this.p = {}
        }
        function EffectsManager(s, e) {
            var a = s.ef || [];
            this.effectElements = [];
            var o, c = a.length, d;
            for (o = 0; o < c; o += 1)
                d = new GroupEffect(a[o],e),
                this.effectElements.push(d)
        }
        function GroupEffect(s, e) {
            this.init(s, e)
        }
        extendPrototype([DynamicPropertyContainer], GroupEffect),
        GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties,
        GroupEffect.prototype.init = function(s, e) {
            this.data = s,
            this.effectElements = [],
            this.initDynamicPropertyContainer(e);
            var a, o = this.data.ef.length, c, d = this.data.ef;
            for (a = 0; a < o; a += 1) {
                switch (c = null,
                d[a].ty) {
                case 0:
                    c = new SliderEffect(d[a],e,this);
                    break;
                case 1:
                    c = new AngleEffect(d[a],e,this);
                    break;
                case 2:
                    c = new ColorEffect(d[a],e,this);
                    break;
                case 3:
                    c = new PointEffect(d[a],e,this);
                    break;
                case 4:
                case 7:
                    c = new CheckboxEffect(d[a],e,this);
                    break;
                case 10:
                    c = new LayerIndexEffect(d[a],e,this);
                    break;
                case 11:
                    c = new MaskIndexEffect(d[a],e,this);
                    break;
                case 5:
                    c = new EffectsManager(d[a],e);
                    break;
                default:
                    c = new NoValueEffect(d[a]);
                    break
                }
                c && this.effectElements.push(c)
            }
        }
        ;
        function BaseElement() {}
        BaseElement.prototype = {
            checkMasks: function() {
                if (!this.data.hasMask)
                    return !1;
                for (var e = 0, a = this.data.masksProperties.length; e < a; ) {
                    if (this.data.masksProperties[e].mode !== "n" && this.data.masksProperties[e].cl !== !1)
                        return !0;
                    e += 1
                }
                return !1
            },
            initExpressions: function() {
                var e = getExpressionInterfaces();
                if (e) {
                    var a = e("layer")
                      , o = e("effects")
                      , c = e("shape")
                      , d = e("text")
                      , g = e("comp");
                    this.layerInterface = a(this),
                    this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                    var _ = o.createEffectsInterface(this, this.layerInterface);
                    this.layerInterface.registerEffectsInterface(_),
                    this.data.ty === 0 || this.data.xt ? this.compInterface = g(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = c(this.shapesData, this.itemsData, this.layerInterface),
                    this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = d(this),
                    this.layerInterface.text = this.layerInterface.textInterface)
                }
            },
            setBlendMode: function() {
                var e = getBlendMode(this.data.bm)
                  , a = this.baseElement || this.layerElement;
                a.style["mix-blend-mode"] = e
            },
            initBaseData: function(e, a, o) {
                this.globalData = a,
                this.comp = o,
                this.data = e,
                this.layerId = createElementID(),
                this.data.sr || (this.data.sr = 1),
                this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties)
            },
            getType: function() {
                return this.type
            },
            sourceRectAtTime: function() {}
        };
        function FrameElement() {}
        FrameElement.prototype = {
            initFrame: function() {
                this._isFirstFrame = !1,
                this.dynamicProperties = [],
                this._mdf = !1
            },
            prepareProperties: function(e, a) {
                var o, c = this.dynamicProperties.length;
                for (o = 0; o < c; o += 1)
                    (a || this._isParent && this.dynamicProperties[o].propType === "transform") && (this.dynamicProperties[o].getValue(),
                    this.dynamicProperties[o]._mdf && (this.globalData._mdf = !0,
                    this._mdf = !0))
            },
            addDynamicProperty: function(e) {
                this.dynamicProperties.indexOf(e) === -1 && this.dynamicProperties.push(e)
            }
        };
        function FootageElement(s, e, a) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = e.getAssetData(s.refId),
            this.footageData = e.imageLoader.getAsset(this.assetData),
            this.initBaseData(s, e, a)
        }
        FootageElement.prototype.prepareFrame = function() {}
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement),
        FootageElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        FootageElement.prototype.renderFrame = function() {}
        ,
        FootageElement.prototype.destroy = function() {}
        ,
        FootageElement.prototype.initExpressions = function() {
            var s = getExpressionInterfaces();
            if (s) {
                var e = s("footage");
                this.layerInterface = e(this)
            }
        }
        ,
        FootageElement.prototype.getFootageData = function() {
            return this.footageData
        }
        ;
        function AudioElement(s, e, a) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = e.getAssetData(s.refId),
            this.initBaseData(s, e, a),
            this._isPlaying = !1,
            this._canPlay = !1;
            var o = this.globalData.getAssetsPath(this.assetData);
            this.audio = this.globalData.audioController.createAudio(o),
            this._currentTime = 0,
            this.globalData.audioController.addAudio(this),
            this._volumeMultiplier = 1,
            this._volume = 1,
            this._previousVolume = null,
            this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this) : {
                _placeholder: !0
            },
            this.lv = PropertyFactory.getProp(this, s.au && s.au.lv ? s.au.lv : {
                k: [100]
            }, 1, .01, this)
        }
        AudioElement.prototype.prepareFrame = function(s) {
            if (this.prepareRenderableFrame(s, !0),
            this.prepareProperties(s, !0),
            this.tm._placeholder)
                this._currentTime = s / this.data.sr;
            else {
                var e = this.tm.v;
                this._currentTime = e
            }
            this._volume = this.lv.v[0];
            var a = this._volume * this._volumeMultiplier;
            this._previousVolume !== a && (this._previousVolume = a,
            this.audio.volume(a))
        }
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement),
        AudioElement.prototype.renderFrame = function() {
            this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(),
            this.audio.seek(this._currentTime / this.globalData.frameRate),
            this._isPlaying = !0))
        }
        ,
        AudioElement.prototype.show = function() {}
        ,
        AudioElement.prototype.hide = function() {
            this.audio.pause(),
            this._isPlaying = !1
        }
        ,
        AudioElement.prototype.pause = function() {
            this.audio.pause(),
            this._isPlaying = !1,
            this._canPlay = !1
        }
        ,
        AudioElement.prototype.resume = function() {
            this._canPlay = !0
        }
        ,
        AudioElement.prototype.setRate = function(s) {
            this.audio.rate(s)
        }
        ,
        AudioElement.prototype.volume = function(s) {
            this._volumeMultiplier = s,
            this._previousVolume = s * this._volume,
            this.audio.volume(this._previousVolume)
        }
        ,
        AudioElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        AudioElement.prototype.destroy = function() {}
        ,
        AudioElement.prototype.sourceRectAtTime = function() {}
        ,
        AudioElement.prototype.initExpressions = function() {}
        ;
        function BaseRenderer() {}
        BaseRenderer.prototype.checkLayers = function(s) {
            var e, a = this.layers.length, o;
            for (this.completeLayers = !0,
            e = a - 1; e >= 0; e -= 1)
                this.elements[e] || (o = this.layers[e],
                o.ip - o.st <= s - this.layers[e].st && o.op - o.st > s - this.layers[e].st && this.buildItem(e)),
                this.completeLayers = this.elements[e] ? this.completeLayers : !1;
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.createItem = function(s) {
            switch (s.ty) {
            case 2:
                return this.createImage(s);
            case 0:
                return this.createComp(s);
            case 1:
                return this.createSolid(s);
            case 3:
                return this.createNull(s);
            case 4:
                return this.createShape(s);
            case 5:
                return this.createText(s);
            case 6:
                return this.createAudio(s);
            case 13:
                return this.createCamera(s);
            case 15:
                return this.createFootage(s);
            default:
                return this.createNull(s)
            }
        }
        ,
        BaseRenderer.prototype.createCamera = function() {
            throw new Error("You're using a 3d camera. Try the html renderer.")
        }
        ,
        BaseRenderer.prototype.createAudio = function(s) {
            return new AudioElement(s,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.createFootage = function(s) {
            return new FootageElement(s,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.buildAllItems = function() {
            var s, e = this.layers.length;
            for (s = 0; s < e; s += 1)
                this.buildItem(s);
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.includeLayers = function(s) {
            this.completeLayers = !1;
            var e, a = s.length, o, c = this.layers.length;
            for (e = 0; e < a; e += 1)
                for (o = 0; o < c; ) {
                    if (this.layers[o].id === s[e].id) {
                        this.layers[o] = s[e];
                        break
                    }
                    o += 1
                }
        }
        ,
        BaseRenderer.prototype.setProjectInterface = function(s) {
            this.globalData.projectInterface = s
        }
        ,
        BaseRenderer.prototype.initItems = function() {
            this.globalData.progressiveLoad || this.buildAllItems()
        }
        ,
        BaseRenderer.prototype.buildElementParenting = function(s, e, a) {
            for (var o = this.elements, c = this.layers, d = 0, g = c.length; d < g; )
                c[d].ind == e && (!o[d] || o[d] === !0 ? (this.buildItem(d),
                this.addPendingElement(s)) : (a.push(o[d]),
                o[d].setAsParent(),
                c[d].parent !== void 0 ? this.buildElementParenting(s, c[d].parent, a) : s.setHierarchy(a))),
                d += 1
        }
        ,
        BaseRenderer.prototype.addPendingElement = function(s) {
            this.pendingElements.push(s)
        }
        ,
        BaseRenderer.prototype.searchExtraCompositions = function(s) {
            var e, a = s.length;
            for (e = 0; e < a; e += 1)
                if (s[e].xt) {
                    var o = this.createComp(s[e]);
                    o.initExpressions(),
                    this.globalData.projectInterface.registerComposition(o)
                }
        }
        ,
        BaseRenderer.prototype.getElementById = function(s) {
            var e, a = this.elements.length;
            for (e = 0; e < a; e += 1)
                if (this.elements[e].data.ind === s)
                    return this.elements[e];
            return null
        }
        ,
        BaseRenderer.prototype.getElementByPath = function(s) {
            var e = s.shift(), a;
            if (typeof e == "number")
                a = this.elements[e];
            else {
                var o, c = this.elements.length;
                for (o = 0; o < c; o += 1)
                    if (this.elements[o].data.nm === e) {
                        a = this.elements[o];
                        break
                    }
            }
            return s.length === 0 ? a : a.getElementByPath(s)
        }
        ,
        BaseRenderer.prototype.setupGlobalData = function(s, e) {
            this.globalData.fontManager = new FontManager,
            this.globalData.slotManager = slotFactory(s),
            this.globalData.fontManager.addChars(s.chars),
            this.globalData.fontManager.addFonts(s.fonts, e),
            this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem),
            this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem),
            this.globalData.imageLoader = this.animationItem.imagePreloader,
            this.globalData.audioController = this.animationItem.audioController,
            this.globalData.frameId = 0,
            this.globalData.frameRate = s.fr,
            this.globalData.nm = s.nm,
            this.globalData.compSize = {
                w: s.w,
                h: s.h
            }
        }
        ;
        var effectTypes = {
            TRANSFORM_EFFECT: "transformEFfect"
        };
        function TransformElement() {}
        TransformElement.prototype = {
            initTransform: function() {
                var e = new Matrix;
                this.finalTransform = {
                    mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                        o: 0
                    },
                    _matMdf: !1,
                    _localMatMdf: !1,
                    _opMdf: !1,
                    mat: e,
                    localMat: e,
                    localOpacity: 1
                },
                this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
                this.data.ty
            },
            renderTransform: function() {
                if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame,
                this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame,
                this.hierarchy) {
                    var e, a = this.finalTransform.mat, o = 0, c = this.hierarchy.length;
                    if (!this.finalTransform._matMdf)
                        for (; o < c; ) {
                            if (this.hierarchy[o].finalTransform.mProp._mdf) {
                                this.finalTransform._matMdf = !0;
                                break
                            }
                            o += 1
                        }
                    if (this.finalTransform._matMdf)
                        for (e = this.finalTransform.mProp.v.props,
                        a.cloneFromProps(e),
                        o = 0; o < c; o += 1)
                            a.multiply(this.hierarchy[o].finalTransform.mProp.v)
                }
                this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
                this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
            },
            renderLocalTransform: function() {
                if (this.localTransforms) {
                    var e = 0
                      , a = this.localTransforms.length;
                    if (this.finalTransform._localMatMdf = this.finalTransform._matMdf,
                    !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
                        for (; e < a; )
                            this.localTransforms[e]._mdf && (this.finalTransform._localMatMdf = !0),
                            this.localTransforms[e]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v,
                            this.finalTransform._opMdf = !0),
                            e += 1;
                    if (this.finalTransform._localMatMdf) {
                        var o = this.finalTransform.localMat;
                        for (this.localTransforms[0].matrix.clone(o),
                        e = 1; e < a; e += 1) {
                            var c = this.localTransforms[e].matrix;
                            o.multiply(c)
                        }
                        o.multiply(this.finalTransform.mat)
                    }
                    if (this.finalTransform._opMdf) {
                        var d = this.finalTransform.localOpacity;
                        for (e = 0; e < a; e += 1)
                            d *= this.localTransforms[e].opacity * .01;
                        this.finalTransform.localOpacity = d
                    }
                }
            },
            searchEffectTransforms: function() {
                if (this.renderableEffectsManager) {
                    var e = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                    if (e.length) {
                        this.localTransforms = [],
                        this.finalTransform.localMat = new Matrix;
                        var a = 0
                          , o = e.length;
                        for (a = 0; a < o; a += 1)
                            this.localTransforms.push(e[a])
                    }
                }
            },
            globalToLocal: function(e) {
                var a = [];
                a.push(this.finalTransform);
                for (var o = !0, c = this.comp; o; )
                    c.finalTransform ? (c.data.hasMask && a.splice(0, 0, c.finalTransform),
                    c = c.comp) : o = !1;
                var d, g = a.length, _;
                for (d = 0; d < g; d += 1)
                    _ = a[d].mat.applyToPointArray(0, 0, 0),
                    e = [e[0] - _[0], e[1] - _[1], 0];
                return e
            },
            mHelper: new Matrix
        };
        function MaskElement(s, e, a) {
            this.data = s,
            this.element = e,
            this.globalData = a,
            this.storedData = [],
            this.masksProperties = this.data.masksProperties || [],
            this.maskElement = null;
            var o = this.globalData.defs, c, d = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(d),
            this.solidPath = "";
            var g, _ = this.masksProperties, b = 0, j = [], $, nt, tt = createElementID(), rt, st, lt, ct, it = "clipPath", ot = "clip-path";
            for (c = 0; c < d; c += 1)
                if ((_[c].mode !== "a" && _[c].mode !== "n" || _[c].inv || _[c].o.k !== 100 || _[c].o.x) && (it = "mask",
                ot = "mask"),
                (_[c].mode === "s" || _[c].mode === "i") && b === 0 ? (rt = createNS("rect"),
                rt.setAttribute("fill", "#ffffff"),
                rt.setAttribute("width", this.element.comp.data.w || 0),
                rt.setAttribute("height", this.element.comp.data.h || 0),
                j.push(rt)) : rt = null,
                g = createNS("path"),
                _[c].mode === "n")
                    this.viewData[c] = {
                        op: PropertyFactory.getProp(this.element, _[c].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, _[c], 3),
                        elem: g,
                        lastPath: ""
                    },
                    o.appendChild(g);
                else {
                    b += 1,
                    g.setAttribute("fill", _[c].mode === "s" ? "#000000" : "#ffffff"),
                    g.setAttribute("clip-rule", "nonzero");
                    var at;
                    if (_[c].x.k !== 0 ? (it = "mask",
                    ot = "mask",
                    ct = PropertyFactory.getProp(this.element, _[c].x, 0, null, this.element),
                    at = createElementID(),
                    st = createNS("filter"),
                    st.setAttribute("id", at),
                    lt = createNS("feMorphology"),
                    lt.setAttribute("operator", "erode"),
                    lt.setAttribute("in", "SourceGraphic"),
                    lt.setAttribute("radius", "0"),
                    st.appendChild(lt),
                    o.appendChild(st),
                    g.setAttribute("stroke", _[c].mode === "s" ? "#000000" : "#ffffff")) : (lt = null,
                    ct = null),
                    this.storedData[c] = {
                        elem: g,
                        x: ct,
                        expan: lt,
                        lastPath: "",
                        lastOperator: "",
                        filterId: at,
                        lastRadius: 0
                    },
                    _[c].mode === "i") {
                        nt = j.length;
                        var ht = createNS("g");
                        for ($ = 0; $ < nt; $ += 1)
                            ht.appendChild(j[$]);
                        var pt = createNS("mask");
                        pt.setAttribute("mask-type", "alpha"),
                        pt.setAttribute("id", tt + "_" + b),
                        pt.appendChild(g),
                        o.appendChild(pt),
                        ht.setAttribute("mask", "url(" + getLocationHref() + "#" + tt + "_" + b + ")"),
                        j.length = 0,
                        j.push(ht)
                    } else
                        j.push(g);
                    _[c].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()),
                    this.viewData[c] = {
                        elem: g,
                        lastPath: "",
                        op: PropertyFactory.getProp(this.element, _[c].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, _[c], 3),
                        invRect: rt
                    },
                    this.viewData[c].prop.k || this.drawPath(_[c], this.viewData[c].prop.v, this.viewData[c])
                }
            for (this.maskElement = createNS(it),
            d = j.length,
            c = 0; c < d; c += 1)
                this.maskElement.appendChild(j[c]);
            b > 0 && (this.maskElement.setAttribute("id", tt),
            this.element.maskedElement.setAttribute(ot, "url(" + getLocationHref() + "#" + tt + ")"),
            o.appendChild(this.maskElement)),
            this.viewData.length && this.element.addRenderableComponent(this)
        }
        MaskElement.prototype.getMaskProperty = function(s) {
            return this.viewData[s].prop
        }
        ,
        MaskElement.prototype.renderFrame = function(s) {
            var e = this.element.finalTransform.mat, a, o = this.masksProperties.length;
            for (a = 0; a < o; a += 1)
                if ((this.viewData[a].prop._mdf || s) && this.drawPath(this.masksProperties[a], this.viewData[a].prop.v, this.viewData[a]),
                (this.viewData[a].op._mdf || s) && this.viewData[a].elem.setAttribute("fill-opacity", this.viewData[a].op.v),
                this.masksProperties[a].mode !== "n" && (this.viewData[a].invRect && (this.element.finalTransform.mProp._mdf || s) && this.viewData[a].invRect.setAttribute("transform", e.getInverseMatrix().to2dCSS()),
                this.storedData[a].x && (this.storedData[a].x._mdf || s))) {
                    var c = this.storedData[a].expan;
                    this.storedData[a].x.v < 0 ? (this.storedData[a].lastOperator !== "erode" && (this.storedData[a].lastOperator = "erode",
                    this.storedData[a].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[a].filterId + ")")),
                    c.setAttribute("radius", -this.storedData[a].x.v)) : (this.storedData[a].lastOperator !== "dilate" && (this.storedData[a].lastOperator = "dilate",
                    this.storedData[a].elem.setAttribute("filter", null)),
                    this.storedData[a].elem.setAttribute("stroke-width", this.storedData[a].x.v * 2))
                }
        }
        ,
        MaskElement.prototype.getMaskelement = function() {
            return this.maskElement
        }
        ,
        MaskElement.prototype.createLayerSolidPath = function() {
            var s = "M0,0 ";
            return s += " h" + this.globalData.compSize.w,
            s += " v" + this.globalData.compSize.h,
            s += " h-" + this.globalData.compSize.w,
            s += " v-" + this.globalData.compSize.h + " ",
            s
        }
        ,
        MaskElement.prototype.drawPath = function(s, e, a) {
            var o = " M" + e.v[0][0] + "," + e.v[0][1], c, d;
            for (d = e._length,
            c = 1; c < d; c += 1)
                o += " C" + e.o[c - 1][0] + "," + e.o[c - 1][1] + " " + e.i[c][0] + "," + e.i[c][1] + " " + e.v[c][0] + "," + e.v[c][1];
            if (e.c && d > 1 && (o += " C" + e.o[c - 1][0] + "," + e.o[c - 1][1] + " " + e.i[0][0] + "," + e.i[0][1] + " " + e.v[0][0] + "," + e.v[0][1]),
            a.lastPath !== o) {
                var g = "";
                a.elem && (e.c && (g = s.inv ? this.solidPath + o : o),
                a.elem.setAttribute("d", g)),
                a.lastPath = o
            }
        }
        ,
        MaskElement.prototype.destroy = function() {
            this.element = null,
            this.globalData = null,
            this.maskElement = null,
            this.data = null,
            this.masksProperties = null
        }
        ;
        var filtersFactory = function() {
            var s = {};
            s.createFilter = e,
            s.createAlphaToLuminanceFilter = a;
            function e(o, c) {
                var d = createNS("filter");
                return d.setAttribute("id", o),
                c !== !0 && (d.setAttribute("filterUnits", "objectBoundingBox"),
                d.setAttribute("x", "0%"),
                d.setAttribute("y", "0%"),
                d.setAttribute("width", "100%"),
                d.setAttribute("height", "100%")),
                d
            }
            function a() {
                var o = createNS("feColorMatrix");
                return o.setAttribute("type", "matrix"),
                o.setAttribute("color-interpolation-filters", "sRGB"),
                o.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"),
                o
            }
            return s
        }()
          , featureSupport = function() {
            var s = {
                maskType: !0,
                svgLumaHidden: !0,
                offscreenCanvas: typeof OffscreenCanvas < "u"
            };
            return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (s.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (s.svgLumaHidden = !1),
            s
        }()
          , registeredEffects$1 = {}
          , idPrefix = "filter_result_";
        function SVGEffects(s) {
            var e, a = "SourceGraphic", o = s.data.ef ? s.data.ef.length : 0, c = createElementID(), d = filtersFactory.createFilter(c, !0), g = 0;
            this.filters = [];
            var _;
            for (e = 0; e < o; e += 1) {
                _ = null;
                var b = s.data.ef[e].ty;
                if (registeredEffects$1[b]) {
                    var j = registeredEffects$1[b].effect;
                    _ = new j(d,s.effectsManager.effectElements[e],s,idPrefix + g,a),
                    a = idPrefix + g,
                    registeredEffects$1[b].countsAsEffect && (g += 1)
                }
                _ && this.filters.push(_)
            }
            g && (s.globalData.defs.appendChild(d),
            s.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + c + ")")),
            this.filters.length && s.addRenderableComponent(this)
        }
        SVGEffects.prototype.renderFrame = function(s) {
            var e, a = this.filters.length;
            for (e = 0; e < a; e += 1)
                this.filters[e].renderFrame(s)
        }
        ,
        SVGEffects.prototype.getEffects = function(s) {
            var e, a = this.filters.length, o = [];
            for (e = 0; e < a; e += 1)
                this.filters[e].type === s && o.push(this.filters[e]);
            return o
        }
        ;
        function registerEffect$1(s, e, a) {
            registeredEffects$1[s] = {
                effect: e,
                countsAsEffect: a
            }
        }
        function SVGBaseElement() {}
        SVGBaseElement.prototype = {
            initRendererElement: function() {
                this.layerElement = createNS("g")
            },
            createContainerElements: function() {
                this.matteElement = createNS("g"),
                this.transformedElement = this.layerElement,
                this.maskedElement = this.layerElement,
                this._sizeChanged = !1;
                var e = null;
                if (this.data.td) {
                    this.matteMasks = {};
                    var a = createNS("g");
                    a.setAttribute("id", this.layerId),
                    a.appendChild(this.layerElement),
                    e = a,
                    this.globalData.defs.appendChild(a)
                } else
                    this.data.tt ? (this.matteElement.appendChild(this.layerElement),
                    e = this.matteElement,
                    this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.ty === 0 && !this.data.hd) {
                    var o = createNS("clipPath")
                      , c = createNS("path");
                    c.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                    var d = createElementID();
                    if (o.setAttribute("id", d),
                    o.appendChild(c),
                    this.globalData.defs.appendChild(o),
                    this.checkMasks()) {
                        var g = createNS("g");
                        g.setAttribute("clip-path", "url(" + getLocationHref() + "#" + d + ")"),
                        g.appendChild(this.layerElement),
                        this.transformedElement = g,
                        e ? e.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                    } else
                        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + d + ")")
                }
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()),
                this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
            },
            destroyBaseElement: function() {
                this.layerElement = null,
                this.matteElement = null,
                this.maskManager.destroy()
            },
            getBaseElement: function() {
                return this.data.hd ? null : this.baseElement
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData),
                this.renderableEffectsManager = new SVGEffects(this),
                this.searchEffectTransforms()
            },
            getMatte: function(e) {
                if (this.matteMasks || (this.matteMasks = {}),
                !this.matteMasks[e]) {
                    var a = this.layerId + "_" + e, o, c, d, g;
                    if (e === 1 || e === 3) {
                        var _ = createNS("mask");
                        _.setAttribute("id", a),
                        _.setAttribute("mask-type", e === 3 ? "luminance" : "alpha"),
                        d = createNS("use"),
                        d.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        _.appendChild(d),
                        this.globalData.defs.appendChild(_),
                        !featureSupport.maskType && e === 1 && (_.setAttribute("mask-type", "luminance"),
                        o = createElementID(),
                        c = filtersFactory.createFilter(o),
                        this.globalData.defs.appendChild(c),
                        c.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        g = createNS("g"),
                        g.appendChild(d),
                        _.appendChild(g),
                        g.setAttribute("filter", "url(" + getLocationHref() + "#" + o + ")"))
                    } else if (e === 2) {
                        var b = createNS("mask");
                        b.setAttribute("id", a),
                        b.setAttribute("mask-type", "alpha");
                        var j = createNS("g");
                        b.appendChild(j),
                        o = createElementID(),
                        c = filtersFactory.createFilter(o);
                        var $ = createNS("feComponentTransfer");
                        $.setAttribute("in", "SourceGraphic"),
                        c.appendChild($);
                        var nt = createNS("feFuncA");
                        nt.setAttribute("type", "table"),
                        nt.setAttribute("tableValues", "1.0 0.0"),
                        $.appendChild(nt),
                        this.globalData.defs.appendChild(c);
                        var tt = createNS("rect");
                        tt.setAttribute("width", this.comp.data.w),
                        tt.setAttribute("height", this.comp.data.h),
                        tt.setAttribute("x", "0"),
                        tt.setAttribute("y", "0"),
                        tt.setAttribute("fill", "#ffffff"),
                        tt.setAttribute("opacity", "0"),
                        j.setAttribute("filter", "url(" + getLocationHref() + "#" + o + ")"),
                        j.appendChild(tt),
                        d = createNS("use"),
                        d.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        j.appendChild(d),
                        featureSupport.maskType || (b.setAttribute("mask-type", "luminance"),
                        c.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        g = createNS("g"),
                        j.appendChild(tt),
                        g.appendChild(this.layerElement),
                        j.appendChild(g)),
                        this.globalData.defs.appendChild(b)
                    }
                    this.matteMasks[e] = a
                }
                return this.matteMasks[e]
            },
            setMatte: function(e) {
                this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + e + ")")
            }
        };
        function HierarchyElement() {}
        HierarchyElement.prototype = {
            initHierarchy: function() {
                this.hierarchy = [],
                this._isParent = !1,
                this.checkParenting()
            },
            setHierarchy: function(e) {
                this.hierarchy = e
            },
            setAsParent: function() {
                this._isParent = !0
            },
            checkParenting: function() {
                this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, [])
            }
        };
        function RenderableDOMElement() {}
        (function() {
            var s = {
                initElement: function(a, o, c) {
                    this.initFrame(),
                    this.initBaseData(a, o, c),
                    this.initTransform(a, o, c),
                    this.initHierarchy(),
                    this.initRenderable(),
                    this.initRendererElement(),
                    this.createContainerElements(),
                    this.createRenderableComponents(),
                    this.createContent(),
                    this.hide()
                },
                hide: function() {
                    if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                        var a = this.baseElement || this.layerElement;
                        a.style.display = "none",
                        this.hidden = !0
                    }
                },
                show: function() {
                    if (this.isInRange && !this.isTransparent) {
                        if (!this.data.hd) {
                            var a = this.baseElement || this.layerElement;
                            a.style.display = "block"
                        }
                        this.hidden = !1,
                        this._isFirstFrame = !0
                    }
                },
                renderFrame: function() {
                    this.data.hd || this.hidden || (this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.renderElement(),
                    this.renderInnerContent(),
                    this._isFirstFrame && (this._isFirstFrame = !1))
                },
                renderInnerContent: function() {},
                prepareFrame: function(a) {
                    this._mdf = !1,
                    this.prepareRenderableFrame(a),
                    this.prepareProperties(a, this.isInRange),
                    this.checkTransparency()
                },
                destroy: function() {
                    this.innerElem = null,
                    this.destroyBaseElement()
                }
            };
            extendPrototype([RenderableElement, createProxyFunction(s)], RenderableDOMElement)
        }
        )();
        function IImageElement(s, e, a) {
            this.assetData = e.getAssetData(s.refId),
            this.assetData && this.assetData.sid && (this.assetData = e.slotManager.getProp(this.assetData)),
            this.initElement(s, e, a),
            this.sourceRect = {
                top: 0,
                left: 0,
                width: this.assetData.w,
                height: this.assetData.h
            }
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement),
        IImageElement.prototype.createContent = function() {
            var s = this.globalData.getAssetsPath(this.assetData);
            this.innerElem = createNS("image"),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio),
            this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", s),
            this.layerElement.appendChild(this.innerElem)
        }
        ,
        IImageElement.prototype.sourceRectAtTime = function() {
            return this.sourceRect
        }
        ;
        function ProcessedElement(s, e) {
            this.elem = s,
            this.pos = e
        }
        function IShapeElement() {}
        IShapeElement.prototype = {
            addShapeToModifiers: function(e) {
                var a, o = this.shapeModifiers.length;
                for (a = 0; a < o; a += 1)
                    this.shapeModifiers[a].addShape(e)
            },
            isShapeInAnimatedModifiers: function(e) {
                for (var a = 0, o = this.shapeModifiers.length; a < o; )
                    if (this.shapeModifiers[a].isAnimatedWithShape(e))
                        return !0;
                return !1
            },
            renderModifiers: function() {
                if (this.shapeModifiers.length) {
                    var e, a = this.shapes.length;
                    for (e = 0; e < a; e += 1)
                        this.shapes[e].sh.reset();
                    a = this.shapeModifiers.length;
                    var o;
                    for (e = a - 1; e >= 0 && (o = this.shapeModifiers[e].processShapes(this._isFirstFrame),
                    !o); e -= 1)
                        ;
                }
            },
            searchProcessedElement: function(e) {
                for (var a = this.processedElements, o = 0, c = a.length; o < c; ) {
                    if (a[o].elem === e)
                        return a[o].pos;
                    o += 1
                }
                return 0
            },
            addProcessedElement: function(e, a) {
                for (var o = this.processedElements, c = o.length; c; )
                    if (c -= 1,
                    o[c].elem === e) {
                        o[c].pos = a;
                        return
                    }
                o.push(new ProcessedElement(e,a))
            },
            prepareFrame: function(e) {
                this.prepareRenderableFrame(e),
                this.prepareProperties(e, this.isInRange)
            }
        };
        var lineCapEnum = {
            1: "butt",
            2: "round",
            3: "square"
        }
          , lineJoinEnum = {
            1: "miter",
            2: "round",
            3: "bevel"
        };
        function SVGShapeData(s, e, a) {
            this.caches = [],
            this.styles = [],
            this.transformers = s,
            this.lStr = "",
            this.sh = a,
            this.lvl = e,
            this._isAnimated = !!a.k;
            for (var o = 0, c = s.length; o < c; ) {
                if (s[o].mProps.dynamicProperties.length) {
                    this._isAnimated = !0;
                    break
                }
                o += 1
            }
        }
        SVGShapeData.prototype.setAsAnimated = function() {
            this._isAnimated = !0
        }
        ;
        function SVGStyleData(s, e) {
            this.data = s,
            this.type = s.ty,
            this.d = "",
            this.lvl = e,
            this._mdf = !1,
            this.closed = s.hd === !0,
            this.pElem = createNS("path"),
            this.msElem = null
        }
        SVGStyleData.prototype.reset = function() {
            this.d = "",
            this._mdf = !1
        }
        ;
        function DashProperty(s, e, a, o) {
            this.elem = s,
            this.frameId = -1,
            this.dataProps = createSizedArray(e.length),
            this.renderer = a,
            this.k = !1,
            this.dashStr = "",
            this.dashArray = createTypedArray("float32", e.length ? e.length - 1 : 0),
            this.dashoffset = createTypedArray("float32", 1),
            this.initDynamicPropertyContainer(o);
            var c, d = e.length || 0, g;
            for (c = 0; c < d; c += 1)
                g = PropertyFactory.getProp(s, e[c].v, 0, 0, this),
                this.k = g.k || this.k,
                this.dataProps[c] = {
                    n: e[c].n,
                    p: g
                };
            this.k || this.getValue(!0),
            this._isAnimated = this.k
        }
        DashProperty.prototype.getValue = function(s) {
            if (!(this.elem.globalData.frameId === this.frameId && !s) && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties(),
            this._mdf = this._mdf || s,
            this._mdf)) {
                var e = 0
                  , a = this.dataProps.length;
                for (this.renderer === "svg" && (this.dashStr = ""),
                e = 0; e < a; e += 1)
                    this.dataProps[e].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[e].p.v : this.dashArray[e] = this.dataProps[e].p.v : this.dashoffset[0] = this.dataProps[e].p.v
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], DashProperty);
        function SVGStrokeStyleData(s, e, a) {
            this.initDynamicPropertyContainer(s),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(s, e.o, 0, .01, this),
            this.w = PropertyFactory.getProp(s, e.w, 0, null, this),
            this.d = new DashProperty(s,e.d || {},"svg",this),
            this.c = PropertyFactory.getProp(s, e.c, 1, 255, this),
            this.style = a,
            this._isAnimated = !!this._isAnimated
        }
        extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
        function SVGFillStyleData(s, e, a) {
            this.initDynamicPropertyContainer(s),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(s, e.o, 0, .01, this),
            this.c = PropertyFactory.getProp(s, e.c, 1, 255, this),
            this.style = a
        }
        extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
        function SVGNoStyleData(s, e, a) {
            this.initDynamicPropertyContainer(s),
            this.getValue = this.iterateDynamicProperties,
            this.style = a
        }
        extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
        function GradientProperty(s, e, a) {
            this.data = e,
            this.c = createTypedArray("uint8c", e.p * 4);
            var o = e.k.k[0].s ? e.k.k[0].s.length - e.p * 4 : e.k.k.length - e.p * 4;
            this.o = createTypedArray("float32", o),
            this._cmdf = !1,
            this._omdf = !1,
            this._collapsable = this.checkCollapsable(),
            this._hasOpacity = o,
            this.initDynamicPropertyContainer(a),
            this.prop = PropertyFactory.getProp(s, e.k, 1, null, this),
            this.k = this.prop.k,
            this.getValue(!0)
        }
        GradientProperty.prototype.comparePoints = function(s, e) {
            for (var a = 0, o = this.o.length / 2, c; a < o; ) {
                if (c = Math.abs(s[a * 4] - s[e * 4 + a * 2]),
                c > .01)
                    return !1;
                a += 1
            }
            return !0
        }
        ,
        GradientProperty.prototype.checkCollapsable = function() {
            if (this.o.length / 2 !== this.c.length / 4)
                return !1;
            if (this.data.k.k[0].s)
                for (var s = 0, e = this.data.k.k.length; s < e; ) {
                    if (!this.comparePoints(this.data.k.k[s].s, this.data.p))
                        return !1;
                    s += 1
                }
            else if (!this.comparePoints(this.data.k.k, this.data.p))
                return !1;
            return !0
        }
        ,
        GradientProperty.prototype.getValue = function(s) {
            if (this.prop.getValue(),
            this._mdf = !1,
            this._cmdf = !1,
            this._omdf = !1,
            this.prop._mdf || s) {
                var e, a = this.data.p * 4, o, c;
                for (e = 0; e < a; e += 1)
                    o = e % 4 === 0 ? 100 : 255,
                    c = Math.round(this.prop.v[e] * o),
                    this.c[e] !== c && (this.c[e] = c,
                    this._cmdf = !s);
                if (this.o.length)
                    for (a = this.prop.v.length,
                    e = this.data.p * 4; e < a; e += 1)
                        o = e % 2 === 0 ? 100 : 1,
                        c = e % 2 === 0 ? Math.round(this.prop.v[e] * 100) : this.prop.v[e],
                        this.o[e - this.data.p * 4] !== c && (this.o[e - this.data.p * 4] = c,
                        this._omdf = !s);
                this._mdf = !s
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], GradientProperty);
        function SVGGradientFillStyleData(s, e, a) {
            this.initDynamicPropertyContainer(s),
            this.getValue = this.iterateDynamicProperties,
            this.initGradientData(s, e, a)
        }
        SVGGradientFillStyleData.prototype.initGradientData = function(s, e, a) {
            this.o = PropertyFactory.getProp(s, e.o, 0, .01, this),
            this.s = PropertyFactory.getProp(s, e.s, 1, null, this),
            this.e = PropertyFactory.getProp(s, e.e, 1, null, this),
            this.h = PropertyFactory.getProp(s, e.h || {
                k: 0
            }, 0, .01, this),
            this.a = PropertyFactory.getProp(s, e.a || {
                k: 0
            }, 0, degToRads, this),
            this.g = new GradientProperty(s,e.g,this),
            this.style = a,
            this.stops = [],
            this.setGradientData(a.pElem, e),
            this.setGradientOpacity(e, a),
            this._isAnimated = !!this._isAnimated
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientData = function(s, e) {
            var a = createElementID()
              , o = createNS(e.t === 1 ? "linearGradient" : "radialGradient");
            o.setAttribute("id", a),
            o.setAttribute("spreadMethod", "pad"),
            o.setAttribute("gradientUnits", "userSpaceOnUse");
            var c = [], d, g, _;
            for (_ = e.g.p * 4,
            g = 0; g < _; g += 4)
                d = createNS("stop"),
                o.appendChild(d),
                c.push(d);
            s.setAttribute(e.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + a + ")"),
            this.gf = o,
            this.cst = c
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientOpacity = function(s, e) {
            if (this.g._hasOpacity && !this.g._collapsable) {
                var a, o, c, d = createNS("mask"), g = createNS("path");
                d.appendChild(g);
                var _ = createElementID()
                  , b = createElementID();
                d.setAttribute("id", b);
                var j = createNS(s.t === 1 ? "linearGradient" : "radialGradient");
                j.setAttribute("id", _),
                j.setAttribute("spreadMethod", "pad"),
                j.setAttribute("gradientUnits", "userSpaceOnUse"),
                c = s.g.k.k[0].s ? s.g.k.k[0].s.length : s.g.k.k.length;
                var $ = this.stops;
                for (o = s.g.p * 4; o < c; o += 2)
                    a = createNS("stop"),
                    a.setAttribute("stop-color", "rgb(255,255,255)"),
                    j.appendChild(a),
                    $.push(a);
                g.setAttribute(s.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + _ + ")"),
                s.ty === "gs" && (g.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]),
                g.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]),
                s.lj === 1 && g.setAttribute("stroke-miterlimit", s.ml)),
                this.of = j,
                this.ms = d,
                this.ost = $,
                this.maskId = b,
                e.msElem = g
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
        function SVGGradientStrokeStyleData(s, e, a) {
            this.initDynamicPropertyContainer(s),
            this.getValue = this.iterateDynamicProperties,
            this.w = PropertyFactory.getProp(s, e.w, 0, null, this),
            this.d = new DashProperty(s,e.d || {},"svg",this),
            this.initGradientData(s, e, a),
            this._isAnimated = !!this._isAnimated
        }
        extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        function ShapeGroupData() {
            this.it = [],
            this.prevViewData = [],
            this.gr = createNS("g")
        }
        function SVGTransformData(s, e, a) {
            this.transform = {
                mProps: s,
                op: e,
                container: a
            },
            this.elements = [],
            this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
        }
        var buildShapeString = function(e, a, o, c) {
            if (a === 0)
                return "";
            var d = e.o, g = e.i, _ = e.v, b, j = " M" + c.applyToPointStringified(_[0][0], _[0][1]);
            for (b = 1; b < a; b += 1)
                j += " C" + c.applyToPointStringified(d[b - 1][0], d[b - 1][1]) + " " + c.applyToPointStringified(g[b][0], g[b][1]) + " " + c.applyToPointStringified(_[b][0], _[b][1]);
            return o && a && (j += " C" + c.applyToPointStringified(d[b - 1][0], d[b - 1][1]) + " " + c.applyToPointStringified(g[0][0], g[0][1]) + " " + c.applyToPointStringified(_[0][0], _[0][1]),
            j += "z"),
            j
        }
          , SVGElementsRenderer = function() {
            var s = new Matrix
              , e = new Matrix
              , a = {
                createRenderFunction: o
            };
            function o(nt) {
                switch (nt.ty) {
                case "fl":
                    return _;
                case "gf":
                    return j;
                case "gs":
                    return b;
                case "st":
                    return $;
                case "sh":
                case "el":
                case "rc":
                case "sr":
                    return g;
                case "tr":
                    return c;
                case "no":
                    return d;
                default:
                    return null
                }
            }
            function c(nt, tt, rt) {
                (rt || tt.transform.op._mdf) && tt.transform.container.setAttribute("opacity", tt.transform.op.v),
                (rt || tt.transform.mProps._mdf) && tt.transform.container.setAttribute("transform", tt.transform.mProps.v.to2dCSS())
            }
            function d() {}
            function g(nt, tt, rt) {
                var st, lt, ct, it, ot, at, ht = tt.styles.length, pt = tt.lvl, dt, yt, vt, xt;
                for (at = 0; at < ht; at += 1) {
                    if (it = tt.sh._mdf || rt,
                    tt.styles[at].lvl < pt) {
                        for (yt = e.reset(),
                        vt = pt - tt.styles[at].lvl,
                        xt = tt.transformers.length - 1; !it && vt > 0; )
                            it = tt.transformers[xt].mProps._mdf || it,
                            vt -= 1,
                            xt -= 1;
                        if (it)
                            for (vt = pt - tt.styles[at].lvl,
                            xt = tt.transformers.length - 1; vt > 0; )
                                yt.multiply(tt.transformers[xt].mProps.v),
                                vt -= 1,
                                xt -= 1
                    } else
                        yt = s;
                    if (dt = tt.sh.paths,
                    lt = dt._length,
                    it) {
                        for (ct = "",
                        st = 0; st < lt; st += 1)
                            ot = dt.shapes[st],
                            ot && ot._length && (ct += buildShapeString(ot, ot._length, ot.c, yt));
                        tt.caches[at] = ct
                    } else
                        ct = tt.caches[at];
                    tt.styles[at].d += nt.hd === !0 ? "" : ct,
                    tt.styles[at]._mdf = it || tt.styles[at]._mdf
                }
            }
            function _(nt, tt, rt) {
                var st = tt.style;
                (tt.c._mdf || rt) && st.pElem.setAttribute("fill", "rgb(" + bmFloor(tt.c.v[0]) + "," + bmFloor(tt.c.v[1]) + "," + bmFloor(tt.c.v[2]) + ")"),
                (tt.o._mdf || rt) && st.pElem.setAttribute("fill-opacity", tt.o.v)
            }
            function b(nt, tt, rt) {
                j(nt, tt, rt),
                $(nt, tt, rt)
            }
            function j(nt, tt, rt) {
                var st = tt.gf
                  , lt = tt.g._hasOpacity
                  , ct = tt.s.v
                  , it = tt.e.v;
                if (tt.o._mdf || rt) {
                    var ot = nt.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                    tt.style.pElem.setAttribute(ot, tt.o.v)
                }
                if (tt.s._mdf || rt) {
                    var at = nt.t === 1 ? "x1" : "cx"
                      , ht = at === "x1" ? "y1" : "cy";
                    st.setAttribute(at, ct[0]),
                    st.setAttribute(ht, ct[1]),
                    lt && !tt.g._collapsable && (tt.of.setAttribute(at, ct[0]),
                    tt.of.setAttribute(ht, ct[1]))
                }
                var pt, dt, yt, vt;
                if (tt.g._cmdf || rt) {
                    pt = tt.cst;
                    var xt = tt.g.c;
                    for (yt = pt.length,
                    dt = 0; dt < yt; dt += 1)
                        vt = pt[dt],
                        vt.setAttribute("offset", xt[dt * 4] + "%"),
                        vt.setAttribute("stop-color", "rgb(" + xt[dt * 4 + 1] + "," + xt[dt * 4 + 2] + "," + xt[dt * 4 + 3] + ")")
                }
                if (lt && (tt.g._omdf || rt)) {
                    var _t = tt.g.o;
                    for (tt.g._collapsable ? pt = tt.cst : pt = tt.ost,
                    yt = pt.length,
                    dt = 0; dt < yt; dt += 1)
                        vt = pt[dt],
                        tt.g._collapsable || vt.setAttribute("offset", _t[dt * 2] + "%"),
                        vt.setAttribute("stop-opacity", _t[dt * 2 + 1])
                }
                if (nt.t === 1)
                    (tt.e._mdf || rt) && (st.setAttribute("x2", it[0]),
                    st.setAttribute("y2", it[1]),
                    lt && !tt.g._collapsable && (tt.of.setAttribute("x2", it[0]),
                    tt.of.setAttribute("y2", it[1])));
                else {
                    var bt;
                    if ((tt.s._mdf || tt.e._mdf || rt) && (bt = Math.sqrt(Math.pow(ct[0] - it[0], 2) + Math.pow(ct[1] - it[1], 2)),
                    st.setAttribute("r", bt),
                    lt && !tt.g._collapsable && tt.of.setAttribute("r", bt)),
                    tt.e._mdf || tt.h._mdf || tt.a._mdf || rt) {
                        bt || (bt = Math.sqrt(Math.pow(ct[0] - it[0], 2) + Math.pow(ct[1] - it[1], 2)));
                        var Rt = Math.atan2(it[1] - ct[1], it[0] - ct[0])
                          , Ft = tt.h.v;
                        Ft >= 1 ? Ft = .99 : Ft <= -1 && (Ft = -.99);
                        var Bt = bt * Ft
                          , Dt = Math.cos(Rt + tt.a.v) * Bt + ct[0]
                          , Mt = Math.sin(Rt + tt.a.v) * Bt + ct[1];
                        st.setAttribute("fx", Dt),
                        st.setAttribute("fy", Mt),
                        lt && !tt.g._collapsable && (tt.of.setAttribute("fx", Dt),
                        tt.of.setAttribute("fy", Mt))
                    }
                }
            }
            function $(nt, tt, rt) {
                var st = tt.style
                  , lt = tt.d;
                lt && (lt._mdf || rt) && lt.dashStr && (st.pElem.setAttribute("stroke-dasharray", lt.dashStr),
                st.pElem.setAttribute("stroke-dashoffset", lt.dashoffset[0])),
                tt.c && (tt.c._mdf || rt) && st.pElem.setAttribute("stroke", "rgb(" + bmFloor(tt.c.v[0]) + "," + bmFloor(tt.c.v[1]) + "," + bmFloor(tt.c.v[2]) + ")"),
                (tt.o._mdf || rt) && st.pElem.setAttribute("stroke-opacity", tt.o.v),
                (tt.w._mdf || rt) && (st.pElem.setAttribute("stroke-width", tt.w.v),
                st.msElem && st.msElem.setAttribute("stroke-width", tt.w.v))
            }
            return a
        }();
        function SVGShapeElement(s, e, a) {
            this.shapes = [],
            this.shapesData = s.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.initElement(s, e, a),
            this.prevViewData = []
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement),
        SVGShapeElement.prototype.initSecondaryElement = function() {}
        ,
        SVGShapeElement.prototype.identityMatrix = new Matrix,
        SVGShapeElement.prototype.buildExpressionInterface = function() {}
        ,
        SVGShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes()
        }
        ,
        SVGShapeElement.prototype.filterUniqueShapes = function() {
            var s, e = this.shapes.length, a, o, c = this.stylesList.length, d, g = [], _ = !1;
            for (o = 0; o < c; o += 1) {
                for (d = this.stylesList[o],
                _ = !1,
                g.length = 0,
                s = 0; s < e; s += 1)
                    a = this.shapes[s],
                    a.styles.indexOf(d) !== -1 && (g.push(a),
                    _ = a._isAnimated || _);
                g.length > 1 && _ && this.setShapesAsAnimated(g)
            }
        }
        ,
        SVGShapeElement.prototype.setShapesAsAnimated = function(s) {
            var e, a = s.length;
            for (e = 0; e < a; e += 1)
                s[e].setAsAnimated()
        }
        ,
        SVGShapeElement.prototype.createStyleElement = function(s, e) {
            var a, o = new SVGStyleData(s,e), c = o.pElem;
            if (s.ty === "st")
                a = new SVGStrokeStyleData(this,s,o);
            else if (s.ty === "fl")
                a = new SVGFillStyleData(this,s,o);
            else if (s.ty === "gf" || s.ty === "gs") {
                var d = s.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
                a = new d(this,s,o),
                this.globalData.defs.appendChild(a.gf),
                a.maskId && (this.globalData.defs.appendChild(a.ms),
                this.globalData.defs.appendChild(a.of),
                c.setAttribute("mask", "url(" + getLocationHref() + "#" + a.maskId + ")"))
            } else
                s.ty === "no" && (a = new SVGNoStyleData(this,s,o));
            return (s.ty === "st" || s.ty === "gs") && (c.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]),
            c.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]),
            c.setAttribute("fill-opacity", "0"),
            s.lj === 1 && c.setAttribute("stroke-miterlimit", s.ml)),
            s.r === 2 && c.setAttribute("fill-rule", "evenodd"),
            s.ln && c.setAttribute("id", s.ln),
            s.cl && c.setAttribute("class", s.cl),
            s.bm && (c.style["mix-blend-mode"] = getBlendMode(s.bm)),
            this.stylesList.push(o),
            this.addToAnimatedContents(s, a),
            a
        }
        ,
        SVGShapeElement.prototype.createGroupElement = function(s) {
            var e = new ShapeGroupData;
            return s.ln && e.gr.setAttribute("id", s.ln),
            s.cl && e.gr.setAttribute("class", s.cl),
            s.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(s.bm)),
            e
        }
        ,
        SVGShapeElement.prototype.createTransformElement = function(s, e) {
            var a = TransformPropertyFactory.getTransformProperty(this, s, this)
              , o = new SVGTransformData(a,a.o,e);
            return this.addToAnimatedContents(s, o),
            o
        }
        ,
        SVGShapeElement.prototype.createShapeElement = function(s, e, a) {
            var o = 4;
            s.ty === "rc" ? o = 5 : s.ty === "el" ? o = 6 : s.ty === "sr" && (o = 7);
            var c = ShapePropertyFactory.getShapeProp(this, s, o, this)
              , d = new SVGShapeData(e,a,c);
            return this.shapes.push(d),
            this.addShapeToModifiers(d),
            this.addToAnimatedContents(s, d),
            d
        }
        ,
        SVGShapeElement.prototype.addToAnimatedContents = function(s, e) {
            for (var a = 0, o = this.animatedContents.length; a < o; ) {
                if (this.animatedContents[a].element === e)
                    return;
                a += 1
            }
            this.animatedContents.push({
                fn: SVGElementsRenderer.createRenderFunction(s),
                element: e,
                data: s
            })
        }
        ,
        SVGShapeElement.prototype.setElementStyles = function(s) {
            var e = s.styles, a, o = this.stylesList.length;
            for (a = 0; a < o; a += 1)
                this.stylesList[a].closed || e.push(this.stylesList[a])
        }
        ,
        SVGShapeElement.prototype.reloadShapes = function() {
            this._isFirstFrame = !0;
            var s, e = this.itemsData.length;
            for (s = 0; s < e; s += 1)
                this.prevViewData[s] = this.itemsData[s];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes(),
            e = this.dynamicProperties.length,
            s = 0; s < e; s += 1)
                this.dynamicProperties[s].getValue();
            this.renderModifiers()
        }
        ,
        SVGShapeElement.prototype.searchShapes = function(s, e, a, o, c, d, g) {
            var _ = [].concat(d), b, j = s.length - 1, $, nt, tt = [], rt = [], st, lt, ct;
            for (b = j; b >= 0; b -= 1) {
                if (ct = this.searchProcessedElement(s[b]),
                ct ? e[b] = a[ct - 1] : s[b]._render = g,
                s[b].ty === "fl" || s[b].ty === "st" || s[b].ty === "gf" || s[b].ty === "gs" || s[b].ty === "no")
                    ct ? e[b].style.closed = !1 : e[b] = this.createStyleElement(s[b], c),
                    s[b]._render && e[b].style.pElem.parentNode !== o && o.appendChild(e[b].style.pElem),
                    tt.push(e[b].style);
                else if (s[b].ty === "gr") {
                    if (!ct)
                        e[b] = this.createGroupElement(s[b]);
                    else
                        for (nt = e[b].it.length,
                        $ = 0; $ < nt; $ += 1)
                            e[b].prevViewData[$] = e[b].it[$];
                    this.searchShapes(s[b].it, e[b].it, e[b].prevViewData, e[b].gr, c + 1, _, g),
                    s[b]._render && e[b].gr.parentNode !== o && o.appendChild(e[b].gr)
                } else
                    s[b].ty === "tr" ? (ct || (e[b] = this.createTransformElement(s[b], o)),
                    st = e[b].transform,
                    _.push(st)) : s[b].ty === "sh" || s[b].ty === "rc" || s[b].ty === "el" || s[b].ty === "sr" ? (ct || (e[b] = this.createShapeElement(s[b], _, c)),
                    this.setElementStyles(e[b])) : s[b].ty === "tm" || s[b].ty === "rd" || s[b].ty === "ms" || s[b].ty === "pb" || s[b].ty === "zz" || s[b].ty === "op" ? (ct ? (lt = e[b],
                    lt.closed = !1) : (lt = ShapeModifiers.getModifier(s[b].ty),
                    lt.init(this, s[b]),
                    e[b] = lt,
                    this.shapeModifiers.push(lt)),
                    rt.push(lt)) : s[b].ty === "rp" && (ct ? (lt = e[b],
                    lt.closed = !0) : (lt = ShapeModifiers.getModifier(s[b].ty),
                    e[b] = lt,
                    lt.init(this, s, b, e),
                    this.shapeModifiers.push(lt),
                    g = !1),
                    rt.push(lt));
                this.addProcessedElement(s[b], b + 1)
            }
            for (j = tt.length,
            b = 0; b < j; b += 1)
                tt[b].closed = !0;
            for (j = rt.length,
            b = 0; b < j; b += 1)
                rt[b].closed = !0
        }
        ,
        SVGShapeElement.prototype.renderInnerContent = function() {
            this.renderModifiers();
            var s, e = this.stylesList.length;
            for (s = 0; s < e; s += 1)
                this.stylesList[s].reset();
            for (this.renderShape(),
            s = 0; s < e; s += 1)
                (this.stylesList[s]._mdf || this._isFirstFrame) && (this.stylesList[s].msElem && (this.stylesList[s].msElem.setAttribute("d", this.stylesList[s].d),
                this.stylesList[s].d = "M0 0" + this.stylesList[s].d),
                this.stylesList[s].pElem.setAttribute("d", this.stylesList[s].d || "M0 0"))
        }
        ,
        SVGShapeElement.prototype.renderShape = function() {
            var s, e = this.animatedContents.length, a;
            for (s = 0; s < e; s += 1)
                a = this.animatedContents[s],
                (this._isFirstFrame || a.element._isAnimated) && a.data !== !0 && a.fn(a.data, a.element, this._isFirstFrame)
        }
        ,
        SVGShapeElement.prototype.destroy = function() {
            this.destroyBaseElement(),
            this.shapesData = null,
            this.itemsData = null
        }
        ;
        function LetterProps(s, e, a, o, c, d) {
            this.o = s,
            this.sw = e,
            this.sc = a,
            this.fc = o,
            this.m = c,
            this.p = d,
            this._mdf = {
                o: !0,
                sw: !!e,
                sc: !!a,
                fc: !!o,
                m: !0,
                p: !0
            }
        }
        LetterProps.prototype.update = function(s, e, a, o, c, d) {
            this._mdf.o = !1,
            this._mdf.sw = !1,
            this._mdf.sc = !1,
            this._mdf.fc = !1,
            this._mdf.m = !1,
            this._mdf.p = !1;
            var g = !1;
            return this.o !== s && (this.o = s,
            this._mdf.o = !0,
            g = !0),
            this.sw !== e && (this.sw = e,
            this._mdf.sw = !0,
            g = !0),
            this.sc !== a && (this.sc = a,
            this._mdf.sc = !0,
            g = !0),
            this.fc !== o && (this.fc = o,
            this._mdf.fc = !0,
            g = !0),
            this.m !== c && (this.m = c,
            this._mdf.m = !0,
            g = !0),
            d.length && (this.p[0] !== d[0] || this.p[1] !== d[1] || this.p[4] !== d[4] || this.p[5] !== d[5] || this.p[12] !== d[12] || this.p[13] !== d[13]) && (this.p = d,
            this._mdf.p = !0,
            g = !0),
            g
        }
        ;
        function TextProperty(s, e) {
            this._frameId = initialDefaultFrame,
            this.pv = "",
            this.v = "",
            this.kf = !1,
            this._isFirstFrame = !0,
            this._mdf = !1,
            e.d && e.d.sid && (e.d = s.globalData.slotManager.getProp(e.d)),
            this.data = e,
            this.elem = s,
            this.comp = this.elem.comp,
            this.keysIndex = 0,
            this.canResize = !1,
            this.minimumFontSize = 1,
            this.effectsSequence = [],
            this.currentData = {
                ascent: 0,
                boxWidth: this.defaultBoxWidth,
                f: "",
                fStyle: "",
                fWeight: "",
                fc: "",
                j: "",
                justifyOffset: "",
                l: [],
                lh: 0,
                lineWidths: [],
                ls: "",
                of: "",
                s: "",
                sc: "",
                sw: 0,
                t: 0,
                tr: 0,
                sz: 0,
                ps: null,
                fillColorAnim: !1,
                strokeColorAnim: !1,
                strokeWidthAnim: !1,
                yOffset: 0,
                finalSize: 0,
                finalText: [],
                finalLineHeight: 0,
                __complete: !1
            },
            this.copyData(this.currentData, this.data.d.k[0].s),
            this.searchProperty() || this.completeTextData(this.currentData)
        }
        TextProperty.prototype.defaultBoxWidth = [0, 0],
        TextProperty.prototype.copyData = function(s, e) {
            for (var a in e)
                Object.prototype.hasOwnProperty.call(e, a) && (s[a] = e[a]);
            return s
        }
        ,
        TextProperty.prototype.setCurrentData = function(s) {
            s.__complete || this.completeTextData(s),
            this.currentData = s,
            this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth,
            this._mdf = !0
        }
        ,
        TextProperty.prototype.searchProperty = function() {
            return this.searchKeyframes()
        }
        ,
        TextProperty.prototype.searchKeyframes = function() {
            return this.kf = this.data.d.k.length > 1,
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
        }
        ,
        TextProperty.prototype.addEffect = function(s) {
            this.effectsSequence.push(s),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.getValue = function(s) {
            if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !s)) {
                this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                var e = this.currentData
                  , a = this.keysIndex;
                if (this.lock) {
                    this.setCurrentData(this.currentData);
                    return
                }
                this.lock = !0,
                this._mdf = !1;
                var o, c = this.effectsSequence.length, d = s || this.data.d.k[this.keysIndex].s;
                for (o = 0; o < c; o += 1)
                    a !== this.keysIndex ? d = this.effectsSequence[o](d, d.t) : d = this.effectsSequence[o](this.currentData, d.t);
                e !== d && this.setCurrentData(d),
                this.v = this.currentData,
                this.pv = this.v,
                this.lock = !1,
                this.frameId = this.elem.globalData.frameId
            }
        }
        ,
        TextProperty.prototype.getKeyframeValue = function() {
            for (var s = this.data.d.k, e = this.elem.comp.renderedFrame, a = 0, o = s.length; a <= o - 1 && !(a === o - 1 || s[a + 1].t > e); )
                a += 1;
            return this.keysIndex !== a && (this.keysIndex = a),
            this.data.d.k[this.keysIndex].s
        }
        ,
        TextProperty.prototype.buildFinalText = function(s) {
            for (var e = [], a = 0, o = s.length, c, d, g = !1, _ = !1, b = ""; a < o; )
                g = _,
                _ = !1,
                c = s.charCodeAt(a),
                b = s.charAt(a),
                FontManager.isCombinedCharacter(c) ? g = !0 : c >= 55296 && c <= 56319 ? FontManager.isRegionalFlag(s, a) ? b = s.substr(a, 14) : (d = s.charCodeAt(a + 1),
                d >= 56320 && d <= 57343 && (FontManager.isModifier(c, d) ? (b = s.substr(a, 2),
                g = !0) : FontManager.isFlagEmoji(s.substr(a, 4)) ? b = s.substr(a, 4) : b = s.substr(a, 2))) : c > 56319 ? (d = s.charCodeAt(a + 1),
                FontManager.isVariationSelector(c) && (g = !0)) : FontManager.isZeroWidthJoiner(c) && (g = !0,
                _ = !0),
                g ? (e[e.length - 1] += b,
                g = !1) : e.push(b),
                a += b.length;
            return e
        }
        ,
        TextProperty.prototype.completeTextData = function(s) {
            s.__complete = !0;
            var e = this.elem.globalData.fontManager, a = this.data, o = [], c, d, g, _ = 0, b, j = a.m.g, $ = 0, nt = 0, tt = 0, rt = [], st = 0, lt = 0, ct, it, ot = e.getFontByName(s.f), at, ht = 0, pt = getFontProperties(ot);
            s.fWeight = pt.weight,
            s.fStyle = pt.style,
            s.finalSize = s.s,
            s.finalText = this.buildFinalText(s.t),
            d = s.finalText.length,
            s.finalLineHeight = s.lh;
            var dt = s.tr / 1e3 * s.finalSize, yt;
            if (s.sz)
                for (var vt = !0, xt = s.sz[0], _t = s.sz[1], bt, Rt; vt; ) {
                    Rt = this.buildFinalText(s.t),
                    bt = 0,
                    st = 0,
                    d = Rt.length,
                    dt = s.tr / 1e3 * s.finalSize;
                    var Ft = -1;
                    for (c = 0; c < d; c += 1)
                        yt = Rt[c].charCodeAt(0),
                        g = !1,
                        Rt[c] === " " ? Ft = c : (yt === 13 || yt === 3) && (st = 0,
                        g = !0,
                        bt += s.finalLineHeight || s.finalSize * 1.2),
                        e.chars ? (at = e.getCharData(Rt[c], ot.fStyle, ot.fFamily),
                        ht = g ? 0 : at.w * s.finalSize / 100) : ht = e.measureText(Rt[c], s.f, s.finalSize),
                        st + ht > xt && Rt[c] !== " " ? (Ft === -1 ? d += 1 : c = Ft,
                        bt += s.finalLineHeight || s.finalSize * 1.2,
                        Rt.splice(c, Ft === c ? 1 : 0, "\r"),
                        Ft = -1,
                        st = 0) : (st += ht,
                        st += dt);
                    bt += ot.ascent * s.finalSize / 100,
                    this.canResize && s.finalSize > this.minimumFontSize && _t < bt ? (s.finalSize -= 1,
                    s.finalLineHeight = s.finalSize * s.lh / s.s) : (s.finalText = Rt,
                    d = s.finalText.length,
                    vt = !1)
                }
            st = -dt,
            ht = 0;
            var Bt = 0, Dt;
            for (c = 0; c < d; c += 1)
                if (g = !1,
                Dt = s.finalText[c],
                yt = Dt.charCodeAt(0),
                yt === 13 || yt === 3 ? (Bt = 0,
                rt.push(st),
                lt = st > lt ? st : lt,
                st = -2 * dt,
                b = "",
                g = !0,
                tt += 1) : b = Dt,
                e.chars ? (at = e.getCharData(Dt, ot.fStyle, e.getFontByName(s.f).fFamily),
                ht = g ? 0 : at.w * s.finalSize / 100) : ht = e.measureText(b, s.f, s.finalSize),
                Dt === " " ? Bt += ht + dt : (st += ht + dt + Bt,
                Bt = 0),
                o.push({
                    l: ht,
                    an: ht,
                    add: $,
                    n: g,
                    anIndexes: [],
                    val: b,
                    line: tt,
                    animatorJustifyOffset: 0
                }),
                j == 2) {
                    if ($ += ht,
                    b === "" || b === " " || c === d - 1) {
                        for ((b === "" || b === " ") && ($ -= ht); nt <= c; )
                            o[nt].an = $,
                            o[nt].ind = _,
                            o[nt].extra = ht,
                            nt += 1;
                        _ += 1,
                        $ = 0
                    }
                } else if (j == 3) {
                    if ($ += ht,
                    b === "" || c === d - 1) {
                        for (b === "" && ($ -= ht); nt <= c; )
                            o[nt].an = $,
                            o[nt].ind = _,
                            o[nt].extra = ht,
                            nt += 1;
                        $ = 0,
                        _ += 1
                    }
                } else
                    o[_].ind = _,
                    o[_].extra = 0,
                    _ += 1;
            if (s.l = o,
            lt = st > lt ? st : lt,
            rt.push(st),
            s.sz)
                s.boxWidth = s.sz[0],
                s.justifyOffset = 0;
            else
                switch (s.boxWidth = lt,
                s.j) {
                case 1:
                    s.justifyOffset = -s.boxWidth;
                    break;
                case 2:
                    s.justifyOffset = -s.boxWidth / 2;
                    break;
                default:
                    s.justifyOffset = 0
                }
            s.lineWidths = rt;
            var Mt = a.a, Tt, mt;
            it = Mt.length;
            var St, wt, Ct = [];
            for (ct = 0; ct < it; ct += 1) {
                for (Tt = Mt[ct],
                Tt.a.sc && (s.strokeColorAnim = !0),
                Tt.a.sw && (s.strokeWidthAnim = !0),
                (Tt.a.fc || Tt.a.fh || Tt.a.fs || Tt.a.fb) && (s.fillColorAnim = !0),
                wt = 0,
                St = Tt.s.b,
                c = 0; c < d; c += 1)
                    mt = o[c],
                    mt.anIndexes[ct] = wt,
                    (St == 1 && mt.val !== "" || St == 2 && mt.val !== "" && mt.val !== " " || St == 3 && (mt.n || mt.val == " " || c == d - 1) || St == 4 && (mt.n || c == d - 1)) && (Tt.s.rn === 1 && Ct.push(wt),
                    wt += 1);
                a.a[ct].s.totalChars = wt;
                var Ht = -1, en;
                if (Tt.s.rn === 1)
                    for (c = 0; c < d; c += 1)
                        mt = o[c],
                        Ht != mt.anIndexes[ct] && (Ht = mt.anIndexes[ct],
                        en = Ct.splice(Math.floor(Math.random() * Ct.length), 1)[0]),
                        mt.anIndexes[ct] = en
            }
            s.yOffset = s.finalLineHeight || s.finalSize * 1.2,
            s.ls = s.ls || 0,
            s.ascent = ot.ascent * s.finalSize / 100
        }
        ,
        TextProperty.prototype.updateDocumentData = function(s, e) {
            e = e === void 0 ? this.keysIndex : e;
            var a = this.copyData({}, this.data.d.k[e].s);
            a = this.copyData(a, s),
            this.data.d.k[e].s = a,
            this.recalculate(e),
            this.setCurrentData(a),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.recalculate = function(s) {
            var e = this.data.d.k[s].s;
            e.__complete = !1,
            this.keysIndex = 0,
            this._isFirstFrame = !0,
            this.getValue(e)
        }
        ,
        TextProperty.prototype.canResizeFont = function(s) {
            this.canResize = s,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.setMinimumFontSize = function(s) {
            this.minimumFontSize = Math.floor(s) || 1,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ;
        var TextSelectorProp = function() {
            var s = Math.max
              , e = Math.min
              , a = Math.floor;
            function o(d, g) {
                this._currentTextLength = -1,
                this.k = !1,
                this.data = g,
                this.elem = d,
                this.comp = d.comp,
                this.finalS = 0,
                this.finalE = 0,
                this.initDynamicPropertyContainer(d),
                this.s = PropertyFactory.getProp(d, g.s || {
                    k: 0
                }, 0, 0, this),
                "e"in g ? this.e = PropertyFactory.getProp(d, g.e, 0, 0, this) : this.e = {
                    v: 100
                },
                this.o = PropertyFactory.getProp(d, g.o || {
                    k: 0
                }, 0, 0, this),
                this.xe = PropertyFactory.getProp(d, g.xe || {
                    k: 0
                }, 0, 0, this),
                this.ne = PropertyFactory.getProp(d, g.ne || {
                    k: 0
                }, 0, 0, this),
                this.sm = PropertyFactory.getProp(d, g.sm || {
                    k: 100
                }, 0, 0, this),
                this.a = PropertyFactory.getProp(d, g.a, 0, .01, this),
                this.dynamicProperties.length || this.getValue()
            }
            o.prototype = {
                getMult: function(g) {
                    this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                    var _ = 0
                      , b = 0
                      , j = 1
                      , $ = 1;
                    this.ne.v > 0 ? _ = this.ne.v / 100 : b = -this.ne.v / 100,
                    this.xe.v > 0 ? j = 1 - this.xe.v / 100 : $ = 1 + this.xe.v / 100;
                    var nt = BezierFactory.getBezierEasing(_, b, j, $).get
                      , tt = 0
                      , rt = this.finalS
                      , st = this.finalE
                      , lt = this.data.sh;
                    if (lt === 2)
                        st === rt ? tt = g >= st ? 1 : 0 : tt = s(0, e(.5 / (st - rt) + (g - rt) / (st - rt), 1)),
                        tt = nt(tt);
                    else if (lt === 3)
                        st === rt ? tt = g >= st ? 0 : 1 : tt = 1 - s(0, e(.5 / (st - rt) + (g - rt) / (st - rt), 1)),
                        tt = nt(tt);
                    else if (lt === 4)
                        st === rt ? tt = 0 : (tt = s(0, e(.5 / (st - rt) + (g - rt) / (st - rt), 1)),
                        tt < .5 ? tt *= 2 : tt = 1 - 2 * (tt - .5)),
                        tt = nt(tt);
                    else if (lt === 5) {
                        if (st === rt)
                            tt = 0;
                        else {
                            var ct = st - rt;
                            g = e(s(0, g + .5 - rt), st - rt);
                            var it = -ct / 2 + g
                              , ot = ct / 2;
                            tt = Math.sqrt(1 - it * it / (ot * ot))
                        }
                        tt = nt(tt)
                    } else
                        lt === 6 ? (st === rt ? tt = 0 : (g = e(s(0, g + .5 - rt), st - rt),
                        tt = (1 + Math.cos(Math.PI + Math.PI * 2 * g / (st - rt))) / 2),
                        tt = nt(tt)) : (g >= a(rt) && (g - rt < 0 ? tt = s(0, e(e(st, 1) - (rt - g), 1)) : tt = s(0, e(st - g, 1))),
                        tt = nt(tt));
                    if (this.sm.v !== 100) {
                        var at = this.sm.v * .01;
                        at === 0 && (at = 1e-8);
                        var ht = .5 - at * .5;
                        tt < ht ? tt = 0 : (tt = (tt - ht) / at,
                        tt > 1 && (tt = 1))
                    }
                    return tt * this.a.v
                },
                getValue: function(g) {
                    this.iterateDynamicProperties(),
                    this._mdf = g || this._mdf,
                    this._currentTextLength = this.elem.textProperty.currentData.l.length || 0,
                    g && this.data.r === 2 && (this.e.v = this._currentTextLength);
                    var _ = this.data.r === 2 ? 1 : 100 / this.data.totalChars
                      , b = this.o.v / _
                      , j = this.s.v / _ + b
                      , $ = this.e.v / _ + b;
                    if (j > $) {
                        var nt = j;
                        j = $,
                        $ = nt
                    }
                    this.finalS = j,
                    this.finalE = $
                }
            },
            extendPrototype([DynamicPropertyContainer], o);
            function c(d, g, _) {
                return new o(d,g)
            }
            return {
                getTextSelectorProp: c
            }
        }();
        function TextAnimatorDataProperty(s, e, a) {
            var o = {
                propType: !1
            }
              , c = PropertyFactory.getProp
              , d = e.a;
            this.a = {
                r: d.r ? c(s, d.r, 0, degToRads, a) : o,
                rx: d.rx ? c(s, d.rx, 0, degToRads, a) : o,
                ry: d.ry ? c(s, d.ry, 0, degToRads, a) : o,
                sk: d.sk ? c(s, d.sk, 0, degToRads, a) : o,
                sa: d.sa ? c(s, d.sa, 0, degToRads, a) : o,
                s: d.s ? c(s, d.s, 1, .01, a) : o,
                a: d.a ? c(s, d.a, 1, 0, a) : o,
                o: d.o ? c(s, d.o, 0, .01, a) : o,
                p: d.p ? c(s, d.p, 1, 0, a) : o,
                sw: d.sw ? c(s, d.sw, 0, 0, a) : o,
                sc: d.sc ? c(s, d.sc, 1, 0, a) : o,
                fc: d.fc ? c(s, d.fc, 1, 0, a) : o,
                fh: d.fh ? c(s, d.fh, 0, 0, a) : o,
                fs: d.fs ? c(s, d.fs, 0, .01, a) : o,
                fb: d.fb ? c(s, d.fb, 0, .01, a) : o,
                t: d.t ? c(s, d.t, 0, 0, a) : o
            },
            this.s = TextSelectorProp.getTextSelectorProp(s, e.s, a),
            this.s.t = e.s.t
        }
        function TextAnimatorProperty(s, e, a) {
            this._isFirstFrame = !0,
            this._hasMaskedPath = !1,
            this._frameId = -1,
            this._textData = s,
            this._renderType = e,
            this._elem = a,
            this._animatorsData = createSizedArray(this._textData.a.length),
            this._pathData = {},
            this._moreOptions = {
                alignment: {}
            },
            this.renderedLetters = [],
            this.lettersChangedFlag = !1,
            this.initDynamicPropertyContainer(a)
        }
        TextAnimatorProperty.prototype.searchProperties = function() {
            var s, e = this._textData.a.length, a, o = PropertyFactory.getProp;
            for (s = 0; s < e; s += 1)
                a = this._textData.a[s],
                this._animatorsData[s] = new TextAnimatorDataProperty(this._elem,a,this);
            this._textData.p && "m"in this._textData.p ? (this._pathData = {
                a: o(this._elem, this._textData.p.a, 0, 0, this),
                f: o(this._elem, this._textData.p.f, 0, 0, this),
                l: o(this._elem, this._textData.p.l, 0, 0, this),
                r: o(this._elem, this._textData.p.r, 0, 0, this),
                p: o(this._elem, this._textData.p.p, 0, 0, this),
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            },
            this._hasMaskedPath = !0) : this._hasMaskedPath = !1,
            this._moreOptions.alignment = o(this._elem, this._textData.m.a, 1, 0, this)
        }
        ,
        TextAnimatorProperty.prototype.getMeasures = function(s, e) {
            if (this.lettersChangedFlag = e,
            !(!this._mdf && !this._isFirstFrame && !e && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
                this._isFirstFrame = !1;
                var a = this._moreOptions.alignment.v, o = this._animatorsData, c = this._textData, d = this.mHelper, g = this._renderType, _ = this.renderedLetters.length, b, j, $, nt, tt = s.l, rt, st, lt, ct, it, ot, at, ht, pt, dt, yt, vt, xt, _t, bt;
                if (this._hasMaskedPath) {
                    if (bt = this._pathData.m,
                    !this._pathData.n || this._pathData._mdf) {
                        var Rt = bt.v;
                        this._pathData.r.v && (Rt = Rt.reverse()),
                        rt = {
                            tLength: 0,
                            segments: []
                        },
                        nt = Rt._length - 1;
                        var Ft;
                        for (vt = 0,
                        $ = 0; $ < nt; $ += 1)
                            Ft = bez.buildBezierData(Rt.v[$], Rt.v[$ + 1], [Rt.o[$][0] - Rt.v[$][0], Rt.o[$][1] - Rt.v[$][1]], [Rt.i[$ + 1][0] - Rt.v[$ + 1][0], Rt.i[$ + 1][1] - Rt.v[$ + 1][1]]),
                            rt.tLength += Ft.segmentLength,
                            rt.segments.push(Ft),
                            vt += Ft.segmentLength;
                        $ = nt,
                        bt.v.c && (Ft = bez.buildBezierData(Rt.v[$], Rt.v[0], [Rt.o[$][0] - Rt.v[$][0], Rt.o[$][1] - Rt.v[$][1]], [Rt.i[0][0] - Rt.v[0][0], Rt.i[0][1] - Rt.v[0][1]]),
                        rt.tLength += Ft.segmentLength,
                        rt.segments.push(Ft),
                        vt += Ft.segmentLength),
                        this._pathData.pi = rt
                    }
                    if (rt = this._pathData.pi,
                    st = this._pathData.f.v,
                    at = 0,
                    ot = 1,
                    ct = 0,
                    it = !0,
                    dt = rt.segments,
                    st < 0 && bt.v.c)
                        for (rt.tLength < Math.abs(st) && (st = -Math.abs(st) % rt.tLength),
                        at = dt.length - 1,
                        pt = dt[at].points,
                        ot = pt.length - 1; st < 0; )
                            st += pt[ot].partialLength,
                            ot -= 1,
                            ot < 0 && (at -= 1,
                            pt = dt[at].points,
                            ot = pt.length - 1);
                    pt = dt[at].points,
                    ht = pt[ot - 1],
                    lt = pt[ot],
                    yt = lt.partialLength
                }
                nt = tt.length,
                b = 0,
                j = 0;
                var Bt = s.finalSize * 1.2 * .714, Dt = !0, Mt, Tt, mt, St, wt;
                St = o.length;
                var Ct, Ht = -1, en, Ot, Yt, rn = st, Xt = at, An = ot, Ln = -1, _n, yn, Pt, Qt, jt, fn, tn, bn, gn = "", vn = this.defaultPropsArray, Lt;
                if (s.j === 2 || s.j === 1) {
                    var At = 0
                      , $t = 0
                      , on = s.j === 2 ? -.5 : -1
                      , sn = 0
                      , cn = !0;
                    for ($ = 0; $ < nt; $ += 1)
                        if (tt[$].n) {
                            for (At && (At += $t); sn < $; )
                                tt[sn].animatorJustifyOffset = At,
                                sn += 1;
                            At = 0,
                            cn = !0
                        } else {
                            for (mt = 0; mt < St; mt += 1)
                                Mt = o[mt].a,
                                Mt.t.propType && (cn && s.j === 2 && ($t += Mt.t.v * on),
                                Tt = o[mt].s,
                                Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                                Ct.length ? At += Mt.t.v * Ct[0] * on : At += Mt.t.v * Ct * on);
                            cn = !1
                        }
                    for (At && (At += $t); sn < $; )
                        tt[sn].animatorJustifyOffset = At,
                        sn += 1
                }
                for ($ = 0; $ < nt; $ += 1) {
                    if (d.reset(),
                    _n = 1,
                    tt[$].n)
                        b = 0,
                        j += s.yOffset,
                        j += Dt ? 1 : 0,
                        st = rn,
                        Dt = !1,
                        this._hasMaskedPath && (at = Xt,
                        ot = An,
                        pt = dt[at].points,
                        ht = pt[ot - 1],
                        lt = pt[ot],
                        yt = lt.partialLength,
                        ct = 0),
                        gn = "",
                        bn = "",
                        fn = "",
                        Lt = "",
                        vn = this.defaultPropsArray;
                    else {
                        if (this._hasMaskedPath) {
                            if (Ln !== tt[$].line) {
                                switch (s.j) {
                                case 1:
                                    st += vt - s.lineWidths[tt[$].line];
                                    break;
                                case 2:
                                    st += (vt - s.lineWidths[tt[$].line]) / 2;
                                    break
                                }
                                Ln = tt[$].line
                            }
                            Ht !== tt[$].ind && (tt[Ht] && (st += tt[Ht].extra),
                            st += tt[$].an / 2,
                            Ht = tt[$].ind),
                            st += a[0] * tt[$].an * .005;
                            var Pn = 0;
                            for (mt = 0; mt < St; mt += 1)
                                Mt = o[mt].a,
                                Mt.p.propType && (Tt = o[mt].s,
                                Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                                Ct.length ? Pn += Mt.p.v[0] * Ct[0] : Pn += Mt.p.v[0] * Ct),
                                Mt.a.propType && (Tt = o[mt].s,
                                Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                                Ct.length ? Pn += Mt.a.v[0] * Ct[0] : Pn += Mt.a.v[0] * Ct);
                            for (it = !0,
                            this._pathData.a.v && (st = tt[0].an * .5 + (vt - this._pathData.f.v - tt[0].an * .5 - tt[tt.length - 1].an * .5) * Ht / (nt - 1),
                            st += this._pathData.f.v); it; )
                                ct + yt >= st + Pn || !pt ? (xt = (st + Pn - ct) / lt.partialLength,
                                Ot = ht.point[0] + (lt.point[0] - ht.point[0]) * xt,
                                Yt = ht.point[1] + (lt.point[1] - ht.point[1]) * xt,
                                d.translate(-a[0] * tt[$].an * .005, -(a[1] * Bt) * .01),
                                it = !1) : pt && (ct += lt.partialLength,
                                ot += 1,
                                ot >= pt.length && (ot = 0,
                                at += 1,
                                dt[at] ? pt = dt[at].points : bt.v.c ? (ot = 0,
                                at = 0,
                                pt = dt[at].points) : (ct -= lt.partialLength,
                                pt = null)),
                                pt && (ht = lt,
                                lt = pt[ot],
                                yt = lt.partialLength));
                            en = tt[$].an / 2 - tt[$].add,
                            d.translate(-en, 0, 0)
                        } else
                            en = tt[$].an / 2 - tt[$].add,
                            d.translate(-en, 0, 0),
                            d.translate(-a[0] * tt[$].an * .005, -a[1] * Bt * .01, 0);
                        for (mt = 0; mt < St; mt += 1)
                            Mt = o[mt].a,
                            Mt.t.propType && (Tt = o[mt].s,
                            Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                            (b !== 0 || s.j !== 0) && (this._hasMaskedPath ? Ct.length ? st += Mt.t.v * Ct[0] : st += Mt.t.v * Ct : Ct.length ? b += Mt.t.v * Ct[0] : b += Mt.t.v * Ct));
                        for (s.strokeWidthAnim && (Pt = s.sw || 0),
                        s.strokeColorAnim && (s.sc ? yn = [s.sc[0], s.sc[1], s.sc[2]] : yn = [0, 0, 0]),
                        s.fillColorAnim && s.fc && (Qt = [s.fc[0], s.fc[1], s.fc[2]]),
                        mt = 0; mt < St; mt += 1)
                            Mt = o[mt].a,
                            Mt.a.propType && (Tt = o[mt].s,
                            Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                            Ct.length ? d.translate(-Mt.a.v[0] * Ct[0], -Mt.a.v[1] * Ct[1], Mt.a.v[2] * Ct[2]) : d.translate(-Mt.a.v[0] * Ct, -Mt.a.v[1] * Ct, Mt.a.v[2] * Ct));
                        for (mt = 0; mt < St; mt += 1)
                            Mt = o[mt].a,
                            Mt.s.propType && (Tt = o[mt].s,
                            Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                            Ct.length ? d.scale(1 + (Mt.s.v[0] - 1) * Ct[0], 1 + (Mt.s.v[1] - 1) * Ct[1], 1) : d.scale(1 + (Mt.s.v[0] - 1) * Ct, 1 + (Mt.s.v[1] - 1) * Ct, 1));
                        for (mt = 0; mt < St; mt += 1) {
                            if (Mt = o[mt].a,
                            Tt = o[mt].s,
                            Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                            Mt.sk.propType && (Ct.length ? d.skewFromAxis(-Mt.sk.v * Ct[0], Mt.sa.v * Ct[1]) : d.skewFromAxis(-Mt.sk.v * Ct, Mt.sa.v * Ct)),
                            Mt.r.propType && (Ct.length ? d.rotateZ(-Mt.r.v * Ct[2]) : d.rotateZ(-Mt.r.v * Ct)),
                            Mt.ry.propType && (Ct.length ? d.rotateY(Mt.ry.v * Ct[1]) : d.rotateY(Mt.ry.v * Ct)),
                            Mt.rx.propType && (Ct.length ? d.rotateX(Mt.rx.v * Ct[0]) : d.rotateX(Mt.rx.v * Ct)),
                            Mt.o.propType && (Ct.length ? _n += (Mt.o.v * Ct[0] - _n) * Ct[0] : _n += (Mt.o.v * Ct - _n) * Ct),
                            s.strokeWidthAnim && Mt.sw.propType && (Ct.length ? Pt += Mt.sw.v * Ct[0] : Pt += Mt.sw.v * Ct),
                            s.strokeColorAnim && Mt.sc.propType)
                                for (jt = 0; jt < 3; jt += 1)
                                    Ct.length ? yn[jt] += (Mt.sc.v[jt] - yn[jt]) * Ct[0] : yn[jt] += (Mt.sc.v[jt] - yn[jt]) * Ct;
                            if (s.fillColorAnim && s.fc) {
                                if (Mt.fc.propType)
                                    for (jt = 0; jt < 3; jt += 1)
                                        Ct.length ? Qt[jt] += (Mt.fc.v[jt] - Qt[jt]) * Ct[0] : Qt[jt] += (Mt.fc.v[jt] - Qt[jt]) * Ct;
                                Mt.fh.propType && (Ct.length ? Qt = addHueToRGB(Qt, Mt.fh.v * Ct[0]) : Qt = addHueToRGB(Qt, Mt.fh.v * Ct)),
                                Mt.fs.propType && (Ct.length ? Qt = addSaturationToRGB(Qt, Mt.fs.v * Ct[0]) : Qt = addSaturationToRGB(Qt, Mt.fs.v * Ct)),
                                Mt.fb.propType && (Ct.length ? Qt = addBrightnessToRGB(Qt, Mt.fb.v * Ct[0]) : Qt = addBrightnessToRGB(Qt, Mt.fb.v * Ct))
                            }
                        }
                        for (mt = 0; mt < St; mt += 1)
                            Mt = o[mt].a,
                            Mt.p.propType && (Tt = o[mt].s,
                            Ct = Tt.getMult(tt[$].anIndexes[mt], c.a[mt].s.totalChars),
                            this._hasMaskedPath ? Ct.length ? d.translate(0, Mt.p.v[1] * Ct[0], -Mt.p.v[2] * Ct[1]) : d.translate(0, Mt.p.v[1] * Ct, -Mt.p.v[2] * Ct) : Ct.length ? d.translate(Mt.p.v[0] * Ct[0], Mt.p.v[1] * Ct[1], -Mt.p.v[2] * Ct[2]) : d.translate(Mt.p.v[0] * Ct, Mt.p.v[1] * Ct, -Mt.p.v[2] * Ct));
                        if (s.strokeWidthAnim && (fn = Pt < 0 ? 0 : Pt),
                        s.strokeColorAnim && (tn = "rgb(" + Math.round(yn[0] * 255) + "," + Math.round(yn[1] * 255) + "," + Math.round(yn[2] * 255) + ")"),
                        s.fillColorAnim && s.fc && (bn = "rgb(" + Math.round(Qt[0] * 255) + "," + Math.round(Qt[1] * 255) + "," + Math.round(Qt[2] * 255) + ")"),
                        this._hasMaskedPath) {
                            if (d.translate(0, -s.ls),
                            d.translate(0, a[1] * Bt * .01 + j, 0),
                            this._pathData.p.v) {
                                _t = (lt.point[1] - ht.point[1]) / (lt.point[0] - ht.point[0]);
                                var dn = Math.atan(_t) * 180 / Math.PI;
                                lt.point[0] < ht.point[0] && (dn += 180),
                                d.rotate(-dn * Math.PI / 180)
                            }
                            d.translate(Ot, Yt, 0),
                            st -= a[0] * tt[$].an * .005,
                            tt[$ + 1] && Ht !== tt[$ + 1].ind && (st += tt[$].an / 2,
                            st += s.tr * .001 * s.finalSize)
                        } else {
                            switch (d.translate(b, j, 0),
                            s.ps && d.translate(s.ps[0], s.ps[1] + s.ascent, 0),
                            s.j) {
                            case 1:
                                d.translate(tt[$].animatorJustifyOffset + s.justifyOffset + (s.boxWidth - s.lineWidths[tt[$].line]), 0, 0);
                                break;
                            case 2:
                                d.translate(tt[$].animatorJustifyOffset + s.justifyOffset + (s.boxWidth - s.lineWidths[tt[$].line]) / 2, 0, 0);
                                break
                            }
                            d.translate(0, -s.ls),
                            d.translate(en, 0, 0),
                            d.translate(a[0] * tt[$].an * .005, a[1] * Bt * .01, 0),
                            b += tt[$].l + s.tr * .001 * s.finalSize
                        }
                        g === "html" ? gn = d.toCSS() : g === "svg" ? gn = d.to2dCSS() : vn = [d.props[0], d.props[1], d.props[2], d.props[3], d.props[4], d.props[5], d.props[6], d.props[7], d.props[8], d.props[9], d.props[10], d.props[11], d.props[12], d.props[13], d.props[14], d.props[15]],
                        Lt = _n
                    }
                    _ <= $ ? (wt = new LetterProps(Lt,fn,tn,bn,gn,vn),
                    this.renderedLetters.push(wt),
                    _ += 1,
                    this.lettersChangedFlag = !0) : (wt = this.renderedLetters[$],
                    this.lettersChangedFlag = wt.update(Lt, fn, tn, bn, gn, vn) || this.lettersChangedFlag)
                }
            }
        }
        ,
        TextAnimatorProperty.prototype.getValue = function() {
            this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        TextAnimatorProperty.prototype.mHelper = new Matrix,
        TextAnimatorProperty.prototype.defaultPropsArray = [],
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
        function ITextElement() {}
        ITextElement.prototype.initElement = function(s, e, a) {
            this.lettersChangedFlag = !0,
            this.initFrame(),
            this.initBaseData(s, e, a),
            this.textProperty = new TextProperty(this,s.t,this.dynamicProperties),
            this.textAnimator = new TextAnimatorProperty(s.t,this.renderType,this),
            this.initTransform(s, e, a),
            this.initHierarchy(),
            this.initRenderable(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            this.createContent(),
            this.hide(),
            this.textAnimator.searchProperties(this.dynamicProperties)
        }
        ,
        ITextElement.prototype.prepareFrame = function(s) {
            this._mdf = !1,
            this.prepareRenderableFrame(s),
            this.prepareProperties(s, this.isInRange)
        }
        ,
        ITextElement.prototype.createPathShape = function(s, e) {
            var a, o = e.length, c, d = "";
            for (a = 0; a < o; a += 1)
                e[a].ty === "sh" && (c = e[a].ks.k,
                d += buildShapeString(c, c.i.length, !0, s));
            return d
        }
        ,
        ITextElement.prototype.updateDocumentData = function(s, e) {
            this.textProperty.updateDocumentData(s, e)
        }
        ,
        ITextElement.prototype.canResizeFont = function(s) {
            this.textProperty.canResizeFont(s)
        }
        ,
        ITextElement.prototype.setMinimumFontSize = function(s) {
            this.textProperty.setMinimumFontSize(s)
        }
        ,
        ITextElement.prototype.applyTextPropertiesToMatrix = function(s, e, a, o, c) {
            switch (s.ps && e.translate(s.ps[0], s.ps[1] + s.ascent, 0),
            e.translate(0, -s.ls, 0),
            s.j) {
            case 1:
                e.translate(s.justifyOffset + (s.boxWidth - s.lineWidths[a]), 0, 0);
                break;
            case 2:
                e.translate(s.justifyOffset + (s.boxWidth - s.lineWidths[a]) / 2, 0, 0);
                break
            }
            e.translate(o, c, 0)
        }
        ,
        ITextElement.prototype.buildColor = function(s) {
            return "rgb(" + Math.round(s[0] * 255) + "," + Math.round(s[1] * 255) + "," + Math.round(s[2] * 255) + ")"
        }
        ,
        ITextElement.prototype.emptyProp = new LetterProps,
        ITextElement.prototype.destroy = function() {}
        ,
        ITextElement.prototype.validateText = function() {
            (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(),
            this.textProperty._isFirstFrame = !1,
            this.textProperty._mdf = !1)
        }
        ;
        var emptyShapeData = {
            shapes: []
        };
        function SVGTextLottieElement(s, e, a) {
            this.textSpans = [],
            this.renderType = "svg",
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement),
        SVGTextLottieElement.prototype.createContent = function() {
            this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
        }
        ,
        SVGTextLottieElement.prototype.buildTextContents = function(s) {
            for (var e = 0, a = s.length, o = [], c = ""; e < a; )
                s[e] === "\r" || s[e] === "" ? (o.push(c),
                c = "") : c += s[e],
                e += 1;
            return o.push(c),
            o
        }
        ,
        SVGTextLottieElement.prototype.buildShapeData = function(s, e) {
            if (s.shapes && s.shapes.length) {
                var a = s.shapes[0];
                if (a.it) {
                    var o = a.it[a.it.length - 1];
                    o.s && (o.s.k[0] = e,
                    o.s.k[1] = e)
                }
            }
            return s
        }
        ,
        SVGTextLottieElement.prototype.buildNewText = function() {
            this.addDynamicProperty(this);
            var s, e, a = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(a ? a.l.length : 0),
            a.fc ? this.layerElement.setAttribute("fill", this.buildColor(a.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            a.sc && (this.layerElement.setAttribute("stroke", this.buildColor(a.sc)),
            this.layerElement.setAttribute("stroke-width", a.sw)),
            this.layerElement.setAttribute("font-size", a.finalSize);
            var o = this.globalData.fontManager.getFontByName(a.f);
            if (o.fClass)
                this.layerElement.setAttribute("class", o.fClass);
            else {
                this.layerElement.setAttribute("font-family", o.fFamily);
                var c = a.fWeight
                  , d = a.fStyle;
                this.layerElement.setAttribute("font-style", d),
                this.layerElement.setAttribute("font-weight", c)
            }
            this.layerElement.setAttribute("aria-label", a.t);
            var g = a.l || []
              , _ = !!this.globalData.fontManager.chars;
            e = g.length;
            var b, j = this.mHelper, $ = "", nt = this.data.singleShape, tt = 0, rt = 0, st = !0, lt = a.tr * .001 * a.finalSize;
            if (nt && !_ && !a.sz) {
                var ct = this.textContainer
                  , it = "start";
                switch (a.j) {
                case 1:
                    it = "end";
                    break;
                case 2:
                    it = "middle";
                    break;
                default:
                    it = "start";
                    break
                }
                ct.setAttribute("text-anchor", it),
                ct.setAttribute("letter-spacing", lt);
                var ot = this.buildTextContents(a.finalText);
                for (e = ot.length,
                rt = a.ps ? a.ps[1] + a.ascent : 0,
                s = 0; s < e; s += 1)
                    b = this.textSpans[s].span || createNS("tspan"),
                    b.textContent = ot[s],
                    b.setAttribute("x", 0),
                    b.setAttribute("y", rt),
                    b.style.display = "inherit",
                    ct.appendChild(b),
                    this.textSpans[s] || (this.textSpans[s] = {
                        span: null,
                        glyph: null
                    }),
                    this.textSpans[s].span = b,
                    rt += a.finalLineHeight;
                this.layerElement.appendChild(ct)
            } else {
                var at = this.textSpans.length, ht;
                for (s = 0; s < e; s += 1) {
                    if (this.textSpans[s] || (this.textSpans[s] = {
                        span: null,
                        childSpan: null,
                        glyph: null
                    }),
                    !_ || !nt || s === 0) {
                        if (b = at > s ? this.textSpans[s].span : createNS(_ ? "g" : "text"),
                        at <= s) {
                            if (b.setAttribute("stroke-linecap", "butt"),
                            b.setAttribute("stroke-linejoin", "round"),
                            b.setAttribute("stroke-miterlimit", "4"),
                            this.textSpans[s].span = b,
                            _) {
                                var pt = createNS("g");
                                b.appendChild(pt),
                                this.textSpans[s].childSpan = pt
                            }
                            this.textSpans[s].span = b,
                            this.layerElement.appendChild(b)
                        }
                        b.style.display = "inherit"
                    }
                    if (j.reset(),
                    nt && (g[s].n && (tt = -lt,
                    rt += a.yOffset,
                    rt += st ? 1 : 0,
                    st = !1),
                    this.applyTextPropertiesToMatrix(a, j, g[s].line, tt, rt),
                    tt += g[s].l || 0,
                    tt += lt),
                    _) {
                        ht = this.globalData.fontManager.getCharData(a.finalText[s], o.fStyle, this.globalData.fontManager.getFontByName(a.f).fFamily);
                        var dt;
                        if (ht.t === 1)
                            dt = new SVGCompElement(ht.data,this.globalData,this);
                        else {
                            var yt = emptyShapeData;
                            ht.data && ht.data.shapes && (yt = this.buildShapeData(ht.data, a.finalSize)),
                            dt = new SVGShapeElement(yt,this.globalData,this)
                        }
                        if (this.textSpans[s].glyph) {
                            var vt = this.textSpans[s].glyph;
                            this.textSpans[s].childSpan.removeChild(vt.layerElement),
                            vt.destroy()
                        }
                        this.textSpans[s].glyph = dt,
                        dt._debug = !0,
                        dt.prepareFrame(0),
                        dt.renderFrame(),
                        this.textSpans[s].childSpan.appendChild(dt.layerElement),
                        ht.t === 1 && this.textSpans[s].childSpan.setAttribute("transform", "scale(" + a.finalSize / 100 + "," + a.finalSize / 100 + ")")
                    } else
                        nt && b.setAttribute("transform", "translate(" + j.props[12] + "," + j.props[13] + ")"),
                        b.textContent = g[s].val,
                        b.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
                }
                nt && b && b.setAttribute("d", $)
            }
            for (; s < this.textSpans.length; )
                this.textSpans[s].span.style.display = "none",
                s += 1;
            this._sizeChanged = !0
        }
        ,
        SVGTextLottieElement.prototype.sourceRectAtTime = function() {
            if (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged) {
                this._sizeChanged = !1;
                var s = this.layerElement.getBBox();
                this.bbox = {
                    top: s.y,
                    left: s.x,
                    width: s.width,
                    height: s.height
                }
            }
            return this.bbox
        }
        ,
        SVGTextLottieElement.prototype.getValue = function() {
            var s, e = this.textSpans.length, a;
            for (this.renderedFrame = this.comp.renderedFrame,
            s = 0; s < e; s += 1)
                a = this.textSpans[s].glyph,
                a && (a.prepareFrame(this.comp.renderedFrame - this.data.st),
                a._mdf && (this._mdf = !0))
        }
        ,
        SVGTextLottieElement.prototype.renderInnerContent = function() {
            if (this.validateText(),
            (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                this._sizeChanged = !0;
                var s, e, a = this.textAnimator.renderedLetters, o = this.textProperty.currentData.l;
                e = o.length;
                var c, d, g;
                for (s = 0; s < e; s += 1)
                    o[s].n || (c = a[s],
                    d = this.textSpans[s].span,
                    g = this.textSpans[s].glyph,
                    g && g.renderFrame(),
                    c._mdf.m && d.setAttribute("transform", c.m),
                    c._mdf.o && d.setAttribute("opacity", c.o),
                    c._mdf.sw && d.setAttribute("stroke-width", c.sw),
                    c._mdf.sc && d.setAttribute("stroke", c.sc),
                    c._mdf.fc && d.setAttribute("fill", c.fc))
            }
        }
        ;
        function ISolidElement(s, e, a) {
            this.initElement(s, e, a)
        }
        extendPrototype([IImageElement], ISolidElement),
        ISolidElement.prototype.createContent = function() {
            var s = createNS("rect");
            s.setAttribute("width", this.data.sw),
            s.setAttribute("height", this.data.sh),
            s.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(s)
        }
        ;
        function NullElement(s, e, a) {
            this.initFrame(),
            this.initBaseData(s, e, a),
            this.initFrame(),
            this.initTransform(s, e, a),
            this.initHierarchy()
        }
        NullElement.prototype.prepareFrame = function(s) {
            this.prepareProperties(s, !0)
        }
        ,
        NullElement.prototype.renderFrame = function() {}
        ,
        NullElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        NullElement.prototype.destroy = function() {}
        ,
        NullElement.prototype.sourceRectAtTime = function() {}
        ,
        NullElement.prototype.hide = function() {}
        ,
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
        function SVGRendererBase() {}
        extendPrototype([BaseRenderer], SVGRendererBase),
        SVGRendererBase.prototype.createNull = function(s) {
            return new NullElement(s,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createShape = function(s) {
            return new SVGShapeElement(s,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createText = function(s) {
            return new SVGTextLottieElement(s,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createImage = function(s) {
            return new IImageElement(s,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createSolid = function(s) {
            return new ISolidElement(s,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.configAnimation = function(s) {
            this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"),
            this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + s.w + " " + s.h),
            this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", s.w),
            this.svgElement.setAttribute("height", s.h),
            this.svgElement.style.width = "100%",
            this.svgElement.style.height = "100%",
            this.svgElement.style.transform = "translate3d(0,0,0)",
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility),
            this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className),
            this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable),
            this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio),
            this.animationItem.wrapper.appendChild(this.svgElement);
            var e = this.globalData.defs;
            this.setupGlobalData(s, e),
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.data = s;
            var a = createNS("clipPath")
              , o = createNS("rect");
            o.setAttribute("width", s.w),
            o.setAttribute("height", s.h),
            o.setAttribute("x", 0),
            o.setAttribute("y", 0);
            var c = createElementID();
            a.setAttribute("id", c),
            a.appendChild(o),
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + c + ")"),
            e.appendChild(a),
            this.layers = s.layers,
            this.elements = createSizedArray(s.layers.length)
        }
        ,
        SVGRendererBase.prototype.destroy = function() {
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.layerElement = null,
            this.globalData.defs = null;
            var s, e = this.layers ? this.layers.length : 0;
            for (s = 0; s < e; s += 1)
                this.elements[s] && this.elements[s].destroy && this.elements[s].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        SVGRendererBase.prototype.updateContainerSize = function() {}
        ,
        SVGRendererBase.prototype.findIndexByInd = function(s) {
            var e = 0
              , a = this.layers.length;
            for (e = 0; e < a; e += 1)
                if (this.layers[e].ind === s)
                    return e;
            return -1
        }
        ,
        SVGRendererBase.prototype.buildItem = function(s) {
            var e = this.elements;
            if (!(e[s] || this.layers[s].ty === 99)) {
                e[s] = !0;
                var a = this.createItem(this.layers[s]);
                if (e[s] = a,
                getExpressionsPlugin() && (this.layers[s].ty === 0 && this.globalData.projectInterface.registerComposition(a),
                a.initExpressions()),
                this.appendElementInPos(a, s),
                this.layers[s].tt) {
                    var o = "tp"in this.layers[s] ? this.findIndexByInd(this.layers[s].tp) : s - 1;
                    if (o === -1)
                        return;
                    if (!this.elements[o] || this.elements[o] === !0)
                        this.buildItem(o),
                        this.addPendingElement(a);
                    else {
                        var c = e[o]
                          , d = c.getMatte(this.layers[s].tt);
                        a.setMatte(d)
                    }
                }
            }
        }
        ,
        SVGRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var s = this.pendingElements.pop();
                if (s.checkParenting(),
                s.data.tt)
                    for (var e = 0, a = this.elements.length; e < a; ) {
                        if (this.elements[e] === s) {
                            var o = "tp"in s.data ? this.findIndexByInd(s.data.tp) : e - 1
                              , c = this.elements[o]
                              , d = c.getMatte(this.layers[e].tt);
                            s.setMatte(d);
                            break
                        }
                        e += 1
                    }
            }
        }
        ,
        SVGRendererBase.prototype.renderFrame = function(s) {
            if (!(this.renderedFrame === s || this.destroyed)) {
                s === null ? s = this.renderedFrame : this.renderedFrame = s,
                this.globalData.frameNum = s,
                this.globalData.frameId += 1,
                this.globalData.projectInterface.currentFrame = s,
                this.globalData._mdf = !1;
                var e, a = this.layers.length;
                for (this.completeLayers || this.checkLayers(s),
                e = a - 1; e >= 0; e -= 1)
                    (this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(s - this.layers[e].st);
                if (this.globalData._mdf)
                    for (e = 0; e < a; e += 1)
                        (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
            }
        }
        ,
        SVGRendererBase.prototype.appendElementInPos = function(s, e) {
            var a = s.getBaseElement();
            if (a) {
                for (var o = 0, c; o < e; )
                    this.elements[o] && this.elements[o] !== !0 && this.elements[o].getBaseElement() && (c = this.elements[o].getBaseElement()),
                    o += 1;
                c ? this.layerElement.insertBefore(a, c) : this.layerElement.appendChild(a)
            }
        }
        ,
        SVGRendererBase.prototype.hide = function() {
            this.layerElement.style.display = "none"
        }
        ,
        SVGRendererBase.prototype.show = function() {
            this.layerElement.style.display = "block"
        }
        ;
        function ICompElement() {}
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement),
        ICompElement.prototype.initElement = function(s, e, a) {
            this.initFrame(),
            this.initBaseData(s, e, a),
            this.initTransform(s, e, a),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            (this.data.xt || !e.progressiveLoad) && this.buildAllItems(),
            this.hide()
        }
        ,
        ICompElement.prototype.prepareFrame = function(s) {
            if (this._mdf = !1,
            this.prepareRenderableFrame(s),
            this.prepareProperties(s, this.isInRange),
            !(!this.isInRange && !this.data.xt)) {
                if (this.tm._placeholder)
                    this.renderedFrame = s / this.data.sr;
                else {
                    var e = this.tm.v;
                    e === this.data.op && (e = this.data.op - 1),
                    this.renderedFrame = e
                }
                var a, o = this.elements.length;
                for (this.completeLayers || this.checkLayers(this.renderedFrame),
                a = o - 1; a >= 0; a -= 1)
                    (this.completeLayers || this.elements[a]) && (this.elements[a].prepareFrame(this.renderedFrame - this.layers[a].st),
                    this.elements[a]._mdf && (this._mdf = !0))
            }
        }
        ,
        ICompElement.prototype.renderInnerContent = function() {
            var s, e = this.layers.length;
            for (s = 0; s < e; s += 1)
                (this.completeLayers || this.elements[s]) && this.elements[s].renderFrame()
        }
        ,
        ICompElement.prototype.setElements = function(s) {
            this.elements = s
        }
        ,
        ICompElement.prototype.getElements = function() {
            return this.elements
        }
        ,
        ICompElement.prototype.destroyElements = function() {
            var s, e = this.layers.length;
            for (s = 0; s < e; s += 1)
                this.elements[s] && this.elements[s].destroy()
        }
        ,
        ICompElement.prototype.destroy = function() {
            this.destroyElements(),
            this.destroyBaseElement()
        }
        ;
        function SVGCompElement(s, e, a) {
            this.layers = s.layers,
            this.supports3d = !0,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(s, e, a),
            this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement),
        SVGCompElement.prototype.createComp = function(s) {
            return new SVGCompElement(s,this.globalData,this)
        }
        ;
        function SVGRenderer(s, e) {
            this.animationItem = s,
            this.layers = null,
            this.renderedFrame = -1,
            this.svgElement = createNS("svg");
            var a = "";
            if (e && e.title) {
                var o = createNS("title")
                  , c = createElementID();
                o.setAttribute("id", c),
                o.textContent = e.title,
                this.svgElement.appendChild(o),
                a += c
            }
            if (e && e.description) {
                var d = createNS("desc")
                  , g = createElementID();
                d.setAttribute("id", g),
                d.textContent = e.description,
                this.svgElement.appendChild(d),
                a += " " + g
            }
            a && this.svgElement.setAttribute("aria-labelledby", a);
            var _ = createNS("defs");
            this.svgElement.appendChild(_);
            var b = createNS("g");
            this.svgElement.appendChild(b),
            this.layerElement = b,
            this.renderConfig = {
                preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: e && e.contentVisibility || "visible",
                progressiveLoad: e && e.progressiveLoad || !1,
                hideOnTransparent: !(e && e.hideOnTransparent === !1),
                viewBoxOnly: e && e.viewBoxOnly || !1,
                viewBoxSize: e && e.viewBoxSize || !1,
                className: e && e.className || "",
                id: e && e.id || "",
                focusable: e && e.focusable,
                filterSize: {
                    width: e && e.filterSize && e.filterSize.width || "100%",
                    height: e && e.filterSize && e.filterSize.height || "100%",
                    x: e && e.filterSize && e.filterSize.x || "0%",
                    y: e && e.filterSize && e.filterSize.y || "0%"
                },
                width: e && e.width,
                height: e && e.height,
                runExpressions: !e || e.runExpressions === void 0 || e.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                defs: _,
                renderConfig: this.renderConfig
            },
            this.elements = [],
            this.pendingElements = [],
            this.destroyed = !1,
            this.rendererType = "svg"
        }
        extendPrototype([SVGRendererBase], SVGRenderer),
        SVGRenderer.prototype.createComp = function(s) {
            return new SVGCompElement(s,this.globalData,this)
        }
        ;
        function ShapeTransformManager() {
            this.sequences = {},
            this.sequenceList = [],
            this.transform_key_count = 0
        }
        ShapeTransformManager.prototype = {
            addTransformSequence: function(e) {
                var a, o = e.length, c = "_";
                for (a = 0; a < o; a += 1)
                    c += e[a].transform.key + "_";
                var d = this.sequences[c];
                return d || (d = {
                    transforms: [].concat(e),
                    finalTransform: new Matrix,
                    _mdf: !1
                },
                this.sequences[c] = d,
                this.sequenceList.push(d)),
                d
            },
            processSequence: function(e, a) {
                for (var o = 0, c = e.transforms.length, d = a; o < c && !a; ) {
                    if (e.transforms[o].transform.mProps._mdf) {
                        d = !0;
                        break
                    }
                    o += 1
                }
                if (d)
                    for (e.finalTransform.reset(),
                    o = c - 1; o >= 0; o -= 1)
                        e.finalTransform.multiply(e.transforms[o].transform.mProps.v);
                e._mdf = d
            },
            processSequences: function(e) {
                var a, o = this.sequenceList.length;
                for (a = 0; a < o; a += 1)
                    this.processSequence(this.sequenceList[a], e)
            },
            getNewKey: function() {
                return this.transform_key_count += 1,
                "_" + this.transform_key_count
            }
        };
        var lumaLoader = function() {
            var e = "__lottie_element_luma_buffer"
              , a = null
              , o = null
              , c = null;
            function d() {
                var b = createNS("svg")
                  , j = createNS("filter")
                  , $ = createNS("feColorMatrix");
                return j.setAttribute("id", e),
                $.setAttribute("type", "matrix"),
                $.setAttribute("color-interpolation-filters", "sRGB"),
                $.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"),
                j.appendChild($),
                b.appendChild(j),
                b.setAttribute("id", e + "_svg"),
                featureSupport.svgLumaHidden && (b.style.display = "none"),
                b
            }
            function g() {
                a || (c = d(),
                document.body.appendChild(c),
                a = createTag("canvas"),
                o = a.getContext("2d"),
                o.filter = "url(#" + e + ")",
                o.fillStyle = "rgba(0,0,0,0)",
                o.fillRect(0, 0, 1, 1))
            }
            function _(b) {
                return a || g(),
                a.width = b.width,
                a.height = b.height,
                o.filter = "url(#" + e + ")",
                a
            }
            return {
                load: g,
                get: _
            }
        };
        function createCanvas(s, e) {
            if (featureSupport.offscreenCanvas)
                return new OffscreenCanvas(s,e);
            var a = createTag("canvas");
            return a.width = s,
            a.height = e,
            a
        }
        var assetLoader = function() {
            return {
                loadLumaCanvas: lumaLoader.load,
                getLumaCanvas: lumaLoader.get,
                createCanvas
            }
        }()
          , registeredEffects = {};
        function CVEffects(s) {
            var e, a = s.data.ef ? s.data.ef.length : 0;
            this.filters = [];
            var o;
            for (e = 0; e < a; e += 1) {
                o = null;
                var c = s.data.ef[e].ty;
                if (registeredEffects[c]) {
                    var d = registeredEffects[c].effect;
                    o = new d(s.effectsManager.effectElements[e],s)
                }
                o && this.filters.push(o)
            }
            this.filters.length && s.addRenderableComponent(this)
        }
        CVEffects.prototype.renderFrame = function(s) {
            var e, a = this.filters.length;
            for (e = 0; e < a; e += 1)
                this.filters[e].renderFrame(s)
        }
        ,
        CVEffects.prototype.getEffects = function(s) {
            var e, a = this.filters.length, o = [];
            for (e = 0; e < a; e += 1)
                this.filters[e].type === s && o.push(this.filters[e]);
            return o
        }
        ;
        function registerEffect(s, e) {
            registeredEffects[s] = {
                effect: e
            }
        }
        function CVMaskElement(s, e) {
            this.data = s,
            this.element = e,
            this.masksProperties = this.data.masksProperties || [],
            this.viewData = createSizedArray(this.masksProperties.length);
            var a, o = this.masksProperties.length, c = !1;
            for (a = 0; a < o; a += 1)
                this.masksProperties[a].mode !== "n" && (c = !0),
                this.viewData[a] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[a], 3);
            this.hasMasks = c,
            c && this.element.addRenderableComponent(this)
        }
        CVMaskElement.prototype.renderFrame = function() {
            if (this.hasMasks) {
                var s = this.element.finalTransform.mat, e = this.element.canvasContext, a, o = this.masksProperties.length, c, d, g;
                for (e.beginPath(),
                a = 0; a < o; a += 1)
                    if (this.masksProperties[a].mode !== "n") {
                        this.masksProperties[a].inv && (e.moveTo(0, 0),
                        e.lineTo(this.element.globalData.compSize.w, 0),
                        e.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h),
                        e.lineTo(0, this.element.globalData.compSize.h),
                        e.lineTo(0, 0)),
                        g = this.viewData[a].v,
                        c = s.applyToPointArray(g.v[0][0], g.v[0][1], 0),
                        e.moveTo(c[0], c[1]);
                        var _, b = g._length;
                        for (_ = 1; _ < b; _ += 1)
                            d = s.applyToTriplePoints(g.o[_ - 1], g.i[_], g.v[_]),
                            e.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5]);
                        d = s.applyToTriplePoints(g.o[_ - 1], g.i[0], g.v[0]),
                        e.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5])
                    }
                this.element.globalData.renderer.save(!0),
                e.clip()
            }
        }
        ,
        CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty,
        CVMaskElement.prototype.destroy = function() {
            this.element = null
        }
        ;
        function CVBaseElement() {}
        var operationsMap = {
            1: "source-in",
            2: "source-out",
            3: "source-in",
            4: "source-out"
        };
        CVBaseElement.prototype = {
            createElements: function() {},
            initRendererElement: function() {},
            createContainerElements: function() {
                if (this.data.tt >= 1) {
                    this.buffers = [];
                    var e = this.globalData.canvasContext
                      , a = assetLoader.createCanvas(e.canvas.width, e.canvas.height);
                    this.buffers.push(a);
                    var o = assetLoader.createCanvas(e.canvas.width, e.canvas.height);
                    this.buffers.push(o),
                    this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
                }
                this.canvasContext = this.globalData.canvasContext,
                this.transformCanvas = this.globalData.transformCanvas,
                this.renderableEffectsManager = new CVEffects(this),
                this.searchEffectTransforms()
            },
            createContent: function() {},
            setBlendMode: function() {
                var e = this.globalData;
                if (e.blendMode !== this.data.bm) {
                    e.blendMode = this.data.bm;
                    var a = getBlendMode(this.data.bm);
                    e.canvasContext.globalCompositeOperation = a
                }
            },
            createRenderableComponents: function() {
                this.maskManager = new CVMaskElement(this.data,this),
                this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
            },
            hideElement: function() {
                !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0)
            },
            showElement: function() {
                this.isInRange && !this.isTransparent && (this.hidden = !1,
                this._isFirstFrame = !0,
                this.maskManager._isFirstFrame = !0)
            },
            clearCanvas: function(e) {
                e.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
            },
            prepareLayer: function() {
                if (this.data.tt >= 1) {
                    var e = this.buffers[0]
                      , a = e.getContext("2d");
                    this.clearCanvas(a),
                    a.drawImage(this.canvasContext.canvas, 0, 0),
                    this.currentTransform = this.canvasContext.getTransform(),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform)
                }
            },
            exitLayer: function() {
                if (this.data.tt >= 1) {
                    var e = this.buffers[1]
                      , a = e.getContext("2d");
                    this.clearCanvas(a),
                    a.drawImage(this.canvasContext.canvas, 0, 0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform);
                    var o = this.comp.getElementById("tp"in this.data ? this.data.tp : this.data.ind - 1);
                    if (o.renderFrame(!0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.data.tt >= 3 && !document._isProxy) {
                        var c = assetLoader.getLumaCanvas(this.canvasContext.canvas)
                          , d = c.getContext("2d");
                        d.drawImage(this.canvasContext.canvas, 0, 0),
                        this.clearCanvas(this.canvasContext),
                        this.canvasContext.drawImage(c, 0, 0)
                    }
                    this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt],
                    this.canvasContext.drawImage(e, 0, 0),
                    this.canvasContext.globalCompositeOperation = "destination-over",
                    this.canvasContext.drawImage(this.buffers[0], 0, 0),
                    this.canvasContext.setTransform(this.currentTransform),
                    this.canvasContext.globalCompositeOperation = "source-over"
                }
            },
            renderFrame: function(e) {
                if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !e)) {
                    this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.setBlendMode();
                    var a = this.data.ty === 0;
                    this.prepareLayer(),
                    this.globalData.renderer.save(a),
                    this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props),
                    this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity),
                    this.renderInnerContent(),
                    this.globalData.renderer.restore(a),
                    this.exitLayer(),
                    this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
                    this._isFirstFrame && (this._isFirstFrame = !1)
                }
            },
            destroy: function() {
                this.canvasContext = null,
                this.data = null,
                this.globalData = null,
                this.maskManager.destroy()
            },
            mHelper: new Matrix
        },
        CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement,
        CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
        function CVShapeData(s, e, a, o) {
            this.styledShapes = [],
            this.tr = [0, 0, 0, 0, 0, 0];
            var c = 4;
            e.ty === "rc" ? c = 5 : e.ty === "el" ? c = 6 : e.ty === "sr" && (c = 7),
            this.sh = ShapePropertyFactory.getShapeProp(s, e, c, s);
            var d, g = a.length, _;
            for (d = 0; d < g; d += 1)
                a[d].closed || (_ = {
                    transforms: o.addTransformSequence(a[d].transforms),
                    trNodes: []
                },
                this.styledShapes.push(_),
                a[d].elements.push(_))
        }
        CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
        function CVShapeElement(s, e, a) {
            this.shapes = [],
            this.shapesData = s.shapes,
            this.stylesList = [],
            this.itemsData = [],
            this.prevViewData = [],
            this.shapeModifiers = [],
            this.processedElements = [],
            this.transformsManager = new ShapeTransformManager,
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement),
        CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement,
        CVShapeElement.prototype.transformHelper = {
            opacity: 1,
            _opMdf: !1
        },
        CVShapeElement.prototype.dashResetter = [],
        CVShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
        }
        ,
        CVShapeElement.prototype.createStyleElement = function(s, e) {
            var a = {
                data: s,
                type: s.ty,
                preTransforms: this.transformsManager.addTransformSequence(e),
                transforms: [],
                elements: [],
                closed: s.hd === !0
            }
              , o = {};
            if (s.ty === "fl" || s.ty === "st" ? (o.c = PropertyFactory.getProp(this, s.c, 1, 255, this),
            o.c.k || (a.co = "rgb(" + bmFloor(o.c.v[0]) + "," + bmFloor(o.c.v[1]) + "," + bmFloor(o.c.v[2]) + ")")) : (s.ty === "gf" || s.ty === "gs") && (o.s = PropertyFactory.getProp(this, s.s, 1, null, this),
            o.e = PropertyFactory.getProp(this, s.e, 1, null, this),
            o.h = PropertyFactory.getProp(this, s.h || {
                k: 0
            }, 0, .01, this),
            o.a = PropertyFactory.getProp(this, s.a || {
                k: 0
            }, 0, degToRads, this),
            o.g = new GradientProperty(this,s.g,this)),
            o.o = PropertyFactory.getProp(this, s.o, 0, .01, this),
            s.ty === "st" || s.ty === "gs") {
                if (a.lc = lineCapEnum[s.lc || 2],
                a.lj = lineJoinEnum[s.lj || 2],
                s.lj == 1 && (a.ml = s.ml),
                o.w = PropertyFactory.getProp(this, s.w, 0, null, this),
                o.w.k || (a.wi = o.w.v),
                s.d) {
                    var c = new DashProperty(this,s.d,"canvas",this);
                    o.d = c,
                    o.d.k || (a.da = o.d.dashArray,
                    a.do = o.d.dashoffset[0])
                }
            } else
                a.r = s.r === 2 ? "evenodd" : "nonzero";
            return this.stylesList.push(a),
            o.style = a,
            o
        }
        ,
        CVShapeElement.prototype.createGroupElement = function() {
            var s = {
                it: [],
                prevViewData: []
            };
            return s
        }
        ,
        CVShapeElement.prototype.createTransformElement = function(s) {
            var e = {
                transform: {
                    opacity: 1,
                    _opMdf: !1,
                    key: this.transformsManager.getNewKey(),
                    op: PropertyFactory.getProp(this, s.o, 0, .01, this),
                    mProps: TransformPropertyFactory.getTransformProperty(this, s, this)
                }
            };
            return e
        }
        ,
        CVShapeElement.prototype.createShapeElement = function(s) {
            var e = new CVShapeData(this,s,this.stylesList,this.transformsManager);
            return this.shapes.push(e),
            this.addShapeToModifiers(e),
            e
        }
        ,
        CVShapeElement.prototype.reloadShapes = function() {
            this._isFirstFrame = !0;
            var s, e = this.itemsData.length;
            for (s = 0; s < e; s += 1)
                this.prevViewData[s] = this.itemsData[s];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []),
            e = this.dynamicProperties.length,
            s = 0; s < e; s += 1)
                this.dynamicProperties[s].getValue();
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame)
        }
        ,
        CVShapeElement.prototype.addTransformToStyleList = function(s) {
            var e, a = this.stylesList.length;
            for (e = 0; e < a; e += 1)
                this.stylesList[e].closed || this.stylesList[e].transforms.push(s)
        }
        ,
        CVShapeElement.prototype.removeTransformFromStyleList = function() {
            var s, e = this.stylesList.length;
            for (s = 0; s < e; s += 1)
                this.stylesList[s].closed || this.stylesList[s].transforms.pop()
        }
        ,
        CVShapeElement.prototype.closeStyles = function(s) {
            var e, a = s.length;
            for (e = 0; e < a; e += 1)
                s[e].closed = !0
        }
        ,
        CVShapeElement.prototype.searchShapes = function(s, e, a, o, c) {
            var d, g = s.length - 1, _, b, j = [], $ = [], nt, tt, rt, st = [].concat(c);
            for (d = g; d >= 0; d -= 1) {
                if (nt = this.searchProcessedElement(s[d]),
                nt ? e[d] = a[nt - 1] : s[d]._shouldRender = o,
                s[d].ty === "fl" || s[d].ty === "st" || s[d].ty === "gf" || s[d].ty === "gs")
                    nt ? e[d].style.closed = !1 : e[d] = this.createStyleElement(s[d], st),
                    j.push(e[d].style);
                else if (s[d].ty === "gr") {
                    if (!nt)
                        e[d] = this.createGroupElement(s[d]);
                    else
                        for (b = e[d].it.length,
                        _ = 0; _ < b; _ += 1)
                            e[d].prevViewData[_] = e[d].it[_];
                    this.searchShapes(s[d].it, e[d].it, e[d].prevViewData, o, st)
                } else
                    s[d].ty === "tr" ? (nt || (rt = this.createTransformElement(s[d]),
                    e[d] = rt),
                    st.push(e[d]),
                    this.addTransformToStyleList(e[d])) : s[d].ty === "sh" || s[d].ty === "rc" || s[d].ty === "el" || s[d].ty === "sr" ? nt || (e[d] = this.createShapeElement(s[d])) : s[d].ty === "tm" || s[d].ty === "rd" || s[d].ty === "pb" || s[d].ty === "zz" || s[d].ty === "op" ? (nt ? (tt = e[d],
                    tt.closed = !1) : (tt = ShapeModifiers.getModifier(s[d].ty),
                    tt.init(this, s[d]),
                    e[d] = tt,
                    this.shapeModifiers.push(tt)),
                    $.push(tt)) : s[d].ty === "rp" && (nt ? (tt = e[d],
                    tt.closed = !0) : (tt = ShapeModifiers.getModifier(s[d].ty),
                    e[d] = tt,
                    tt.init(this, s, d, e),
                    this.shapeModifiers.push(tt),
                    o = !1),
                    $.push(tt));
                this.addProcessedElement(s[d], d + 1)
            }
            for (this.removeTransformFromStyleList(),
            this.closeStyles(j),
            g = $.length,
            d = 0; d < g; d += 1)
                $[d].closed = !0
        }
        ,
        CVShapeElement.prototype.renderInnerContent = function() {
            this.transformHelper.opacity = 1,
            this.transformHelper._opMdf = !1,
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
        }
        ,
        CVShapeElement.prototype.renderShapeTransform = function(s, e) {
            (s._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = s.opacity,
            e.opacity *= e.op.v,
            e._opMdf = !0)
        }
        ,
        CVShapeElement.prototype.drawLayer = function() {
            var s, e = this.stylesList.length, a, o, c, d, g, _, b = this.globalData.renderer, j = this.globalData.canvasContext, $, nt;
            for (s = 0; s < e; s += 1)
                if (nt = this.stylesList[s],
                $ = nt.type,
                !(($ === "st" || $ === "gs") && nt.wi === 0 || !nt.data._shouldRender || nt.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                    for (b.save(),
                    g = nt.elements,
                    $ === "st" || $ === "gs" ? (b.ctxStrokeStyle($ === "st" ? nt.co : nt.grd),
                    b.ctxLineWidth(nt.wi),
                    b.ctxLineCap(nt.lc),
                    b.ctxLineJoin(nt.lj),
                    b.ctxMiterLimit(nt.ml || 0)) : b.ctxFillStyle($ === "fl" ? nt.co : nt.grd),
                    b.ctxOpacity(nt.coOp),
                    $ !== "st" && $ !== "gs" && j.beginPath(),
                    b.ctxTransform(nt.preTransforms.finalTransform.props),
                    o = g.length,
                    a = 0; a < o; a += 1) {
                        for (($ === "st" || $ === "gs") && (j.beginPath(),
                        nt.da && (j.setLineDash(nt.da),
                        j.lineDashOffset = nt.do)),
                        _ = g[a].trNodes,
                        d = _.length,
                        c = 0; c < d; c += 1)
                            _[c].t === "m" ? j.moveTo(_[c].p[0], _[c].p[1]) : _[c].t === "c" ? j.bezierCurveTo(_[c].pts[0], _[c].pts[1], _[c].pts[2], _[c].pts[3], _[c].pts[4], _[c].pts[5]) : j.closePath();
                        ($ === "st" || $ === "gs") && (b.ctxStroke(),
                        nt.da && j.setLineDash(this.dashResetter))
                    }
                    $ !== "st" && $ !== "gs" && this.globalData.renderer.ctxFill(nt.r),
                    b.restore()
                }
        }
        ,
        CVShapeElement.prototype.renderShape = function(s, e, a, o) {
            var c, d = e.length - 1, g;
            for (g = s,
            c = d; c >= 0; c -= 1)
                e[c].ty === "tr" ? (g = a[c].transform,
                this.renderShapeTransform(s, g)) : e[c].ty === "sh" || e[c].ty === "el" || e[c].ty === "rc" || e[c].ty === "sr" ? this.renderPath(e[c], a[c]) : e[c].ty === "fl" ? this.renderFill(e[c], a[c], g) : e[c].ty === "st" ? this.renderStroke(e[c], a[c], g) : e[c].ty === "gf" || e[c].ty === "gs" ? this.renderGradientFill(e[c], a[c], g) : e[c].ty === "gr" ? this.renderShape(g, e[c].it, a[c].it) : e[c].ty;
            o && this.drawLayer()
        }
        ,
        CVShapeElement.prototype.renderStyledShape = function(s, e) {
            if (this._isFirstFrame || e._mdf || s.transforms._mdf) {
                var a = s.trNodes, o = e.paths, c, d, g, _ = o._length;
                a.length = 0;
                var b = s.transforms.finalTransform;
                for (g = 0; g < _; g += 1) {
                    var j = o.shapes[g];
                    if (j && j.v) {
                        for (d = j._length,
                        c = 1; c < d; c += 1)
                            c === 1 && a.push({
                                t: "m",
                                p: b.applyToPointArray(j.v[0][0], j.v[0][1], 0)
                            }),
                            a.push({
                                t: "c",
                                pts: b.applyToTriplePoints(j.o[c - 1], j.i[c], j.v[c])
                            });
                        d === 1 && a.push({
                            t: "m",
                            p: b.applyToPointArray(j.v[0][0], j.v[0][1], 0)
                        }),
                        j.c && d && (a.push({
                            t: "c",
                            pts: b.applyToTriplePoints(j.o[c - 1], j.i[0], j.v[0])
                        }),
                        a.push({
                            t: "z"
                        }))
                    }
                }
                s.trNodes = a
            }
        }
        ,
        CVShapeElement.prototype.renderPath = function(s, e) {
            if (s.hd !== !0 && s._shouldRender) {
                var a, o = e.styledShapes.length;
                for (a = 0; a < o; a += 1)
                    this.renderStyledShape(e.styledShapes[a], e.sh)
            }
        }
        ,
        CVShapeElement.prototype.renderFill = function(s, e, a) {
            var o = e.style;
            (e.c._mdf || this._isFirstFrame) && (o.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"),
            (e.o._mdf || a._opMdf || this._isFirstFrame) && (o.coOp = e.o.v * a.opacity)
        }
        ,
        CVShapeElement.prototype.renderGradientFill = function(s, e, a) {
            var o = e.style, c;
            if (!o.grd || e.g._mdf || e.s._mdf || e.e._mdf || s.t !== 1 && (e.h._mdf || e.a._mdf)) {
                var d = this.globalData.canvasContext
                  , g = e.s.v
                  , _ = e.e.v;
                if (s.t === 1)
                    c = d.createLinearGradient(g[0], g[1], _[0], _[1]);
                else {
                    var b = Math.sqrt(Math.pow(g[0] - _[0], 2) + Math.pow(g[1] - _[1], 2))
                      , j = Math.atan2(_[1] - g[1], _[0] - g[0])
                      , $ = e.h.v;
                    $ >= 1 ? $ = .99 : $ <= -1 && ($ = -.99);
                    var nt = b * $
                      , tt = Math.cos(j + e.a.v) * nt + g[0]
                      , rt = Math.sin(j + e.a.v) * nt + g[1];
                    c = d.createRadialGradient(tt, rt, 0, g[0], g[1], b)
                }
                var st, lt = s.g.p, ct = e.g.c, it = 1;
                for (st = 0; st < lt; st += 1)
                    e.g._hasOpacity && e.g._collapsable && (it = e.g.o[st * 2 + 1]),
                    c.addColorStop(ct[st * 4] / 100, "rgba(" + ct[st * 4 + 1] + "," + ct[st * 4 + 2] + "," + ct[st * 4 + 3] + "," + it + ")");
                o.grd = c
            }
            o.coOp = e.o.v * a.opacity
        }
        ,
        CVShapeElement.prototype.renderStroke = function(s, e, a) {
            var o = e.style
              , c = e.d;
            c && (c._mdf || this._isFirstFrame) && (o.da = c.dashArray,
            o.do = c.dashoffset[0]),
            (e.c._mdf || this._isFirstFrame) && (o.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"),
            (e.o._mdf || a._opMdf || this._isFirstFrame) && (o.coOp = e.o.v * a.opacity),
            (e.w._mdf || this._isFirstFrame) && (o.wi = e.w.v)
        }
        ,
        CVShapeElement.prototype.destroy = function() {
            this.shapesData = null,
            this.globalData = null,
            this.canvasContext = null,
            this.stylesList.length = 0,
            this.itemsData.length = 0
        }
        ;
        function CVTextElement(s, e, a) {
            this.textSpans = [],
            this.yOffset = 0,
            this.fillColorAnim = !1,
            this.strokeColorAnim = !1,
            this.strokeWidthAnim = !1,
            this.stroke = !1,
            this.fill = !1,
            this.justifyOffset = 0,
            this.currentRender = null,
            this.renderType = "canvas",
            this.values = {
                fill: "rgba(0,0,0,0)",
                stroke: "rgba(0,0,0,0)",
                sWidth: 0,
                fValue: ""
            },
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement),
        CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"),
        CVTextElement.prototype.buildNewText = function() {
            var s = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(s.l ? s.l.length : 0);
            var e = !1;
            s.fc ? (e = !0,
            this.values.fill = this.buildColor(s.fc)) : this.values.fill = "rgba(0,0,0,0)",
            this.fill = e;
            var a = !1;
            s.sc && (a = !0,
            this.values.stroke = this.buildColor(s.sc),
            this.values.sWidth = s.sw);
            var o = this.globalData.fontManager.getFontByName(s.f), c, d, g = s.l, _ = this.mHelper;
            this.stroke = a,
            this.values.fValue = s.finalSize + "px " + this.globalData.fontManager.getFontByName(s.f).fFamily,
            d = s.finalText.length;
            var b, j, $, nt, tt, rt, st, lt, ct, it, ot = this.data.singleShape, at = s.tr * .001 * s.finalSize, ht = 0, pt = 0, dt = !0, yt = 0;
            for (c = 0; c < d; c += 1) {
                b = this.globalData.fontManager.getCharData(s.finalText[c], o.fStyle, this.globalData.fontManager.getFontByName(s.f).fFamily),
                j = b && b.data || {},
                _.reset(),
                ot && g[c].n && (ht = -at,
                pt += s.yOffset,
                pt += dt ? 1 : 0,
                dt = !1),
                tt = j.shapes ? j.shapes[0].it : [],
                st = tt.length,
                _.scale(s.finalSize / 100, s.finalSize / 100),
                ot && this.applyTextPropertiesToMatrix(s, _, g[c].line, ht, pt),
                ct = createSizedArray(st - 1);
                var vt = 0;
                for (rt = 0; rt < st; rt += 1)
                    if (tt[rt].ty === "sh") {
                        for (nt = tt[rt].ks.k.i.length,
                        lt = tt[rt].ks.k,
                        it = [],
                        $ = 1; $ < nt; $ += 1)
                            $ === 1 && it.push(_.applyToX(lt.v[0][0], lt.v[0][1], 0), _.applyToY(lt.v[0][0], lt.v[0][1], 0)),
                            it.push(_.applyToX(lt.o[$ - 1][0], lt.o[$ - 1][1], 0), _.applyToY(lt.o[$ - 1][0], lt.o[$ - 1][1], 0), _.applyToX(lt.i[$][0], lt.i[$][1], 0), _.applyToY(lt.i[$][0], lt.i[$][1], 0), _.applyToX(lt.v[$][0], lt.v[$][1], 0), _.applyToY(lt.v[$][0], lt.v[$][1], 0));
                        it.push(_.applyToX(lt.o[$ - 1][0], lt.o[$ - 1][1], 0), _.applyToY(lt.o[$ - 1][0], lt.o[$ - 1][1], 0), _.applyToX(lt.i[0][0], lt.i[0][1], 0), _.applyToY(lt.i[0][0], lt.i[0][1], 0), _.applyToX(lt.v[0][0], lt.v[0][1], 0), _.applyToY(lt.v[0][0], lt.v[0][1], 0)),
                        ct[vt] = it,
                        vt += 1
                    }
                ot && (ht += g[c].l,
                ht += at),
                this.textSpans[yt] ? this.textSpans[yt].elem = ct : this.textSpans[yt] = {
                    elem: ct
                },
                yt += 1
            }
        }
        ,
        CVTextElement.prototype.renderInnerContent = function() {
            this.validateText();
            var s = this.canvasContext;
            s.font = this.values.fValue,
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            var e, a, o, c, d, g, _ = this.textAnimator.renderedLetters, b = this.textProperty.currentData.l;
            a = b.length;
            var j, $ = null, nt = null, tt = null, rt, st, lt = this.globalData.renderer;
            for (e = 0; e < a; e += 1)
                if (!b[e].n) {
                    if (j = _[e],
                    j && (lt.save(),
                    lt.ctxTransform(j.p),
                    lt.ctxOpacity(j.o)),
                    this.fill) {
                        for (j && j.fc ? $ !== j.fc && (lt.ctxFillStyle(j.fc),
                        $ = j.fc) : $ !== this.values.fill && ($ = this.values.fill,
                        lt.ctxFillStyle(this.values.fill)),
                        rt = this.textSpans[e].elem,
                        c = rt.length,
                        this.globalData.canvasContext.beginPath(),
                        o = 0; o < c; o += 1)
                            for (st = rt[o],
                            g = st.length,
                            this.globalData.canvasContext.moveTo(st[0], st[1]),
                            d = 2; d < g; d += 6)
                                this.globalData.canvasContext.bezierCurveTo(st[d], st[d + 1], st[d + 2], st[d + 3], st[d + 4], st[d + 5]);
                        this.globalData.canvasContext.closePath(),
                        lt.ctxFill()
                    }
                    if (this.stroke) {
                        for (j && j.sw ? tt !== j.sw && (tt = j.sw,
                        lt.ctxLineWidth(j.sw)) : tt !== this.values.sWidth && (tt = this.values.sWidth,
                        lt.ctxLineWidth(this.values.sWidth)),
                        j && j.sc ? nt !== j.sc && (nt = j.sc,
                        lt.ctxStrokeStyle(j.sc)) : nt !== this.values.stroke && (nt = this.values.stroke,
                        lt.ctxStrokeStyle(this.values.stroke)),
                        rt = this.textSpans[e].elem,
                        c = rt.length,
                        this.globalData.canvasContext.beginPath(),
                        o = 0; o < c; o += 1)
                            for (st = rt[o],
                            g = st.length,
                            this.globalData.canvasContext.moveTo(st[0], st[1]),
                            d = 2; d < g; d += 6)
                                this.globalData.canvasContext.bezierCurveTo(st[d], st[d + 1], st[d + 2], st[d + 3], st[d + 4], st[d + 5]);
                        this.globalData.canvasContext.closePath(),
                        lt.ctxStroke()
                    }
                    j && this.globalData.renderer.restore()
                }
        }
        ;
        function CVImageElement(s, e, a) {
            this.assetData = e.getAssetData(s.refId),
            this.img = e.imageLoader.getAsset(this.assetData),
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement),
        CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVImageElement.prototype.createContent = function() {
            if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                var s = createTag("canvas");
                s.width = this.assetData.w,
                s.height = this.assetData.h;
                var e = s.getContext("2d"), a = this.img.width, o = this.img.height, c = a / o, d = this.assetData.w / this.assetData.h, g, _, b = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                c > d && b === "xMidYMid slice" || c < d && b !== "xMidYMid slice" ? (_ = o,
                g = _ * d) : (g = a,
                _ = g / d),
                e.drawImage(this.img, (a - g) / 2, (o - _) / 2, g, _, 0, 0, this.assetData.w, this.assetData.h),
                this.img = s
            }
        }
        ,
        CVImageElement.prototype.renderInnerContent = function() {
            this.canvasContext.drawImage(this.img, 0, 0)
        }
        ,
        CVImageElement.prototype.destroy = function() {
            this.img = null
        }
        ;
        function CVSolidElement(s, e, a) {
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement),
        CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVSolidElement.prototype.renderInnerContent = function() {
            this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
        }
        ;
        function CanvasRendererBase() {}
        extendPrototype([BaseRenderer], CanvasRendererBase),
        CanvasRendererBase.prototype.createShape = function(s) {
            return new CVShapeElement(s,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createText = function(s) {
            return new CVTextElement(s,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createImage = function(s) {
            return new CVImageElement(s,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createSolid = function(s) {
            return new CVSolidElement(s,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        CanvasRendererBase.prototype.ctxTransform = function(s) {
            s[0] === 1 && s[1] === 0 && s[4] === 0 && s[5] === 1 && s[12] === 0 && s[13] === 0 || this.canvasContext.transform(s[0], s[1], s[4], s[5], s[12], s[13])
        }
        ,
        CanvasRendererBase.prototype.ctxOpacity = function(s) {
            this.canvasContext.globalAlpha *= s < 0 ? 0 : s
        }
        ,
        CanvasRendererBase.prototype.ctxFillStyle = function(s) {
            this.canvasContext.fillStyle = s
        }
        ,
        CanvasRendererBase.prototype.ctxStrokeStyle = function(s) {
            this.canvasContext.strokeStyle = s
        }
        ,
        CanvasRendererBase.prototype.ctxLineWidth = function(s) {
            this.canvasContext.lineWidth = s
        }
        ,
        CanvasRendererBase.prototype.ctxLineCap = function(s) {
            this.canvasContext.lineCap = s
        }
        ,
        CanvasRendererBase.prototype.ctxLineJoin = function(s) {
            this.canvasContext.lineJoin = s
        }
        ,
        CanvasRendererBase.prototype.ctxMiterLimit = function(s) {
            this.canvasContext.miterLimit = s
        }
        ,
        CanvasRendererBase.prototype.ctxFill = function(s) {
            this.canvasContext.fill(s)
        }
        ,
        CanvasRendererBase.prototype.ctxFillRect = function(s, e, a, o) {
            this.canvasContext.fillRect(s, e, a, o)
        }
        ,
        CanvasRendererBase.prototype.ctxStroke = function() {
            this.canvasContext.stroke()
        }
        ,
        CanvasRendererBase.prototype.reset = function() {
            if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return
            }
            this.contextData.reset()
        }
        ,
        CanvasRendererBase.prototype.save = function() {
            this.canvasContext.save()
        }
        ,
        CanvasRendererBase.prototype.restore = function(s) {
            if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return
            }
            s && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(s)
        }
        ,
        CanvasRendererBase.prototype.configAnimation = function(s) {
            if (this.animationItem.wrapper) {
                this.animationItem.container = createTag("canvas");
                var e = this.animationItem.container.style;
                e.width = "100%",
                e.height = "100%";
                var a = "0px 0px 0px";
                e.transformOrigin = a,
                e.mozTransformOrigin = a,
                e.webkitTransformOrigin = a,
                e["-webkit-transform"] = a,
                e.contentVisibility = this.renderConfig.contentVisibility,
                this.animationItem.wrapper.appendChild(this.animationItem.container),
                this.canvasContext = this.animationItem.container.getContext("2d"),
                this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className),
                this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
            } else
                this.canvasContext = this.renderConfig.context;
            this.contextData.setContext(this.canvasContext),
            this.data = s,
            this.layers = s.layers,
            this.transformCanvas = {
                w: s.w,
                h: s.h,
                sx: 0,
                sy: 0,
                tx: 0,
                ty: 0
            },
            this.setupGlobalData(s, document.body),
            this.globalData.canvasContext = this.canvasContext,
            this.globalData.renderer = this,
            this.globalData.isDashed = !1,
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.globalData.transformCanvas = this.transformCanvas,
            this.elements = createSizedArray(s.layers.length),
            this.updateContainerSize()
        }
        ,
        CanvasRendererBase.prototype.updateContainerSize = function(s, e) {
            this.reset();
            var a, o;
            s ? (a = s,
            o = e,
            this.canvasContext.canvas.width = a,
            this.canvasContext.canvas.height = o) : (this.animationItem.wrapper && this.animationItem.container ? (a = this.animationItem.wrapper.offsetWidth,
            o = this.animationItem.wrapper.offsetHeight) : (a = this.canvasContext.canvas.width,
            o = this.canvasContext.canvas.height),
            this.canvasContext.canvas.width = a * this.renderConfig.dpr,
            this.canvasContext.canvas.height = o * this.renderConfig.dpr);
            var c, d;
            if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
                var g = this.renderConfig.preserveAspectRatio.split(" ")
                  , _ = g[1] || "meet"
                  , b = g[0] || "xMidYMid"
                  , j = b.substr(0, 4)
                  , $ = b.substr(4);
                c = a / o,
                d = this.transformCanvas.w / this.transformCanvas.h,
                d > c && _ === "meet" || d < c && _ === "slice" ? (this.transformCanvas.sx = a / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = a / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = o / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.sy = o / (this.transformCanvas.h / this.renderConfig.dpr)),
                j === "xMid" && (d < c && _ === "meet" || d > c && _ === "slice") ? this.transformCanvas.tx = (a - this.transformCanvas.w * (o / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : j === "xMax" && (d < c && _ === "meet" || d > c && _ === "slice") ? this.transformCanvas.tx = (a - this.transformCanvas.w * (o / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0,
                $ === "YMid" && (d > c && _ === "meet" || d < c && _ === "slice") ? this.transformCanvas.ty = (o - this.transformCanvas.h * (a / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : $ === "YMax" && (d > c && _ === "meet" || d < c && _ === "slice") ? this.transformCanvas.ty = (o - this.transformCanvas.h * (a / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0
            } else
                this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = a / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = o / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr,
                this.transformCanvas.sy = this.renderConfig.dpr,
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0);
            this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1],
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0)
        }
        ,
        CanvasRendererBase.prototype.destroy = function() {
            this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
            var s, e = this.layers ? this.layers.length : 0;
            for (s = e - 1; s >= 0; s -= 1)
                this.elements[s] && this.elements[s].destroy && this.elements[s].destroy();
            this.elements.length = 0,
            this.globalData.canvasContext = null,
            this.animationItem.container = null,
            this.destroyed = !0
        }
        ,
        CanvasRendererBase.prototype.renderFrame = function(s, e) {
            if (!(this.renderedFrame === s && this.renderConfig.clearCanvas === !0 && !e || this.destroyed || s === -1)) {
                this.renderedFrame = s,
                this.globalData.frameNum = s - this.animationItem._isFirstFrame,
                this.globalData.frameId += 1,
                this.globalData._mdf = !this.renderConfig.clearCanvas || e,
                this.globalData.projectInterface.currentFrame = s;
                var a, o = this.layers.length;
                for (this.completeLayers || this.checkLayers(s),
                a = o - 1; a >= 0; a -= 1)
                    (this.completeLayers || this.elements[a]) && this.elements[a].prepareFrame(s - this.layers[a].st);
                if (this.globalData._mdf) {
                    for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(),
                    a = o - 1; a >= 0; a -= 1)
                        (this.completeLayers || this.elements[a]) && this.elements[a].renderFrame();
                    this.renderConfig.clearCanvas !== !0 && this.restore()
                }
            }
        }
        ,
        CanvasRendererBase.prototype.buildItem = function(s) {
            var e = this.elements;
            if (!(e[s] || this.layers[s].ty === 99)) {
                var a = this.createItem(this.layers[s], this, this.globalData);
                e[s] = a,
                a.initExpressions()
            }
        }
        ,
        CanvasRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var s = this.pendingElements.pop();
                s.checkParenting()
            }
        }
        ,
        CanvasRendererBase.prototype.hide = function() {
            this.animationItem.container.style.display = "none"
        }
        ,
        CanvasRendererBase.prototype.show = function() {
            this.animationItem.container.style.display = "block"
        }
        ;
        function CanvasContext() {
            this.opacity = -1,
            this.transform = createTypedArray("float32", 16),
            this.fillStyle = "",
            this.strokeStyle = "",
            this.lineWidth = "",
            this.lineCap = "",
            this.lineJoin = "",
            this.miterLimit = "",
            this.id = Math.random()
        }
        function CVContextData() {
            this.stack = [],
            this.cArrPos = 0,
            this.cTr = new Matrix;
            var s, e = 15;
            for (s = 0; s < e; s += 1) {
                var a = new CanvasContext;
                this.stack[s] = a
            }
            this._length = e,
            this.nativeContext = null,
            this.transformMat = new Matrix,
            this.currentOpacity = 1,
            this.currentFillStyle = "",
            this.appliedFillStyle = "",
            this.currentStrokeStyle = "",
            this.appliedStrokeStyle = "",
            this.currentLineWidth = "",
            this.appliedLineWidth = "",
            this.currentLineCap = "",
            this.appliedLineCap = "",
            this.currentLineJoin = "",
            this.appliedLineJoin = "",
            this.appliedMiterLimit = "",
            this.currentMiterLimit = ""
        }
        CVContextData.prototype.duplicate = function() {
            var s = this._length * 2
              , e = 0;
            for (e = this._length; e < s; e += 1)
                this.stack[e] = new CanvasContext;
            this._length = s
        }
        ,
        CVContextData.prototype.reset = function() {
            this.cArrPos = 0,
            this.cTr.reset(),
            this.stack[this.cArrPos].opacity = 1
        }
        ,
        CVContextData.prototype.restore = function(s) {
            this.cArrPos -= 1;
            var e = this.stack[this.cArrPos], a = e.transform, o, c = this.cTr.props;
            for (o = 0; o < 16; o += 1)
                c[o] = a[o];
            if (s) {
                this.nativeContext.restore();
                var d = this.stack[this.cArrPos + 1];
                this.appliedFillStyle = d.fillStyle,
                this.appliedStrokeStyle = d.strokeStyle,
                this.appliedLineWidth = d.lineWidth,
                this.appliedLineCap = d.lineCap,
                this.appliedLineJoin = d.lineJoin,
                this.appliedMiterLimit = d.miterLimit
            }
            this.nativeContext.setTransform(a[0], a[1], a[4], a[5], a[12], a[13]),
            (s || e.opacity !== -1 && this.currentOpacity !== e.opacity) && (this.nativeContext.globalAlpha = e.opacity,
            this.currentOpacity = e.opacity),
            this.currentFillStyle = e.fillStyle,
            this.currentStrokeStyle = e.strokeStyle,
            this.currentLineWidth = e.lineWidth,
            this.currentLineCap = e.lineCap,
            this.currentLineJoin = e.lineJoin,
            this.currentMiterLimit = e.miterLimit
        }
        ,
        CVContextData.prototype.save = function(s) {
            s && this.nativeContext.save();
            var e = this.cTr.props;
            this._length <= this.cArrPos && this.duplicate();
            var a = this.stack[this.cArrPos], o;
            for (o = 0; o < 16; o += 1)
                a.transform[o] = e[o];
            this.cArrPos += 1;
            var c = this.stack[this.cArrPos];
            c.opacity = a.opacity,
            c.fillStyle = a.fillStyle,
            c.strokeStyle = a.strokeStyle,
            c.lineWidth = a.lineWidth,
            c.lineCap = a.lineCap,
            c.lineJoin = a.lineJoin,
            c.miterLimit = a.miterLimit
        }
        ,
        CVContextData.prototype.setOpacity = function(s) {
            this.stack[this.cArrPos].opacity = s
        }
        ,
        CVContextData.prototype.setContext = function(s) {
            this.nativeContext = s
        }
        ,
        CVContextData.prototype.fillStyle = function(s) {
            this.stack[this.cArrPos].fillStyle !== s && (this.currentFillStyle = s,
            this.stack[this.cArrPos].fillStyle = s)
        }
        ,
        CVContextData.prototype.strokeStyle = function(s) {
            this.stack[this.cArrPos].strokeStyle !== s && (this.currentStrokeStyle = s,
            this.stack[this.cArrPos].strokeStyle = s)
        }
        ,
        CVContextData.prototype.lineWidth = function(s) {
            this.stack[this.cArrPos].lineWidth !== s && (this.currentLineWidth = s,
            this.stack[this.cArrPos].lineWidth = s)
        }
        ,
        CVContextData.prototype.lineCap = function(s) {
            this.stack[this.cArrPos].lineCap !== s && (this.currentLineCap = s,
            this.stack[this.cArrPos].lineCap = s)
        }
        ,
        CVContextData.prototype.lineJoin = function(s) {
            this.stack[this.cArrPos].lineJoin !== s && (this.currentLineJoin = s,
            this.stack[this.cArrPos].lineJoin = s)
        }
        ,
        CVContextData.prototype.miterLimit = function(s) {
            this.stack[this.cArrPos].miterLimit !== s && (this.currentMiterLimit = s,
            this.stack[this.cArrPos].miterLimit = s)
        }
        ,
        CVContextData.prototype.transform = function(s) {
            this.transformMat.cloneFromProps(s);
            var e = this.cTr;
            this.transformMat.multiply(e),
            e.cloneFromProps(this.transformMat.props);
            var a = e.props;
            this.nativeContext.setTransform(a[0], a[1], a[4], a[5], a[12], a[13])
        }
        ,
        CVContextData.prototype.opacity = function(s) {
            var e = this.stack[this.cArrPos].opacity;
            e *= s < 0 ? 0 : s,
            this.stack[this.cArrPos].opacity !== e && (this.currentOpacity !== s && (this.nativeContext.globalAlpha = s,
            this.currentOpacity = s),
            this.stack[this.cArrPos].opacity = e)
        }
        ,
        CVContextData.prototype.fill = function(s) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fill(s)
        }
        ,
        CVContextData.prototype.fillRect = function(s, e, a, o) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fillRect(s, e, a, o)
        }
        ,
        CVContextData.prototype.stroke = function() {
            this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle,
            this.nativeContext.strokeStyle = this.appliedStrokeStyle),
            this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth,
            this.nativeContext.lineWidth = this.appliedLineWidth),
            this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap,
            this.nativeContext.lineCap = this.appliedLineCap),
            this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin,
            this.nativeContext.lineJoin = this.appliedLineJoin),
            this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit,
            this.nativeContext.miterLimit = this.appliedMiterLimit),
            this.nativeContext.stroke()
        }
        ;
        function CVCompElement(s, e, a) {
            this.completeLayers = !1,
            this.layers = s.layers,
            this.pendingElements = [],
            this.elements = createSizedArray(this.layers.length),
            this.initElement(s, e, a),
            this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement),
        CVCompElement.prototype.renderInnerContent = function() {
            var s = this.canvasContext;
            s.beginPath(),
            s.moveTo(0, 0),
            s.lineTo(this.data.w, 0),
            s.lineTo(this.data.w, this.data.h),
            s.lineTo(0, this.data.h),
            s.lineTo(0, 0),
            s.clip();
            var e, a = this.layers.length;
            for (e = a - 1; e >= 0; e -= 1)
                (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
        }
        ,
        CVCompElement.prototype.destroy = function() {
            var s, e = this.layers.length;
            for (s = e - 1; s >= 0; s -= 1)
                this.elements[s] && this.elements[s].destroy();
            this.layers = null,
            this.elements = null
        }
        ,
        CVCompElement.prototype.createComp = function(s) {
            return new CVCompElement(s,this.globalData,this)
        }
        ;
        function CanvasRenderer(s, e) {
            this.animationItem = s,
            this.renderConfig = {
                clearCanvas: e && e.clearCanvas !== void 0 ? e.clearCanvas : !0,
                context: e && e.context || null,
                progressiveLoad: e && e.progressiveLoad || !1,
                preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: e && e.contentVisibility || "visible",
                className: e && e.className || "",
                id: e && e.id || "",
                runExpressions: !e || e.runExpressions === void 0 || e.runExpressions
            },
            this.renderConfig.dpr = e && e.dpr || 1,
            this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1),
            this.renderedFrame = -1,
            this.globalData = {
                frameNum: -1,
                _mdf: !1,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
            },
            this.contextData = new CVContextData,
            this.elements = [],
            this.pendingElements = [],
            this.transformMat = new Matrix,
            this.completeLayers = !1,
            this.rendererType = "canvas",
            this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData),
            this.ctxOpacity = this.contextData.opacity.bind(this.contextData),
            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData),
            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData),
            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData),
            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData),
            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData),
            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData),
            this.ctxFill = this.contextData.fill.bind(this.contextData),
            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData),
            this.ctxStroke = this.contextData.stroke.bind(this.contextData),
            this.save = this.contextData.save.bind(this.contextData))
        }
        extendPrototype([CanvasRendererBase], CanvasRenderer),
        CanvasRenderer.prototype.createComp = function(s) {
            return new CVCompElement(s,this.globalData,this)
        }
        ;
        function HBaseElement() {}
        HBaseElement.prototype = {
            checkBlendMode: function() {},
            initRendererElement: function() {
                this.baseElement = createTag(this.data.tg || "div"),
                this.data.hasMask ? (this.svgElement = createNS("svg"),
                this.layerElement = createNS("g"),
                this.maskedElement = this.layerElement,
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement,
                styleDiv(this.baseElement)
            },
            createContainerElements: function() {
                this.renderableEffectsManager = new CVEffects(this),
                this.transformedElement = this.baseElement,
                this.maskedElement = this.layerElement,
                this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                var e = this.transformedElement ? this.transformedElement.style : {};
                if (this.finalTransform._matMdf) {
                    var a = this.finalTransform.mat.toCSS();
                    e.transform = a,
                    e.webkitTransform = a
                }
                this.finalTransform._opMdf && (e.opacity = this.finalTransform.mProp.o.v)
            },
            renderFrame: function() {
                this.data.hd || this.hidden || (this.renderTransform(),
                this.renderRenderable(),
                this.renderElement(),
                this.renderInnerContent(),
                this._isFirstFrame && (this._isFirstFrame = !1))
            },
            destroy: function() {
                this.layerElement = null,
                this.transformedElement = null,
                this.matteElement && (this.matteElement = null),
                this.maskManager && (this.maskManager.destroy(),
                this.maskManager = null)
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData)
            },
            addEffects: function() {},
            setMatte: function() {}
        },
        HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement,
        HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy,
        HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
        function HSolidElement(s, e, a) {
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement),
        HSolidElement.prototype.createContent = function() {
            var s;
            this.data.hasMask ? (s = createNS("rect"),
            s.setAttribute("width", this.data.sw),
            s.setAttribute("height", this.data.sh),
            s.setAttribute("fill", this.data.sc),
            this.svgElement.setAttribute("width", this.data.sw),
            this.svgElement.setAttribute("height", this.data.sh)) : (s = createTag("div"),
            s.style.width = this.data.sw + "px",
            s.style.height = this.data.sh + "px",
            s.style.backgroundColor = this.data.sc),
            this.layerElement.appendChild(s)
        }
        ;
        function HShapeElement(s, e, a) {
            this.shapes = [],
            this.shapesData = s.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.shapesContainer = createNS("g"),
            this.initElement(s, e, a),
            this.prevViewData = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            }
        }
        extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement),
        HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent,
        HShapeElement.prototype.createContent = function() {
            var s;
            if (this.baseElement.style.fontSize = 0,
            this.data.hasMask)
                this.layerElement.appendChild(this.shapesContainer),
                s = this.svgElement;
            else {
                s = createNS("svg");
                var e = this.comp.data ? this.comp.data : this.globalData.compSize;
                s.setAttribute("width", e.w),
                s.setAttribute("height", e.h),
                s.appendChild(this.shapesContainer),
                this.layerElement.appendChild(s)
            }
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0),
            this.filterUniqueShapes(),
            this.shapeCont = s
        }
        ,
        HShapeElement.prototype.getTransformedPoint = function(s, e) {
            var a, o = s.length;
            for (a = 0; a < o; a += 1)
                e = s[a].mProps.v.applyToPointArray(e[0], e[1], 0);
            return e
        }
        ,
        HShapeElement.prototype.calculateShapeBoundingBox = function(s, e) {
            var a = s.sh.v, o = s.transformers, c, d = a._length, g, _, b, j;
            if (!(d <= 1)) {
                for (c = 0; c < d - 1; c += 1)
                    g = this.getTransformedPoint(o, a.v[c]),
                    _ = this.getTransformedPoint(o, a.o[c]),
                    b = this.getTransformedPoint(o, a.i[c + 1]),
                    j = this.getTransformedPoint(o, a.v[c + 1]),
                    this.checkBounds(g, _, b, j, e);
                a.c && (g = this.getTransformedPoint(o, a.v[c]),
                _ = this.getTransformedPoint(o, a.o[c]),
                b = this.getTransformedPoint(o, a.i[0]),
                j = this.getTransformedPoint(o, a.v[0]),
                this.checkBounds(g, _, b, j, e))
            }
        }
        ,
        HShapeElement.prototype.checkBounds = function(s, e, a, o, c) {
            this.getBoundsOfCurve(s, e, a, o);
            var d = this.shapeBoundingBox;
            c.x = bmMin(d.left, c.x),
            c.xMax = bmMax(d.right, c.xMax),
            c.y = bmMin(d.top, c.y),
            c.yMax = bmMax(d.bottom, c.yMax)
        }
        ,
        HShapeElement.prototype.shapeBoundingBox = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0
        },
        HShapeElement.prototype.getBoundsOfCurve = function(s, e, a, o) {
            for (var c = [[s[0], o[0]], [s[1], o[1]]], d, g, _, b, j, $, nt, tt = 0; tt < 2; ++tt)
                g = 6 * s[tt] - 12 * e[tt] + 6 * a[tt],
                d = -3 * s[tt] + 9 * e[tt] - 9 * a[tt] + 3 * o[tt],
                _ = 3 * e[tt] - 3 * s[tt],
                g |= 0,
                d |= 0,
                _ |= 0,
                d === 0 && g === 0 || (d === 0 ? (b = -_ / g,
                b > 0 && b < 1 && c[tt].push(this.calculateF(b, s, e, a, o, tt))) : (j = g * g - 4 * _ * d,
                j >= 0 && ($ = (-g + bmSqrt(j)) / (2 * d),
                $ > 0 && $ < 1 && c[tt].push(this.calculateF($, s, e, a, o, tt)),
                nt = (-g - bmSqrt(j)) / (2 * d),
                nt > 0 && nt < 1 && c[tt].push(this.calculateF(nt, s, e, a, o, tt)))));
            this.shapeBoundingBox.left = bmMin.apply(null, c[0]),
            this.shapeBoundingBox.top = bmMin.apply(null, c[1]),
            this.shapeBoundingBox.right = bmMax.apply(null, c[0]),
            this.shapeBoundingBox.bottom = bmMax.apply(null, c[1])
        }
        ,
        HShapeElement.prototype.calculateF = function(s, e, a, o, c, d) {
            return bmPow(1 - s, 3) * e[d] + 3 * bmPow(1 - s, 2) * s * a[d] + 3 * (1 - s) * bmPow(s, 2) * o[d] + bmPow(s, 3) * c[d]
        }
        ,
        HShapeElement.prototype.calculateBoundingBox = function(s, e) {
            var a, o = s.length;
            for (a = 0; a < o; a += 1)
                s[a] && s[a].sh ? this.calculateShapeBoundingBox(s[a], e) : s[a] && s[a].it ? this.calculateBoundingBox(s[a].it, e) : s[a] && s[a].style && s[a].w && this.expandStrokeBoundingBox(s[a].w, e)
        }
        ,
        HShapeElement.prototype.expandStrokeBoundingBox = function(s, e) {
            var a = 0;
            if (s.keyframes) {
                for (var o = 0; o < s.keyframes.length; o += 1) {
                    var c = s.keyframes[o].s;
                    c > a && (a = c)
                }
                a *= s.mult
            } else
                a = s.v * s.mult;
            e.x -= a,
            e.xMax += a,
            e.y -= a,
            e.yMax += a
        }
        ,
        HShapeElement.prototype.currentBoxContains = function(s) {
            return this.currentBBox.x <= s.x && this.currentBBox.y <= s.y && this.currentBBox.width + this.currentBBox.x >= s.x + s.width && this.currentBBox.height + this.currentBBox.y >= s.y + s.height
        }
        ,
        HShapeElement.prototype.renderInnerContent = function() {
            if (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf)) {
                var s = this.tempBoundingBox
                  , e = 999999;
                if (s.x = e,
                s.xMax = -e,
                s.y = e,
                s.yMax = -e,
                this.calculateBoundingBox(this.itemsData, s),
                s.width = s.xMax < s.x ? 0 : s.xMax - s.x,
                s.height = s.yMax < s.y ? 0 : s.yMax - s.y,
                this.currentBoxContains(s))
                    return;
                var a = !1;
                if (this.currentBBox.w !== s.width && (this.currentBBox.w = s.width,
                this.shapeCont.setAttribute("width", s.width),
                a = !0),
                this.currentBBox.h !== s.height && (this.currentBBox.h = s.height,
                this.shapeCont.setAttribute("height", s.height),
                a = !0),
                a || this.currentBBox.x !== s.x || this.currentBBox.y !== s.y) {
                    this.currentBBox.w = s.width,
                    this.currentBBox.h = s.height,
                    this.currentBBox.x = s.x,
                    this.currentBBox.y = s.y,
                    this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                    var o = this.shapeCont.style
                      , c = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                    o.transform = c,
                    o.webkitTransform = c
                }
            }
        }
        ;
        function HTextElement(s, e, a) {
            this.textSpans = [],
            this.textPaths = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            },
            this.renderType = "svg",
            this.isMasked = !1,
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement),
        HTextElement.prototype.createContent = function() {
            if (this.isMasked = this.checkMasks(),
            this.isMasked) {
                this.renderType = "svg",
                this.compW = this.comp.data.w,
                this.compH = this.comp.data.h,
                this.svgElement.setAttribute("width", this.compW),
                this.svgElement.setAttribute("height", this.compH);
                var s = createNS("g");
                this.maskedElement.appendChild(s),
                this.innerElem = s
            } else
                this.renderType = "html",
                this.innerElem = this.layerElement;
            this.checkParenting()
        }
        ,
        HTextElement.prototype.buildNewText = function() {
            var s = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(s.l ? s.l.length : 0);
            var e = this.innerElem.style
              , a = s.fc ? this.buildColor(s.fc) : "rgba(0,0,0,0)";
            e.fill = a,
            e.color = a,
            s.sc && (e.stroke = this.buildColor(s.sc),
            e.strokeWidth = s.sw + "px");
            var o = this.globalData.fontManager.getFontByName(s.f);
            if (!this.globalData.fontManager.chars)
                if (e.fontSize = s.finalSize + "px",
                e.lineHeight = s.finalSize + "px",
                o.fClass)
                    this.innerElem.className = o.fClass;
                else {
                    e.fontFamily = o.fFamily;
                    var c = s.fWeight
                      , d = s.fStyle;
                    e.fontStyle = d,
                    e.fontWeight = c
                }
            var g, _, b = s.l;
            _ = b.length;
            var j, $, nt, tt = this.mHelper, rt, st = "", lt = 0;
            for (g = 0; g < _; g += 1) {
                if (this.globalData.fontManager.chars ? (this.textPaths[lt] ? j = this.textPaths[lt] : (j = createNS("path"),
                j.setAttribute("stroke-linecap", lineCapEnum[1]),
                j.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                j.setAttribute("stroke-miterlimit", "4")),
                this.isMasked || (this.textSpans[lt] ? ($ = this.textSpans[lt],
                nt = $.children[0]) : ($ = createTag("div"),
                $.style.lineHeight = 0,
                nt = createNS("svg"),
                nt.appendChild(j),
                styleDiv($)))) : this.isMasked ? j = this.textPaths[lt] ? this.textPaths[lt] : createNS("text") : this.textSpans[lt] ? ($ = this.textSpans[lt],
                j = this.textPaths[lt]) : ($ = createTag("span"),
                styleDiv($),
                j = createTag("span"),
                styleDiv(j),
                $.appendChild(j)),
                this.globalData.fontManager.chars) {
                    var ct = this.globalData.fontManager.getCharData(s.finalText[g], o.fStyle, this.globalData.fontManager.getFontByName(s.f).fFamily), it;
                    if (ct ? it = ct.data : it = null,
                    tt.reset(),
                    it && it.shapes && it.shapes.length && (rt = it.shapes[0].it,
                    tt.scale(s.finalSize / 100, s.finalSize / 100),
                    st = this.createPathShape(tt, rt),
                    j.setAttribute("d", st)),
                    this.isMasked)
                        this.innerElem.appendChild(j);
                    else {
                        if (this.innerElem.appendChild($),
                        it && it.shapes) {
                            document.body.appendChild(nt);
                            var ot = nt.getBBox();
                            nt.setAttribute("width", ot.width + 2),
                            nt.setAttribute("height", ot.height + 2),
                            nt.setAttribute("viewBox", ot.x - 1 + " " + (ot.y - 1) + " " + (ot.width + 2) + " " + (ot.height + 2));
                            var at = nt.style
                              , ht = "translate(" + (ot.x - 1) + "px," + (ot.y - 1) + "px)";
                            at.transform = ht,
                            at.webkitTransform = ht,
                            b[g].yOffset = ot.y - 1
                        } else
                            nt.setAttribute("width", 1),
                            nt.setAttribute("height", 1);
                        $.appendChild(nt)
                    }
                } else if (j.textContent = b[g].val,
                j.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"),
                this.isMasked)
                    this.innerElem.appendChild(j);
                else {
                    this.innerElem.appendChild($);
                    var pt = j.style
                      , dt = "translate3d(0," + -s.finalSize / 1.2 + "px,0)";
                    pt.transform = dt,
                    pt.webkitTransform = dt
                }
                this.isMasked ? this.textSpans[lt] = j : this.textSpans[lt] = $,
                this.textSpans[lt].style.display = "block",
                this.textPaths[lt] = j,
                lt += 1
            }
            for (; lt < this.textSpans.length; )
                this.textSpans[lt].style.display = "none",
                lt += 1
        }
        ,
        HTextElement.prototype.renderInnerContent = function() {
            this.validateText();
            var s;
            if (this.data.singleShape) {
                if (!this._isFirstFrame && !this.lettersChangedFlag)
                    return;
                if (this.isMasked && this.finalTransform._matMdf) {
                    this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH),
                    s = this.svgElement.style;
                    var e = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                    s.transform = e,
                    s.webkitTransform = e
                }
            }
            if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
                var a, o, c = 0, d = this.textAnimator.renderedLetters, g = this.textProperty.currentData.l;
                o = g.length;
                var _, b, j;
                for (a = 0; a < o; a += 1)
                    g[a].n ? c += 1 : (b = this.textSpans[a],
                    j = this.textPaths[a],
                    _ = d[c],
                    c += 1,
                    _._mdf.m && (this.isMasked ? b.setAttribute("transform", _.m) : (b.style.webkitTransform = _.m,
                    b.style.transform = _.m)),
                    b.style.opacity = _.o,
                    _.sw && _._mdf.sw && j.setAttribute("stroke-width", _.sw),
                    _.sc && _._mdf.sc && j.setAttribute("stroke", _.sc),
                    _.fc && _._mdf.fc && (j.setAttribute("fill", _.fc),
                    j.style.color = _.fc));
                if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var $ = this.innerElem.getBBox();
                    this.currentBBox.w !== $.width && (this.currentBBox.w = $.width,
                    this.svgElement.setAttribute("width", $.width)),
                    this.currentBBox.h !== $.height && (this.currentBBox.h = $.height,
                    this.svgElement.setAttribute("height", $.height));
                    var nt = 1;
                    if (this.currentBBox.w !== $.width + nt * 2 || this.currentBBox.h !== $.height + nt * 2 || this.currentBBox.x !== $.x - nt || this.currentBBox.y !== $.y - nt) {
                        this.currentBBox.w = $.width + nt * 2,
                        this.currentBBox.h = $.height + nt * 2,
                        this.currentBBox.x = $.x - nt,
                        this.currentBBox.y = $.y - nt,
                        this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h),
                        s = this.svgElement.style;
                        var tt = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                        s.transform = tt,
                        s.webkitTransform = tt
                    }
                }
            }
        }
        ;
        function HCameraElement(s, e, a) {
            this.initFrame(),
            this.initBaseData(s, e, a),
            this.initHierarchy();
            var o = PropertyFactory.getProp;
            if (this.pe = o(this, s.pe, 0, 0, this),
            s.ks.p.s ? (this.px = o(this, s.ks.p.x, 1, 0, this),
            this.py = o(this, s.ks.p.y, 1, 0, this),
            this.pz = o(this, s.ks.p.z, 1, 0, this)) : this.p = o(this, s.ks.p, 1, 0, this),
            s.ks.a && (this.a = o(this, s.ks.a, 1, 0, this)),
            s.ks.or.k.length && s.ks.or.k[0].to) {
                var c, d = s.ks.or.k.length;
                for (c = 0; c < d; c += 1)
                    s.ks.or.k[c].to = null,
                    s.ks.or.k[c].ti = null
            }
            this.or = o(this, s.ks.or, 1, degToRads, this),
            this.or.sh = !0,
            this.rx = o(this, s.ks.rx, 0, degToRads, this),
            this.ry = o(this, s.ks.ry, 0, degToRads, this),
            this.rz = o(this, s.ks.rz, 0, degToRads, this),
            this.mat = new Matrix,
            this._prevMat = new Matrix,
            this._isFirstFrame = !0,
            this.finalTransform = {
                mProp: this
            }
        }
        extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement),
        HCameraElement.prototype.setup = function() {
            var s, e = this.comp.threeDElements.length, a, o, c;
            for (s = 0; s < e; s += 1)
                if (a = this.comp.threeDElements[s],
                a.type === "3d") {
                    o = a.perspectiveElem.style,
                    c = a.container.style;
                    var d = this.pe.v + "px"
                      , g = "0px 0px 0px"
                      , _ = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                    o.perspective = d,
                    o.webkitPerspective = d,
                    c.transformOrigin = g,
                    c.mozTransformOrigin = g,
                    c.webkitTransformOrigin = g,
                    o.transform = _,
                    o.webkitTransform = _
                }
        }
        ,
        HCameraElement.prototype.createElements = function() {}
        ,
        HCameraElement.prototype.hide = function() {}
        ,
        HCameraElement.prototype.renderFrame = function() {
            var s = this._isFirstFrame, e, a;
            if (this.hierarchy)
                for (a = this.hierarchy.length,
                e = 0; e < a; e += 1)
                    s = this.hierarchy[e].finalTransform.mProp._mdf || s;
            if (s || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                if (this.mat.reset(),
                this.hierarchy)
                    for (a = this.hierarchy.length - 1,
                    e = a; e >= 0; e -= 1) {
                        var o = this.hierarchy[e].finalTransform.mProp;
                        this.mat.translate(-o.p.v[0], -o.p.v[1], o.p.v[2]),
                        this.mat.rotateX(-o.or.v[0]).rotateY(-o.or.v[1]).rotateZ(o.or.v[2]),
                        this.mat.rotateX(-o.rx.v).rotateY(-o.ry.v).rotateZ(o.rz.v),
                        this.mat.scale(1 / o.s.v[0], 1 / o.s.v[1], 1 / o.s.v[2]),
                        this.mat.translate(o.a.v[0], o.a.v[1], o.a.v[2])
                    }
                if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
                this.a) {
                    var c;
                    this.p ? c = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : c = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                    var d = Math.sqrt(Math.pow(c[0], 2) + Math.pow(c[1], 2) + Math.pow(c[2], 2))
                      , g = [c[0] / d, c[1] / d, c[2] / d]
                      , _ = Math.sqrt(g[2] * g[2] + g[0] * g[0])
                      , b = Math.atan2(g[1], _)
                      , j = Math.atan2(g[0], -g[2]);
                    this.mat.rotateY(j).rotateX(-b)
                }
                this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
                this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]),
                this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0),
                this.mat.translate(0, 0, this.pe.v);
                var $ = !this._prevMat.equals(this.mat);
                if (($ || this.pe._mdf) && this.comp.threeDElements) {
                    a = this.comp.threeDElements.length;
                    var nt, tt, rt;
                    for (e = 0; e < a; e += 1)
                        if (nt = this.comp.threeDElements[e],
                        nt.type === "3d") {
                            if ($) {
                                var st = this.mat.toCSS();
                                rt = nt.container.style,
                                rt.transform = st,
                                rt.webkitTransform = st
                            }
                            this.pe._mdf && (tt = nt.perspectiveElem.style,
                            tt.perspective = this.pe.v + "px",
                            tt.webkitPerspective = this.pe.v + "px")
                        }
                    this.mat.clone(this._prevMat)
                }
            }
            this._isFirstFrame = !1
        }
        ,
        HCameraElement.prototype.prepareFrame = function(s) {
            this.prepareProperties(s, !0)
        }
        ,
        HCameraElement.prototype.destroy = function() {}
        ,
        HCameraElement.prototype.getBaseElement = function() {
            return null
        }
        ;
        function HImageElement(s, e, a) {
            this.assetData = e.getAssetData(s.refId),
            this.initElement(s, e, a)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement),
        HImageElement.prototype.createContent = function() {
            var s = this.globalData.getAssetsPath(this.assetData)
              , e = new Image;
            this.data.hasMask ? (this.imageElem = createNS("image"),
            this.imageElem.setAttribute("width", this.assetData.w + "px"),
            this.imageElem.setAttribute("height", this.assetData.h + "px"),
            this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", s),
            this.layerElement.appendChild(this.imageElem),
            this.baseElement.setAttribute("width", this.assetData.w),
            this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(e),
            e.crossOrigin = "anonymous",
            e.src = s,
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
        }
        ;
        function HybridRendererBase(s, e) {
            this.animationItem = s,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: e && e.className || "",
                imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(e && e.hideOnTransparent === !1),
                filterSize: {
                    width: e && e.filterSize && e.filterSize.width || "400%",
                    height: e && e.filterSize && e.filterSize.height || "400%",
                    x: e && e.filterSize && e.filterSize.x || "-100%",
                    y: e && e.filterSize && e.filterSize.y || "-100%"
                }
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        extendPrototype([BaseRenderer], HybridRendererBase),
        HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem,
        HybridRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var s = this.pendingElements.pop();
                s.checkParenting()
            }
        }
        ,
        HybridRendererBase.prototype.appendElementInPos = function(s, e) {
            var a = s.getBaseElement();
            if (a) {
                var o = this.layers[e];
                if (!o.ddd || !this.supports3d)
                    if (this.threeDElements)
                        this.addTo3dContainer(a, e);
                    else {
                        for (var c = 0, d, g, _; c < e; )
                            this.elements[c] && this.elements[c] !== !0 && this.elements[c].getBaseElement && (g = this.elements[c],
                            _ = this.layers[c].ddd ? this.getThreeDContainerByPos(c) : g.getBaseElement(),
                            d = _ || d),
                            c += 1;
                        d ? (!o.ddd || !this.supports3d) && this.layerElement.insertBefore(a, d) : (!o.ddd || !this.supports3d) && this.layerElement.appendChild(a)
                    }
                else
                    this.addTo3dContainer(a, e)
            }
        }
        ,
        HybridRendererBase.prototype.createShape = function(s) {
            return this.supports3d ? new HShapeElement(s,this.globalData,this) : new SVGShapeElement(s,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createText = function(s) {
            return this.supports3d ? new HTextElement(s,this.globalData,this) : new SVGTextLottieElement(s,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createCamera = function(s) {
            return this.camera = new HCameraElement(s,this.globalData,this),
            this.camera
        }
        ,
        HybridRendererBase.prototype.createImage = function(s) {
            return this.supports3d ? new HImageElement(s,this.globalData,this) : new IImageElement(s,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createSolid = function(s) {
            return this.supports3d ? new HSolidElement(s,this.globalData,this) : new ISolidElement(s,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        HybridRendererBase.prototype.getThreeDContainerByPos = function(s) {
            for (var e = 0, a = this.threeDElements.length; e < a; ) {
                if (this.threeDElements[e].startPos <= s && this.threeDElements[e].endPos >= s)
                    return this.threeDElements[e].perspectiveElem;
                e += 1
            }
            return null
        }
        ,
        HybridRendererBase.prototype.createThreeDContainer = function(s, e) {
            var a = createTag("div"), o, c;
            styleDiv(a);
            var d = createTag("div");
            if (styleDiv(d),
            e === "3d") {
                o = a.style,
                o.width = this.globalData.compSize.w + "px",
                o.height = this.globalData.compSize.h + "px";
                var g = "50% 50%";
                o.webkitTransformOrigin = g,
                o.mozTransformOrigin = g,
                o.transformOrigin = g,
                c = d.style;
                var _ = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                c.transform = _,
                c.webkitTransform = _
            }
            a.appendChild(d);
            var b = {
                container: d,
                perspectiveElem: a,
                startPos: s,
                endPos: s,
                type: e
            };
            return this.threeDElements.push(b),
            b
        }
        ,
        HybridRendererBase.prototype.build3dContainers = function() {
            var s, e = this.layers.length, a, o = "";
            for (s = 0; s < e; s += 1)
                this.layers[s].ddd && this.layers[s].ty !== 3 ? (o !== "3d" && (o = "3d",
                a = this.createThreeDContainer(s, "3d")),
                a.endPos = Math.max(a.endPos, s)) : (o !== "2d" && (o = "2d",
                a = this.createThreeDContainer(s, "2d")),
                a.endPos = Math.max(a.endPos, s));
            for (e = this.threeDElements.length,
            s = e - 1; s >= 0; s -= 1)
                this.resizerElem.appendChild(this.threeDElements[s].perspectiveElem)
        }
        ,
        HybridRendererBase.prototype.addTo3dContainer = function(s, e) {
            for (var a = 0, o = this.threeDElements.length; a < o; ) {
                if (e <= this.threeDElements[a].endPos) {
                    for (var c = this.threeDElements[a].startPos, d; c < e; )
                        this.elements[c] && this.elements[c].getBaseElement && (d = this.elements[c].getBaseElement()),
                        c += 1;
                    d ? this.threeDElements[a].container.insertBefore(s, d) : this.threeDElements[a].container.appendChild(s);
                    break
                }
                a += 1
            }
        }
        ,
        HybridRendererBase.prototype.configAnimation = function(s) {
            var e = createTag("div")
              , a = this.animationItem.wrapper
              , o = e.style;
            o.width = s.w + "px",
            o.height = s.h + "px",
            this.resizerElem = e,
            styleDiv(e),
            o.transformStyle = "flat",
            o.mozTransformStyle = "flat",
            o.webkitTransformStyle = "flat",
            this.renderConfig.className && e.setAttribute("class", this.renderConfig.className),
            a.appendChild(e),
            o.overflow = "hidden";
            var c = createNS("svg");
            c.setAttribute("width", "1"),
            c.setAttribute("height", "1"),
            styleDiv(c),
            this.resizerElem.appendChild(c);
            var d = createNS("defs");
            c.appendChild(d),
            this.data = s,
            this.setupGlobalData(s, c),
            this.globalData.defs = d,
            this.layers = s.layers,
            this.layerElement = this.resizerElem,
            this.build3dContainers(),
            this.updateContainerSize()
        }
        ,
        HybridRendererBase.prototype.destroy = function() {
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.animationItem.container = null,
            this.globalData.defs = null;
            var s, e = this.layers ? this.layers.length : 0;
            for (s = 0; s < e; s += 1)
                this.elements[s] && this.elements[s].destroy && this.elements[s].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        HybridRendererBase.prototype.updateContainerSize = function() {
            var s = this.animationItem.wrapper.offsetWidth, e = this.animationItem.wrapper.offsetHeight, a = s / e, o = this.globalData.compSize.w / this.globalData.compSize.h, c, d, g, _;
            o > a ? (c = s / this.globalData.compSize.w,
            d = s / this.globalData.compSize.w,
            g = 0,
            _ = (e - this.globalData.compSize.h * (s / this.globalData.compSize.w)) / 2) : (c = e / this.globalData.compSize.h,
            d = e / this.globalData.compSize.h,
            g = (s - this.globalData.compSize.w * (e / this.globalData.compSize.h)) / 2,
            _ = 0);
            var b = this.resizerElem.style;
            b.webkitTransform = "matrix3d(" + c + ",0,0,0,0," + d + ",0,0,0,0,1,0," + g + "," + _ + ",0,1)",
            b.transform = b.webkitTransform
        }
        ,
        HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame,
        HybridRendererBase.prototype.hide = function() {
            this.resizerElem.style.display = "none"
        }
        ,
        HybridRendererBase.prototype.show = function() {
            this.resizerElem.style.display = "block"
        }
        ,
        HybridRendererBase.prototype.initItems = function() {
            if (this.buildAllItems(),
            this.camera)
                this.camera.setup();
            else {
                var s = this.globalData.compSize.w, e = this.globalData.compSize.h, a, o = this.threeDElements.length;
                for (a = 0; a < o; a += 1) {
                    var c = this.threeDElements[a].perspectiveElem.style;
                    c.webkitPerspective = Math.sqrt(Math.pow(s, 2) + Math.pow(e, 2)) + "px",
                    c.perspective = c.webkitPerspective
                }
            }
        }
        ,
        HybridRendererBase.prototype.searchExtraCompositions = function(s) {
            var e, a = s.length, o = createTag("div");
            for (e = 0; e < a; e += 1)
                if (s[e].xt) {
                    var c = this.createComp(s[e], o, this.globalData.comp, null);
                    c.initExpressions(),
                    this.globalData.projectInterface.registerComposition(c)
                }
        }
        ;
        function HCompElement(s, e, a) {
            this.layers = s.layers,
            this.supports3d = !s.hasMask,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(s, e, a),
            this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement),
        HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements,
        HCompElement.prototype.createContainerElements = function() {
            this._createBaseContainerElements(),
            this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w),
            this.svgElement.setAttribute("height", this.data.h),
            this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
        }
        ,
        HCompElement.prototype.addTo3dContainer = function(s, e) {
            for (var a = 0, o; a < e; )
                this.elements[a] && this.elements[a].getBaseElement && (o = this.elements[a].getBaseElement()),
                a += 1;
            o ? this.layerElement.insertBefore(s, o) : this.layerElement.appendChild(s)
        }
        ,
        HCompElement.prototype.createComp = function(s) {
            return this.supports3d ? new HCompElement(s,this.globalData,this) : new SVGCompElement(s,this.globalData,this)
        }
        ;
        function HybridRenderer(s, e) {
            this.animationItem = s,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: e && e.className || "",
                imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(e && e.hideOnTransparent === !1),
                filterSize: {
                    width: e && e.filterSize && e.filterSize.width || "400%",
                    height: e && e.filterSize && e.filterSize.height || "400%",
                    x: e && e.filterSize && e.filterSize.x || "-100%",
                    y: e && e.filterSize && e.filterSize.y || "-100%"
                },
                runExpressions: !e || e.runExpressions === void 0 || e.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        extendPrototype([HybridRendererBase], HybridRenderer),
        HybridRenderer.prototype.createComp = function(s) {
            return this.supports3d ? new HCompElement(s,this.globalData,this) : new SVGCompElement(s,this.globalData,this)
        }
        ;
        var CompExpressionInterface = function() {
            return function(s) {
                function e(a) {
                    for (var o = 0, c = s.layers.length; o < c; ) {
                        if (s.layers[o].nm === a || s.layers[o].ind === a)
                            return s.elements[o].layerInterface;
                        o += 1
                    }
                    return null
                }
                return Object.defineProperty(e, "_name", {
                    value: s.data.nm
                }),
                e.layer = e,
                e.pixelAspect = 1,
                e.height = s.data.h || s.globalData.compSize.h,
                e.width = s.data.w || s.globalData.compSize.w,
                e.pixelAspect = 1,
                e.frameDuration = 1 / s.globalData.frameRate,
                e.displayStartTime = 0,
                e.numLayers = s.layers.length,
                e
            }
        }();
        function _typeof$2(s) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function(a) {
                return typeof a
            }
            : _typeof$2 = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            _typeof$2(s)
        }
        function seedRandom(s, e) {
            var a = this, o = 256, c = 6, d = 52, g = "random", _ = e.pow(o, c), b = e.pow(2, d), j = b * 2, $ = o - 1, nt;
            function tt(at, ht, pt) {
                var dt = [];
                ht = ht === !0 ? {
                    entropy: !0
                } : ht || {};
                var yt = ct(lt(ht.entropy ? [at, ot(s)] : at === null ? it() : at, 3), dt)
                  , vt = new rt(dt)
                  , xt = function() {
                    for (var bt = vt.g(c), Rt = _, Ft = 0; bt < b; )
                        bt = (bt + Ft) * o,
                        Rt *= o,
                        Ft = vt.g(1);
                    for (; bt >= j; )
                        bt /= 2,
                        Rt /= 2,
                        Ft >>>= 1;
                    return (bt + Ft) / Rt
                };
                return xt.int32 = function() {
                    return vt.g(4) | 0
                }
                ,
                xt.quick = function() {
                    return vt.g(4) / 4294967296
                }
                ,
                xt.double = xt,
                ct(ot(vt.S), s),
                (ht.pass || pt || function(_t, bt, Rt, Ft) {
                    return Ft && (Ft.S && st(Ft, vt),
                    _t.state = function() {
                        return st(vt, {})
                    }
                    ),
                    Rt ? (e[g] = _t,
                    bt) : _t
                }
                )(xt, yt, "global"in ht ? ht.global : this == e, ht.state)
            }
            e["seed" + g] = tt;
            function rt(at) {
                var ht, pt = at.length, dt = this, yt = 0, vt = dt.i = dt.j = 0, xt = dt.S = [];
                for (pt || (at = [pt++]); yt < o; )
                    xt[yt] = yt++;
                for (yt = 0; yt < o; yt++)
                    xt[yt] = xt[vt = $ & vt + at[yt % pt] + (ht = xt[yt])],
                    xt[vt] = ht;
                dt.g = function(_t) {
                    for (var bt, Rt = 0, Ft = dt.i, Bt = dt.j, Dt = dt.S; _t--; )
                        bt = Dt[Ft = $ & Ft + 1],
                        Rt = Rt * o + Dt[$ & (Dt[Ft] = Dt[Bt = $ & Bt + bt]) + (Dt[Bt] = bt)];
                    return dt.i = Ft,
                    dt.j = Bt,
                    Rt
                }
            }
            function st(at, ht) {
                return ht.i = at.i,
                ht.j = at.j,
                ht.S = at.S.slice(),
                ht
            }
            function lt(at, ht) {
                var pt = [], dt = _typeof$2(at), yt;
                if (ht && dt == "object")
                    for (yt in at)
                        try {
                            pt.push(lt(at[yt], ht - 1))
                        } catch {}
                return pt.length ? pt : dt == "string" ? at : at + "\0"
            }
            function ct(at, ht) {
                for (var pt = at + "", dt, yt = 0; yt < pt.length; )
                    ht[$ & yt] = $ & (dt ^= ht[$ & yt] * 19) + pt.charCodeAt(yt++);
                return ot(ht)
            }
            function it() {
                try {
                    var at = new Uint8Array(o);
                    return (a.crypto || a.msCrypto).getRandomValues(at),
                    ot(at)
                } catch {
                    var ht = a.navigator
                      , pt = ht && ht.plugins;
                    return [+new Date, a, pt, a.screen, ot(s)]
                }
            }
            function ot(at) {
                return String.fromCharCode.apply(0, at)
            }
            ct(e.random(), s)
        }
        function initialize$2(s) {
            seedRandom([], s)
        }
        var propTypes = {
            SHAPE: "shape"
        };
        function _typeof$1(s) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function(a) {
                return typeof a
            }
            : _typeof$1 = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            _typeof$1(s)
        }
        var ExpressionManager = function() {
            var ob = {}
              , Math = BMMath
              , window = null
              , document = null
              , XMLHttpRequest = null
              , fetch = null
              , frames = null
              , _lottieGlobal = {};
            initialize$2(BMMath);
            function resetFrame() {
                _lottieGlobal = {}
            }
            function $bm_isInstanceOfArray(s) {
                return s.constructor === Array || s.constructor === Float32Array
            }
            function isNumerable(s, e) {
                return s === "number" || e instanceof Number || s === "boolean" || s === "string"
            }
            function $bm_neg(s) {
                var e = _typeof$1(s);
                if (e === "number" || s instanceof Number || e === "boolean")
                    return -s;
                if ($bm_isInstanceOfArray(s)) {
                    var a, o = s.length, c = [];
                    for (a = 0; a < o; a += 1)
                        c[a] = -s[a];
                    return c
                }
                return s.propType ? s.v : -s
            }
            var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get
              , easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get
              , easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;
            function sum(s, e) {
                var a = _typeof$1(s)
                  , o = _typeof$1(e);
                if (isNumerable(a, s) && isNumerable(o, e) || a === "string" || o === "string")
                    return s + e;
                if ($bm_isInstanceOfArray(s) && isNumerable(o, e))
                    return s = s.slice(0),
                    s[0] += e,
                    s;
                if (isNumerable(a, s) && $bm_isInstanceOfArray(e))
                    return e = e.slice(0),
                    e[0] = s + e[0],
                    e;
                if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(e)) {
                    for (var c = 0, d = s.length, g = e.length, _ = []; c < d || c < g; )
                        (typeof s[c] == "number" || s[c]instanceof Number) && (typeof e[c] == "number" || e[c]instanceof Number) ? _[c] = s[c] + e[c] : _[c] = e[c] === void 0 ? s[c] : s[c] || e[c],
                        c += 1;
                    return _
                }
                return 0
            }
            var add = sum;
            function sub(s, e) {
                var a = _typeof$1(s)
                  , o = _typeof$1(e);
                if (isNumerable(a, s) && isNumerable(o, e))
                    return a === "string" && (s = parseInt(s, 10)),
                    o === "string" && (e = parseInt(e, 10)),
                    s - e;
                if ($bm_isInstanceOfArray(s) && isNumerable(o, e))
                    return s = s.slice(0),
                    s[0] -= e,
                    s;
                if (isNumerable(a, s) && $bm_isInstanceOfArray(e))
                    return e = e.slice(0),
                    e[0] = s - e[0],
                    e;
                if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(e)) {
                    for (var c = 0, d = s.length, g = e.length, _ = []; c < d || c < g; )
                        (typeof s[c] == "number" || s[c]instanceof Number) && (typeof e[c] == "number" || e[c]instanceof Number) ? _[c] = s[c] - e[c] : _[c] = e[c] === void 0 ? s[c] : s[c] || e[c],
                        c += 1;
                    return _
                }
                return 0
            }
            function mul(s, e) {
                var a = _typeof$1(s), o = _typeof$1(e), c;
                if (isNumerable(a, s) && isNumerable(o, e))
                    return s * e;
                var d, g;
                if ($bm_isInstanceOfArray(s) && isNumerable(o, e)) {
                    for (g = s.length,
                    c = createTypedArray("float32", g),
                    d = 0; d < g; d += 1)
                        c[d] = s[d] * e;
                    return c
                }
                if (isNumerable(a, s) && $bm_isInstanceOfArray(e)) {
                    for (g = e.length,
                    c = createTypedArray("float32", g),
                    d = 0; d < g; d += 1)
                        c[d] = s * e[d];
                    return c
                }
                return 0
            }
            function div(s, e) {
                var a = _typeof$1(s), o = _typeof$1(e), c;
                if (isNumerable(a, s) && isNumerable(o, e))
                    return s / e;
                var d, g;
                if ($bm_isInstanceOfArray(s) && isNumerable(o, e)) {
                    for (g = s.length,
                    c = createTypedArray("float32", g),
                    d = 0; d < g; d += 1)
                        c[d] = s[d] / e;
                    return c
                }
                if (isNumerable(a, s) && $bm_isInstanceOfArray(e)) {
                    for (g = e.length,
                    c = createTypedArray("float32", g),
                    d = 0; d < g; d += 1)
                        c[d] = s / e[d];
                    return c
                }
                return 0
            }
            function mod(s, e) {
                return typeof s == "string" && (s = parseInt(s, 10)),
                typeof e == "string" && (e = parseInt(e, 10)),
                s % e
            }
            var $bm_sum = sum
              , $bm_sub = sub
              , $bm_mul = mul
              , $bm_div = div
              , $bm_mod = mod;
            function clamp(s, e, a) {
                if (e > a) {
                    var o = a;
                    a = e,
                    e = o
                }
                return Math.min(Math.max(s, e), a)
            }
            function radiansToDegrees(s) {
                return s / degToRads
            }
            var radians_to_degrees = radiansToDegrees;
            function degreesToRadians(s) {
                return s * degToRads
            }
            var degrees_to_radians = radiansToDegrees
              , helperLengthArray = [0, 0, 0, 0, 0, 0];
            function length(s, e) {
                if (typeof s == "number" || s instanceof Number)
                    return e = e || 0,
                    Math.abs(s - e);
                e || (e = helperLengthArray);
                var a, o = Math.min(s.length, e.length), c = 0;
                for (a = 0; a < o; a += 1)
                    c += Math.pow(e[a] - s[a], 2);
                return Math.sqrt(c)
            }
            function normalize(s) {
                return div(s, length(s))
            }
            function rgbToHsl(s) {
                var e = s[0], a = s[1], o = s[2], c = Math.max(e, a, o), d = Math.min(e, a, o), g, _, b = (c + d) / 2;
                if (c === d)
                    g = 0,
                    _ = 0;
                else {
                    var j = c - d;
                    switch (_ = b > .5 ? j / (2 - c - d) : j / (c + d),
                    c) {
                    case e:
                        g = (a - o) / j + (a < o ? 6 : 0);
                        break;
                    case a:
                        g = (o - e) / j + 2;
                        break;
                    case o:
                        g = (e - a) / j + 4;
                        break
                    }
                    g /= 6
                }
                return [g, _, b, s[3]]
            }
            function hue2rgb(s, e, a) {
                return a < 0 && (a += 1),
                a > 1 && (a -= 1),
                a < 1 / 6 ? s + (e - s) * 6 * a : a < 1 / 2 ? e : a < 2 / 3 ? s + (e - s) * (2 / 3 - a) * 6 : s
            }
            function hslToRgb(s) {
                var e = s[0], a = s[1], o = s[2], c, d, g;
                if (a === 0)
                    c = o,
                    g = o,
                    d = o;
                else {
                    var _ = o < .5 ? o * (1 + a) : o + a - o * a
                      , b = 2 * o - _;
                    c = hue2rgb(b, _, e + 1 / 3),
                    d = hue2rgb(b, _, e),
                    g = hue2rgb(b, _, e - 1 / 3)
                }
                return [c, d, g, s[3]]
            }
            function linear(s, e, a, o, c) {
                if ((o === void 0 || c === void 0) && (o = e,
                c = a,
                e = 0,
                a = 1),
                a < e) {
                    var d = a;
                    a = e,
                    e = d
                }
                if (s <= e)
                    return o;
                if (s >= a)
                    return c;
                var g = a === e ? 0 : (s - e) / (a - e);
                if (!o.length)
                    return o + (c - o) * g;
                var _, b = o.length, j = createTypedArray("float32", b);
                for (_ = 0; _ < b; _ += 1)
                    j[_] = o[_] + (c[_] - o[_]) * g;
                return j
            }
            function random(s, e) {
                if (e === void 0 && (s === void 0 ? (s = 0,
                e = 1) : (e = s,
                s = void 0)),
                e.length) {
                    var a, o = e.length;
                    s || (s = createTypedArray("float32", o));
                    var c = createTypedArray("float32", o)
                      , d = BMMath.random();
                    for (a = 0; a < o; a += 1)
                        c[a] = s[a] + d * (e[a] - s[a]);
                    return c
                }
                s === void 0 && (s = 0);
                var g = BMMath.random();
                return s + g * (e - s)
            }
            function createPath(s, e, a, o) {
                var c, d = s.length, g = shapePool.newElement();
                g.setPathData(!!o, d);
                var _ = [0, 0], b, j;
                for (c = 0; c < d; c += 1)
                    b = e && e[c] ? e[c] : _,
                    j = a && a[c] ? a[c] : _,
                    g.setTripleAt(s[c][0], s[c][1], j[0] + s[c][0], j[1] + s[c][1], b[0] + s[c][0], b[1] + s[c][1], c, !0);
                return g
            }
            function initiateExpression(elem, data, property) {
                function noOp(s) {
                    return s
                }
                if (!elem.globalData.renderConfig.runExpressions)
                    return noOp;
                var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
                thisProperty.valueAtTime = thisProperty.getValueAtTime,
                Object.defineProperty(thisProperty, "value", {
                    get: function() {
                        return thisProperty.v
                    }
                }),
                elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate,
                elem.comp.displayStartTime = 0;
                var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function s(e, a) {
                    var o, c, d = this.pv.length ? this.pv.length : 1, g = createTypedArray("float32", d);
                    e = 5;
                    var _ = Math.floor(time * e);
                    for (o = 0,
                    c = 0; o < _; ) {
                        for (c = 0; c < d; c += 1)
                            g[c] += -a + a * 2 * BMMath.random();
                        o += 1
                    }
                    var b = time * e
                      , j = b - Math.floor(b)
                      , $ = createTypedArray("float32", d);
                    if (d > 1) {
                        for (c = 0; c < d; c += 1)
                            $[c] = this.pv[c] + g[c] + (-a + a * 2 * BMMath.random()) * j;
                        return $
                    }
                    return this.pv + g[0] + (-a + a * 2 * BMMath.random()) * j
                }
                ).bind(this);
                thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty),
                loop_in = loopIn),
                thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty),
                loop_out = loopOut),
                thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));
                function loopInDuration(s, e) {
                    return loopIn(s, e, !0)
                }
                function loopOutDuration(s, e) {
                    return loopOut(s, e, !0)
                }
                this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)),
                this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
                function lookAt(s, e) {
                    var a = [e[0] - s[0], e[1] - s[1], e[2] - s[2]]
                      , o = Math.atan2(a[0], Math.sqrt(a[1] * a[1] + a[2] * a[2])) / degToRads
                      , c = -Math.atan2(a[1], a[2]) / degToRads;
                    return [c, o, 0]
                }
                function easeOut(s, e, a, o, c) {
                    return applyEase(easeOutBez, s, e, a, o, c)
                }
                function easeIn(s, e, a, o, c) {
                    return applyEase(easeInBez, s, e, a, o, c)
                }
                function ease(s, e, a, o, c) {
                    return applyEase(easeInOutBez, s, e, a, o, c)
                }
                function applyEase(s, e, a, o, c, d) {
                    c === void 0 ? (c = a,
                    d = o) : e = (e - a) / (o - a),
                    e > 1 ? e = 1 : e < 0 && (e = 0);
                    var g = s(e);
                    if ($bm_isInstanceOfArray(c)) {
                        var _, b = c.length, j = createTypedArray("float32", b);
                        for (_ = 0; _ < b; _ += 1)
                            j[_] = (d[_] - c[_]) * g + c[_];
                        return j
                    }
                    return (d - c) * g + c
                }
                function nearestKey(s) {
                    var e, a = data.k.length, o, c;
                    if (!data.k.length || typeof data.k[0] == "number")
                        o = 0,
                        c = 0;
                    else if (o = -1,
                    s *= elem.comp.globalData.frameRate,
                    s < data.k[0].t)
                        o = 1,
                        c = data.k[0].t;
                    else {
                        for (e = 0; e < a - 1; e += 1)
                            if (s === data.k[e].t) {
                                o = e + 1,
                                c = data.k[e].t;
                                break
                            } else if (s > data.k[e].t && s < data.k[e + 1].t) {
                                s - data.k[e].t > data.k[e + 1].t - s ? (o = e + 2,
                                c = data.k[e + 1].t) : (o = e + 1,
                                c = data.k[e].t);
                                break
                            }
                        o === -1 && (o = e + 1,
                        c = data.k[e].t)
                    }
                    var d = {};
                    return d.index = o,
                    d.time = c / elem.comp.globalData.frameRate,
                    d
                }
                function key(s) {
                    var e, a, o;
                    if (!data.k.length || typeof data.k[0] == "number")
                        throw new Error("The property has no keyframe at index " + s);
                    s -= 1,
                    e = {
                        time: data.k[s].t / elem.comp.globalData.frameRate,
                        value: []
                    };
                    var c = Object.prototype.hasOwnProperty.call(data.k[s], "s") ? data.k[s].s : data.k[s - 1].e;
                    for (o = c.length,
                    a = 0; a < o; a += 1)
                        e[a] = c[a],
                        e.value[a] = c[a];
                    return e
                }
                function framesToTime(s, e) {
                    return e || (e = elem.comp.globalData.frameRate),
                    s / e
                }
                function timeToFrames(s, e) {
                    return !s && s !== 0 && (s = time),
                    e || (e = elem.comp.globalData.frameRate),
                    s * e
                }
                function seedRandom(s) {
                    BMMath.seedrandom(randSeed + s)
                }
                function sourceRectAtTime() {
                    return elem.sourceRectAtTime()
                }
                function substring(s, e) {
                    return typeof value == "string" ? e === void 0 ? value.substring(s) : value.substring(s, e) : ""
                }
                function substr(s, e) {
                    return typeof value == "string" ? e === void 0 ? value.substr(s) : value.substr(s, e) : ""
                }
                function posterizeTime(s) {
                    time = s === 0 ? 0 : Math.floor(time * s) / s,
                    value = valueAtTime(time)
                }
                var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData;
                function executeExpression(s) {
                    return value = s,
                    this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex,
                    textTotal = this.textTotal,
                    selectorValue = this.selectorValue),
                    thisLayer || (text = elem.layerInterface.text,
                    thisLayer = elem.layerInterface,
                    thisComp = elem.comp.compInterface,
                    toWorld = thisLayer.toWorld.bind(thisLayer),
                    fromWorld = thisLayer.fromWorld.bind(thisLayer),
                    fromComp = thisLayer.fromComp.bind(thisLayer),
                    toComp = thisLayer.toComp.bind(thisLayer),
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null,
                    fromCompToSurface = fromComp),
                    transform || (transform = elem.layerInterface("ADBE Transform Group"),
                    $bm_transform = transform,
                    transform && (anchorPoint = transform.anchorPoint)),
                    elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    hasParent = !!(elem.hierarchy && elem.hierarchy.length),
                    hasParent && !parent && (parent = elem.hierarchy[0].layerInterface),
                    time = this.comp.renderedFrame / this.comp.globalData.frameRate,
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    this.frameExpressionId = elem.globalData.frameId,
                    scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt,
                    scoped_bm_rt)
                }
                return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData],
                executeExpression
            }
            return ob.initiateExpression = initiateExpression,
            ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal],
            ob.resetFrame = resetFrame,
            ob
        }()
          , Expressions = function() {
            var s = {};
            s.initExpressions = e,
            s.resetFrame = ExpressionManager.resetFrame;
            function e(a) {
                var o = 0
                  , c = [];
                function d() {
                    o += 1
                }
                function g() {
                    o -= 1,
                    o === 0 && b()
                }
                function _(j) {
                    c.indexOf(j) === -1 && c.push(j)
                }
                function b() {
                    var j, $ = c.length;
                    for (j = 0; j < $; j += 1)
                        c[j].release();
                    c.length = 0
                }
                a.renderer.compInterface = CompExpressionInterface(a.renderer),
                a.renderer.globalData.projectInterface.registerComposition(a.renderer),
                a.renderer.globalData.pushExpression = d,
                a.renderer.globalData.popExpression = g,
                a.renderer.globalData.registerExpressionProperty = _
            }
            return s
        }()
          , MaskManagerInterface = function() {
            function s(a, o) {
                this._mask = a,
                this._data = o
            }
            Object.defineProperty(s.prototype, "maskPath", {
                get: function() {
                    return this._mask.prop.k && this._mask.prop.getValue(),
                    this._mask.prop
                }
            }),
            Object.defineProperty(s.prototype, "maskOpacity", {
                get: function() {
                    return this._mask.op.k && this._mask.op.getValue(),
                    this._mask.op.v * 100
                }
            });
            var e = function(o) {
                var c = createSizedArray(o.viewData.length), d, g = o.viewData.length;
                for (d = 0; d < g; d += 1)
                    c[d] = new s(o.viewData[d],o.masksProperties[d]);
                var _ = function(j) {
                    for (d = 0; d < g; ) {
                        if (o.masksProperties[d].nm === j)
                            return c[d];
                        d += 1
                    }
                    return null
                };
                return _
            };
            return e
        }()
          , ExpressionPropertyInterface = function() {
            var s = {
                pv: 0,
                v: 0,
                mult: 1
            }
              , e = {
                pv: [0, 0, 0],
                v: [0, 0, 0],
                mult: 1
            };
            function a(g, _, b) {
                Object.defineProperty(g, "velocity", {
                    get: function() {
                        return _.getVelocityAtTime(_.comp.currentFrame)
                    }
                }),
                g.numKeys = _.keyframes ? _.keyframes.length : 0,
                g.key = function(j) {
                    if (!g.numKeys)
                        return 0;
                    var $ = "";
                    "s"in _.keyframes[j - 1] ? $ = _.keyframes[j - 1].s : "e"in _.keyframes[j - 2] ? $ = _.keyframes[j - 2].e : $ = _.keyframes[j - 2].s;
                    var nt = b === "unidimensional" ? new Number($) : Object.assign({}, $);
                    return nt.time = _.keyframes[j - 1].t / _.elem.comp.globalData.frameRate,
                    nt.value = b === "unidimensional" ? $[0] : $,
                    nt
                }
                ,
                g.valueAtTime = _.getValueAtTime,
                g.speedAtTime = _.getSpeedAtTime,
                g.velocityAtTime = _.getVelocityAtTime,
                g.propertyGroup = _.propertyGroup
            }
            function o(g) {
                (!g || !("pv"in g)) && (g = s);
                var _ = 1 / g.mult
                  , b = g.pv * _
                  , j = new Number(b);
                return j.value = b,
                a(j, g, "unidimensional"),
                function() {
                    return g.k && g.getValue(),
                    b = g.v * _,
                    j.value !== b && (j = new Number(b),
                    j.value = b,
                    a(j, g, "unidimensional")),
                    j
                }
            }
            function c(g) {
                (!g || !("pv"in g)) && (g = e);
                var _ = 1 / g.mult
                  , b = g.data && g.data.l || g.pv.length
                  , j = createTypedArray("float32", b)
                  , $ = createTypedArray("float32", b);
                return j.value = $,
                a(j, g, "multidimensional"),
                function() {
                    g.k && g.getValue();
                    for (var nt = 0; nt < b; nt += 1)
                        $[nt] = g.v[nt] * _,
                        j[nt] = $[nt];
                    return j
                }
            }
            function d() {
                return s
            }
            return function(g) {
                return g ? g.propType === "unidimensional" ? o(g) : c(g) : d
            }
        }()
          , TransformExpressionInterface = function() {
            return function(s) {
                function e(g) {
                    switch (g) {
                    case "scale":
                    case "Scale":
                    case "ADBE Scale":
                    case 6:
                        return e.scale;
                    case "rotation":
                    case "Rotation":
                    case "ADBE Rotation":
                    case "ADBE Rotate Z":
                    case 10:
                        return e.rotation;
                    case "ADBE Rotate X":
                        return e.xRotation;
                    case "ADBE Rotate Y":
                        return e.yRotation;
                    case "position":
                    case "Position":
                    case "ADBE Position":
                    case 2:
                        return e.position;
                    case "ADBE Position_0":
                        return e.xPosition;
                    case "ADBE Position_1":
                        return e.yPosition;
                    case "ADBE Position_2":
                        return e.zPosition;
                    case "anchorPoint":
                    case "AnchorPoint":
                    case "Anchor Point":
                    case "ADBE AnchorPoint":
                    case 1:
                        return e.anchorPoint;
                    case "opacity":
                    case "Opacity":
                    case 11:
                        return e.opacity;
                    default:
                        return null
                    }
                }
                Object.defineProperty(e, "rotation", {
                    get: ExpressionPropertyInterface(s.r || s.rz)
                }),
                Object.defineProperty(e, "zRotation", {
                    get: ExpressionPropertyInterface(s.rz || s.r)
                }),
                Object.defineProperty(e, "xRotation", {
                    get: ExpressionPropertyInterface(s.rx)
                }),
                Object.defineProperty(e, "yRotation", {
                    get: ExpressionPropertyInterface(s.ry)
                }),
                Object.defineProperty(e, "scale", {
                    get: ExpressionPropertyInterface(s.s)
                });
                var a, o, c, d;
                return s.p ? d = ExpressionPropertyInterface(s.p) : (a = ExpressionPropertyInterface(s.px),
                o = ExpressionPropertyInterface(s.py),
                s.pz && (c = ExpressionPropertyInterface(s.pz))),
                Object.defineProperty(e, "position", {
                    get: function() {
                        return s.p ? d() : [a(), o(), c ? c() : 0]
                    }
                }),
                Object.defineProperty(e, "xPosition", {
                    get: ExpressionPropertyInterface(s.px)
                }),
                Object.defineProperty(e, "yPosition", {
                    get: ExpressionPropertyInterface(s.py)
                }),
                Object.defineProperty(e, "zPosition", {
                    get: ExpressionPropertyInterface(s.pz)
                }),
                Object.defineProperty(e, "anchorPoint", {
                    get: ExpressionPropertyInterface(s.a)
                }),
                Object.defineProperty(e, "opacity", {
                    get: ExpressionPropertyInterface(s.o)
                }),
                Object.defineProperty(e, "skew", {
                    get: ExpressionPropertyInterface(s.sk)
                }),
                Object.defineProperty(e, "skewAxis", {
                    get: ExpressionPropertyInterface(s.sa)
                }),
                Object.defineProperty(e, "orientation", {
                    get: ExpressionPropertyInterface(s.or)
                }),
                e
            }
        }()
          , LayerExpressionInterface = function() {
            function s(j) {
                var $ = new Matrix;
                if (j !== void 0) {
                    var nt = this._elem.finalTransform.mProp.getValueAtTime(j);
                    nt.clone($)
                } else {
                    var tt = this._elem.finalTransform.mProp;
                    tt.applyToMatrix($)
                }
                return $
            }
            function e(j, $) {
                var nt = this.getMatrix($);
                return nt.props[12] = 0,
                nt.props[13] = 0,
                nt.props[14] = 0,
                this.applyPoint(nt, j)
            }
            function a(j, $) {
                var nt = this.getMatrix($);
                return this.applyPoint(nt, j)
            }
            function o(j, $) {
                var nt = this.getMatrix($);
                return nt.props[12] = 0,
                nt.props[13] = 0,
                nt.props[14] = 0,
                this.invertPoint(nt, j)
            }
            function c(j, $) {
                var nt = this.getMatrix($);
                return this.invertPoint(nt, j)
            }
            function d(j, $) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var nt, tt = this._elem.hierarchy.length;
                    for (nt = 0; nt < tt; nt += 1)
                        this._elem.hierarchy[nt].finalTransform.mProp.applyToMatrix(j)
                }
                return j.applyToPointArray($[0], $[1], $[2] || 0)
            }
            function g(j, $) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var nt, tt = this._elem.hierarchy.length;
                    for (nt = 0; nt < tt; nt += 1)
                        this._elem.hierarchy[nt].finalTransform.mProp.applyToMatrix(j)
                }
                return j.inversePoint($)
            }
            function _(j) {
                var $ = new Matrix;
                if ($.reset(),
                this._elem.finalTransform.mProp.applyToMatrix($),
                this._elem.hierarchy && this._elem.hierarchy.length) {
                    var nt, tt = this._elem.hierarchy.length;
                    for (nt = 0; nt < tt; nt += 1)
                        this._elem.hierarchy[nt].finalTransform.mProp.applyToMatrix($);
                    return $.inversePoint(j)
                }
                return $.inversePoint(j)
            }
            function b() {
                return [1, 1, 1, 1]
            }
            return function(j) {
                var $;
                function nt(lt) {
                    rt.mask = new MaskManagerInterface(lt,j)
                }
                function tt(lt) {
                    rt.effect = lt
                }
                function rt(lt) {
                    switch (lt) {
                    case "ADBE Root Vectors Group":
                    case "Contents":
                    case 2:
                        return rt.shapeInterface;
                    case 1:
                    case 6:
                    case "Transform":
                    case "transform":
                    case "ADBE Transform Group":
                        return $;
                    case 4:
                    case "ADBE Effect Parade":
                    case "effects":
                    case "Effects":
                        return rt.effect;
                    case "ADBE Text Properties":
                        return rt.textInterface;
                    default:
                        return null
                    }
                }
                rt.getMatrix = s,
                rt.invertPoint = g,
                rt.applyPoint = d,
                rt.toWorld = a,
                rt.toWorldVec = e,
                rt.fromWorld = c,
                rt.fromWorldVec = o,
                rt.toComp = a,
                rt.fromComp = _,
                rt.sampleImage = b,
                rt.sourceRectAtTime = j.sourceRectAtTime.bind(j),
                rt._elem = j,
                $ = TransformExpressionInterface(j.finalTransform.mProp);
                var st = getDescriptor($, "anchorPoint");
                return Object.defineProperties(rt, {
                    hasParent: {
                        get: function() {
                            return j.hierarchy.length
                        }
                    },
                    parent: {
                        get: function() {
                            return j.hierarchy[0].layerInterface
                        }
                    },
                    rotation: getDescriptor($, "rotation"),
                    scale: getDescriptor($, "scale"),
                    position: getDescriptor($, "position"),
                    opacity: getDescriptor($, "opacity"),
                    anchorPoint: st,
                    anchor_point: st,
                    transform: {
                        get: function() {
                            return $
                        }
                    },
                    active: {
                        get: function() {
                            return j.isInRange
                        }
                    }
                }),
                rt.startTime = j.data.st,
                rt.index = j.data.ind,
                rt.source = j.data.refId,
                rt.height = j.data.ty === 0 ? j.data.h : 100,
                rt.width = j.data.ty === 0 ? j.data.w : 100,
                rt.inPoint = j.data.ip / j.comp.globalData.frameRate,
                rt.outPoint = j.data.op / j.comp.globalData.frameRate,
                rt._name = j.data.nm,
                rt.registerMaskInterface = nt,
                rt.registerEffectsInterface = tt,
                rt
            }
        }()
          , propertyGroupFactory = function() {
            return function(s, e) {
                return function(a) {
                    return a = a === void 0 ? 1 : a,
                    a <= 0 ? s : e(a - 1)
                }
            }
        }()
          , PropertyInterface = function() {
            return function(s, e) {
                var a = {
                    _name: s
                };
                function o(c) {
                    return c = c === void 0 ? 1 : c,
                    c <= 0 ? a : e(c - 1)
                }
                return o
            }
        }()
          , EffectsExpressionInterface = function() {
            var s = {
                createEffectsInterface: e
            };
            function e(c, d) {
                if (c.effectsManager) {
                    var g = [], _ = c.data.ef, b, j = c.effectsManager.effectElements.length;
                    for (b = 0; b < j; b += 1)
                        g.push(a(_[b], c.effectsManager.effectElements[b], d, c));
                    var $ = c.data.ef || []
                      , nt = function(rt) {
                        for (b = 0,
                        j = $.length; b < j; ) {
                            if (rt === $[b].nm || rt === $[b].mn || rt === $[b].ix)
                                return g[b];
                            b += 1
                        }
                        return null
                    };
                    return Object.defineProperty(nt, "numProperties", {
                        get: function() {
                            return $.length
                        }
                    }),
                    nt
                }
                return null
            }
            function a(c, d, g, _) {
                function b(rt) {
                    for (var st = c.ef, lt = 0, ct = st.length; lt < ct; ) {
                        if (rt === st[lt].nm || rt === st[lt].mn || rt === st[lt].ix)
                            return st[lt].ty === 5 ? $[lt] : $[lt]();
                        lt += 1
                    }
                    throw new Error
                }
                var j = propertyGroupFactory(b, g), $ = [], nt, tt = c.ef.length;
                for (nt = 0; nt < tt; nt += 1)
                    c.ef[nt].ty === 5 ? $.push(a(c.ef[nt], d.effectElements[nt], d.effectElements[nt].propertyGroup, _)) : $.push(o(d.effectElements[nt], c.ef[nt].ty, _, j));
                return c.mn === "ADBE Color Control" && Object.defineProperty(b, "color", {
                    get: function() {
                        return $[0]()
                    }
                }),
                Object.defineProperties(b, {
                    numProperties: {
                        get: function() {
                            return c.np
                        }
                    },
                    _name: {
                        value: c.nm
                    },
                    propertyGroup: {
                        value: j
                    }
                }),
                b.enabled = c.en !== 0,
                b.active = b.enabled,
                b
            }
            function o(c, d, g, _) {
                var b = ExpressionPropertyInterface(c.p);
                function j() {
                    return d === 10 ? g.comp.compInterface(c.p.v) : b()
                }
                return c.p.setGroupProperty && c.p.setGroupProperty(PropertyInterface("", _)),
                j
            }
            return s
        }()
          , ShapePathInterface = function() {
            return function(e, a, o) {
                var c = a.sh;
                function d(_) {
                    return _ === "Shape" || _ === "shape" || _ === "Path" || _ === "path" || _ === "ADBE Vector Shape" || _ === 2 ? d.path : null
                }
                var g = propertyGroupFactory(d, o);
                return c.setGroupProperty(PropertyInterface("Path", g)),
                Object.defineProperties(d, {
                    path: {
                        get: function() {
                            return c.k && c.getValue(),
                            c
                        }
                    },
                    shape: {
                        get: function() {
                            return c.k && c.getValue(),
                            c
                        }
                    },
                    _name: {
                        value: e.nm
                    },
                    ix: {
                        value: e.ix
                    },
                    propertyIndex: {
                        value: e.ix
                    },
                    mn: {
                        value: e.mn
                    },
                    propertyGroup: {
                        value: o
                    }
                }),
                d
            }
        }()
          , ShapeExpressionInterface = function() {
            function s(st, lt, ct) {
                var it = [], ot, at = st ? st.length : 0;
                for (ot = 0; ot < at; ot += 1)
                    st[ot].ty === "gr" ? it.push(a(st[ot], lt[ot], ct)) : st[ot].ty === "fl" ? it.push(o(st[ot], lt[ot], ct)) : st[ot].ty === "st" ? it.push(g(st[ot], lt[ot], ct)) : st[ot].ty === "tm" ? it.push(_(st[ot], lt[ot], ct)) : st[ot].ty === "tr" || (st[ot].ty === "el" ? it.push(j(st[ot], lt[ot], ct)) : st[ot].ty === "sr" ? it.push($(st[ot], lt[ot], ct)) : st[ot].ty === "sh" ? it.push(ShapePathInterface(st[ot], lt[ot], ct)) : st[ot].ty === "rc" ? it.push(nt(st[ot], lt[ot], ct)) : st[ot].ty === "rd" ? it.push(tt(st[ot], lt[ot], ct)) : st[ot].ty === "rp" ? it.push(rt(st[ot], lt[ot], ct)) : st[ot].ty === "gf" ? it.push(c(st[ot], lt[ot], ct)) : it.push(d(st[ot], lt[ot])));
                return it
            }
            function e(st, lt, ct) {
                var it, ot = function(pt) {
                    for (var dt = 0, yt = it.length; dt < yt; ) {
                        if (it[dt]._name === pt || it[dt].mn === pt || it[dt].propertyIndex === pt || it[dt].ix === pt || it[dt].ind === pt)
                            return it[dt];
                        dt += 1
                    }
                    return typeof pt == "number" ? it[pt - 1] : null
                };
                ot.propertyGroup = propertyGroupFactory(ot, ct),
                it = s(st.it, lt.it, ot.propertyGroup),
                ot.numProperties = it.length;
                var at = b(st.it[st.it.length - 1], lt.it[lt.it.length - 1], ot.propertyGroup);
                return ot.transform = at,
                ot.propertyIndex = st.cix,
                ot._name = st.nm,
                ot
            }
            function a(st, lt, ct) {
                var it = function(pt) {
                    switch (pt) {
                    case "ADBE Vectors Group":
                    case "Contents":
                    case 2:
                        return it.content;
                    default:
                        return it.transform
                    }
                };
                it.propertyGroup = propertyGroupFactory(it, ct);
                var ot = e(st, lt, it.propertyGroup)
                  , at = b(st.it[st.it.length - 1], lt.it[lt.it.length - 1], it.propertyGroup);
                return it.content = ot,
                it.transform = at,
                Object.defineProperty(it, "_name", {
                    get: function() {
                        return st.nm
                    }
                }),
                it.numProperties = st.np,
                it.propertyIndex = st.ix,
                it.nm = st.nm,
                it.mn = st.mn,
                it
            }
            function o(st, lt, ct) {
                function it(ot) {
                    return ot === "Color" || ot === "color" ? it.color : ot === "Opacity" || ot === "opacity" ? it.opacity : null
                }
                return Object.defineProperties(it, {
                    color: {
                        get: ExpressionPropertyInterface(lt.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(lt.o)
                    },
                    _name: {
                        value: st.nm
                    },
                    mn: {
                        value: st.mn
                    }
                }),
                lt.c.setGroupProperty(PropertyInterface("Color", ct)),
                lt.o.setGroupProperty(PropertyInterface("Opacity", ct)),
                it
            }
            function c(st, lt, ct) {
                function it(ot) {
                    return ot === "Start Point" || ot === "start point" ? it.startPoint : ot === "End Point" || ot === "end point" ? it.endPoint : ot === "Opacity" || ot === "opacity" ? it.opacity : null
                }
                return Object.defineProperties(it, {
                    startPoint: {
                        get: ExpressionPropertyInterface(lt.s)
                    },
                    endPoint: {
                        get: ExpressionPropertyInterface(lt.e)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(lt.o)
                    },
                    type: {
                        get: function() {
                            return "a"
                        }
                    },
                    _name: {
                        value: st.nm
                    },
                    mn: {
                        value: st.mn
                    }
                }),
                lt.s.setGroupProperty(PropertyInterface("Start Point", ct)),
                lt.e.setGroupProperty(PropertyInterface("End Point", ct)),
                lt.o.setGroupProperty(PropertyInterface("Opacity", ct)),
                it
            }
            function d() {
                function st() {
                    return null
                }
                return st
            }
            function g(st, lt, ct) {
                var it = propertyGroupFactory(yt, ct)
                  , ot = propertyGroupFactory(dt, it);
                function at(vt) {
                    Object.defineProperty(dt, st.d[vt].nm, {
                        get: ExpressionPropertyInterface(lt.d.dataProps[vt].p)
                    })
                }
                var ht, pt = st.d ? st.d.length : 0, dt = {};
                for (ht = 0; ht < pt; ht += 1)
                    at(ht),
                    lt.d.dataProps[ht].p.setGroupProperty(ot);
                function yt(vt) {
                    return vt === "Color" || vt === "color" ? yt.color : vt === "Opacity" || vt === "opacity" ? yt.opacity : vt === "Stroke Width" || vt === "stroke width" ? yt.strokeWidth : null
                }
                return Object.defineProperties(yt, {
                    color: {
                        get: ExpressionPropertyInterface(lt.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(lt.o)
                    },
                    strokeWidth: {
                        get: ExpressionPropertyInterface(lt.w)
                    },
                    dash: {
                        get: function() {
                            return dt
                        }
                    },
                    _name: {
                        value: st.nm
                    },
                    mn: {
                        value: st.mn
                    }
                }),
                lt.c.setGroupProperty(PropertyInterface("Color", it)),
                lt.o.setGroupProperty(PropertyInterface("Opacity", it)),
                lt.w.setGroupProperty(PropertyInterface("Stroke Width", it)),
                yt
            }
            function _(st, lt, ct) {
                function it(at) {
                    return at === st.e.ix || at === "End" || at === "end" ? it.end : at === st.s.ix ? it.start : at === st.o.ix ? it.offset : null
                }
                var ot = propertyGroupFactory(it, ct);
                return it.propertyIndex = st.ix,
                lt.s.setGroupProperty(PropertyInterface("Start", ot)),
                lt.e.setGroupProperty(PropertyInterface("End", ot)),
                lt.o.setGroupProperty(PropertyInterface("Offset", ot)),
                it.propertyIndex = st.ix,
                it.propertyGroup = ct,
                Object.defineProperties(it, {
                    start: {
                        get: ExpressionPropertyInterface(lt.s)
                    },
                    end: {
                        get: ExpressionPropertyInterface(lt.e)
                    },
                    offset: {
                        get: ExpressionPropertyInterface(lt.o)
                    },
                    _name: {
                        value: st.nm
                    }
                }),
                it.mn = st.mn,
                it
            }
            function b(st, lt, ct) {
                function it(at) {
                    return st.a.ix === at || at === "Anchor Point" ? it.anchorPoint : st.o.ix === at || at === "Opacity" ? it.opacity : st.p.ix === at || at === "Position" ? it.position : st.r.ix === at || at === "Rotation" || at === "ADBE Vector Rotation" ? it.rotation : st.s.ix === at || at === "Scale" ? it.scale : st.sk && st.sk.ix === at || at === "Skew" ? it.skew : st.sa && st.sa.ix === at || at === "Skew Axis" ? it.skewAxis : null
                }
                var ot = propertyGroupFactory(it, ct);
                return lt.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", ot)),
                lt.transform.mProps.p.setGroupProperty(PropertyInterface("Position", ot)),
                lt.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", ot)),
                lt.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", ot)),
                lt.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", ot)),
                lt.transform.mProps.sk && (lt.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", ot)),
                lt.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", ot))),
                lt.transform.op.setGroupProperty(PropertyInterface("Opacity", ot)),
                Object.defineProperties(it, {
                    opacity: {
                        get: ExpressionPropertyInterface(lt.transform.mProps.o)
                    },
                    position: {
                        get: ExpressionPropertyInterface(lt.transform.mProps.p)
                    },
                    anchorPoint: {
                        get: ExpressionPropertyInterface(lt.transform.mProps.a)
                    },
                    scale: {
                        get: ExpressionPropertyInterface(lt.transform.mProps.s)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(lt.transform.mProps.r)
                    },
                    skew: {
                        get: ExpressionPropertyInterface(lt.transform.mProps.sk)
                    },
                    skewAxis: {
                        get: ExpressionPropertyInterface(lt.transform.mProps.sa)
                    },
                    _name: {
                        value: st.nm
                    }
                }),
                it.ty = "tr",
                it.mn = st.mn,
                it.propertyGroup = ct,
                it
            }
            function j(st, lt, ct) {
                function it(ht) {
                    return st.p.ix === ht ? it.position : st.s.ix === ht ? it.size : null
                }
                var ot = propertyGroupFactory(it, ct);
                it.propertyIndex = st.ix;
                var at = lt.sh.ty === "tm" ? lt.sh.prop : lt.sh;
                return at.s.setGroupProperty(PropertyInterface("Size", ot)),
                at.p.setGroupProperty(PropertyInterface("Position", ot)),
                Object.defineProperties(it, {
                    size: {
                        get: ExpressionPropertyInterface(at.s)
                    },
                    position: {
                        get: ExpressionPropertyInterface(at.p)
                    },
                    _name: {
                        value: st.nm
                    }
                }),
                it.mn = st.mn,
                it
            }
            function $(st, lt, ct) {
                function it(ht) {
                    return st.p.ix === ht ? it.position : st.r.ix === ht ? it.rotation : st.pt.ix === ht ? it.points : st.or.ix === ht || ht === "ADBE Vector Star Outer Radius" ? it.outerRadius : st.os.ix === ht ? it.outerRoundness : st.ir && (st.ir.ix === ht || ht === "ADBE Vector Star Inner Radius") ? it.innerRadius : st.is && st.is.ix === ht ? it.innerRoundness : null
                }
                var ot = propertyGroupFactory(it, ct)
                  , at = lt.sh.ty === "tm" ? lt.sh.prop : lt.sh;
                return it.propertyIndex = st.ix,
                at.or.setGroupProperty(PropertyInterface("Outer Radius", ot)),
                at.os.setGroupProperty(PropertyInterface("Outer Roundness", ot)),
                at.pt.setGroupProperty(PropertyInterface("Points", ot)),
                at.p.setGroupProperty(PropertyInterface("Position", ot)),
                at.r.setGroupProperty(PropertyInterface("Rotation", ot)),
                st.ir && (at.ir.setGroupProperty(PropertyInterface("Inner Radius", ot)),
                at.is.setGroupProperty(PropertyInterface("Inner Roundness", ot))),
                Object.defineProperties(it, {
                    position: {
                        get: ExpressionPropertyInterface(at.p)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(at.r)
                    },
                    points: {
                        get: ExpressionPropertyInterface(at.pt)
                    },
                    outerRadius: {
                        get: ExpressionPropertyInterface(at.or)
                    },
                    outerRoundness: {
                        get: ExpressionPropertyInterface(at.os)
                    },
                    innerRadius: {
                        get: ExpressionPropertyInterface(at.ir)
                    },
                    innerRoundness: {
                        get: ExpressionPropertyInterface(at.is)
                    },
                    _name: {
                        value: st.nm
                    }
                }),
                it.mn = st.mn,
                it
            }
            function nt(st, lt, ct) {
                function it(ht) {
                    return st.p.ix === ht ? it.position : st.r.ix === ht ? it.roundness : st.s.ix === ht || ht === "Size" || ht === "ADBE Vector Rect Size" ? it.size : null
                }
                var ot = propertyGroupFactory(it, ct)
                  , at = lt.sh.ty === "tm" ? lt.sh.prop : lt.sh;
                return it.propertyIndex = st.ix,
                at.p.setGroupProperty(PropertyInterface("Position", ot)),
                at.s.setGroupProperty(PropertyInterface("Size", ot)),
                at.r.setGroupProperty(PropertyInterface("Rotation", ot)),
                Object.defineProperties(it, {
                    position: {
                        get: ExpressionPropertyInterface(at.p)
                    },
                    roundness: {
                        get: ExpressionPropertyInterface(at.r)
                    },
                    size: {
                        get: ExpressionPropertyInterface(at.s)
                    },
                    _name: {
                        value: st.nm
                    }
                }),
                it.mn = st.mn,
                it
            }
            function tt(st, lt, ct) {
                function it(ht) {
                    return st.r.ix === ht || ht === "Round Corners 1" ? it.radius : null
                }
                var ot = propertyGroupFactory(it, ct)
                  , at = lt;
                return it.propertyIndex = st.ix,
                at.rd.setGroupProperty(PropertyInterface("Radius", ot)),
                Object.defineProperties(it, {
                    radius: {
                        get: ExpressionPropertyInterface(at.rd)
                    },
                    _name: {
                        value: st.nm
                    }
                }),
                it.mn = st.mn,
                it
            }
            function rt(st, lt, ct) {
                function it(ht) {
                    return st.c.ix === ht || ht === "Copies" ? it.copies : st.o.ix === ht || ht === "Offset" ? it.offset : null
                }
                var ot = propertyGroupFactory(it, ct)
                  , at = lt;
                return it.propertyIndex = st.ix,
                at.c.setGroupProperty(PropertyInterface("Copies", ot)),
                at.o.setGroupProperty(PropertyInterface("Offset", ot)),
                Object.defineProperties(it, {
                    copies: {
                        get: ExpressionPropertyInterface(at.c)
                    },
                    offset: {
                        get: ExpressionPropertyInterface(at.o)
                    },
                    _name: {
                        value: st.nm
                    }
                }),
                it.mn = st.mn,
                it
            }
            return function(st, lt, ct) {
                var it;
                function ot(ht) {
                    if (typeof ht == "number")
                        return ht = ht === void 0 ? 1 : ht,
                        ht === 0 ? ct : it[ht - 1];
                    for (var pt = 0, dt = it.length; pt < dt; ) {
                        if (it[pt]._name === ht)
                            return it[pt];
                        pt += 1
                    }
                    return null
                }
                function at() {
                    return ct
                }
                return ot.propertyGroup = propertyGroupFactory(ot, at),
                it = s(st, lt, ot.propertyGroup),
                ot.numProperties = it.length,
                ot._name = "Contents",
                ot
            }
        }()
          , TextExpressionInterface = function() {
            return function(s) {
                var e;
                function a(o) {
                    switch (o) {
                    case "ADBE Text Document":
                        return a.sourceText;
                    default:
                        return null
                    }
                }
                return Object.defineProperty(a, "sourceText", {
                    get: function() {
                        s.textProperty.getValue();
                        var c = s.textProperty.currentData.t;
                        return (!e || c !== e.value) && (e = new String(c),
                        e.value = c || new String(c),
                        Object.defineProperty(e, "style", {
                            get: function() {
                                return {
                                    fillColor: s.textProperty.currentData.fc
                                }
                            }
                        })),
                        e
                    }
                }),
                a
            }
        }();
        function _typeof(s) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(a) {
                return typeof a
            }
            : _typeof = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            _typeof(s)
        }
        var FootageInterface = function() {
            var s = function(o) {
                var c = ""
                  , d = o.getFootageData();
                function g() {
                    return c = "",
                    d = o.getFootageData(),
                    _
                }
                function _(b) {
                    if (d[b])
                        return c = b,
                        d = d[b],
                        _typeof(d) === "object" ? _ : d;
                    var j = b.indexOf(c);
                    if (j !== -1) {
                        var $ = parseInt(b.substr(j + c.length), 10);
                        return d = d[$],
                        _typeof(d) === "object" ? _ : d
                    }
                    return ""
                }
                return g
            }
              , e = function(o) {
                function c(d) {
                    return d === "Outline" ? c.outlineInterface() : null
                }
                return c._name = "Outline",
                c.outlineInterface = s(o),
                c
            };
            return function(a) {
                function o(c) {
                    return c === "Data" ? o.dataInterface : null
                }
                return o._name = "Data",
                o.dataInterface = e(a),
                o
            }
        }()
          , interfaces = {
            layer: LayerExpressionInterface,
            effects: EffectsExpressionInterface,
            comp: CompExpressionInterface,
            shape: ShapeExpressionInterface,
            text: TextExpressionInterface,
            footage: FootageInterface
        };
        function getInterface(s) {
            return interfaces[s] || null
        }
        var expressionHelpers = function() {
            function s(g, _, b) {
                _.x && (b.k = !0,
                b.x = !0,
                b.initiateExpression = ExpressionManager.initiateExpression,
                b.effectsSequence.push(b.initiateExpression(g, _, b).bind(b)))
            }
            function e(g) {
                return g *= this.elem.globalData.frameRate,
                g -= this.offsetTime,
                g !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < g ? this._cachingAtTime.lastIndex : 0,
                this._cachingAtTime.value = this.interpolateValue(g, this._cachingAtTime),
                this._cachingAtTime.lastFrame = g),
                this._cachingAtTime.value
            }
            function a(g) {
                var _ = -.01
                  , b = this.getValueAtTime(g)
                  , j = this.getValueAtTime(g + _)
                  , $ = 0;
                if (b.length) {
                    var nt;
                    for (nt = 0; nt < b.length; nt += 1)
                        $ += Math.pow(j[nt] - b[nt], 2);
                    $ = Math.sqrt($) * 100
                } else
                    $ = 0;
                return $
            }
            function o(g) {
                if (this.vel !== void 0)
                    return this.vel;
                var _ = -.001, b = this.getValueAtTime(g), j = this.getValueAtTime(g + _), $;
                if (b.length) {
                    $ = createTypedArray("float32", b.length);
                    var nt;
                    for (nt = 0; nt < b.length; nt += 1)
                        $[nt] = (j[nt] - b[nt]) / _
                } else
                    $ = (j - b) / _;
                return $
            }
            function c() {
                return this.pv
            }
            function d(g) {
                this.propertyGroup = g
            }
            return {
                searchExpressions: s,
                getSpeedAtTime: a,
                getVelocityAtTime: o,
                getValueAtTime: e,
                getStaticValueAtTime: c,
                setGroupProperty: d
            }
        }();
        function addPropertyDecorator() {
            function s(tt, rt, st) {
                if (!this.k || !this.keyframes)
                    return this.pv;
                tt = tt ? tt.toLowerCase() : "";
                var lt = this.comp.renderedFrame
                  , ct = this.keyframes
                  , it = ct[ct.length - 1].t;
                if (lt <= it)
                    return this.pv;
                var ot, at;
                st ? (rt ? ot = Math.abs(it - this.elem.comp.globalData.frameRate * rt) : ot = Math.max(0, it - this.elem.data.ip),
                at = it - ot) : ((!rt || rt > ct.length - 1) && (rt = ct.length - 1),
                at = ct[ct.length - 1 - rt].t,
                ot = it - at);
                var ht, pt, dt;
                if (tt === "pingpong") {
                    var yt = Math.floor((lt - at) / ot);
                    if (yt % 2 !== 0)
                        return this.getValueAtTime((ot - (lt - at) % ot + at) / this.comp.globalData.frameRate, 0)
                } else if (tt === "offset") {
                    var vt = this.getValueAtTime(at / this.comp.globalData.frameRate, 0)
                      , xt = this.getValueAtTime(it / this.comp.globalData.frameRate, 0)
                      , _t = this.getValueAtTime(((lt - at) % ot + at) / this.comp.globalData.frameRate, 0)
                      , bt = Math.floor((lt - at) / ot);
                    if (this.pv.length) {
                        for (dt = new Array(vt.length),
                        pt = dt.length,
                        ht = 0; ht < pt; ht += 1)
                            dt[ht] = (xt[ht] - vt[ht]) * bt + _t[ht];
                        return dt
                    }
                    return (xt - vt) * bt + _t
                } else if (tt === "continue") {
                    var Rt = this.getValueAtTime(it / this.comp.globalData.frameRate, 0)
                      , Ft = this.getValueAtTime((it - .001) / this.comp.globalData.frameRate, 0);
                    if (this.pv.length) {
                        for (dt = new Array(Rt.length),
                        pt = dt.length,
                        ht = 0; ht < pt; ht += 1)
                            dt[ht] = Rt[ht] + (Rt[ht] - Ft[ht]) * ((lt - it) / this.comp.globalData.frameRate) / 5e-4;
                        return dt
                    }
                    return Rt + (Rt - Ft) * ((lt - it) / .001)
                }
                return this.getValueAtTime(((lt - at) % ot + at) / this.comp.globalData.frameRate, 0)
            }
            function e(tt, rt, st) {
                if (!this.k)
                    return this.pv;
                tt = tt ? tt.toLowerCase() : "";
                var lt = this.comp.renderedFrame
                  , ct = this.keyframes
                  , it = ct[0].t;
                if (lt >= it)
                    return this.pv;
                var ot, at;
                st ? (rt ? ot = Math.abs(this.elem.comp.globalData.frameRate * rt) : ot = Math.max(0, this.elem.data.op - it),
                at = it + ot) : ((!rt || rt > ct.length - 1) && (rt = ct.length - 1),
                at = ct[rt].t,
                ot = at - it);
                var ht, pt, dt;
                if (tt === "pingpong") {
                    var yt = Math.floor((it - lt) / ot);
                    if (yt % 2 === 0)
                        return this.getValueAtTime(((it - lt) % ot + it) / this.comp.globalData.frameRate, 0)
                } else if (tt === "offset") {
                    var vt = this.getValueAtTime(it / this.comp.globalData.frameRate, 0)
                      , xt = this.getValueAtTime(at / this.comp.globalData.frameRate, 0)
                      , _t = this.getValueAtTime((ot - (it - lt) % ot + it) / this.comp.globalData.frameRate, 0)
                      , bt = Math.floor((it - lt) / ot) + 1;
                    if (this.pv.length) {
                        for (dt = new Array(vt.length),
                        pt = dt.length,
                        ht = 0; ht < pt; ht += 1)
                            dt[ht] = _t[ht] - (xt[ht] - vt[ht]) * bt;
                        return dt
                    }
                    return _t - (xt - vt) * bt
                } else if (tt === "continue") {
                    var Rt = this.getValueAtTime(it / this.comp.globalData.frameRate, 0)
                      , Ft = this.getValueAtTime((it + .001) / this.comp.globalData.frameRate, 0);
                    if (this.pv.length) {
                        for (dt = new Array(Rt.length),
                        pt = dt.length,
                        ht = 0; ht < pt; ht += 1)
                            dt[ht] = Rt[ht] + (Rt[ht] - Ft[ht]) * (it - lt) / .001;
                        return dt
                    }
                    return Rt + (Rt - Ft) * (it - lt) / .001
                }
                return this.getValueAtTime((ot - ((it - lt) % ot + it)) / this.comp.globalData.frameRate, 0)
            }
            function a(tt, rt) {
                if (!this.k)
                    return this.pv;
                if (tt = (tt || .4) * .5,
                rt = Math.floor(rt || 5),
                rt <= 1)
                    return this.pv;
                var st = this.comp.renderedFrame / this.comp.globalData.frameRate, lt = st - tt, ct = st + tt, it = rt > 1 ? (ct - lt) / (rt - 1) : 1, ot = 0, at = 0, ht;
                this.pv.length ? ht = createTypedArray("float32", this.pv.length) : ht = 0;
                for (var pt; ot < rt; ) {
                    if (pt = this.getValueAtTime(lt + ot * it),
                    this.pv.length)
                        for (at = 0; at < this.pv.length; at += 1)
                            ht[at] += pt[at];
                    else
                        ht += pt;
                    ot += 1
                }
                if (this.pv.length)
                    for (at = 0; at < this.pv.length; at += 1)
                        ht[at] /= rt;
                else
                    ht /= rt;
                return ht
            }
            function o(tt) {
                this._transformCachingAtTime || (this._transformCachingAtTime = {
                    v: new Matrix
                });
                var rt = this._transformCachingAtTime.v;
                if (rt.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1) {
                    var st = this.a.getValueAtTime(tt);
                    rt.translate(-st[0] * this.a.mult, -st[1] * this.a.mult, st[2] * this.a.mult)
                }
                if (this.appliedTransformations < 2) {
                    var lt = this.s.getValueAtTime(tt);
                    rt.scale(lt[0] * this.s.mult, lt[1] * this.s.mult, lt[2] * this.s.mult)
                }
                if (this.sk && this.appliedTransformations < 3) {
                    var ct = this.sk.getValueAtTime(tt)
                      , it = this.sa.getValueAtTime(tt);
                    rt.skewFromAxis(-ct * this.sk.mult, it * this.sa.mult)
                }
                if (this.r && this.appliedTransformations < 4) {
                    var ot = this.r.getValueAtTime(tt);
                    rt.rotate(-ot * this.r.mult)
                } else if (!this.r && this.appliedTransformations < 4) {
                    var at = this.rz.getValueAtTime(tt)
                      , ht = this.ry.getValueAtTime(tt)
                      , pt = this.rx.getValueAtTime(tt)
                      , dt = this.or.getValueAtTime(tt);
                    rt.rotateZ(-at * this.rz.mult).rotateY(ht * this.ry.mult).rotateX(pt * this.rx.mult).rotateZ(-dt[2] * this.or.mult).rotateY(dt[1] * this.or.mult).rotateX(dt[0] * this.or.mult)
                }
                if (this.data.p && this.data.p.s) {
                    var yt = this.px.getValueAtTime(tt)
                      , vt = this.py.getValueAtTime(tt);
                    if (this.data.p.z) {
                        var xt = this.pz.getValueAtTime(tt);
                        rt.translate(yt * this.px.mult, vt * this.py.mult, -xt * this.pz.mult)
                    } else
                        rt.translate(yt * this.px.mult, vt * this.py.mult, 0)
                } else {
                    var _t = this.p.getValueAtTime(tt);
                    rt.translate(_t[0] * this.p.mult, _t[1] * this.p.mult, -_t[2] * this.p.mult)
                }
                return rt
            }
            function c() {
                return this.v.clone(new Matrix)
            }
            var d = TransformPropertyFactory.getTransformProperty;
            TransformPropertyFactory.getTransformProperty = function(tt, rt, st) {
                var lt = d(tt, rt, st);
                return lt.dynamicProperties.length ? lt.getValueAtTime = o.bind(lt) : lt.getValueAtTime = c.bind(lt),
                lt.setGroupProperty = expressionHelpers.setGroupProperty,
                lt
            }
            ;
            var g = PropertyFactory.getProp;
            PropertyFactory.getProp = function(tt, rt, st, lt, ct) {
                var it = g(tt, rt, st, lt, ct);
                it.kf ? it.getValueAtTime = expressionHelpers.getValueAtTime.bind(it) : it.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(it),
                it.setGroupProperty = expressionHelpers.setGroupProperty,
                it.loopOut = s,
                it.loopIn = e,
                it.smooth = a,
                it.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(it),
                it.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(it),
                it.numKeys = rt.a === 1 ? rt.k.length : 0,
                it.propertyIndex = rt.ix;
                var ot = 0;
                return st !== 0 && (ot = createTypedArray("float32", rt.a === 1 ? rt.k[0].s.length : rt.k.length)),
                it._cachingAtTime = {
                    lastFrame: initialDefaultFrame,
                    lastIndex: 0,
                    value: ot
                },
                expressionHelpers.searchExpressions(tt, rt, it),
                it.k && ct.addDynamicProperty(it),
                it
            }
            ;
            function _(tt) {
                return this._cachingAtTime || (this._cachingAtTime = {
                    shapeValue: shapePool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                }),
                tt *= this.elem.globalData.frameRate,
                tt -= this.offsetTime,
                tt !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < tt ? this._caching.lastIndex : 0,
                this._cachingAtTime.lastTime = tt,
                this.interpolateShape(tt, this._cachingAtTime.shapeValue, this._cachingAtTime)),
                this._cachingAtTime.shapeValue
            }
            var b = ShapePropertyFactory.getConstructorFunction()
              , j = ShapePropertyFactory.getKeyframedConstructorFunction();
            function $() {}
            $.prototype = {
                vertices: function(rt, st) {
                    this.k && this.getValue();
                    var lt = this.v;
                    st !== void 0 && (lt = this.getValueAtTime(st, 0));
                    var ct, it = lt._length, ot = lt[rt], at = lt.v, ht = createSizedArray(it);
                    for (ct = 0; ct < it; ct += 1)
                        rt === "i" || rt === "o" ? ht[ct] = [ot[ct][0] - at[ct][0], ot[ct][1] - at[ct][1]] : ht[ct] = [ot[ct][0], ot[ct][1]];
                    return ht
                },
                points: function(rt) {
                    return this.vertices("v", rt)
                },
                inTangents: function(rt) {
                    return this.vertices("i", rt)
                },
                outTangents: function(rt) {
                    return this.vertices("o", rt)
                },
                isClosed: function() {
                    return this.v.c
                },
                pointOnPath: function(rt, st) {
                    var lt = this.v;
                    st !== void 0 && (lt = this.getValueAtTime(st, 0)),
                    this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(lt));
                    for (var ct = this._segmentsLength, it = ct.lengths, ot = ct.totalLength * rt, at = 0, ht = it.length, pt = 0, dt; at < ht; ) {
                        if (pt + it[at].addedLength > ot) {
                            var yt = at
                              , vt = lt.c && at === ht - 1 ? 0 : at + 1
                              , xt = (ot - pt) / it[at].addedLength;
                            dt = bez.getPointInSegment(lt.v[yt], lt.v[vt], lt.o[yt], lt.i[vt], xt, it[at]);
                            break
                        } else
                            pt += it[at].addedLength;
                        at += 1
                    }
                    return dt || (dt = lt.c ? [lt.v[0][0], lt.v[0][1]] : [lt.v[lt._length - 1][0], lt.v[lt._length - 1][1]]),
                    dt
                },
                vectorOnPath: function(rt, st, lt) {
                    rt == 1 ? rt = this.v.c : rt == 0 && (rt = .999);
                    var ct = this.pointOnPath(rt, st)
                      , it = this.pointOnPath(rt + .001, st)
                      , ot = it[0] - ct[0]
                      , at = it[1] - ct[1]
                      , ht = Math.sqrt(Math.pow(ot, 2) + Math.pow(at, 2));
                    if (ht === 0)
                        return [0, 0];
                    var pt = lt === "tangent" ? [ot / ht, at / ht] : [-at / ht, ot / ht];
                    return pt
                },
                tangentOnPath: function(rt, st) {
                    return this.vectorOnPath(rt, st, "tangent")
                },
                normalOnPath: function(rt, st) {
                    return this.vectorOnPath(rt, st, "normal")
                },
                setGroupProperty: expressionHelpers.setGroupProperty,
                getValueAtTime: expressionHelpers.getStaticValueAtTime
            },
            extendPrototype([$], b),
            extendPrototype([$], j),
            j.prototype.getValueAtTime = _,
            j.prototype.initiateExpression = ExpressionManager.initiateExpression;
            var nt = ShapePropertyFactory.getShapeProp;
            ShapePropertyFactory.getShapeProp = function(tt, rt, st, lt, ct) {
                var it = nt(tt, rt, st, lt, ct);
                return it.propertyIndex = rt.ix,
                it.lock = !1,
                st === 3 ? expressionHelpers.searchExpressions(tt, rt.pt, it) : st === 4 && expressionHelpers.searchExpressions(tt, rt.ks, it),
                it.k && tt.addDynamicProperty(it),
                it
            }
        }
        function initialize$1() {
            addPropertyDecorator()
        }
        function addDecorator() {
            function s() {
                return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this),
                this.addEffect(this.getExpressionValue.bind(this)),
                !0) : null
            }
            TextProperty.prototype.getExpressionValue = function(e, a) {
                var o = this.calculateExpression(a);
                if (e.t !== o) {
                    var c = {};
                    return this.copyData(c, e),
                    c.t = o.toString(),
                    c.__complete = !1,
                    c
                }
                return e
            }
            ,
            TextProperty.prototype.searchProperty = function() {
                var e = this.searchKeyframes()
                  , a = this.searchExpressions();
                return this.kf = e || a,
                this.kf
            }
            ,
            TextProperty.prototype.searchExpressions = s
        }
        function initialize() {
            addDecorator()
        }
        function SVGComposableEffect() {}
        SVGComposableEffect.prototype = {
            createMergeNode: function s(e, a) {
                var o = createNS("feMerge");
                o.setAttribute("result", e);
                var c, d;
                for (d = 0; d < a.length; d += 1)
                    c = createNS("feMergeNode"),
                    c.setAttribute("in", a[d]),
                    o.appendChild(c),
                    o.appendChild(c);
                return o
            }
        };
        var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
        function SVGTintFilter(s, e, a, o, c) {
            this.filterManager = e;
            var d = createNS("feColorMatrix");
            d.setAttribute("type", "matrix"),
            d.setAttribute("color-interpolation-filters", "linearRGB"),
            d.setAttribute("values", linearFilterValue + " 1 0"),
            this.linearFilter = d,
            d.setAttribute("result", o + "_tint_1"),
            s.appendChild(d),
            d = createNS("feColorMatrix"),
            d.setAttribute("type", "matrix"),
            d.setAttribute("color-interpolation-filters", "sRGB"),
            d.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            d.setAttribute("result", o + "_tint_2"),
            s.appendChild(d),
            this.matrixFilter = d;
            var g = this.createMergeNode(o, [c, o + "_tint_1", o + "_tint_2"]);
            s.appendChild(g)
        }
        extendPrototype([SVGComposableEffect], SVGTintFilter),
        SVGTintFilter.prototype.renderFrame = function(s) {
            if (s || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[0].p.v
                  , a = this.filterManager.effectElements[1].p.v
                  , o = this.filterManager.effectElements[2].p.v / 100;
                this.linearFilter.setAttribute("values", linearFilterValue + " " + o + " 0"),
                this.matrixFilter.setAttribute("values", a[0] - e[0] + " 0 0 0 " + e[0] + " " + (a[1] - e[1]) + " 0 0 0 " + e[1] + " " + (a[2] - e[2]) + " 0 0 0 " + e[2] + " 0 0 0 1 0")
            }
        }
        ;
        function SVGFillFilter(s, e, a, o) {
            this.filterManager = e;
            var c = createNS("feColorMatrix");
            c.setAttribute("type", "matrix"),
            c.setAttribute("color-interpolation-filters", "sRGB"),
            c.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            c.setAttribute("result", o),
            s.appendChild(c),
            this.matrixFilter = c
        }
        SVGFillFilter.prototype.renderFrame = function(s) {
            if (s || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[2].p.v
                  , a = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute("values", "0 0 0 0 " + e[0] + " 0 0 0 0 " + e[1] + " 0 0 0 0 " + e[2] + " 0 0 0 " + a + " 0")
            }
        }
        ;
        function SVGStrokeEffect(s, e, a) {
            this.initialized = !1,
            this.filterManager = e,
            this.elem = a,
            this.paths = []
        }
        SVGStrokeEffect.prototype.initialize = function() {
            var s = this.elem.layerElement.children || this.elem.layerElement.childNodes, e, a, o, c;
            for (this.filterManager.effectElements[1].p.v === 1 ? (c = this.elem.maskManager.masksProperties.length,
            o = 0) : (o = this.filterManager.effectElements[0].p.v - 1,
            c = o + 1),
            a = createNS("g"),
            a.setAttribute("fill", "none"),
            a.setAttribute("stroke-linecap", "round"),
            a.setAttribute("stroke-dashoffset", 1),
            o; o < c; o += 1)
                e = createNS("path"),
                a.appendChild(e),
                this.paths.push({
                    p: e,
                    m: o
                });
            if (this.filterManager.effectElements[10].p.v === 3) {
                var d = createNS("mask")
                  , g = createElementID();
                d.setAttribute("id", g),
                d.setAttribute("mask-type", "alpha"),
                d.appendChild(a),
                this.elem.globalData.defs.appendChild(d);
                var _ = createNS("g");
                for (_.setAttribute("mask", "url(" + getLocationHref() + "#" + g + ")"); s[0]; )
                    _.appendChild(s[0]);
                this.elem.layerElement.appendChild(_),
                this.masker = d,
                a.setAttribute("stroke", "#fff")
            } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                if (this.filterManager.effectElements[10].p.v === 2)
                    for (s = this.elem.layerElement.children || this.elem.layerElement.childNodes; s.length; )
                        this.elem.layerElement.removeChild(s[0]);
                this.elem.layerElement.appendChild(a),
                this.elem.layerElement.removeAttribute("mask"),
                a.setAttribute("stroke", "#fff")
            }
            this.initialized = !0,
            this.pathMasker = a
        }
        ,
        SVGStrokeEffect.prototype.renderFrame = function(s) {
            this.initialized || this.initialize();
            var e, a = this.paths.length, o, c;
            for (e = 0; e < a; e += 1)
                if (this.paths[e].m !== -1 && (o = this.elem.maskManager.viewData[this.paths[e].m],
                c = this.paths[e].p,
                (s || this.filterManager._mdf || o.prop._mdf) && c.setAttribute("d", o.lastPath),
                s || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || o.prop._mdf)) {
                    var d;
                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                        var g = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                          , _ = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                          , b = c.getTotalLength();
                        d = "0 0 0 " + b * g + " ";
                        var j = b * (_ - g), $ = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01, nt = Math.floor(j / $), tt;
                        for (tt = 0; tt < nt; tt += 1)
                            d += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " ";
                        d += "0 " + b * 10 + " 0 0"
                    } else
                        d = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
                    c.setAttribute("stroke-dasharray", d)
                }
            if ((s || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2),
            (s || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v),
            (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (s || this.filterManager.effectElements[3].p._mdf)) {
                var rt = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(rt[0] * 255) + "," + bmFloor(rt[1] * 255) + "," + bmFloor(rt[2] * 255) + ")")
            }
        }
        ;
        function SVGTritoneFilter(s, e, a, o) {
            this.filterManager = e;
            var c = createNS("feColorMatrix");
            c.setAttribute("type", "matrix"),
            c.setAttribute("color-interpolation-filters", "linearRGB"),
            c.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"),
            s.appendChild(c);
            var d = createNS("feComponentTransfer");
            d.setAttribute("color-interpolation-filters", "sRGB"),
            d.setAttribute("result", o),
            this.matrixFilter = d;
            var g = createNS("feFuncR");
            g.setAttribute("type", "table"),
            d.appendChild(g),
            this.feFuncR = g;
            var _ = createNS("feFuncG");
            _.setAttribute("type", "table"),
            d.appendChild(_),
            this.feFuncG = _;
            var b = createNS("feFuncB");
            b.setAttribute("type", "table"),
            d.appendChild(b),
            this.feFuncB = b,
            s.appendChild(d)
        }
        SVGTritoneFilter.prototype.renderFrame = function(s) {
            if (s || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[0].p.v
                  , a = this.filterManager.effectElements[1].p.v
                  , o = this.filterManager.effectElements[2].p.v
                  , c = o[0] + " " + a[0] + " " + e[0]
                  , d = o[1] + " " + a[1] + " " + e[1]
                  , g = o[2] + " " + a[2] + " " + e[2];
                this.feFuncR.setAttribute("tableValues", c),
                this.feFuncG.setAttribute("tableValues", d),
                this.feFuncB.setAttribute("tableValues", g)
            }
        }
        ;
        function SVGProLevelsFilter(s, e, a, o) {
            this.filterManager = e;
            var c = this.filterManager.effectElements
              , d = createNS("feComponentTransfer");
            (c[10].p.k || c[10].p.v !== 0 || c[11].p.k || c[11].p.v !== 1 || c[12].p.k || c[12].p.v !== 1 || c[13].p.k || c[13].p.v !== 0 || c[14].p.k || c[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", d)),
            (c[17].p.k || c[17].p.v !== 0 || c[18].p.k || c[18].p.v !== 1 || c[19].p.k || c[19].p.v !== 1 || c[20].p.k || c[20].p.v !== 0 || c[21].p.k || c[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", d)),
            (c[24].p.k || c[24].p.v !== 0 || c[25].p.k || c[25].p.v !== 1 || c[26].p.k || c[26].p.v !== 1 || c[27].p.k || c[27].p.v !== 0 || c[28].p.k || c[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", d)),
            (c[31].p.k || c[31].p.v !== 0 || c[32].p.k || c[32].p.v !== 1 || c[33].p.k || c[33].p.v !== 1 || c[34].p.k || c[34].p.v !== 0 || c[35].p.k || c[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", d)),
            (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (d.setAttribute("color-interpolation-filters", "sRGB"),
            s.appendChild(d)),
            (c[3].p.k || c[3].p.v !== 0 || c[4].p.k || c[4].p.v !== 1 || c[5].p.k || c[5].p.v !== 1 || c[6].p.k || c[6].p.v !== 0 || c[7].p.k || c[7].p.v !== 1) && (d = createNS("feComponentTransfer"),
            d.setAttribute("color-interpolation-filters", "sRGB"),
            d.setAttribute("result", o),
            s.appendChild(d),
            this.feFuncRComposed = this.createFeFunc("feFuncR", d),
            this.feFuncGComposed = this.createFeFunc("feFuncG", d),
            this.feFuncBComposed = this.createFeFunc("feFuncB", d))
        }
        SVGProLevelsFilter.prototype.createFeFunc = function(s, e) {
            var a = createNS(s);
            return a.setAttribute("type", "table"),
            e.appendChild(a),
            a
        }
        ,
        SVGProLevelsFilter.prototype.getTableValue = function(s, e, a, o, c) {
            for (var d = 0, g = 256, _, b = Math.min(s, e), j = Math.max(s, e), $ = Array.call(null, {
                length: g
            }), nt, tt = 0, rt = c - o, st = e - s; d <= 256; )
                _ = d / 256,
                _ <= b ? nt = st < 0 ? c : o : _ >= j ? nt = st < 0 ? o : c : nt = o + rt * Math.pow((_ - s) / st, 1 / a),
                $[tt] = nt,
                tt += 1,
                d += 256 / (g - 1);
            return $.join(" ")
        }
        ,
        SVGProLevelsFilter.prototype.renderFrame = function(s) {
            if (s || this.filterManager._mdf) {
                var e, a = this.filterManager.effectElements;
                this.feFuncRComposed && (s || a[3].p._mdf || a[4].p._mdf || a[5].p._mdf || a[6].p._mdf || a[7].p._mdf) && (e = this.getTableValue(a[3].p.v, a[4].p.v, a[5].p.v, a[6].p.v, a[7].p.v),
                this.feFuncRComposed.setAttribute("tableValues", e),
                this.feFuncGComposed.setAttribute("tableValues", e),
                this.feFuncBComposed.setAttribute("tableValues", e)),
                this.feFuncR && (s || a[10].p._mdf || a[11].p._mdf || a[12].p._mdf || a[13].p._mdf || a[14].p._mdf) && (e = this.getTableValue(a[10].p.v, a[11].p.v, a[12].p.v, a[13].p.v, a[14].p.v),
                this.feFuncR.setAttribute("tableValues", e)),
                this.feFuncG && (s || a[17].p._mdf || a[18].p._mdf || a[19].p._mdf || a[20].p._mdf || a[21].p._mdf) && (e = this.getTableValue(a[17].p.v, a[18].p.v, a[19].p.v, a[20].p.v, a[21].p.v),
                this.feFuncG.setAttribute("tableValues", e)),
                this.feFuncB && (s || a[24].p._mdf || a[25].p._mdf || a[26].p._mdf || a[27].p._mdf || a[28].p._mdf) && (e = this.getTableValue(a[24].p.v, a[25].p.v, a[26].p.v, a[27].p.v, a[28].p.v),
                this.feFuncB.setAttribute("tableValues", e)),
                this.feFuncA && (s || a[31].p._mdf || a[32].p._mdf || a[33].p._mdf || a[34].p._mdf || a[35].p._mdf) && (e = this.getTableValue(a[31].p.v, a[32].p.v, a[33].p.v, a[34].p.v, a[35].p.v),
                this.feFuncA.setAttribute("tableValues", e))
            }
        }
        ;
        function SVGDropShadowEffect(s, e, a, o, c) {
            var d = e.container.globalData.renderConfig.filterSize
              , g = e.data.fs || d;
            s.setAttribute("x", g.x || d.x),
            s.setAttribute("y", g.y || d.y),
            s.setAttribute("width", g.width || d.width),
            s.setAttribute("height", g.height || d.height),
            this.filterManager = e;
            var _ = createNS("feGaussianBlur");
            _.setAttribute("in", "SourceAlpha"),
            _.setAttribute("result", o + "_drop_shadow_1"),
            _.setAttribute("stdDeviation", "0"),
            this.feGaussianBlur = _,
            s.appendChild(_);
            var b = createNS("feOffset");
            b.setAttribute("dx", "25"),
            b.setAttribute("dy", "0"),
            b.setAttribute("in", o + "_drop_shadow_1"),
            b.setAttribute("result", o + "_drop_shadow_2"),
            this.feOffset = b,
            s.appendChild(b);
            var j = createNS("feFlood");
            j.setAttribute("flood-color", "#00ff00"),
            j.setAttribute("flood-opacity", "1"),
            j.setAttribute("result", o + "_drop_shadow_3"),
            this.feFlood = j,
            s.appendChild(j);
            var $ = createNS("feComposite");
            $.setAttribute("in", o + "_drop_shadow_3"),
            $.setAttribute("in2", o + "_drop_shadow_2"),
            $.setAttribute("operator", "in"),
            $.setAttribute("result", o + "_drop_shadow_4"),
            s.appendChild($);
            var nt = this.createMergeNode(o, [o + "_drop_shadow_4", c]);
            s.appendChild(nt)
        }
        extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        SVGDropShadowEffect.prototype.renderFrame = function(s) {
            if (s || this.filterManager._mdf) {
                if ((s || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4),
                s || this.filterManager.effectElements[0].p._mdf) {
                    var e = this.filterManager.effectElements[0].p.v;
                    this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(e[0] * 255), Math.round(e[1] * 255), Math.round(e[2] * 255)))
                }
                if ((s || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255),
                s || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                    var a = this.filterManager.effectElements[3].p.v
                      , o = (this.filterManager.effectElements[2].p.v - 90) * degToRads
                      , c = a * Math.cos(o)
                      , d = a * Math.sin(o);
                    this.feOffset.setAttribute("dx", c),
                    this.feOffset.setAttribute("dy", d)
                }
            }
        }
        ;
        var _svgMatteSymbols = [];
        function SVGMatte3Effect(s, e, a) {
            this.initialized = !1,
            this.filterManager = e,
            this.filterElem = s,
            this.elem = a,
            a.matteElement = createNS("g"),
            a.matteElement.appendChild(a.layerElement),
            a.matteElement.appendChild(a.transformedElement),
            a.baseElement = a.matteElement
        }
        SVGMatte3Effect.prototype.findSymbol = function(s) {
            for (var e = 0, a = _svgMatteSymbols.length; e < a; ) {
                if (_svgMatteSymbols[e] === s)
                    return _svgMatteSymbols[e];
                e += 1
            }
            return null
        }
        ,
        SVGMatte3Effect.prototype.replaceInParent = function(s, e) {
            var a = s.layerElement.parentNode;
            if (a) {
                for (var o = a.children, c = 0, d = o.length; c < d && o[c] !== s.layerElement; )
                    c += 1;
                var g;
                c <= d - 2 && (g = o[c + 1]);
                var _ = createNS("use");
                _.setAttribute("href", "#" + e),
                g ? a.insertBefore(_, g) : a.appendChild(_)
            }
        }
        ,
        SVGMatte3Effect.prototype.setElementAsMask = function(s, e) {
            if (!this.findSymbol(e)) {
                var a = createElementID()
                  , o = createNS("mask");
                o.setAttribute("id", e.layerId),
                o.setAttribute("mask-type", "alpha"),
                _svgMatteSymbols.push(e);
                var c = s.globalData.defs;
                c.appendChild(o);
                var d = createNS("symbol");
                d.setAttribute("id", a),
                this.replaceInParent(e, a),
                d.appendChild(e.layerElement),
                c.appendChild(d);
                var g = createNS("use");
                g.setAttribute("href", "#" + a),
                o.appendChild(g),
                e.data.hd = !1,
                e.show()
            }
            s.setMatte(e.layerId)
        }
        ,
        SVGMatte3Effect.prototype.initialize = function() {
            for (var s = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, a = 0, o = e.length; a < o; )
                e[a] && e[a].data.ind === s && this.setElementAsMask(this.elem, e[a]),
                a += 1;
            this.initialized = !0
        }
        ,
        SVGMatte3Effect.prototype.renderFrame = function() {
            this.initialized || this.initialize()
        }
        ;
        function SVGGaussianBlurEffect(s, e, a, o) {
            s.setAttribute("x", "-100%"),
            s.setAttribute("y", "-100%"),
            s.setAttribute("width", "300%"),
            s.setAttribute("height", "300%"),
            this.filterManager = e;
            var c = createNS("feGaussianBlur");
            c.setAttribute("result", o),
            s.appendChild(c),
            this.feGaussianBlur = c
        }
        SVGGaussianBlurEffect.prototype.renderFrame = function(s) {
            if (s || this.filterManager._mdf) {
                var e = .3
                  , a = this.filterManager.effectElements[0].p.v * e
                  , o = this.filterManager.effectElements[1].p.v
                  , c = o == 3 ? 0 : a
                  , d = o == 2 ? 0 : a;
                this.feGaussianBlur.setAttribute("stdDeviation", c + " " + d);
                var g = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
                this.feGaussianBlur.setAttribute("edgeMode", g)
            }
        }
        ;
        function TransformEffect() {}
        TransformEffect.prototype.init = function(s) {
            this.effectsManager = s,
            this.type = effectTypes.TRANSFORM_EFFECT,
            this.matrix = new Matrix,
            this.opacity = -1,
            this._mdf = !1,
            this._opMdf = !1
        }
        ,
        TransformEffect.prototype.renderFrame = function(s) {
            if (this._opMdf = !1,
            this._mdf = !1,
            s || this.effectsManager._mdf) {
                var e = this.effectsManager.effectElements
                  , a = e[0].p.v
                  , o = e[1].p.v
                  , c = e[2].p.v === 1
                  , d = e[3].p.v
                  , g = c ? d : e[4].p.v
                  , _ = e[5].p.v
                  , b = e[6].p.v
                  , j = e[7].p.v;
                this.matrix.reset(),
                this.matrix.translate(-a[0], -a[1], a[2]),
                this.matrix.scale(g * .01, d * .01, 1),
                this.matrix.rotate(-j * degToRads),
                this.matrix.skewFromAxis(-_ * degToRads, (b + 90) * degToRads),
                this.matrix.translate(o[0], o[1], 0),
                this._mdf = !0,
                this.opacity !== e[8].p.v && (this.opacity = e[8].p.v,
                this._opMdf = !0)
            }
        }
        ;
        function SVGTransformEffect(s, e) {
            this.init(e)
        }
        extendPrototype([TransformEffect], SVGTransformEffect);
        function CVTransformEffect(s) {
            this.init(s)
        }
        return extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
    })
}
)(lottie$1, lottie$1.exports);
var lottieExports = lottie$1.exports;
const lottie = getDefaultExportFromCjs(lottieExports);
var react = function s(e, a) {
    if (e === a)
        return !0;
    if (e && a && typeof e == "object" && typeof a == "object") {
        if (e.constructor !== a.constructor)
            return !1;
        var o, c, d;
        if (Array.isArray(e)) {
            if (o = e.length,
            o != a.length)
                return !1;
            for (c = o; c-- !== 0; )
                if (!s(e[c], a[c]))
                    return !1;
            return !0
        }
        if (e instanceof Map && a instanceof Map) {
            if (e.size !== a.size)
                return !1;
            for (c of e.entries())
                if (!a.has(c[0]))
                    return !1;
            for (c of e.entries())
                if (!s(c[1], a.get(c[0])))
                    return !1;
            return !0
        }
        if (e instanceof Set && a instanceof Set) {
            if (e.size !== a.size)
                return !1;
            for (c of e.entries())
                if (!a.has(c[0]))
                    return !1;
            return !0
        }
        if (ArrayBuffer.isView(e) && ArrayBuffer.isView(a)) {
            if (o = e.length,
            o != a.length)
                return !1;
            for (c = o; c-- !== 0; )
                if (e[c] !== a[c])
                    return !1;
            return !0
        }
        if (e.constructor === RegExp)
            return e.source === a.source && e.flags === a.flags;
        if (e.valueOf !== Object.prototype.valueOf)
            return e.valueOf() === a.valueOf();
        if (e.toString !== Object.prototype.toString)
            return e.toString() === a.toString();
        if (d = Object.keys(e),
        o = d.length,
        o !== Object.keys(a).length)
            return !1;
        for (c = o; c-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(a, d[c]))
                return !1;
        for (c = o; c-- !== 0; ) {
            var g = d[c];
            if (!(g === "_owner" && e.$$typeof) && !s(e[g], a[g]))
                return !1
        }
        return !0
    }
    return e !== e && a !== a
};
const equal = getDefaultExportFromCjs(react);
var rfdc_1 = rfdc;
function copyBuffer(s) {
    return s instanceof Buffer ? Buffer.from(s) : new s.constructor(s.buffer.slice(),s.byteOffset,s.length)
}
function rfdc(s) {
    if (s = s || {},
    s.circles)
        return rfdcCircles(s);
    const e = new Map;
    if (e.set(Date, g => new Date(g)),
    e.set(Map, (g, _) => new Map(o(Array.from(g), _))),
    e.set(Set, (g, _) => new Set(o(Array.from(g), _))),
    s.constructorHandlers)
        for (const g of s.constructorHandlers)
            e.set(g[0], g[1]);
    let a = null;
    return s.proto ? d : c;
    function o(g, _) {
        const b = Object.keys(g)
          , j = new Array(b.length);
        for (let $ = 0; $ < b.length; $++) {
            const nt = b[$]
              , tt = g[nt];
            typeof tt != "object" || tt === null ? j[nt] = tt : tt.constructor !== Object && (a = e.get(tt.constructor)) ? j[nt] = a(tt, _) : ArrayBuffer.isView(tt) ? j[nt] = copyBuffer(tt) : j[nt] = _(tt)
        }
        return j
    }
    function c(g) {
        if (typeof g != "object" || g === null)
            return g;
        if (Array.isArray(g))
            return o(g, c);
        if (g.constructor !== Object && (a = e.get(g.constructor)))
            return a(g, c);
        const _ = {};
        for (const b in g) {
            if (Object.hasOwnProperty.call(g, b) === !1)
                continue;
            const j = g[b];
            typeof j != "object" || j === null ? _[b] = j : j.constructor !== Object && (a = e.get(j.constructor)) ? _[b] = a(j, c) : ArrayBuffer.isView(j) ? _[b] = copyBuffer(j) : _[b] = c(j)
        }
        return _
    }
    function d(g) {
        if (typeof g != "object" || g === null)
            return g;
        if (Array.isArray(g))
            return o(g, d);
        if (g.constructor !== Object && (a = e.get(g.constructor)))
            return a(g, d);
        const _ = {};
        for (const b in g) {
            const j = g[b];
            typeof j != "object" || j === null ? _[b] = j : j.constructor !== Object && (a = e.get(j.constructor)) ? _[b] = a(j, d) : ArrayBuffer.isView(j) ? _[b] = copyBuffer(j) : _[b] = d(j)
        }
        return _
    }
}
function rfdcCircles(s) {
    const e = []
      , a = []
      , o = new Map;
    if (o.set(Date, b => new Date(b)),
    o.set(Map, (b, j) => new Map(d(Array.from(b), j))),
    o.set(Set, (b, j) => new Set(d(Array.from(b), j))),
    s.constructorHandlers)
        for (const b of s.constructorHandlers)
            o.set(b[0], b[1]);
    let c = null;
    return s.proto ? _ : g;
    function d(b, j) {
        const $ = Object.keys(b)
          , nt = new Array($.length);
        for (let tt = 0; tt < $.length; tt++) {
            const rt = $[tt]
              , st = b[rt];
            if (typeof st != "object" || st === null)
                nt[rt] = st;
            else if (st.constructor !== Object && (c = o.get(st.constructor)))
                nt[rt] = c(st, j);
            else if (ArrayBuffer.isView(st))
                nt[rt] = copyBuffer(st);
            else {
                const lt = e.indexOf(st);
                lt !== -1 ? nt[rt] = a[lt] : nt[rt] = j(st)
            }
        }
        return nt
    }
    function g(b) {
        if (typeof b != "object" || b === null)
            return b;
        if (Array.isArray(b))
            return d(b, g);
        if (b.constructor !== Object && (c = o.get(b.constructor)))
            return c(b, g);
        const j = {};
        e.push(b),
        a.push(j);
        for (const $ in b) {
            if (Object.hasOwnProperty.call(b, $) === !1)
                continue;
            const nt = b[$];
            if (typeof nt != "object" || nt === null)
                j[$] = nt;
            else if (nt.constructor !== Object && (c = o.get(nt.constructor)))
                j[$] = c(nt, g);
            else if (ArrayBuffer.isView(nt))
                j[$] = copyBuffer(nt);
            else {
                const tt = e.indexOf(nt);
                tt !== -1 ? j[$] = a[tt] : j[$] = g(nt)
            }
        }
        return e.pop(),
        a.pop(),
        j
    }
    function _(b) {
        if (typeof b != "object" || b === null)
            return b;
        if (Array.isArray(b))
            return d(b, _);
        if (b.constructor !== Object && (c = o.get(b.constructor)))
            return c(b, _);
        const j = {};
        e.push(b),
        a.push(j);
        for (const $ in b) {
            const nt = b[$];
            if (typeof nt != "object" || nt === null)
                j[$] = nt;
            else if (nt.constructor !== Object && (c = o.get(nt.constructor)))
                j[$] = c(nt, _);
            else if (ArrayBuffer.isView(nt))
                j[$] = copyBuffer(nt);
            else {
                const tt = e.indexOf(nt);
                tt !== -1 ? j[$] = a[tt] : j[$] = _(nt)
            }
        }
        return e.pop(),
        a.pop(),
        j
    }
}
var _default = rfdc_1();
const clone = getDefaultExportFromCjs(_default);
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(s) {
        for (var e = 1; e < arguments.length; e++) {
            var a = arguments[e];
            for (var o in a)
                Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o])
        }
        return s
    }
    ,
    _extends.apply(this, arguments)
}
function _objectWithoutPropertiesLoose(s, e) {
    if (s == null)
        return {};
    var a = {}, o = Object.keys(s), c, d;
    for (d = 0; d < o.length; d++)
        c = o[d],
        !(e.indexOf(c) >= 0) && (a[c] = s[c]);
    return a
}
var emptyObject = {}
  , noOp = function s() {}
  , makeLottiePlayer = function s(e) {
    var a = e.loadAnimation
      , o = reactExports.memo(reactExports.forwardRef(function(c, d) {
        var g = c.play, _ = g === void 0 ? null : g, b = c.speed, j = b === void 0 ? 1 : b, $ = c.direction, nt = $ === void 0 ? 1 : $, tt = c.segments, rt = tt === void 0 ? null : tt, st = c.goTo, lt = st === void 0 ? null : st, ct = c.useSubframes, it = ct === void 0 ? !0 : ct, ot = c.renderer, at = ot === void 0 ? "svg" : ot, ht = c.loop, pt = ht === void 0 ? !0 : ht, dt = c.rendererSettings, yt = dt === void 0 ? emptyObject : dt, vt = c.audioFactory, xt = c.onLoad, _t = xt === void 0 ? noOp : xt, bt = c.onComplete, Rt = bt === void 0 ? noOp : bt, Ft = c.onLoopComplete, Bt = Ft === void 0 ? noOp : Ft, Dt = c.onEnterFrame, Mt = Dt === void 0 ? noOp : Dt, Tt = c.onSegmentStart, mt = Tt === void 0 ? noOp : Tt, St = _objectWithoutPropertiesLoose(c, ["play", "speed", "direction", "segments", "goTo", "useSubframes", "renderer", "loop", "rendererSettings", "audioFactory", "onLoad", "onComplete", "onLoopComplete", "onEnterFrame", "onSegmentStart"]), wt = St, Ct, Ht;
        if ("animationData"in St) {
            var en = St;
            Ct = en.animationData,
            wt = _objectWithoutPropertiesLoose(en, ["animationData"])
        }
        if ("path"in St) {
            var Ot = St;
            Ht = Ot.path,
            wt = _objectWithoutPropertiesLoose(Ot, ["path"])
        }
        var Yt = reactExports.useRef(null)
          , rn = reactExports.useRef()
          , Xt = reactExports.useCallback(function() {
            if (rn.current == null)
                throw new Error("Lottie ref is not set");
            return rn.current
        }, [])
          , An = reactExports.useState(!1)
          , Ln = An[0]
          , _n = An[1]
          , yn = reactExports.useState(rt)
          , Pt = yn[0]
          , Qt = yn[1];
        reactExports.useEffect(function() {
            equal(Pt, rt) || Qt(rt)
        }, [rt, Pt]);
        var jt = reactExports.useState(yt)
          , fn = jt[0]
          , tn = jt[1];
        reactExports.useEffect(function() {
            equal(fn, yt) || tn(yt)
        }, [yt, fn]),
        reactExports.useEffect(function() {
            return function() {
                return Xt().removeEventListener("complete", Rt)
            }
        }, [Xt, Rt]),
        reactExports.useEffect(function() {
            return function() {
                return Xt().removeEventListener("loopComplete", Bt)
            }
        }, [Xt, Bt]),
        reactExports.useEffect(function() {
            return function() {
                return Xt().removeEventListener("enterFrame", Mt)
            }
        }, [Xt, Mt]),
        reactExports.useEffect(function() {
            return function() {
                return Xt().removeEventListener("segmentStart", mt)
            }
        }, [Xt, mt]),
        reactExports.useEffect(function() {
            return function() {
                return Xt().removeEventListener("DOMLoaded", _t)
            }
        }, [Xt, _t]);
        var bn = reactExports.useCallback(function(vn) {
            rn.current = vn,
            typeof d == "function" ? d(vn) : d != null && (d.current = vn)
        }, [d]);
        reactExports.useEffect(function() {
            function vn() {
                return Ct == null || typeof Ct != "object" ? Ct : "default"in Ct && typeof Ct.default == "object" ? clone(Ct.default) : clone(Ct)
            }
            if (Yt.current == null)
                throw new Error("animElementRef is not set");
            var Lt = a(_extends({
                animationData: vn(),
                path: Ht,
                container: Yt.current,
                renderer: at,
                loop: !1,
                autoplay: !1,
                rendererSettings: fn
            }, vt ? {
                audioFactory: vt
            } : {}));
            bn(Lt);
            var At = function() {
                return _n(!0)
            };
            return Xt().addEventListener("DOMLoaded", At),
            function() {
                Xt().removeEventListener("DOMLoaded", At),
                _n(!1),
                Xt().destroy(),
                bn(void 0)
            }
        }, [pt, at, fn, Ct, Ht, vt, bn, Xt]),
        reactExports.useEffect(function() {
            Xt().addEventListener("DOMLoaded", _t)
        }, [Xt, _t]),
        reactExports.useEffect(function() {
            Xt().addEventListener("complete", Rt)
        }, [Xt, Rt]),
        reactExports.useEffect(function() {
            Xt().addEventListener("loopComplete", Bt)
        }, [Xt, Bt]),
        reactExports.useEffect(function() {
            Xt().addEventListener("enterFrame", Mt)
        }, [Xt, Mt]),
        reactExports.useEffect(function() {
            Xt().addEventListener("segmentStart", mt)
        }, [Xt, mt]),
        reactExports.useEffect(function() {
            Ln && (Xt().loop = pt)
        }, [Ln, pt, Xt]);
        var gn = reactExports.useRef(!1);
        return reactExports.useEffect(function() {
            if (!Ln)
                return;
            function vn(on) {
                Xt().goToAndPlay(on, !0),
                Xt().setDirection(nt)
            }
            if (_ === !0) {
                var Lt = !0;
                if (Pt) {
                    if (Xt().playSegments(Pt, Lt),
                    gn.current = !0,
                    nt === -1) {
                        var At = typeof Pt[1] == "number" ? Pt[1] : Pt[1][1];
                        vn(At)
                    }
                } else if (gn.current && Xt().resetSegments(Lt),
                gn.current = !1,
                nt === -1) {
                    var $t = Xt().getDuration(!0);
                    vn($t)
                } else
                    Xt().play()
            } else
                _ === !1 && Xt().pause()
        }, [_, Pt, Ln, nt, Xt]),
        reactExports.useEffect(function() {
            Ln && (Number.isNaN(j) || Xt().setSpeed(j))
        }, [j, Ln, Xt]),
        reactExports.useEffect(function() {
            Ln && Xt().setDirection(nt)
        }, [nt, Xt, Ln]),
        reactExports.useEffect(function() {
            if (Ln && lt != null) {
                var vn = !0;
                _ ? Xt().goToAndPlay(lt, vn) : Xt().goToAndStop(lt, vn)
            }
        }, [Xt, lt, _, Ln]),
        reactExports.useEffect(function() {
            Xt().setSubframe && Xt().setSubframe(it)
        }, [Xt, it]),
        React.createElement("div", _extends({}, wt, {
            ref: Yt
        }))
    }));
    return o
}
  , LottiePlayer = makeLottiePlayer(lottie);
const nm$1 = "Comp 1"
  , mn = ""
  , layers$1 = [{
    ty: 4,
    nm: "Talk",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [209, 164.75, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0, 0, 100],
                t: 30
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [100, 100, 100],
                t: 60
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0, 0, 100],
                t: 90.0000036657751
            }],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [209, 164.75, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 1",
        ix: 1,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[-14.421, .539], [-10.647, -3.235], [-3.369, 3.235], [10.917, -10.513], [14.421, -6.739], [-3.908, 10.513]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [1, 1, 1, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [178.441, 145.032],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 2",
        ix: 2,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [4.825, -1.471], [4.23, 13.874], [-13.875, 4.23], [-4.23, -13.875], [1.999, -5.254], [0, 0]],
                    o: [[0, 0], [-3.108, 3.524], [-13.875, 4.23], [-4.23, -13.875], [13.874, -4.23], [1.766, 5.793], [0, 0], [0, 0]],
                    v: [[30.025, 19.857], [19.008, 17.392], [6.985, 25.122], [-25.796, 7.659], [-8.332, -25.122], [24.449, -7.659], [23.875, 9.319], [23.884, 9.307]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [0, .8667, .702, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [179.208, 145.035],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 0
}, {
    ty: 0,
    nm: "Pre-comp 1",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [250, 250, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [250, 250, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        }
    },
    ef: [],
    w: 500,
    h: 500,
    refId: "comp_0",
    ind: 1
}, {
    ty: 4,
    nm: "Ilustrao-WampsNegcios2 Outlines",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [250, 250, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [250, 250, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 3",
        ix: 1,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[8.289, 1.751], [0, 0], [-4.633, -.032], [-3.108, 3.436]],
                    o: [[0, 0], [3.061, 3.479], [4.633, .032], [-8.305, 1.671]],
                    v: [[-12.465, -1.89], [-12.775, -1.938], [0, 1.935], [12.775, -1.768]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [0, 0, 0, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [248.748, 264.62],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 5",
        ix: 2,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.221, 1.596], [10.149, -.007], [-1.99, -.183], [-1.952, .376], [-4.667, 1.746]],
                    o: [[-9.459, 3.812], [1.296, 1.412], [1.99, .184], [4.938, -.952], [1.611, -.604]],
                    v: [[14.468, -4.278], [-14.486, 1.894], [-9.192, 4.224], [-3.254, 3.718], [11.191, -.34]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [0, 0, 0, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [239.583, 182.672],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 6",
        ix: 3,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.111, 2.836], [-.021, -.189], [-.032, -.344], [-.089, -1.403], [-.253, -5.022], [-.575, -15.331], [-.085, -2.308], [0, 0], [-1.305, -8.61], [-.352, -2.412], [-.091, -.66], [-.022, -.187], [.008, -.001], [.032, .157], [.054, .286], [.197, 1.153], [.688, 4.252], [2.11, 13.477], [0, 0], [0, 0], [.092, 2.47]],
                    o: [[.009, -.001], [.02, .218], [.064, .738], [.191, 2.807], [.501, 10.044], [.091, 2.47], [0, 0], [2.043, 13.487], [.622, 4.262], [.159, 1.159], [.035, .289], [.016, .16], [-.008, .001], [-.035, -.186], [-.112, -.656], [-.39, -2.407], [-1.347, -8.602], [0, 0], [0, 0], [-.086, -2.308], [-1.185, -30.268]],
                    v: [[-5.035, -55.255], [-4.99, -54.97], [-4.912, -54.132], [-4.672, -50.901], [-4.006, -39.009], [-2.342, .244], [-2.077, 7.455], [-2.08, 7.426], [3.076, 41.46], [4.553, 51.57], [4.928, 54.301], [5.013, 55.01], [5.026, 55.254], [4.965, 55.018], [4.832, 54.315], [4.368, 51.599], [2.735, 41.512], [-2.59, 7.504], [-2.593, 7.49], [-2.593, 7.474], [-2.862, .264]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [283.216, 248.048],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 7",
        ix: 4,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.018, -.004], [.09, .339], [.15, .599], [.526, 2.262], [1.582, 7.05], [1.052, 4.711], [.307, 1.373], [.086, .4], [-.018, .004], [-.1, -.336], [-.166, -.594], [-.567, -2.312], [-1.58, -7.089], [-.968, -4.66], [-.279, -1.38], [-.074, -.403]],
                    o: [[-.018, .004], [-.099, -.397], [-.318, -1.37], [-1.058, -4.711], [-1.575, -7.054], [-.507, -2.266], [-.128, -.603], [-.067, -.344], [.017, -.005], [.111, .394], [.35, 1.285], [1.134, 4.623], [1.58, 7.087], [.459, 2.276], [.111, .607], [.057, .346]],
                    v: [[5.78, 25.652], [5.616, 25.142], [5.244, 23.653], [3.968, 18.164], [-.104, .025], [-4.155, -18.122], [-5.385, -23.621], [-5.704, -25.121], [-5.78, -25.652], [-5.602, -25.146], [-5.188, -23.669], [-3.797, -18.207], [.404, -.09], [4.328, 18.086], [5.443, 23.611], [5.719, 25.119]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [212.161, 231.844],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 8",
        ix: 5,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.044, -.124], [2.296, -.11], [.048, .149], [-2.388, .095]],
                    o: [[-.034, .153], [-2.298, .09], [-.054, -.12], [2.387, -.112]],
                    v: [[4.175, .12], [-.007, .001], [-4.164, .483], [-.03, -.52]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [225.999, 381.908],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 9",
        ix: 6,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.005, -.063], [3.54, -.883], [.079, .146], [-1.071, .576], [-1.808, .443], [-1.214, -.019]],
                    o: [[-.003, .166], [-3.55, .848], [-.033, -.054], [1.069, -.576], [1.809, -.439], [1.216, .017]],
                    v: [[6.383, -1.511], [-.158, -.664], [-6.355, 1.598], [-4.72, .508], [-.282, -1.17], [4.43, -1.725]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [278.532, 379.616],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 10",
        ix: 7,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.026, -.141], [6.296, -1.154], [.026, .142], [-6.299, 1.155]],
                    o: [[.026, .141], [-6.299, 1.154], [-.026, -.141], [6.296, -1.154]],
                    v: [[11.403, -2.09], [.048, .256], [-11.403, 2.089], [-.046, -.257]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [250.436, 318.99],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 11",
        ix: 8,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.144, .004], [-.179, -7.18], [.144, -.003], [.179, 7.183]],
                    o: [[.144, -.004], [.179, 7.183], [-.144, .004], [-.179, -7.18]],
                    v: [[-.324, -13.003], [.26, -.007], [.324, 13.003], [-.26, .006]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [247.826, 285.667],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 13",
        ix: 9,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.007, -.035], [.936, -.204], [1.699, -.228], [5.228, .391], [3.288, .968], [.892, .351], [-.012, .033], [-.913, -.282], [-1.649, -.434], [-5.189, -.4], [-3.39, .365], [-.943, .151]],
                    o: [[.007, .035], [-.935, .212], [-3.397, .461], [-5.229, -.403], [-1.645, -.481], [-.895, -.343], [.013, -.034], [.909, .291], [3.296, .873], [5.189, .387], [1.695, -.18], [.945, -.141]],
                    v: [[18.616, .532], [17.173, .9], [13.171, 1.577], [-.21, 1.936], [-13.386, -.439], [-17.24, -1.712], [-18.611, -2.293], [-17.174, -1.904], [-13.288, -.794], [-.171, 1.417], [13.128, 1.211], [17.137, .7]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [243.966, 257.009],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 14",
        ix: 10,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.019, -.031], [.726, -.463], [.541, -.286], [.701, -.321], [1.917, -.695], [2.294, -.517], [3.074, -.11], [.86, .034], [0, .036], [-.857, .033], [-1.527, .105], [-4.561, 1.006], [-1.921, .628], [-1.385, .649], [-.545, .268], [-.373, .211]],
                    o: [[.019, .03], [-.36, .239], [-.536, .296], [-1.376, .697], [-1.929, .658], [-4.598, 1.014], [-1.537, .059], [-.86, -.029], [.001, -.036], [.857, -.028], [3.055, -.204], [2.276, -.513], [1.908, -.664], [.705, -.298], [.55, -.261], [.754, -.406]],
                    v: [[16.279, -3.976], [15.18, -3.213], [13.827, -2.418], [11.982, -1.458], [6.982, .617], [.604, 2.418], [-11.321, 3.943], [-14.964, 3.973], [-16.298, 3.874], [-14.965, 3.77], [-11.341, 3.576], [.491, 1.91], [6.827, .162], [11.826, -1.792], [13.691, -2.674], [15.078, -3.389]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [240.371, 180.603],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 20",
        ix: 11,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [1.121, -1.962], [-3.339, -15.679], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [2.291, 10.758], [0, 0], [-.254, 0], [0, 0], [0, 0]],
                    v: [[35.355, 15.085], [33.624, -31.578], [30.746, -63.801], [11.125, -63.801], [6.114, -68.686], [-19.053, -63.801], [-21.383, -56.772], [-42.716, -48.375], [-32.288, -4.716], [-27.585, 17.068], [-33.969, 68.686], [4.91, 66.963], [42.716, 62.874]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [245.526, 240.428],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 21",
        ix: 12,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [1.33, -.333], [0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[-41.211, -75.301], [-42.454, 5.375], [-45.194, 89.124], [-22.461, 90.767], [-14.791, 5.375], [-6.062, -55.215], [-4.14, -55.333], [13.033, 7.747], [23.736, 88.699], [45.194, 86.777], [31.23, -77.135], [28.904, -90.767], [-30.943, -89.437]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [254.811, 374.264],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 23",
        ix: 13,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[-12.256, 4.89], [-12.057, .07], [11.425, -4.89], [12.256, -.921]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [1, 1, 1, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [238.993, 174.34],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 24",
        ix: 14,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.166, .003], [-.891, -2.423], [-.073, .11], [.815, 2.306]],
                    o: [[-.127, -.04], [.865, 2.434], [.127, -.105], [-.848, -2.294]],
                    v: [[-1.279, -4.148], [-.93, .36], [1.695, 4.078], [-.423, .184]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [225.823, 154.232],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 25",
        ix: 15,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.165, -.033], [-1.474, -2.466], [-.058, .115], [1.383, 2.376]],
                    o: [[-.132, -.008], [1.449, 2.481], [.112, -.122], [-1.414, -2.358]],
                    v: [[-2.497, -4.284], [-1.042, .548], [2.517, 4.202], [-.574, .286]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [230.255, 158.054],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 26",
        ix: 16,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.145, -.041], [-.341, 1.592], [.145, .014], [.339, -1.565]],
                    o: [[.139, .04], [.345, -1.592], [-.15, -.015], [-.336, 1.566]],
                    v: [[-.615, 2.841], [.38, .061], [.615, -2.866], [-.147, -.04]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [244.303, 147.956],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 27",
        ix: 17,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.147, -.056], [-.411, 2.277], [.137, -.015], [.413, -2.208]],
                    o: [[.124, .057], [.425, -2.275], [-.159, .007], [-.399, 2.209]],
                    v: [[-.852, 3.999], [.573, .09], [.626, -4.041], [.044, .005]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [246.867, 145.039],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 28",
        ix: 18,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.07, .043], [.452, .53], [.457, .192], [.549, -.17], [.336, -.564], [-.059, -.035], [-.406, .513], [-.904, .271], [-.465, -.412]],
                    o: [[.057, -.031], [-.231, -.257], [-.449, -.197], [-1.118, .344], [-.341, .587], [.067, .039], [.405, -.501], [.902, -.29], [.478, .417]],
                    v: [[2.811, .46], [2.291, -.508], [1.282, -1.247], [-.314, -1.324], [-2.392, .444], [-2.809, 1.454], [-2.077, .647], [-.162, -.826], [2.017, -.249]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [242.303, 124.271],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 29",
        ix: 19,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.051, .04], [.042, .457], [-.291, .665], [-.211, .358], [-.036, .034], [.172, .076], [.225, -.219], [.188, -.279], [.154, -.368], [-.163, -.507]],
                    o: [[.068, -.043], [-.048, -.458], [.285, -.643], [.246, -.336], [.028, -.015], [-.155, -.079], [-.226, .217], [-.179, .284], [-.324, .732], [.157, .518]],
                    v: [[-.52, 2.328], [-.63, 1.553], [-.305, -.203], [.551, -1.87], [1.139, -2.083], [.977, -2.289], [.271, -2.117], [-.281, -1.37], [-.803, -.394], [-1.003, 1.626]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [235.518, 131.291],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 30",
        ix: 20,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.026, .006], [-.647, 1.263], [-.879, .349], [-.982, -.469], [0, 0], [0, 0], [-.088, .565], [-.951, .62], [-.87, -.063], [-.051, .095], [.423, .3], [.948, .121], [1.089, -.695], [.234, -1.415], [-.155, -.584], [0, 0], [.964, -.429], [.307, -.683], [-.033, -.402]],
                    o: [[.097, .005], [.324, -.61], [.861, -.354], [0, 0], [0, 0], [-.131, -.516], [.209, -1.267], [.95, -.638], [1.794, .154], [.021, -.019], [-.424, -.291], [-.932, -.116], [-1.086, .677], [-.099, .632], [0, 0], [-1.154, -.535], [-.987, .428], [-.314, .693], [.035, .407]],
                    v: [[-6.452, 4.94], [-5.972, 2.764], [-4.186, 1.145], [-1.205, 1.21], [-.692, 1.456], [-.829, .914], [-.896, -.732], [1.014, -3.734], [3.932, -4.465], [6.617, -3.521], [6.044, -4.068], [3.975, -4.831], [.74, -4.132], [-1.428, -.807], [-1.342, 1.047], [-.966, .751], [-4.369, .734], [-6.285, 2.622], [-6.604, 4.333]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [229.318, 130.474],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 31",
        ix: 21,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.058, -.059], [-.235, -.297], [-.654, -.321], [-1.029, .196], [-.7, 1.071], [0, 0], [-1.411, -.277], [-1.124, 1.06], [-.242, 1.225], [0, 0], [-1.528, .22], [-.651, .883], [-.066, .585], [.022, -.003], [.114, -.563], [.665, -.818], [1.429, -.159], [1.124, 1.208], [0, 0], [0, 0], [.951, -.862], [1.262, .287], [.359, 1.003], [0, 0], [0, 0], [.915, -.198], [.62, .266]],
                    o: [[-.017, .01], [.236, .292], [.642, .32], [1.014, -.188], [0, 0], [.398, 1.18], [1.413, .338], [1.049, -.954], [0, 0], [1.276, 1.343], [1.569, -.208], [.67, -.899], [.061, -.592], [-.041, .001], [-.117, .556], [-.652, .807], [-1.4, .174], [0, 0], [0, 0], [-.232, 1.125], [-1.03, .958], [-1.264, -.238], [0, 0], [0, 0], [-.597, .957], [-.925, .208], [-1.264, -.561]],
                    v: [[-12.147, 1.588], [-11.852, 2.081], [-10.555, 3.1], [-7.964, 3.456], [-5.143, 1.586], [-5.562, 1.546], [-2.568, 3.946], [1.628, 2.733], [3.542, -.704], [3.09, -.579], [7.757, 1], [11.143, -1.011], [12.104, -3.373], [12.07, -4.281], [11.926, -3.397], [10.876, -1.204], [7.702, .567], [3.482, -.918], [3.133, -1.293], [3.029, -.793], [1.262, 2.355], [-2.456, 3.454], [-5.122, 1.395], [-5.283, .944], [-5.54, 1.355], [-8.038, 3.095], [-10.436, 2.862]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [235.341, 136.06],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 32",
        ix: 22,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !1,
                    i: [[0, 0], [.042, 5.213], [.487, 1.893], [1.162, 1.599], [2.545, .079], [1.633, -1.908], [2.333, -.933], [-.052, -2.432], [1.442, -1.192], [-.798, -1.645], [.359, -1.31], [-.934, -.997], [-1.172, -1.089], [.695, -1.699]],
                    o: [[-.225, -4.915], [-.016, -1.956], [-.49, -1.902], [-1.458, -2.004], [-2.545, -.08], [-1.703, -1.771], [-2.334, .933], [-1.55, -1.022], [-1.441, 1.192], [-1.328, .439], [-.359, 1.311], [1.091, 1.165], [1.348, 1.255], [0, 0]],
                    v: [[18.38, 15.657], [17.58, -.048], [17.335, -6.762], [15.172, -12.213], [8.707, -15.577], [1.959, -12.624], [-4.96, -14.062], [-8.871, -8.295], [-14.13, -7.997], [-15.261, -3.011], [-18.021, -.149], [-17.081, 3.627], [-13.116, 6.344], [-12.004, 11.369]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [233.997, 135.157],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 33",
        ix: 23,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-.003, -.153], [-1.829, .505], [.078, .112], [1.753, -.471]],
                    o: [[-.008, .135], [1.832, -.495], [-.077, -.132], [-1.748, .485]],
                    v: [[-3.233, .814], [.139, .56], [3.163, -.932], [-.002, .059]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [239.607, 169.459],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 34",
        ix: 24,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [.296, -3.275], [4.241, -3.238], [4.536, 2.738], [.983, 3.468], [.602, 3.553], [0, 0], [0, 0], [0, 0]],
                    o: [[-.107, 4.849], [-.467, 5.182], [-4.241, 3.237], [-3.148, -1.9], [-.983, -3.469], [-1.086, -6.407], [0, 0], [0, 0], [0, 0]],
                    v: [[16.568, -6.172], [16.737, 4.398], [10.087, 17.048], [-4.978, 18.52], [-11.5, 10.816], [-14.51, -2.398], [-17.034, -14.866], [1.412, -21.258], [13.218, -16.805]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [235.429, 148.833],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 35",
        ix: 25,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-1.095, -5.589], [.021, .162]],
                    o: [[-.155, -.037], [1.096, 5.589], [-.021, -.163]],
                    v: [[1.672, -5.041], [-2.794, 0], [3.868, 3.148]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.62, 1, .9683, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [221.017, 151.887],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 36",
        ix: 26,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-.724, -5.649], [.031, .16]],
                    o: [[.135, -.084], [.724, 5.649], [-.031, -.161]],
                    v: [[-3.513, -3.032], [2.789, 0], [-2.539, 5.089]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.62, 1, .9683, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [253.725, 146.626],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 37",
        ix: 27,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [1.436, 8.202], [0, 0], [-9.522, -4.94], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [-1.435, -8.202], [9.192, -5.684], [0, 0], [0, 0]],
                    v: [[14.803, 24.519], [-7.664, 27.871], [-8.716, 8.648], [-11.775, .377], [-15.862, -21.726], [14.449, -22.931], [15.862, -22.198]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.62, 1, .9683, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [235.381, 155.252],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 38",
        ix: 28,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[-8.279, -1.347], [-8.056, 1.986], [8.279, .525], [8.116, -1.986]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [0, 0, 0, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [288.843, 458.522],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 39",
        ix: 29,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.072, .053], [-.279, .42], [-.636, .644], [-1.059, .582], [-1.408, .072], [-1.252, -1.308], [-.241, -.443], [.027, -.013], [1.302, 1.181], [2.68, -.155], [1.272, -1.17]],
                    o: [[-.026, -.017], [.278, -.419], [.636, -.642], [1.048, -.59], [2.824, -.167], [.648, .643], [.238, .447], [-.086, .055], [-1.263, -1.187], [-2.672, .147], [-1.299, 1.197]],
                    v: [[-8.082, 2.743], [-7.704, 2.056], [-6.343, .413], [-3.814, -1.518], [-.062, -2.63], [6.473, -.25], [7.776, 1.453], [8.081, 2.176], [6.234, .005], [-.038, -2.135], [-6.101, .664]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [289.449, 466.427],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 40",
        ix: 30,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[8.088, -1.736], [-8.223, -.404], [-8.079, 1.736], [8.223, .35]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [290.094, 477.122],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 41",
        ix: 31,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.136, -.007], [.427, 8.175], [-.137, .008], [-.428, -8.178]],
                    o: [[-.137, .007], [-.427, -8.177], [.136, -.007], [.427, 8.174]],
                    v: [[.774, 14.804], [-.247, .014], [-.773, -14.803], [.248, -.011]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [289.416, 462.212],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 42",
        ix: 32,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[7.203, -15.82], [9.164, 14.435], [-7.138, 15.82], [-9.165, -14.49]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [0, 0, 0, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [289.152, 463.038],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 43",
        ix: 33,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[-7.992, -2.233], [-8.299, 1.093], [8.061, 2.234], [8.298, -.27]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [0, 0, 0, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [221.579, 458.896],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 44",
        ix: 34,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.063, .063], [-.341, .37], [-.73, .536], [-1.138, .407], [-1.402, -.151], [-1.029, -1.49], [-.169, -.476], [.028, -.009], [1.099, 1.372], [2.67, .271], [1.441, -.953]],
                    o: [[-.023, -.021], [.342, -.37], [.729, -.533], [1.129, -.417], [2.815, .282], [.539, .738], [.164, .479], [-.094, .041], [-1.06, -1.372], [-2.662, -.277], [-1.472, .977]],
                    v: [[-8.027, 1.075], [-7.546, .457], [-5.941, -.952], [-3.139, -2.457], [.742, -2.962], [6.818, .422], [7.836, 2.31], [8.022, 3.072], [6.542, .636], [.688, -2.47], [-5.742, -.665]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [220.51, 467.56],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 45",
        ix: 35,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[8.256, -.408], [-8.059, -1.673], [-8.256, .462], [8.06, 1.673]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [219.846, 477.84],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 46",
        ix: 36,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.136, .015], [-.872, 8.139], [-.136, -.014], [.871, -8.142]],
                    o: [[-.136, -.014], [.871, -8.142], [.136, .015], [-.871, 8.139]],
                    v: [[-1.578, 14.739], [-.246, -.026], [1.578, -14.74], [.246, .027]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [221.531, 463.038],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 47",
        ix: 37,
        cix: 2,
        np: 2,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[9.583, -14.454], [6.732, 15.73], [-9.583, 14.517], [-6.79, -15.73]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [0, 0, 0, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [221.173, 463.784],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 2
}, {
    ty: 4,
    nm: "Brao 2",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [275, 179, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [275, 179, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [30],
                t: 30
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 50
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [67],
                t: 81
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 100
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [50],
                t: 130
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 15",
        ix: 1,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.068, -.108], [2.702, -.189], [.064, .149], [-2.834, .166]],
                    o: [[-.044, .157], [-2.705, .153], [-.081, -.099], [2.832, -.194]],
                    v: [[4.844, .164], [-.036, -.213], [-4.831, .778], [-.07, -.733]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [307.841, 177.222],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 16",
        ix: 2,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.045, -.041], [3.596, 1.797], [-.034, .167], [-1.315, -.252], [-1.83, -.924], [-.976, -.911]],
                    o: [[-.115, .126], [-3.576, -1.837], [.007, -.061], [1.312, .249], [1.826, .929], [.981, .911]],
                    v: [[6.4, 3.212], [.435, -.902], [-6.411, -3.277], [-4.26, -3.076], [.671, -1.367], [4.964, 1.598]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [310.102, 180.444],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 18",
        ix: 3,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-2.689, 2.15], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [5.026, -4.02], [0, 0], [0, 0]],
                    v: [[-1.076, -22.639], [2.848, -7.501], [-6.122, -4.138], [-25.464, -8.342], [-25.464, 20.25], [-22.728, 27.685], [20.438, 6], [17.485, -11.863], [10.137, -27.685]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [300.956, 184.97],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 19",
        ix: 4,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [.341, 0], [0, 0], [-1.364, .613], [-.272, .477], [.545, .75], [.341, .545], [-.886, .205], [-.75, -.613], [-.409, .205], [0, 0], [.068, .205], [-1.871, -.327], [-.272, .272], [-.546, .613], [-1.091, -1.227], [-.344, -.068], [.136, .477], [0, .545], [-.545, .068], [0, 0], [-.457, -.841], [0, 0]],
                    o: [[0, 0], [-.341, 0], [0, 0], [1.363, -.613], [.273, -.477], [-.546, -.749], [-.341, -.545], [.886, -.204], [.749, .613], [.409, -.204], [0, 0], [-.068, -.204], [.895, .157], [.273, -.273], [.545, -.614], [1.09, 1.226], [.344, .069], [-.137, -.477], [0, -.545], [.545, -.068], [0, 0], [.53, .974], [0, 0]],
                    v: [[5.001, 12.225], [-1.099, 12.676], [-7.369, 13.221], [-5.733, 11.177], [-1.499, 9.137], [-1.167, 7.224], [-11.986, -4.153], [-11.986, -5.925], [-9.26, -4.562], [-4.234, -.886], [-4.166, -1.431], [-10.803, -8.396], [-9.774, -10.266], [-1.781, -3.407], [-6.96, -11.994], [-4.711, -11.994], [1.419, -4.43], [2.036, -5.179], [-.891, -11.061], [.202, -11.809], [6.602, -3.407], [11.577, 4.703], [12.872, 8.383]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.62, 1, .9683, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [296.317, 149.731],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 3
}, {
    ty: 4,
    nm: "Brao 1",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [203.875, 192.25, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [203.875, 192.25, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [14],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [60],
                t: 30
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [-15],
                t: 50
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [72],
                t: 81
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 100
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [76],
                t: 130
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [14],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 12",
        ix: 1,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.138, .04], [-1.869, 6.409], [-.138, -.04], [1.869, -6.411]],
                    o: [[-.138, -.04], [1.869, -6.411], [.138, .04], [-1.869, 6.408]],
                    v: [[-3.385, 11.605], [-.25, -.072], [3.385, -11.606], [.25, .074]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.1458, .1811, .2142, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [189.517, 230.852],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 17",
        ix: 2,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-3.709, 1.61], [0, 0], [-1.695, 4.901]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [6.296, -2.734], [0, 0], [1.695, -4.901]],
                    v: [[10.902, -33.358], [6.374, -24.294], [-5.066, 13.576], [-17.85, 16.986], [-20.253, 28.671], [3.447, 31.748], [20.253, 2.94], [43.618, -45.946]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.0314, .3412, .6275, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [191.908, 225.412],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 22",
        ix: 3,
        cix: 2,
        np: 4,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[.47, -.393], [-.809, -.85], [-1.442, -.931], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [.744, -1.172], [0, 0], [1.069, 1.275], [.753, .183], [-.609, -1.672], [.152, -.326], [.293, .289], [1.006, .144], [-.985, -1.617], [.237, -.378], [0, 0], [.83, -.11], [-.467, -.766], [-.106, -.461], [.481, .407]],
                    o: [[0, 0], [.809, .849], [1.442, .93], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-1.05, 1.653], [0, 0], [-1.068, -1.275], [-.754, -.182], [.61, 1.671], [-.151, .326], [-.292, -.288], [-1.072, -.153], [.985, 1.617], [-.237, .377], [0, 0], [-.921, .122], [.466, .766], [.069, .301], [-.482, -.407]],
                    v: [[-12.509, -1.38], [-12.86, .065], [.072, 11.328], [5.835, 13.38], [8.658, 12.855], [10.309, 6.053], [12.301, 2.78], [11.794, 2.028], [13.669, -5.244], [11.297, -4.732], [8.796, -.407], [4.79, -1.235], [-3.257, -13.198], [-4.545, -11.479], [-.106, -3.526], [-1.154, -3.041], [-8.804, -11.861], [-9.66, -9.53], [-3.743, -1.638], [-4.667, -1.717], [-11.407, -7.778], [-12.005, -5.964], [-5.444, 1.053], [-6.11, 2.139]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.62, 1, .9683, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [165.735, 238.923],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 4
}, {
    ty: 4,
    nm: "Engrenagem Principal",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [242.303, 196.513, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [239.303, 196.513, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [60],
                t: 30
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [60],
                t: 50
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [120],
                t: 81
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [120],
                t: 100
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 130
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 62",
        ix: 1,
        cix: 2,
        np: 6,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[11.776, -18.291], [-18.292, -11.775], [-11.775, 18.292], [18.292, 11.775]],
                    o: [[-11.776, 18.292], [18.292, 11.776], [11.774, -18.291], [-18.291, -11.775]],
                    v: [[-33.118, -21.322], [-21.322, 33.119], [33.119, 21.321], [21.321, -33.12]]
                },
                ix: 2
            }
        }, {
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 2",
            ix: 2,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-5.714, 2.921], [0, 0], [0, 0], [0, 0], [-6.252, -2.021], [0, 0], [0, 0], [0, 0], [-2.921, -5.715], [0, 0], [0, 0], [0, 0], [2.02, -6.252], [0, 0], [0, 0], [0, 0], [5.715, -2.921], [0, 0], [0, 0], [0, 0], [6.252, 2.02], [0, 0], [0, 0], [0, 0], [2.921, 5.716], [0, 0], [0, 0], [0, 0], [-2.019, 6.252], [0, 0], [0, 0]],
                    o: [[4.854, -4.427], [0, 0], [0, 0], [0, 0], [6.412, .294], [0, 0], [0, 0], [0, 0], [4.428, 4.856], [0, 0], [0, 0], [0, 0], [-.294, 6.411], [0, 0], [0, 0], [0, 0], [-4.855, 4.428], [0, 0], [0, 0], [0, 0], [-6.411, -.294], [0, 0], [0, 0], [0, 0], [-4.428, -4.855], [0, 0], [0, 0], [0, 0], [.294, -6.41], [0, 0], [0, 0], [0, 0]],
                    v: [[-49.354, -54.184], [-33.416, -65.224], [-33.248, -83.203], [-4.179, -89.501], [3.417, -73.207], [22.498, -69.755], [35.325, -82.343], [60.332, -66.241], [54.184, -49.358], [65.225, -33.415], [83.201, -33.247], [89.5, -4.178], [73.206, 3.418], [69.754, 22.497], [82.341, 35.324], [66.242, 60.333], [49.357, 54.184], [33.415, 65.224], [33.246, 83.203], [4.179, 89.501], [-3.418, 73.205], [-22.498, 69.753], [-35.323, 82.341], [-60.332, 66.24], [-54.184, 49.356], [-65.226, 33.415], [-83.202, 33.247], [-89.501, 4.178], [-73.206, -3.419], [-69.754, -22.498], [-82.34, -35.324], [-66.242, -60.333]]
                },
                ix: 2
            }
        }, {
            ty: "mm",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Filter - Merge",
            nm: "Merge Paths 1",
            mm: 1
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.7, 1, .945, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [242.303, 196.513],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 5
}, {
    ty: 0,
    nm: "Pre-comp 2",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [250, 250, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [250, 250, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        }
    },
    ef: [],
    w: 500,
    h: 500,
    refId: "comp_1",
    ind: 6
}, {
    ty: 4,
    nm: "Engrenagens 6",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [85.924, 237.173, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [58, 58, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [366.924, 58.173, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 77",
        ix: 1,
        cix: 2,
        np: 5,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[4.98, -5.158], [-5.158, -4.98], [-4.98, 5.158], [5.158, 4.98]],
                    o: [[-4.98, 5.158], [5.157, 4.979], [4.979, -5.158], [-5.158, -4.979]],
                    v: [[-8.956, -9.413], [-8.633, 8.943], [9.721, 8.62], [9.398, -9.736]]
                },
                ix: 2
            }
        }, {
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 2",
            ix: 2,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-2.512, .714], [0, 0], [0, 0], [0, 0], [-2.335, -1.301], [0, 0], [0, 0], [0, 0], [-.713, -2.512], [0, 0], [0, 0], [0, 0], [1.302, -2.335], [0, 0], [0, 0], [0, 0], [2.512, -.713], [0, 0], [0, 0], [0, 0], [2.335, 1.301], [0, 0], [0, 0], [0, 0], [.713, 2.512], [0, 0], [0, 0], [0, 0], [-1.3, 2.335], [0, 0], [0, 0]],
                    o: [[2.288, -1.382], [0, 0], [0, 0], [0, 0], [2.535, .625], [0, 0], [0, 0], [0, 0], [1.383, 2.288], [0, 0], [0, 0], [0, 0], [-.625, 2.535], [0, 0], [0, 0], [0, 0], [-2.288, 1.382], [0, 0], [0, 0], [0, 0], [-2.536, -.625], [0, 0], [0, 0], [0, 0], [-1.382, -2.289], [0, 0], [0, 0], [0, 0], [.625, -2.535], [0, 0], [0, 0], [0, 0]],
                    v: [[-15.407, -25.531], [-8.172, -28.675], [-6.682, -35.835], [5.417, -36.048], [7.16, -28.945], [14.501, -26.057], [20.616, -30.064], [29.32, -21.658], [25.531, -15.408], [28.674, -8.171], [35.835, -6.682], [36.048, 5.417], [28.943, 7.159], [26.056, 14.499], [30.063, 20.614], [21.659, 29.32], [15.408, 25.53], [8.172, 28.673], [6.682, 35.835], [-5.418, 36.048], [-7.159, 28.943], [-14.5, 26.055], [-20.615, 30.063], [-29.32, 21.658], [-25.531, 15.407], [-28.674, 8.171], [-35.835, 6.68], [-36.048, -5.417], [-28.943, -7.16], [-26.055, -14.501], [-30.064, -20.615], [-21.659, -29.321]]
                },
                ix: 2
            }
        }, {
            ty: "mm",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Filter - Merge",
            nm: "Merge Paths 1",
            mm: 1
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [85.924, 237.173],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "st",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Graphic - Stroke",
        nm: "Stroke 1",
        lc: 1,
        lj: 1,
        ml: 4,
        o: {
            a: 0,
            k: 100,
            ix: 4
        },
        w: {
            a: 0,
            k: 2,
            ix: 5
        },
        d: [],
        c: {
            a: 0,
            k: [.74, 1, .9523, 1],
            ix: 3
        }
    }],
    ind: 7
}, {
    ty: 4,
    nm: "Engrenagens 5",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [85.924, 237.173, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [58, 58, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [57.924, 175.173, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 77",
        ix: 1,
        cix: 2,
        np: 5,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[4.98, -5.158], [-5.158, -4.98], [-4.98, 5.158], [5.158, 4.98]],
                    o: [[-4.98, 5.158], [5.157, 4.979], [4.979, -5.158], [-5.158, -4.979]],
                    v: [[-8.956, -9.413], [-8.633, 8.943], [9.721, 8.62], [9.398, -9.736]]
                },
                ix: 2
            }
        }, {
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 2",
            ix: 2,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-2.512, .714], [0, 0], [0, 0], [0, 0], [-2.335, -1.301], [0, 0], [0, 0], [0, 0], [-.713, -2.512], [0, 0], [0, 0], [0, 0], [1.302, -2.335], [0, 0], [0, 0], [0, 0], [2.512, -.713], [0, 0], [0, 0], [0, 0], [2.335, 1.301], [0, 0], [0, 0], [0, 0], [.713, 2.512], [0, 0], [0, 0], [0, 0], [-1.3, 2.335], [0, 0], [0, 0]],
                    o: [[2.288, -1.382], [0, 0], [0, 0], [0, 0], [2.535, .625], [0, 0], [0, 0], [0, 0], [1.383, 2.288], [0, 0], [0, 0], [0, 0], [-.625, 2.535], [0, 0], [0, 0], [0, 0], [-2.288, 1.382], [0, 0], [0, 0], [0, 0], [-2.536, -.625], [0, 0], [0, 0], [0, 0], [-1.382, -2.289], [0, 0], [0, 0], [0, 0], [.625, -2.535], [0, 0], [0, 0], [0, 0]],
                    v: [[-15.407, -25.531], [-8.172, -28.675], [-6.682, -35.835], [5.417, -36.048], [7.16, -28.945], [14.501, -26.057], [20.616, -30.064], [29.32, -21.658], [25.531, -15.408], [28.674, -8.171], [35.835, -6.682], [36.048, 5.417], [28.943, 7.159], [26.056, 14.499], [30.063, 20.614], [21.659, 29.32], [15.408, 25.53], [8.172, 28.673], [6.682, 35.835], [-5.418, 36.048], [-7.159, 28.943], [-14.5, 26.055], [-20.615, 30.063], [-29.32, 21.658], [-25.531, 15.407], [-28.674, 8.171], [-35.835, 6.68], [-36.048, -5.417], [-28.943, -7.16], [-26.055, -14.501], [-30.064, -20.615], [-21.659, -29.321]]
                },
                ix: 2
            }
        }, {
            ty: "mm",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Filter - Merge",
            nm: "Merge Paths 1",
            mm: 1
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [85.924, 237.173],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }, {
        ty: "st",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Graphic - Stroke",
        nm: "Stroke 1",
        lc: 1,
        lj: 1,
        ml: 4,
        o: {
            a: 0,
            k: 100,
            ix: 4
        },
        w: {
            a: 0,
            k: 2,
            ix: 5
        },
        d: [],
        c: {
            a: 0,
            k: [.74, 1, .9523, 1],
            ix: 3
        }
    }],
    ind: 8
}, {
    ty: 4,
    nm: "Engrenagens 4",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [85.924, 237.173, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [83, 83, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [414.924, 92.173, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 77",
        ix: 1,
        cix: 2,
        np: 6,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[4.98, -5.158], [-5.158, -4.98], [-4.98, 5.158], [5.158, 4.98]],
                    o: [[-4.98, 5.158], [5.157, 4.979], [4.979, -5.158], [-5.158, -4.979]],
                    v: [[-8.956, -9.413], [-8.633, 8.943], [9.721, 8.62], [9.398, -9.736]]
                },
                ix: 2
            }
        }, {
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 2",
            ix: 2,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-2.512, .714], [0, 0], [0, 0], [0, 0], [-2.335, -1.301], [0, 0], [0, 0], [0, 0], [-.713, -2.512], [0, 0], [0, 0], [0, 0], [1.302, -2.335], [0, 0], [0, 0], [0, 0], [2.512, -.713], [0, 0], [0, 0], [0, 0], [2.335, 1.301], [0, 0], [0, 0], [0, 0], [.713, 2.512], [0, 0], [0, 0], [0, 0], [-1.3, 2.335], [0, 0], [0, 0]],
                    o: [[2.288, -1.382], [0, 0], [0, 0], [0, 0], [2.535, .625], [0, 0], [0, 0], [0, 0], [1.383, 2.288], [0, 0], [0, 0], [0, 0], [-.625, 2.535], [0, 0], [0, 0], [0, 0], [-2.288, 1.382], [0, 0], [0, 0], [0, 0], [-2.536, -.625], [0, 0], [0, 0], [0, 0], [-1.382, -2.289], [0, 0], [0, 0], [0, 0], [.625, -2.535], [0, 0], [0, 0], [0, 0]],
                    v: [[-15.407, -25.531], [-8.172, -28.675], [-6.682, -35.835], [5.417, -36.048], [7.16, -28.945], [14.501, -26.057], [20.616, -30.064], [29.32, -21.658], [25.531, -15.408], [28.674, -8.171], [35.835, -6.682], [36.048, 5.417], [28.943, 7.159], [26.056, 14.499], [30.063, 20.614], [21.659, 29.32], [15.408, 25.53], [8.172, 28.673], [6.682, 35.835], [-5.418, 36.048], [-7.159, 28.943], [-14.5, 26.055], [-20.615, 30.063], [-29.32, 21.658], [-25.531, 15.407], [-28.674, 8.171], [-35.835, 6.68], [-36.048, -5.417], [-28.943, -7.16], [-26.055, -14.501], [-30.064, -20.615], [-21.659, -29.321]]
                },
                ix: 2
            }
        }, {
            ty: "mm",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Filter - Merge",
            nm: "Merge Paths 1",
            mm: 1
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.78, 1, .9597, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [85.924, 237.173],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 9
}, {
    ty: 4,
    nm: "Engrenagens 3",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [397.045, 165.234, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [79, 79, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [142.045, 65.234, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 80",
        ix: 1,
        cix: 2,
        np: 6,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[4.98, -5.158], [-5.159, -4.979], [-4.98, 5.157], [5.158, 4.98]],
                    o: [[-4.98, 5.158], [5.157, 4.98], [4.979, -5.158], [-5.158, -4.979]],
                    v: [[-8.957, -9.413], [-8.634, 8.942], [9.721, 8.62], [9.398, -9.736]]
                },
                ix: 2
            }
        }, {
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 2",
            ix: 2,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-2.512, .714], [0, 0], [0, 0], [0, 0], [-2.335, -1.301], [0, 0], [0, 0], [0, 0], [-.713, -2.512], [0, 0], [0, 0], [0, 0], [1.302, -2.335], [0, 0], [0, 0], [0, 0], [2.512, -.713], [0, 0], [0, 0], [0, 0], [2.335, 1.301], [0, 0], [0, 0], [0, 0], [.713, 2.512], [0, 0], [0, 0], [0, 0], [-1.3, 2.335], [0, 0], [0, 0]],
                    o: [[2.288, -1.382], [0, 0], [0, 0], [0, 0], [2.535, .625], [0, 0], [0, 0], [0, 0], [1.383, 2.289], [0, 0], [0, 0], [0, 0], [-.624, 2.535], [0, 0], [0, 0], [0, 0], [-2.288, 1.382], [0, 0], [0, 0], [0, 0], [-2.536, -.625], [0, 0], [0, 0], [0, 0], [-1.383, -2.288], [0, 0], [0, 0], [0, 0], [.625, -2.535], [0, 0], [0, 0], [0, 0]],
                    v: [[-15.407, -25.531], [-8.172, -28.675], [-6.682, -35.835], [5.417, -36.048], [7.159, -28.945], [14.5, -26.057], [20.615, -30.064], [29.32, -21.658], [25.53, -15.408], [28.674, -8.171], [35.835, -6.682], [36.047, 5.417], [28.943, 7.16], [26.055, 14.499], [30.063, 20.614], [21.659, 29.32], [15.407, 25.531], [8.171, 28.673], [6.681, 35.835], [-5.418, 36.048], [-7.159, 28.943], [-14.5, 26.055], [-20.615, 30.063], [-29.321, 21.657], [-25.53, 15.406], [-28.675, 8.171], [-35.836, 6.68], [-36.048, -5.417], [-28.944, -7.16], [-26.056, -14.501], [-30.064, -20.615], [-21.659, -29.321]]
                },
                ix: 2
            }
        }, {
            ty: "mm",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Filter - Merge",
            nm: "Merge Paths 1",
            mm: 1
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.74, 1, .9523, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [397.045, 165.234],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 10
}, {
    ty: 4,
    nm: "Engrenagens 2",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [85.924, 237.173, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [85.924, 237.173, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 77",
        ix: 1,
        cix: 2,
        np: 6,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[4.98, -5.158], [-5.158, -4.98], [-4.98, 5.158], [5.158, 4.98]],
                    o: [[-4.98, 5.158], [5.157, 4.979], [4.979, -5.158], [-5.158, -4.979]],
                    v: [[-8.956, -9.413], [-8.633, 8.943], [9.721, 8.62], [9.398, -9.736]]
                },
                ix: 2
            }
        }, {
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 2",
            ix: 2,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-2.512, .714], [0, 0], [0, 0], [0, 0], [-2.335, -1.301], [0, 0], [0, 0], [0, 0], [-.713, -2.512], [0, 0], [0, 0], [0, 0], [1.302, -2.335], [0, 0], [0, 0], [0, 0], [2.512, -.713], [0, 0], [0, 0], [0, 0], [2.335, 1.301], [0, 0], [0, 0], [0, 0], [.713, 2.512], [0, 0], [0, 0], [0, 0], [-1.3, 2.335], [0, 0], [0, 0]],
                    o: [[2.288, -1.382], [0, 0], [0, 0], [0, 0], [2.535, .625], [0, 0], [0, 0], [0, 0], [1.383, 2.288], [0, 0], [0, 0], [0, 0], [-.625, 2.535], [0, 0], [0, 0], [0, 0], [-2.288, 1.382], [0, 0], [0, 0], [0, 0], [-2.536, -.625], [0, 0], [0, 0], [0, 0], [-1.382, -2.289], [0, 0], [0, 0], [0, 0], [.625, -2.535], [0, 0], [0, 0], [0, 0]],
                    v: [[-15.407, -25.531], [-8.172, -28.675], [-6.682, -35.835], [5.417, -36.048], [7.16, -28.945], [14.501, -26.057], [20.616, -30.064], [29.32, -21.658], [25.531, -15.408], [28.674, -8.171], [35.835, -6.682], [36.048, 5.417], [28.943, 7.159], [26.056, 14.499], [30.063, 20.614], [21.659, 29.32], [15.408, 25.53], [8.172, 28.673], [6.682, 35.835], [-5.418, 36.048], [-7.159, 28.943], [-14.5, 26.055], [-20.615, 30.063], [-29.32, 21.658], [-25.531, 15.407], [-28.674, 8.171], [-35.835, 6.68], [-36.048, -5.417], [-28.943, -7.16], [-26.055, -14.501], [-30.064, -20.615], [-21.659, -29.321]]
                },
                ix: 2
            }
        }, {
            ty: "mm",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Filter - Merge",
            nm: "Merge Paths 1",
            mm: 1
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.78, 1, .9597, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [85.924, 237.173],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 11
}, {
    ty: 4,
    nm: "Engrenagens 1",
    mn: "",
    sr: 1,
    st: 0,
    op: 150.000006109625,
    ip: 0,
    hd: !1,
    cl: "",
    ln: "",
    ddd: 0,
    bm: 0,
    tt: 0,
    hasMask: !1,
    td: 0,
    ao: 0,
    ks: {
        a: {
            a: 0,
            k: [397.045, 165.234, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        },
        sk: {
            a: 0,
            k: 0
        },
        p: {
            a: 0,
            k: [397.045, 165.234, 0],
            ix: 2
        },
        sa: {
            a: 0,
            k: 0
        },
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [0],
                t: 0
            }, {
                o: {
                    x: .167,
                    y: .167
                },
                i: {
                    x: .833,
                    y: .833
                },
                s: [180],
                t: 149.000006068894
            }],
            ix: 10
        }
    },
    ef: [],
    shapes: [{
        ty: "gr",
        bm: 0,
        cl: "",
        ln: "",
        hd: !1,
        mn: "ADBE Vector Group",
        nm: "Group 80",
        ix: 1,
        cix: 2,
        np: 6,
        it: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[4.98, -5.158], [-5.159, -4.979], [-4.98, 5.157], [5.158, 4.98]],
                    o: [[-4.98, 5.158], [5.157, 4.98], [4.979, -5.158], [-5.158, -4.979]],
                    v: [[-8.957, -9.413], [-8.634, 8.942], [9.721, 8.62], [9.398, -9.736]]
                },
                ix: 2
            }
        }, {
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 2",
            ix: 2,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [-2.512, .714], [0, 0], [0, 0], [0, 0], [-2.335, -1.301], [0, 0], [0, 0], [0, 0], [-.713, -2.512], [0, 0], [0, 0], [0, 0], [1.302, -2.335], [0, 0], [0, 0], [0, 0], [2.512, -.713], [0, 0], [0, 0], [0, 0], [2.335, 1.301], [0, 0], [0, 0], [0, 0], [.713, 2.512], [0, 0], [0, 0], [0, 0], [-1.3, 2.335], [0, 0], [0, 0]],
                    o: [[2.288, -1.382], [0, 0], [0, 0], [0, 0], [2.535, .625], [0, 0], [0, 0], [0, 0], [1.383, 2.289], [0, 0], [0, 0], [0, 0], [-.624, 2.535], [0, 0], [0, 0], [0, 0], [-2.288, 1.382], [0, 0], [0, 0], [0, 0], [-2.536, -.625], [0, 0], [0, 0], [0, 0], [-1.383, -2.288], [0, 0], [0, 0], [0, 0], [.625, -2.535], [0, 0], [0, 0], [0, 0]],
                    v: [[-15.407, -25.531], [-8.172, -28.675], [-6.682, -35.835], [5.417, -36.048], [7.159, -28.945], [14.5, -26.057], [20.615, -30.064], [29.32, -21.658], [25.53, -15.408], [28.674, -8.171], [35.835, -6.682], [36.047, 5.417], [28.943, 7.16], [26.055, 14.499], [30.063, 20.614], [21.659, 29.32], [15.407, 25.531], [8.171, 28.673], [6.681, 35.835], [-5.418, 36.048], [-7.159, 28.943], [-14.5, 26.055], [-20.615, 30.063], [-29.321, 21.657], [-25.53, 15.406], [-28.675, 8.171], [-35.836, 6.68], [-36.048, -5.417], [-28.944, -7.16], [-26.056, -14.501], [-30.064, -20.615], [-21.659, -29.321]]
                },
                ix: 2
            }
        }, {
            ty: "mm",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Filter - Merge",
            nm: "Merge Paths 1",
            mm: 1
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 0,
                k: [.74, 1, .9523, 1],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }, {
            ty: "tr",
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            p: {
                a: 0,
                k: [397.045, 165.234],
                ix: 2
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            }
        }]
    }],
    ind: 12
}]
  , ddd$1 = 0
  , h$1 = 500
  , w$1 = 500
  , meta$1 = {
    a: "",
    k: "",
    d: "",
    g: "LottieFiles AE 0.1.21",
    tc: "#ffffff"
}
  , v$1 = "5.5.7"
  , fr$1 = 29.9700012207031
  , op$1 = 150.000006109625
  , ip$1 = 0
  , assets$1 = [{
    nm: "",
    mn: "",
    layers: [{
        ty: 4,
        nm: "1",
        mn: "",
        sr: 1,
        st: 0,
        op: 150.000006109625,
        ip: 0,
        hd: !1,
        cl: "",
        ln: "",
        ddd: 0,
        bm: 0,
        tt: 0,
        hasMask: !1,
        td: 0,
        ao: 0,
        ks: {
            a: {
                a: 0,
                k: [254.5, 196, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100, 100],
                ix: 6
            },
            sk: {
                a: 0,
                k: 0
            },
            p: {
                a: 0,
                k: [252, 191, 0],
                ix: 2
            },
            sa: {
                a: 0,
                k: 0
            },
            o: {
                a: 0,
                k: 100,
                ix: 11
            },
            r: {
                a: 0,
                k: 0,
                ix: 10
            }
        },
        ef: [],
        shapes: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[148.384, 304.168], [131.365, 290.941], [118.983, 281.319], [118.983, 304.168], [18.358, 304.168], [18.358, 341.168], [118.983, 341.168], [118.983, 364.017], [148.384, 341.168], [171.477, 323.221], [172.188, 322.668]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 1,
                k: [{
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 0
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 23
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 45
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 67
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 89
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 111
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 133
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 149
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 154
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 155
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 177
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 178
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 199
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 200
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 221
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 222
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 243
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 244
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 265
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 266
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 287
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 288
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 309
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 310
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 332.000013522637
                }],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }],
        ind: 0
    }, {
        ty: 4,
        nm: "2",
        mn: "",
        sr: 1,
        st: 0,
        op: 150.000006109625,
        ip: 0,
        hd: !1,
        cl: "",
        ln: "",
        ddd: 0,
        bm: 0,
        tt: 0,
        hasMask: !1,
        td: 0,
        ao: 0,
        ks: {
            a: {
                a: 0,
                k: [254.5, 196, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100, 100],
                ix: 6
            },
            sk: {
                a: 0,
                k: 0
            },
            p: {
                a: 0,
                k: [252, 191, 0],
                ix: 2
            },
            sa: {
                a: 0,
                k: 0
            },
            o: {
                a: 0,
                k: 100,
                ix: 11
            },
            r: {
                a: 0,
                k: 0,
                ix: 10
            }
        },
        ef: [],
        shapes: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [33.483, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-12.78, 3.582], [-17.752, 17.689], [-4.072, 5.308], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [-20.908, 26.047], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [13.702, 0], [23.809, -6.673], [4.648, -4.632], [0, 0], [0, 0]],
                    v: [[375.605, 261.672], [373.454, 232.39], [345.308, 241.805], [315.174, 251.884], [332.225, 263.235], [246.886, 304.168], [241.658, 304.168], [148.383, 304.168], [172.188, 322.668], [171.476, 323.221], [148.384, 341.168], [241.658, 341.168], [246.886, 341.168], [286.748, 335.71], [350.014, 298.71], [363.12, 283.802], [377.956, 293.679]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 1,
                k: [{
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 0
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 23
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 46
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 68
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 90
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 112
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 134
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 149
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 155
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 156
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 177
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 178
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 200
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 201
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 222
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 223
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 244
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 245
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 266
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 267
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 288
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 289
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 310
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 311
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 332
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 333
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 355.000014459446
                }],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }],
        ind: 1
    }, {
        ty: 4,
        nm: "3",
        mn: "",
        sr: 1,
        st: 0,
        op: 150.000006109625,
        ip: 0,
        hd: !1,
        cl: "",
        ln: "",
        ddd: 0,
        bm: 0,
        tt: 0,
        hasMask: !1,
        td: 0,
        ao: 0,
        ks: {
            a: {
                a: 0,
                k: [254.5, 196, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100, 100],
                ix: 6
            },
            sk: {
                a: 0,
                k: 0
            },
            p: {
                a: 0,
                k: [252, 191, 0],
                ix: 2
            },
            sa: {
                a: 0,
                k: 0
            },
            o: {
                a: 0,
                k: 100,
                ix: 11
            },
            r: {
                a: 0,
                k: 0,
                ix: 10
            }
        },
        ef: [],
        shapes: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[10.438, 20.607], [2.296, 4.097], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-.729, -1.439], [0, -17.38], [5.964, -14.14], [0, 0], [0, 0], [0, 0], [0, 21.689]],
                    o: [[-1.107, -2.184], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [1.679, 3.035], [7.788, 15.376], [0, 14.554], [0, 0], [0, 0], [0, 0], [9.145, -19.508], [0, -23.243]],
                    v: [[377.586, 128.656], [371.405, 117.263], [386.964, 107.026], [355.208, 96.213], [328.791, 87.218], [326.251, 119.405], [323.957, 148.481], [340.41, 137.655], [344.579, 145.376], [356.315, 194.74], [345.309, 241.804], [373.455, 232.39], [375.606, 261.672], [376.734, 262.201], [393.315, 194.74]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 1,
                k: [{
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 0
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 23
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 46
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 69
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 91
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 113
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 135
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 149
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 156
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 157
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 178
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 179
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 200
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 201
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 223
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 224
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 245
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 246
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 267
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 268
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 289
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 290
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 311
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 312
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 333
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 334
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 355
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 356
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 378.000015396256
                }],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }],
        ind: 2
    }, {
        ty: 4,
        nm: "4",
        mn: "",
        sr: 1,
        st: 0,
        op: 150.000006109625,
        ip: 0,
        hd: !1,
        cl: "",
        ln: "",
        ddd: 0,
        bm: 0,
        tt: 0,
        hasMask: !1,
        td: 0,
        ao: 0,
        ks: {
            a: {
                a: 0,
                k: [254.5, 196, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100, 100],
                ix: 6
            },
            sk: {
                a: 0,
                k: 0
            },
            p: {
                a: 0,
                k: [252, 191, 0],
                ix: 2
            },
            sa: {
                a: 0,
                k: 0
            },
            o: {
                a: 0,
                k: 100,
                ix: 11
            },
            r: {
                a: 0,
                k: 0,
                ix: 10
            }
        },
        ef: [],
        shapes: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[31.612, 5.631], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-15.965, -16.807], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [22.511, 4.211], [0, 0], [0, 0], [-21.91, -24.072]],
                    v: [[272.556, 50.592], [276.124, 27.112], [234.462, 50.711], [214.641, 61.938], [238.089, 87.588], [262.824, 114.646], [266.997, 87.18], [326.251, 119.405], [328.791, 87.218], [355.208, 96.213]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 1,
                k: [{
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 0
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 23
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 46
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 69
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 92
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 114
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 136
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 149
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 157
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 158
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 179
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 180
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 201
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 202
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 223
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 224
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 246
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 247
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 268
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 269
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 290
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 291
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 312
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 313
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 334
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 335
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 356
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 357
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 378
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 379
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 401.000016333065
                }],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }],
        ind: 3
    }, {
        ty: 4,
        nm: "5",
        mn: "",
        sr: 1,
        st: 0,
        op: 150.000006109625,
        ip: 0,
        hd: !1,
        cl: "",
        ln: "",
        ddd: 0,
        bm: 0,
        tt: 0,
        hasMask: !1,
        td: 0,
        ao: 0,
        ks: {
            a: {
                a: 0,
                k: [254.5, 196, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100, 100],
                ix: 6
            },
            sk: {
                a: 0,
                k: 0
            },
            p: {
                a: 0,
                k: [252, 191, 0],
                ix: 2
            },
            sa: {
                a: 0,
                k: 0
            },
            o: {
                a: 0,
                k: 100,
                ix: 11
            },
            r: {
                a: 0,
                k: 0,
                ix: 10
            }
        },
        ef: [],
        shapes: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[-44.195, 1.553], [0, 0], [0, 0], [19.862, -53.55], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [-59.634, 3.031], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [15.781, -38.975]],
                    v: [[238.089, 87.588], [214.641, 61.938], [234.462, 50.711], [104.637, 146.164], [85.016, 140.783], [97.571, 171.068], [108.55, 197.552], [133.821, 178.64], [157.752, 160.731], [140.508, 156.002]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 1,
                k: [{
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 0
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 23
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 46
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 69
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 92
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 115
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 137
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 149
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 158
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 159
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 180
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 181
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 202
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 203
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 224
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 225
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 246
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 247
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 269
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 270
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 291
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 292
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 313
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 314
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 335
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 336
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 357
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 358
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 379
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 380
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 401
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 402.000016373796
                }],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }],
        ind: 4
    }],
    id: "comp_0",
    fr: 30
}, {
    nm: "",
    mn: "",
    layers: [{
        ty: 4,
        nm: "6",
        mn: "",
        sr: 1,
        st: 0,
        op: 150.000006109625,
        ip: 0,
        hd: !1,
        cl: "",
        ln: "",
        ddd: 0,
        bm: 0,
        tt: 0,
        hasMask: !1,
        td: 0,
        ao: 0,
        ks: {
            a: {
                a: 0,
                k: [254.5, 196, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100, 100],
                ix: 6
            },
            sk: {
                a: 0,
                k: 0
            },
            p: {
                a: 0,
                k: [252, 191, 0],
                ix: 2
            },
            sa: {
                a: 0,
                k: 0
            },
            o: {
                a: 0,
                k: 100,
                ix: 11
            },
            r: {
                a: 0,
                k: 0,
                ix: 10
            }
        },
        ef: [],
        shapes: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 60.339], [-.841, 7.419], [0, 0], [0, 0], [-.4, -5.068], [-20.096, -23.011], [0, 0]],
                    o: [[-60.339, 0], [0, 0], [0, 0], [0, 0], [-1.149, 11.506], [2.545, 32.236], [0, 0], [0, 0]],
                    v: [[241.658, 304.168], [132.23, 194.74], [133.821, 178.64], [108.551, 197.552], [97.571, 171.068], [95.687, 206.368], [131.364, 290.941], [148.384, 304.168]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 1,
                k: [{
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 0
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 23
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 46
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 69
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 92
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 115
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 138
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 149
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 159
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 160
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 181
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 182
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 203
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 204
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 225
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 226
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 247
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 248
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 269
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 270
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 292
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 293
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 314
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 315
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 336
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 337
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 358
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 359
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 380
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 381
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 402
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 403.000016414526
                }],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }],
        ind: 0
    }, {
        ty: 4,
        nm: "7",
        mn: "",
        sr: 1,
        st: 0,
        op: 150.000006109625,
        ip: 0,
        hd: !1,
        cl: "",
        ln: "",
        ddd: 0,
        bm: 0,
        tt: 0,
        hasMask: !1,
        td: 0,
        ao: 0,
        ks: {
            a: {
                a: 0,
                k: [254.5, 196, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100, 100],
                ix: 6
            },
            sk: {
                a: 0,
                k: 0
            },
            p: {
                a: 0,
                k: [252, 191, 0],
                ix: 2
            },
            sa: {
                a: 0,
                k: 0
            },
            o: {
                a: 0,
                k: 100,
                ix: 11
            },
            r: {
                a: 0,
                k: 0,
                ix: 10
            }
        },
        ef: [],
        shapes: [{
            ty: "sh",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Shape - Group",
            nm: "Path 1",
            ix: 1,
            d: 1,
            ks: {
                a: 0,
                k: {
                    c: !0,
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [23.809, -6.672], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [-17.752, 17.69], [0, 0], [0, 0], [0, 0]],
                    v: [[490.323, 317.209], [436.425, 275.86], [436.425, 279.584], [436.425, 298.709], [350.014, 298.709], [286.748, 335.709], [436.425, 335.709], [436.425, 358.558]]
                },
                ix: 2
            }
        }, {
            ty: "fl",
            bm: 0,
            cl: "",
            ln: "",
            hd: !1,
            mn: "ADBE Vector Graphic - Fill",
            nm: "Fill 1",
            c: {
                a: 1,
                k: [{
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 0
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 23
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 46
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 69
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 92
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 115
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 138
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 149
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 159
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 160
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 181
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 182
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 203
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 204
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 225
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 226
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 247
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 248
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 269
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 270
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 292
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 293
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 314
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 315
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 336
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 337
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 358
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 359
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 380
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 381
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 402
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 403
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.0039, .6157, .5686, 1],
                    t: 424
                }, {
                    o: {
                        x: .167,
                        y: .167
                    },
                    i: {
                        x: .833,
                        y: .833
                    },
                    s: [.34, 1, .945, 1],
                    t: 425.000017310605
                }],
                ix: 4
            },
            r: 1,
            o: {
                a: 0,
                k: 100,
                ix: 5
            }
        }],
        ind: 1
    }],
    id: "comp_1",
    fr: 30
}]
  , animationData$1 = {
    nm: nm$1,
    mn,
    layers: layers$1,
    ddd: ddd$1,
    h: h$1,
    w: w$1,
    meta: meta$1,
    v: v$1,
    fr: fr$1,
    op: op$1,
    ip: ip$1,
    assets: assets$1
}
  , defaultOptions$1 = {
    loop: !0,
    play: !0,
    animationData: animationData$1,
    rendererSettings: {
        preserveAspectRatio: "xMidYMid slice"
    }
}
  , Hero = () => jsxRuntimeExports.jsxs("section", {
    id: "home",
    className: `flex md:flex-row flex-col ${styles.paddingY}`,
    children: [jsxRuntimeExports.jsxs("div", {
        className: `flex-1 ${styles.flexStart} flex-col xl:px-0 sm:px-16 px-6`,
        children: [jsxRuntimeExports.jsxs("div", {
            className: "flex flex-row justify-between items-center w-full text-white",
            children: [jsxRuntimeExports.jsxs("h1", {
                className: "flex-1 font-poppins font-semibold ss:text-[52px] text-[52px] name-gradient1 text-black ss:leading-[80px] leading-[80px]",
                children: ["Hi, there!", jsxRuntimeExports.jsx("br", {
                    className: "sm:block hidden"
                }), " I am"]
            }), jsxRuntimeExports.jsx("div", {
                className: "ss:flex hidden md:mr-4 mr-0",
                children: jsxRuntimeExports.jsx(LetsConnect, {})
            })]
        }), jsxRuntimeExports.jsx("h1", {
            className: "font-poppins font-semibold ss:text-[68px] text-[52px] text-white ss:leading-[80px] leading-[80px] w-full",
            children: jsxRuntimeExports.jsx("span", {
                className: "name-gradient",
                children: aboutMe.name
            })
        }), jsxRuntimeExports.jsx("p", {
            className: `${styles.paragraph} max-w-[470px] mt-5`,
            children: aboutMe.intro
        })]
    }), jsxRuntimeExports.jsxs("div", {
        className: `flex-1 flex ${styles.flexCenter} md:my-0 my-10 relative`,
        children: [jsxRuntimeExports.jsx("div", {
            className: "relative z-index-[5] h-[90%] w-[85%]",
            children: jsxRuntimeExports.jsx(LottiePlayer, {
                ...defaultOptions$1
            })
        }), jsxRuntimeExports.jsx("div", {
            className: "absolute z-[1] w-[50%] h-[50%] rounded-full bottom-40 white__gradient"
        })]
    }), jsxRuntimeExports.jsx("div", {
        className: `ss:hidden ${styles.flexCenter}`,
        children: jsxRuntimeExports.jsx(LetsConnect, {})
    })]
})
  , v = "4.8.0"
  , meta = {
    g: "LottieFiles AE 1.0.0",
    a: "",
    k: "",
    d: "",
    tc: ""
}
  , fr = 59.9400024414062
  , ip = 0
  , op = 197.000008023974
  , w = 1e3
  , h = 1e3
  , nm = "Graduation"
  , ddd = 1
  , assets = []
  , layers = [{
    ddd: 0,
    ind: 1,
    ty: 4,
    nm: "Cap Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                i: {
                    x: [.496],
                    y: [1]
                },
                o: {
                    x: [.333],
                    y: [0]
                },
                t: 41,
                s: [360]
            }, {
                t: 67.0000027289659,
                s: [0]
            }],
            ix: 10
        },
        p: {
            a: 1,
            k: [{
                i: {
                    x: .496,
                    y: 1
                },
                o: {
                    x: .333,
                    y: 0
                },
                t: 41,
                s: [256.778, -124.098, 0],
                to: [0, 92.167, 0],
                ti: [0, -92.167, 0]
            }, {
                t: 67.0000027289659,
                s: [256.778, 428.902, 0]
            }],
            ix: 2
        },
        a: {
            a: 0,
            k: [84.943, 82.153, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 139,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 184.000007494474,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[-16.043, 39.46], [16.043, -39.46]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.26666666666666666, .6235294117647059, .9803921568627451, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 8,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [36.132, 103.036],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[1.082, -.428], [0, 0], [.433, -1.097], [0, 0], [-2.191, -.883], [-1.069, .491], [0, 0], [-.432, .948], [0, 0], [2.159, .979]],
                    o: [[0, 0], [-1.094, .44], [0, 0], [-.883, 2.19], [1.09, .44], [0, 0], [.952, -.425], [0, 0], [.979, -2.159], [-1.059, -.48]],
                    v: [[68.363, -73.944], [-31.697, -34.086], [-34.089, -31.679], [-73.947, 68.366], [-71.58, 73.932], [-68.198, 73.853], [28.182, 30.224], [30.329, 28.093], [73.851, -68.18], [71.714, -73.862]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [75.08, 74.622],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [1.772, -4.75], [39.361, -14.666], [3.577, 3.595], [0, 0], [0, 0]],
                    o: [[3.592, 3.577], [-14.673, 39.359], [-4.746, 1.783], [0, 0], [0, 0], [0, 0]],
                    v: [[70.798, -24.968], [73.787, -11.294], [-11.295, 73.774], [-24.97, 70.799], [-75.559, 20.21], [20.224, -75.557]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "gr",
            it: [{
                ty: "tr",
                p: {
                    a: 0,
                    k: [0, 0],
                    ix: 2
                },
                a: {
                    a: 0,
                    k: [0, 0],
                    ix: 1
                },
                s: {
                    a: 0,
                    k: [100, 100],
                    ix: 3
                },
                r: {
                    a: 0,
                    k: 0,
                    ix: 6
                },
                o: {
                    a: 0,
                    k: 100,
                    ix: 7
                },
                sk: {
                    a: 0,
                    k: 0,
                    ix: 4
                },
                sa: {
                    a: 0,
                    k: 0,
                    ix: 5
                },
                nm: "Transform"
            }],
            nm: "Group 1",
            np: 0,
            cix: 2,
            bm: 0,
            ix: 2,
            mn: "ADBE Vector Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.9921568627450981, .9921568627450981, .9921568627450981, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [94.077, 88.5],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 3",
        np: 4,
        cix: 2,
        bm: 0,
        ix: 3,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 2,
    ty: 4,
    nm: "Triangle Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [146.335, 627.725, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [15.205, 13.119, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 40,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 50,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 56,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 181,
                s: [110, 110, 100]
            }, {
                t: 196.000007983244,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[.306, .02], [0, 0], [.067, -.786], [-.095, -.218], [0, 0], [-.735, .307], [-.149, .178], [0, 0], [.6, .509]],
                    o: [[0, 0], [-.785, -.067], [-.02, .236], [0, 0], [.306, .734], [.215, -.089], [0, 0], [.51, -.6], [-.234, -.199]],
                    v: [[13.449, -10.856], [-13.394, -12.803], [-14.935, -11.502], [-14.82, -10.81], [-5.238, 11.788], [-3.354, 12.562], [-2.801, 12.155], [14.445, -8.511], [14.281, -10.52]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23529411764705882, .4588235294117647, .8392156862745098, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [15.205, 13.119],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 3,
    ty: 4,
    nm: "Speaker Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 0,
                s: [-2.375]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 90,
                s: [-5]
            }, {
                t: 196.000007983244,
                s: [0]
            }],
            ix: 10
        },
        p: {
            a: 0,
            k: [826.195, 347.741, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [59.566, 63.602, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 0,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 21.875,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 35,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 181,
                s: [110, 110, 100]
            }, {
                t: 196.000007983244,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [-.766, -5.672], [0, 0], [5.289, 2.161], [0, 0]],
                    o: [[0, 0], [4.523, -3.511], [0, 0], [.767, 5.673], [0, 0], [0, 0]],
                    v: [[-30.676, -32.048], [5.273, -59.84], [14.901, -55.901], [29.909, 54.812], [21.677, 61.19], [-20.374, 43.959]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [82.843, 63.602],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [52.798, 70.121],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [-.491, -3.559], [0, 0], [3.559, -.492], [0, 0]],
                    o: [[0, 0], [3.561, -.472], [0, 0], [.473, 3.562], [0, 0], [0, 0]],
                    v: [[-8.415, -23.104], [-3.984, -23.717], [3.343, -18.137], [7.942, 16.264], [2.362, 23.592], [-2.068, 24.189]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [110.467, 62.522],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 3",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 3,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-13.854, 2.091], [0, 0], [0, 0], [0, 0], [1.708, 14.214]],
                    o: [[0, 0], [0, 0], [0, 0], [-14.215, 1.707], [-1.671, -13.912]],
                    v: [[-2.218, -25.122], [18.799, -27.958], [25.759, 23.399], [4.741, 26.251], [-24.089, 3.604]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [26.009, 73.063],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 4",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 4,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 4,
    ty: 4,
    nm: "Yellow Circle Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [116.859, 483.435, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [6.061, 6.06, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 40,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 50,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 56,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 181,
                s: [110, 110, 100]
            }, {
                t: 196.000007983244,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-3.209, 0], [0, -3.209], [3.208, 0], [0, 3.208]],
                    o: [[3.208, 0], [0, 3.208], [-3.209, 0], [0, -3.209]],
                    v: [[.001, -5.81], [5.811, .001], [.001, 5.81], [-5.811, .001]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.9686274509803922, .7647058823529411, .2823529411764706, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [6.06, 6.06],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 5,
    ty: 4,
    nm: "Yellow Heart Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 0,
                s: [0]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 60,
                s: [6]
            }, {
                t: 120.0000048877,
                s: [0]
            }],
            ix: 10
        },
        p: {
            a: 0,
            k: [706.232, 252.799, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [14.652, 13.49, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 0,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 60,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 181,
                s: [110, 110, 100]
            }, {
                t: 196.000007983244,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[3.7, 1.423], [0, 0], [1.429, -3.71], [0, 0], [0, 0], [1.422, -3.717], [0, 0], [-3.706, -1.428], [-.01, -.004], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [-3.717, -1.414], [0, 0], [0, 0], [-3.717, -1.422], [0, 0], [-1.428, 3.705], [.01, .004], [0, 0], [0, 0], [0, 0], [0, 0], [1.392, -3.713]],
                    v: [[8.84, -11.826], [8.84, -11.826], [-.466, -7.671], [-1.339, -5.387], [-3.669, -6.277], [-12.974, -2.123], [-12.974, -2.121], [-8.85, 7.173], [-8.82, 7.184], [-6.506, 8.072], [6.97, 13.239], [12.121, -.236], [13.01, -2.551]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.9686274509803922, .7647058823529411, .2823529411764706, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [14.652, 13.49],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 6,
    ty: 4,
    nm: "Pink Heart Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 0,
                s: [0]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 60,
                s: [-6]
            }, {
                t: 120.0000048877,
                s: [0]
            }],
            ix: 10
        },
        p: {
            a: 0,
            k: [885.154, 546.215, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [15.143, 13.447, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 0,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 60,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 181,
                s: [110, 110, 100]
            }, {
                t: 196.000007983244,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[2.086, 3.384], [0, 0], [3.382, -2.095], [0, 0], [0, 0], [3.382, -2.095], [-2.084, -3.387], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [-2.096, -3.382], [0, 0], [0, 0], [-2.095, -3.381], [-3.38, 2.096], [0, 0], [0, 0], [0, 0], [0, 0], [3.375, -2.102]],
                    v: [[12.807, -5.629], [12.807, -5.629], [2.889, -7.958], [.773, -6.655], [-.546, -8.771], [-10.464, -11.102], [-12.809, -1.184], [-11.491, .934], [-3.903, 13.197], [8.362, 5.609], [10.477, 4.29]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.2901960784313726, .5647058823529412, .8862745098039215, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [15.143, 13.447],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 7,
    ty: 4,
    nm: "Purple Rectangle Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [313.481, 252.232, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [16.011, 16.011, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 0,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 25,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 40,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 181,
                s: [110, 110, 100]
            }, {
                t: 196.000007983244,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[.001, -15.762], [15.762, .001], [.001, 15.762], [-15.762, .001]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23529411764705882, .4588235294117647, .8392156862745098, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [16.011, 16.011],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 8,
    ty: 4,
    nm: "Circle Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [681.607, 366.743, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [8.467, 8.467, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 1.667]
                },
                t: 0,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 4.182]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 25,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 40,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 184.000007494474,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-4.538, 0], [0, -4.538], [4.538, 0], [0, 4.538]],
                    o: [[4.538, 0], [0, 4.538], [-4.538, 0], [0, -4.538]],
                    v: [[0, -8.217], [8.217, 0], [0, 8.217], [-8.217, 0]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23529411764705882, .4588235294117647, .8392156862745098, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [8.467, 8.467],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 9,
    ty: 4,
    nm: "Certificate Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 0,
                s: [8]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 90,
                s: [0]
            }, {
                t: 196.000007983244,
                s: [8]
            }],
            ix: 10
        },
        p: {
            a: 0,
            k: [143.463, 229.205, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [55.76, 67.725, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 1.667]
                },
                t: 0,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 4.182]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 25,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 40,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 184.000007494474,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [.62, 6.183], [-6.183, .62], [-.62, -6.183], [-.008, -.11], [6.099, -.522]],
                    o: [[-6.184, .62], [-.62, -6.184], [6.184, -.619], [.01, .11], [.522, 6.099], [0, 0]],
                    v: [[1.157, 11.196], [-11.161, 1.122], [-1.088, -11.197], [11.232, -1.122], [11.26, -.792], [1.161, 11.196]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [55.861, 78.382],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[3.38, -12.341], [-8.792, 8.876], [-.238, 5.611], [3.074, 12.341], [8.792, -9.965]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [48.962, 96.232],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[16.411, -6.631], [-17.852, -7.842], [-9.727, -.958], [-14.571, 7.842], [17.852, -.421]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [32.804, 82.55],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 3",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 3,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[1.901, 2.902], [23.333, -5.764], [-1.533, -2.115], [-2.989, 5.764], [-.384, .936]],
                    o: [[0, 3.25], [1.533, 2.085], [14.732, -4.353], [.46, -.92], [-1.983, -2.81]],
                    v: [[9.351, -14.656], [-15.177, 8.34], [-10.578, 14.656], [13.766, -3.019], [15.177, -6.087]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [62.261, 71.642],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 4",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 4,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[1.195, 2.162], [0, 0], [9.152, -1.932], [0, 0], [-3.554, 2.497]],
                    o: [[0, 0], [0, 0], [0, 0], [3.809, -2.088], [10.93, -7.68]],
                    v: [[15.093, -12.287], [15.093, -12.287], [-16.288, 8.44], [-13.467, 12.287], [-2.414, 5.404]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [26.84, 14.668],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 5",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 5,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-1.441, -2.054], [11.099, -7.742], [1.426, 2.054], [-11.099, 7.741]],
                    o: [[1.426, 2.054], [-11.098, 7.742], [-1.426, -2.055], [11.099, -7.742]],
                    v: [[20.105, -14.058], [2.614, 3.679], [-20.105, 14.058], [-2.568, -3.771]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.15294117647058825, .7647058823529411, .5725490196078431, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [21.782, 16.362],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 6",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 6,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [-15.561, -32.944], [0, 0], [-4.139, 26.398], [17.201, 34.01], [0, 0]],
                    o: [[0, 0], [26.36, 25.151], [0, 0], [0, 0], [-25.339, -28.468], [0, 0], [0, 0]],
                    v: [[-54.775, -38.295], [-43.614, -27.655], [19.807, 60.232], [21.508, 63.834], [54.775, 40.028], [-9.306, -54.084], [-14.594, -66.425]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [56.496, 68.775],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 7",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 7,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 10,
    ty: 4,
    nm: "Book3 Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 1,
            k: [{
                i: {
                    x: .701,
                    y: 1
                },
                o: {
                    x: .649,
                    y: 0
                },
                t: 30,
                s: [395.683, -170.331, 0],
                to: [0, 130.5, 0],
                ti: [0, -130.5, 0]
            }, {
                t: 54.0000021994651,
                s: [395.683, 612.669, 0]
            }],
            ix: 2
        },
        a: {
            a: 0,
            k: [160.605, 26.311, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 137,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 155,
                s: [110, 110, 100]
            }, {
                t: 170.000006924242,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-.396, .005], [0, 0], [0, 10.455], [8.83, 0], [0, 0], [.184, .366], [0, 0], [-.647, .432], [-.205, .03], [0, 0], [0, -14.364], [12.203, 0], [0, 0], [-.117, .771], [-.103, .164], [0, 0]],
                    o: [[0, 0], [8.83, 0], [0, -10.439], [0, 0], [-.408, -.003], [0, 0], [-.432, -.648], [.173, -.115], [0, 0], [12.264, 0], [0, 14.41], [0, 0], [-.77, -.118], [.029, -.191], [0, 0], [.206, -.338]],
                    v: [[-156.428, 18.672], [134.57, 18.672], [150.574, -.246], [134.57, -19.163], [-156.551, -19.163], [-157.516, -19.762], [-159.923, -23.885], [-159.532, -25.841], [-158.957, -26.061], [138.279, -26.061], [160.355, -.001], [138.279, 26.061], [-159.019, 26.061], [-160.201, 24.454], [-160, 23.914], [-157.394, 19.224]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.24705882352941178, .8117647058823529, .792156862745098, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [160.605, 26.311],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[8.83, 0], [0, 0], [.022, -6.507], [2.591, -5.97], [0, 0], [0, 10.455]],
                    o: [[0, 0], [2.59, 5.969], [.023, 6.507], [0, 0], [8.83, 0], [0, -10.439]],
                    v: [[136.438, -18.918], [-152.443, -18.918], [-148.549, -.001], [-152.443, 18.918], [136.438, 18.918], [152.443, -.001]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [158.736, 26.065],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 11,
    ty: 4,
    nm: "Book2 Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 1,
            k: [{
                i: {
                    x: .701,
                    y: 1
                },
                o: {
                    x: .649,
                    y: 0
                },
                t: 20,
                s: [389.263, -114.39, 0],
                to: [0, 130.5, 0],
                ti: [0, -130.5, 0]
            }, {
                t: 44.0000017921567,
                s: [389.263, 668.61, 0]
            }],
            ix: 2
        },
        a: {
            a: 0,
            k: [156.742, 29.945, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 137,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 155,
                s: [110, 110, 100]
            }, {
                t: 170.000006924242,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[.523, .008], [0, 0], [0, -11.854], [-11.853, 0], [0, 0], [-.289, -.427], [0, 0], [.676, -.51], [.359, .018], [0, 0], [0, 16.383], [-16.383, 0], [0, 0], [-.046, -.846], [.209, -.285], [0, 0]],
                    o: [[0, 0], [-11.853, 0], [0, 11.853], [0, 0], [.515, -.006], [0, 0], [.509, .676], [-.287, .216], [0, 0], [-16.383, 0], [0, -16.383], [0, 0], [.846, -.045], [.019, .353], [0, 0], [-.288, .437]],
                    v: [[151.277, -21.081], [-121.83, -21.081], [-143.292, .382], [-121.83, 21.844], [151.46, 21.844], [152.748, 22.518], [155.982, 27.225], [155.679, 29.372], [154.679, 29.678], [-126.827, 29.678], [-156.492, .014], [-126.827, -29.65], [154.771, -29.65], [156.384, -28.201], [156.089, -27.214], [152.579, -21.77]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.2823529411764706, .6078431372549019, .9686274509803922, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [156.742, 29.945],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-11.853, 0], [0, 0], [-.006, 7.47], [-3.44, 6.631], [0, 0], [0, -11.853]],
                    o: [[0, 0], [-3.44, -6.631], [-.006, -7.47], [0, 0], [-11.853, 0], [0, 11.854]],
                    v: [[-124.427, 21.462], [145.889, 21.462], [140.661, 0], [145.889, -21.462], [-124.427, -21.462], [-145.889, 0]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [159.339, 30.434],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 12,
    ty: 4,
    nm: "Book1 Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 1,
            k: [{
                i: {
                    x: .701,
                    y: 1
                },
                o: {
                    x: .649,
                    y: 0
                },
                t: 10,
                s: [405.091, -54.612, 0],
                to: [0, 130.5, 0],
                ti: [0, -130.5, 0]
            }, {
                t: 34.0000013848484,
                s: [405.091, 728.388, 0]
            }],
            ix: 2
        },
        a: {
            a: 0,
            k: [156.747, 29.943, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 3.182]
                },
                t: 137,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 19.333]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 155,
                s: [110, 110, 100]
            }, {
                t: 171.000006964973,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-.542, 0], [0, 0], [0, 11.853], [11.854, 0], [0, 0], [.289, .427], [0, 0], [-.67, .517], [-.37, -.022], [0, 0], [0, -16.382], [16.382, 0], [0, 0], [.036, .845], [-.206, .281], [0, 0]],
                    o: [[0, 0], [11.854, 0], [0, -11.853], [0, 0], [-.516, .006], [0, 0], [-.518, -.67], [.293, -.227], [0, 0], [16.382, 0], [0, 16.383], [0, 0], [-.845, .038], [-.015, -.349], [0, 0], [.276, -.466]],
                    v: [[-151.271, 21.132], [121.834, 21.132], [143.296, -.329], [121.834, -21.792], [-151.456, -21.792], [-152.743, -22.467], [-155.979, -27.203], [-155.704, -29.354], [-154.675, -29.671], [126.833, -29.671], [156.497, -.008], [126.833, 29.656], [-154.768, 29.656], [-156.365, 28.191], [-156.07, 27.219], [-152.59, 21.883]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [156.747, 29.944],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[11.854, 0], [0, 0], [0, -7.471], [3.444, -6.63], [0, 0], [0, 11.853]],
                    o: [[0, 0], [3.444, 6.63], [0, 7.472], [0, 0], [11.854, 0], [0, -11.853]],
                    v: [[124.427, -21.463], [-145.889, -21.463], [-140.647, -.001], [-145.889, 21.463], [124.427, 21.463], [145.889, -.001]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [154.154, 29.522],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 13,
    ty: 4,
    nm: "Stroke9 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [405.858, 265.627, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 105.715,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 122.143,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 132,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.649, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 14,
    ty: 4,
    nm: "Stroke8 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [405.858, 253.499, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 97.5,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 113.928,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 123.785,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.649, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 15,
    ty: 4,
    nm: "Stroke7 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [405.858, 242.138, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 89.285,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 105.715,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 115.573,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.649, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 16,
    ty: 4,
    nm: "Stroke6 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [405.603, 186.223, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.703, .703, .703],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.185, .185, .185],
                    y: [.185, .185, 0]
                },
                t: 81.073,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 97.5,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 107.358,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.648, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 17,
    ty: 4,
    nm: "Stroke5 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [405.603, 174.095, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 72.858,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 89.285,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 99.143,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.648, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 18,
    ty: 4,
    nm: "Stroke4 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [405.603, 162.733, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 64.643,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 81.073,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 90.928,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.648, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 19,
    ty: 4,
    nm: "Stroke3 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [407.135, 110.903, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 56.428,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 72.858,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 82.715,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.648, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 20,
    ty: 4,
    nm: "Stroke2 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [407.135, 98.776, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 48.215,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 64.643,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 74.5,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.648, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 21,
    ty: 4,
    nm: "Stroke1 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [407.135, 87.414, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [1.5, 1.5, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 40,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 56.428,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 66.285,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[1.5, 1.5], [86.648, 1.5]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [0, 0],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 22,
    ty: 4,
    nm: "Triangle4 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [361.52, 253.801, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [12.134, 12.393, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 73.89,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 90.833,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 101,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[.266, .137], [0, 0], [.364, -.708], [.002, -.226], [0, 0], [-.796, -.004], [-.206, .106], [0, 0], [.366, .707]],
                    o: [[0, 0], [-.708, -.363], [-.103, .201], [0, 0], [-.003, .796], [.232, .001], [0, 0], [.707, -.366], [-.137, -.265]],
                    v: [[10.9, -1.186], [-9.781, -11.78], [-11.721, -11.157], [-11.88, -10.507], [-11.88, 10.695], [-10.446, 12.142], [-9.781, 11.982], [10.9, 1.374], [11.518, -.568]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.5882352941176471, .792156862745098, .9921568627450981, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [12.133, 12.393],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 23,
    ty: 4,
    nm: "Rec Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [359.175, 254.332, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [30.236, 19.397, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 65.418,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 82.36,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 92.528,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-5.367, 0], [0, 0], [0, -5.368], [0, 0], [5.368, 0], [0, 0], [0, 5.368], [0, 0]],
                    o: [[0, 0], [5.368, 0], [0, 0], [0, 5.368], [0, 0], [-5.367, 0], [0, 0], [0, -5.368]],
                    v: [[-20.267, -19.148], [20.266, -19.148], [29.986, -9.428], [29.986, 9.428], [20.266, 19.148], [-20.267, 19.148], [-29.986, 9.428], [-29.986, -9.428]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [30.236, 19.397],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 24,
    ty: 4,
    nm: "Triangle3 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [360.449, 175.265, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [12.152, 12.394, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 65.418,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 82.36,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 92.528,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[.303, .141], [0, 0], [.364, -.707], [.002, -.227], [0, 0], [-.796, -.004], [-.206, .106], [0, 0], [.345, .716]],
                    o: [[0, 0], [-.708, -.364], [-.104, .201], [0, 0], [-.003, .796], [.231, .001], [0, 0], [.717, -.343], [-.143, -.302]],
                    v: [[10.867, -1.232], [-9.798, -11.779], [-11.738, -11.158], [-11.899, -10.507], [-11.899, 10.695], [-10.463, 12.143], [-9.798, 11.982], [10.883, 1.374], [11.558, -.548]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.5882352941176471, .792156862745098, .9921568627450981, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [12.152, 12.394],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 25,
    ty: 4,
    nm: "Rec Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [358.071, 175.75, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [30.235, 19.397, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 56.945,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 73.89,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 84.055,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-5.368, 0], [0, 0], [0, -5.367], [0, 0], [5.367, 0], [0, 0], [0, 5.368], [0, 0]],
                    o: [[0, 0], [5.367, 0], [0, 0], [0, 5.368], [0, 0], [-5.368, 0], [0, 0], [0, -5.367]],
                    v: [[-20.266, -19.148], [20.266, -19.148], [29.985, -9.428], [29.985, 9.428], [20.266, 19.148], [-20.266, 19.148], [-29.985, 9.428], [-29.985, -9.428]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [30.235, 19.397],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 26,
    ty: 4,
    nm: "Triangle2 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [361.52, 96.628, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [12.134, 12.401, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 56.945,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 73.89,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 84.055,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[.266, .138], [0, 0], [.364, -.707], [-.001, -.232], [0, 0], [-.796, -.003], [-.206, .105], [0, 0], [.366, .707]],
                    o: [[0, 0], [-.708, -.365], [-.106, .206], [0, 0], [-.003, .796], [.232, .001], [0, 0], [.707, -.367], [-.137, -.264]],
                    v: [[10.9, -1.178], [-9.781, -11.786], [-11.721, -11.164], [-11.88, -10.498], [-11.88, 10.703], [-10.446, 12.15], [-9.781, 11.991], [10.9, 1.383], [11.518, -.56]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.5882352941176471, .792156862745098, .9921568627450981, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [12.133, 12.401],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 27,
    ty: 4,
    nm: "Rec Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [359.175, 97.168, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [30.236, 19.397, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 48.473,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 65.418,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 75.583,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-5.367, 0], [0, 0], [0, -5.368], [0, 0], [5.368, 0], [0, 0], [0, 5.367], [0, 0]],
                    o: [[0, 0], [5.368, 0], [0, 0], [0, 5.367], [0, 0], [-5.367, 0], [0, 0], [0, -5.368]],
                    v: [[-20.267, -19.147], [20.266, -19.147], [29.986, -9.428], [29.986, 9.428], [20.266, 19.147], [-20.267, 19.147], [-29.986, 9.428], [-29.986, -9.428]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [30.236, 19.397],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 28,
    ty: 4,
    nm: "Triangle1 Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [152.434, 107.6, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [23, 23.54, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 48.473,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 65.418,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 75.583,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[.265, .138], [0, 0], [.364, -.698], [-.002, -.232], [0, 0], [-.787, -.014], [-.211, .111], [0, 0], [.365, .707]],
                    o: [[0, 0], [-.699, -.364], [-.107, .206], [0, 0], [-.014, .787], [.238, .003], [0, 0], [.707, -.366], [-.137, -.264]],
                    v: [[21.767, -1.189], [-20.651, -22.926], [-22.575, -22.322], [-22.736, -21.654], [-22.736, 21.837], [-21.335, 23.288], [-20.651, 23.125], [21.767, 1.372], [22.385, -.57]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.5882352941176471, .792156862745098, .9921568627450981, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [23, 23.54],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 29,
    ty: 4,
    nm: "Rec Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [147.412, 108.504, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [56.028, 35.869, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 40,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 56.945,
                s: [110, 110, 110]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 67.11,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 151,
                s: [100, 100, 90.909]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 110]
            }, {
                t: 182.000007413012,
                s: [0, 0, 0]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-5.368, 0], [0, 0], [0, -5.367], [0, 0], [5.368, 0], [0, 0], [0, 5.368], [0, 0]],
                    o: [[0, 0], [5.368, 0], [0, 0], [0, 5.368], [0, 0], [-5.368, 0], [0, 0], [0, -5.367]],
                    v: [[-46.059, -35.62], [46.06, -35.62], [55.779, -25.9], [55.779, 25.901], [46.06, 35.62], [-46.059, 35.62], [-55.779, 25.901], [-55.779, -25.9]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [56.028, 35.87],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 30,
    ty: 4,
    nm: "Cap Outlines",
    parent: 1,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 67,
                s: [0]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 90,
                s: [12]
            }, {
                t: 110.000004480392,
                s: [0]
            }],
            ix: 10
        },
        p: {
            a: 0,
            k: [21.443, 144.138, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [4, 4, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 1.667]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 19.333]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-1.131, 1.131], [0, 0], [-1.132, -1.131], [0, 0], [1.131, -1.132], [0, 0], [1.131, 1.132], [0, 0]],
                    o: [[0, 0], [1.132, -1.131], [0, 0], [1.131, 1.132], [0, 0], [-1.131, 1.132], [0, 0], [-1.131, -1.131]],
                    v: [[-14.005, -6.84], [-6.841, -14.006], [-2.743, -14.006], [14.006, 2.742], [14.006, 6.84], [6.84, 14.005], [2.743, 14.005], [-14.005, -2.743]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.5882352941176471, .792156862745098, .9921568627450981, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [37.685, 38.047],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[-14.311, -14.215], [14.311, 14.215]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.5882352941176471, .792156862745098, .9921568627450981, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 8,
                ix: 5
            },
            lc: 2,
            lj: 2,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [18.311, 18.215],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 31,
    ty: 4,
    nm: "Book Outlines",
    parent: 33,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [105.207, 55.526, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [26.034, 16.404, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 18.845,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 37.693,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 49,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [0, 0, 1.667]
                },
                t: 151,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 19.333]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[-24.225, -14.595], [24.225, 14.595]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3.618,
                ix: 5
            },
            lc: 1,
            lj: 1,
            ml: 10,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [26.034, 16.404],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "tm",
        s: {
            a: 0,
            k: 0,
            ix: 1
        },
        e: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 10,
                s: [0]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 30,
                s: [100]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 70,
                s: [64]
            }, {
                t: 129.000005254278,
                s: [100]
            }],
            ix: 2
        },
        o: {
            a: 0,
            k: 0,
            ix: 3
        },
        m: 1,
        ix: 2,
        nm: "Trim Paths 1",
        mn: "ADBE Vector Filter - Trim",
        hd: !1
    }],
    ip: 10.0000004073083,
    op: 5141.00020939722,
    st: 10.0000004073083,
    bm: 0
}, {
    ddd: 0,
    ind: 32,
    ty: 4,
    nm: "Book Outlines",
    parent: 33,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [107.455, 76.445, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [36.93, 22.968, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 9.423,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 28.27,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 39.578,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [0, 0, 1.667]
                },
                t: 151,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 19.333]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0]],
                    o: [[0, 0], [0, 0]],
                    v: [[-35.121, -21.159], [35.121, 21.159]],
                    c: !1
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "st",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 3
            },
            o: {
                a: 0,
                k: 100,
                ix: 4
            },
            w: {
                a: 0,
                k: 3.618,
                ix: 5
            },
            lc: 1,
            lj: 1,
            ml: 10,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [36.93, 22.968],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "tm",
        s: {
            a: 0,
            k: 0,
            ix: 1
        },
        e: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 5,
                s: [0]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 25,
                s: [100]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 65,
                s: [70]
            }, {
                t: 124.000005050624,
                s: [100]
            }],
            ix: 2
        },
        o: {
            a: 0,
            k: 0,
            ix: 3
        },
        m: 1,
        ix: 2,
        nm: "Trim Paths 1",
        mn: "ADBE Vector Filter - Trim",
        hd: !1
    }],
    ip: 5.00000020365417,
    op: 5136.00020919357,
    st: 5.00000020365417,
    bm: 0
}, {
    ddd: 0,
    ind: 33,
    ty: 4,
    nm: "Book Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 1,
            k: [{
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 0,
                s: [-2.375]
            }, {
                i: {
                    x: [.833],
                    y: [.833]
                },
                o: {
                    x: [.167],
                    y: [.167]
                },
                t: 89,
                s: [7]
            }, {
                t: 192.00000782032,
                s: [-2.375]
            }],
            ix: 10
        },
        p: {
            a: 0,
            k: [527.508, 280.817, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [91.541, 100.739, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 0,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 18.845,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 30.155,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [0, 0, 1.667]
                },
                t: 151,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 19.333]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [2.56, -2.131], [-34.8, 59.604], [-8.401, -5.044]],
                    o: [[0, 0], [31.979, -63.007], [0, 0], [0, 0]],
                    v: [[-29.012, 60.508], [-42.534, 72.205], [32.125, -65.414], [42.534, -67.161]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.10196078431372549, .9294117647058824, .9019607843137255, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [42.783, 72.455],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[84.531, -33.665], [11.299, 92.119], [-84.531, 35.55], [-12.985, -92.119]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [98.301, 97.413],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[82.538, -33.098], [9.305, 92.701], [-82.538, 38.479], [-10.104, -92.701]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [85.899, 102.625],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 3",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 3,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[84.523, -33.68], [11.29, 92.119], [-84.523, 35.55], [-12.993, -92.119]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23529411764705882, .4588235294117647, .8392156862745098, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [84.773, 109.109],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 4",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 4,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 34,
    ty: 4,
    nm: "Rec Outlines",
    parent: 36,
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 0,
            k: [0, 0, 0],
            ix: 7
        },
        p: {
            a: 0,
            k: [406.289, 187.984, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [103.195, 138.447, 0],
            ix: 1
        },
        s: {
            a: 1,
            k: [{
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 40,
                s: [0, 0, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 50,
                s: [110, 110, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, .833]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, .167]
                },
                t: 56,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.667, .667, .667],
                    y: [1, 1, 1]
                },
                o: {
                    x: [.167, .167, .167],
                    y: [.167, .167, 0]
                },
                t: 151,
                s: [100, 100, 100]
            }, {
                i: {
                    x: [.833, .833, .833],
                    y: [.833, .833, 1]
                },
                o: {
                    x: [.333, .333, .333],
                    y: [0, 0, 0]
                },
                t: 169,
                s: [110, 110, 100]
            }, {
                t: 182.000007413012,
                s: [0, 0, 100]
            }],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[-103.195, -138.446], [103.195, -138.446], [103.195, 138.447], [-103.195, 138.447]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.996078431372549, .9686274509803922, .8901960784313725, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 30,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [103.195, 138.447],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 0,
    ind: 35,
    ty: 4,
    nm: "Laptop Outlines",
    sr: 1,
    ks: {
        o: {
            a: 0,
            k: 100,
            ix: 11
        },
        r: {
            a: 0,
            k: 0,
            ix: 10
        },
        p: {
            a: 0,
            k: [523.154, 784.834, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [370.779, 26.089, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [5.562, 0], [0, 0], [0, 5.562], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 5.562], [0, 0], [-5.563, 0], [0, 0], [0, 0]],
                    v: [[-104.023, -9.995], [104.038, -9.995], [104.038, -.076], [93.966, 9.995], [-93.966, 9.995], [-104.038, -.076], [-104.038, -9.995]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.06274509803921569, .17647058823529413, .27450980392156865, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [370.542, 10.246],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [9.88, 0], [0, 0], [0, 9.881]],
                    o: [[0, 0], [0, 0], [0, 9.881], [0, 0], [-9.88, 0], [0, 0]],
                    v: [[-319.794, -17.76], [319.794, -17.76], [319.794, -.13], [301.905, 17.76], [-301.904, 17.76], [-319.794, -.13]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [370.542, 18.011],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[6.592, 0], [0, 0], [0, 4.4], [-6.623, 0], [0, 0], [0, -4.4]],
                    o: [[0, 0], [-6.623, 0], [0, -4.4], [0, 0], [6.607, 0], [0, 4.4]],
                    v: [[358.556, 7.971], [-358.556, 7.971], [-370.53, -.001], [-358.556, -7.971], [358.556, -7.971], [370.529, -.001]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.5882352941176471, .792156862745098, .9921568627450981, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [370.779, 43.957],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 3",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 3,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}, {
    ddd: 1,
    ind: 36,
    ty: 4,
    nm: "Laptop Top Outlines",
    sr: 1,
    ks: {
        o: {
            a: 1,
            k: [{
                i: {
                    x: [.667],
                    y: [1]
                },
                o: {
                    x: [.333],
                    y: [0]
                },
                t: 0,
                s: [0]
            }, {
                i: {
                    x: [.667],
                    y: [1]
                },
                o: {
                    x: [.333],
                    y: [0]
                },
                t: 1,
                s: [100]
            }, {
                i: {
                    x: [.833],
                    y: [1]
                },
                o: {
                    x: [.333],
                    y: [0]
                },
                t: 186,
                s: [100]
            }, {
                t: 192.00000782032,
                s: [0]
            }],
            ix: 11
        },
        rx: {
            a: 0,
            k: 0,
            ix: 8
        },
        ry: {
            a: 0,
            k: 0,
            ix: 9
        },
        rz: {
            a: 0,
            k: 0,
            ix: 10
        },
        or: {
            a: 1,
            k: [{
                i: {
                    x: .667,
                    y: 1
                },
                o: {
                    x: .363,
                    y: 0
                },
                t: 0,
                s: [75, 0, 0],
                to: [0, 0, 0],
                ti: [0, 0, 0]
            }, {
                i: {
                    x: .833,
                    y: .833
                },
                o: {
                    x: .167,
                    y: .167
                },
                t: 40,
                s: [0, 0, 0],
                to: [0, 0, 0],
                ti: [0, 0, 0]
            }, {
                i: {
                    x: .667,
                    y: 1
                },
                o: {
                    x: .167,
                    y: 0
                },
                t: 161,
                s: [0, 0, 0],
                to: [0, 0, 0],
                ti: [0, 0, 0]
            }, {
                t: 192.00000782032,
                s: [75, 0, 0]
            }],
            ix: 7
        },
        p: {
            a: 0,
            k: [522.924, 794.515, 0],
            ix: 2
        },
        a: {
            a: 0,
            k: [276.545, 370.259, 0],
            ix: 1
        },
        s: {
            a: 0,
            k: [100, 100, 100],
            ix: 6
        }
    },
    ao: 0,
    shapes: [{
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    o: [[0, 0], [0, 0], [0, 0], [0, 0]],
                    v: [[-256.902, -169.467], [256.903, -169.467], [256.903, 169.467], [-256.902, 169.467]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.09803921568627451, .2549019607843137, .4117647058823529, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [276.545, 185.263],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 1",
        np: 2,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
    }, {
        ty: "gr",
        it: [{
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
                a: 0,
                k: {
                    i: [[-7.34, 0], [0, 0], [0, -7.341], [0, 0], [7.34, 0], [0, 0], [0, 7.34], [0, 0]],
                    o: [[0, 0], [7.34, 0], [0, 0], [0, 7.34], [0, 0], [-7.34, 0], [0, 0], [0, -7.341]],
                    v: [[-263.004, -185.005], [263.004, -185.005], [276.295, -171.712], [276.295, 171.713], [263.004, 185.005], [-263.004, 185.005], [-276.295, 171.713], [-276.295, -171.712]],
                    c: !0
                },
                ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
        }, {
            ty: "mm",
            mm: 4,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
        }, {
            ty: "fl",
            c: {
                a: 0,
                k: [.23921568627450981, .7803921568627451, .7607843137254902, 1],
                ix: 4
            },
            o: {
                a: 0,
                k: 100,
                ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
        }, {
            ty: "tr",
            p: {
                a: 0,
                k: [276.545, 185.255],
                ix: 2
            },
            a: {
                a: 0,
                k: [0, 0],
                ix: 1
            },
            s: {
                a: 0,
                k: [100, 100],
                ix: 3
            },
            r: {
                a: 0,
                k: 0,
                ix: 6
            },
            o: {
                a: 0,
                k: 100,
                ix: 7
            },
            sk: {
                a: 0,
                k: 0,
                ix: 4
            },
            sa: {
                a: 0,
                k: 0,
                ix: 5
            },
            nm: "Transform"
        }],
        nm: "Group 2",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
    }],
    ip: 0,
    op: 5131.00020898991,
    st: 0,
    bm: 0
}]
  , markers = []
  , animationData = {
    v,
    meta,
    fr,
    ip,
    op,
    w,
    h,
    nm,
    ddd,
    assets,
    layers,
    markers
}
  , defaultOptions = {
    loop: !0,
    play: !0,
    animationData,
    rendererSettings: {
        preserveAspectRatio: "xMidYMid slice"
    }
}
  , FeatureCard = ({icon: s, title: e, degree: a, university: o, duration: c, content1: d, index: g}) => jsxRuntimeExports.jsxs("div", {
    className: "flex border-black justify-center flex-row p-6  rounded-[30px] feature-card py-7 px-50 w-[105%]",
    children: [jsxRuntimeExports.jsx("div", {
        className: `w-[64px] h-[64px] rounded-full ${styles.flexCenter} bg-black`,
        children: jsxRuntimeExports.jsx("img", {
            src: s,
            alt: "icon",
            className: "w-[80%] h-[80%] object-contain"
        })
    }), jsxRuntimeExports.jsxs("div", {
        className: "flex-1 flex flex-col mx-4 ",
        children: [jsxRuntimeExports.jsx("h4", {
            className: "font-poppins text-center font-bold text-white text-[20px] leading-[30px] mb-1 text-gradient",
            children: e
        }), jsxRuntimeExports.jsx("p", {
            className: "font-poppins text-center font-semibold text-white text-[18px] leading-[30px] mb-1",
            children: o
        }), jsxRuntimeExports.jsx("p", {
            className: "font-poppins font-normal text-white text-[16px] leading-[30px] mb-1 ",
            children: a
        }), jsxRuntimeExports.jsxs("p", {
            className: "font-poppins font-normal text-dimWhite text-[16px] leading-[30px] mb-1",
            children: ["- ", d]
        }), jsxRuntimeExports.jsx("p", {
            className: "font-poppins font-normal text-dimWhite text-[14px] leading-[30px] mb-1",
            children: c
        })]
    })]
})
  , Education = () => jsxRuntimeExports.jsxs("section", {
    id: "education",
    children: [jsxRuntimeExports.jsx("h1", {
        className: "flex-1 name-gradient font-poppins font-semibold ss:text-[55px] text-[45px] text-white ss:leading-[80px] leading-[80px]",
        children: "Education"
    }), jsxRuntimeExports.jsxs(motion.div, {
        className: layout.sectionReverse,
        whileInView: {
            x: [-60, 0],
            opacity: [0, 1]
        },
        transition: {
            duration: 1
        },
        children: [jsxRuntimeExports.jsxs("div", {
            className: layout.sectionImgReverse,
            children: [jsxRuntimeExports.jsx("div", {
                className: "w-[80%] h-[80%] relative z-[5] mt-5",
                children: jsxRuntimeExports.jsx(LottiePlayer, {
                    ...defaultOptions
                })
            }), jsxRuntimeExports.jsx("div", {
                className: "absolute z-[3] -left-1/2 top-0 w-[50%] h-[50%] rounded-full white__gradient"
            }), jsxRuntimeExports.jsx("div", {
                className: "absolute z-[0] w-[50%] h-[50%] -left-1/2 bottom-0 rounded-full pink__gradient"
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: `${layout.sectionInfo} flex-col md:p-20 py-12 px-4`,
            children: educationList.map( (s, e) => jsxRuntimeExports.jsx(FeatureCard, {
                index: e,
                ...s
            }, s.id))
        })]
    })]
})
  , SkillIcon = ({icon: s, name: e}) => jsxRuntimeExports.jsxs("div", {
    className: "flex flex-col",
    children: [jsxRuntimeExports.jsx("span", {
        className: "text-white text-[30px] hover:text-black",
        children: React.createElement(s)
    }), jsxRuntimeExports.jsx("p", {
        className: "font-poppins  text-white text-[12px] mt-2",
        children: e
    })]
})
  , SkillCard = s => jsxRuntimeExports.jsxs(motion.div, {
    whileInView: {
        y: [-20, 0],
        opacity: [0, 1]
    },
    transition: {
        duration: 1
    },
    className: "mt-4 mb-6 border-l-2 border-gray-200 dark:border-black mx-4",
    children: [jsxRuntimeExports.jsx("div", {
        className: "relative w-4 h-4 bg-gray-200 rounded-full top-5 right-[8px] border dark:border-gray-900 dark:bg-white"
    }), jsxRuntimeExports.jsx("div", {
        className: "flex flex-row items-center mb-6 ml-6",
        children: jsxRuntimeExports.jsx("h4", {
            className: "font-poppins font-semibold text-[20px] name-gradient1 leading-[32px]",
            children: s.title
        })
    }), jsxRuntimeExports.jsx("div", {
        className: "grid grid-cols-3 gap-8 ml-8",
        children: s.items.map( (e, a) => jsxRuntimeExports.jsx(SkillIcon, {
            index: a,
            ...e
        }, e.id))
    })]
})
  , Content = ({text: s, link: e}) => jsxRuntimeExports.jsx("div", {
    children: jsxRuntimeExports.jsxs("p", {
        className: "font-poppins font-normal text-[14px] text-dimWhite mt-4",
        children: ["- ", s, " ", e ? jsxRuntimeExports.jsx("a", {
            href: e,
            target: "_blank",
            children: jsxRuntimeExports.jsx(BsLink45Deg, {
                size: "1rem",
                className: "inline hover:text-black"
            })
        }) : ""]
    })
})
  , ExperienceCard = s => jsxRuntimeExports.jsxs(motion.div, {
    whileInView: {
        y: [-20, 0],
        opacity: [0, 1]
    },
    transition: {
        duration: 1
    },
    children: [jsxRuntimeExports.jsxs("div", {
        className: "flex flex-row items-center mb-6 mt-5",
        children: [jsxRuntimeExports.jsx("img", {
            src: s.logo,
            alt: s.organisation,
            className: "w-[52px] h-[52px] rounded-full z-[2]"
        }), jsxRuntimeExports.jsx("h4", {
            className: "font-poppins font-semibold text-[20px] name-gradient1 leading-[32px] ml-2",
            children: s.organisation
        })]
    }), jsxRuntimeExports.jsx("ol", {
        className: "relative border-l-2 border-gray-200 dark:border-black ml-6",
        children: s.positions.map( (e, a) => jsxRuntimeExports.jsxs("li", {
            className: `${a === s.positions.length - 1 ? "mb-0" : "mb-4"} ml-4`,
            children: [jsxRuntimeExports.jsx("div", {
                className: "absolute w-4 h-4 bg-gray-200 rounded-full mt-1.5 -left-[8px] border border-white dark:border-gray-900 dark:bg-white"
            }), jsxRuntimeExports.jsx("h3", {
                className: "text-lg font-semibold text-gray-900 dark:text-white",
                children: e.title
            }), jsxRuntimeExports.jsx("time", {
                className: "mb-1 text-sm font-normal leading-none text-black",
                children: e.duration
            }), e.content.map( (o, c) => jsxRuntimeExports.jsx(Content, {
                index: c,
                ...o
            })), jsxRuntimeExports.jsx("p", {
                className: "mb-4 text-base font-normal text-gray-500 dark:text-gray-400"
            })]
        }))
    })]
})
  , SkillsAndExperience = () => jsxRuntimeExports.jsxs("section", {
    id: "skills",
    className: "mb-12",
    children: [jsxRuntimeExports.jsx("h1", {
        className: "flex-1 font-poppins name-gradient font-semibold ss:text-[55px] text-[45px] text-white ss:leading-[80px] leading-[80px]",
        children: "Skills"
    }), jsxRuntimeExports.jsxs("div", {
        className: layout.section,
        whileInView: {
            y: [-20, 0],
            opacity: [0, 1]
        },
        transition: {
            duration: .5
        },
        children: [jsxRuntimeExports.jsx(motion.div, {
            className: `ml-2 mb-6 ${layout.sectionInfo}`,
            children: skills.map( (s, e) => jsxRuntimeExports.jsx(SkillCard, {
                index: e,
                ...s
            }))
        }), jsxRuntimeExports.jsx(motion.div, {
            className: "flex flex-1 items-center justify-start flex-col",
            children: experiences.map( (s, e) => jsxRuntimeExports.jsx(ExperienceCard, {
                index: e,
                ...s
            }))
        })]
    })]
});
function BsLink45Deg$1(s) {
    return GenIcon({
        tag: "svg",
        attr: {
            fill: "currentColor",
            viewBox: "0 0 16 16"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1 1 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4 4 0 0 1-.128-1.287z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243z"
            },
            child: []
        }]
    })(s)
}
var __defProp = Object.defineProperty
  , __defProps = Object.defineProperties
  , __getOwnPropDescs = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols = Object.getOwnPropertySymbols
  , __hasOwnProp = Object.prototype.hasOwnProperty
  , __propIsEnum = Object.prototype.propertyIsEnumerable
  , __defNormalProp = (s, e, a) => e in s ? __defProp(s, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : s[e] = a
  , __spreadValues = (s, e) => {
    for (var a in e || (e = {}))
        __hasOwnProp.call(e, a) && __defNormalProp(s, a, e[a]);
    if (__getOwnPropSymbols)
        for (var a of __getOwnPropSymbols(e))
            __propIsEnum.call(e, a) && __defNormalProp(s, a, e[a]);
    return s
}
  , __spreadProps = (s, e) => __defProps(s, __getOwnPropDescs(e))
  , Tilt = class extends reactExports.Component {
    constructor(s) {
        super(s),
        this.ref = React.createRef(),
        this.state = {
            style: {}
        };
        const e = {
            reverse: !1,
            max: 35,
            perspective: 1e3,
            easing: "cubic-bezier(.03,.98,.52,.99)",
            scale: "1.1",
            speed: "1000",
            transition: !0,
            axis: null,
            reset: !0
        };
        this.width = null,
        this.height = null,
        this.left = null,
        this.top = null,
        this.transitionTimeout = null,
        this.updateCall = null,
        this.element = null,
        this.settings = Object.assign({}, e, this.props.options),
        this.reverse = this.settings.reverse ? -1 : 1,
        this.onMouseEnter = this.onMouseEnter.bind(this, this.props.onMouseEnter),
        this.onMouseMove = this.onMouseMove.bind(this, this.props.onMouseMove),
        this.onMouseLeave = this.onMouseLeave.bind(this, this.props.onMouseLeave)
    }
    componentDidMount() {
        this.element = this.ref.current,
        setTimeout( () => {
            this.element.parentElement.querySelector(":hover") === this.element && this.onMouseEnter()
        }
        , 0)
    }
    componentWillUnmount() {
        clearTimeout(this.transitionTimeout),
        cancelAnimationFrame(this.updateCall)
    }
    onMouseEnter(s= () => {}
    , e) {
        return this.updateElementPosition(),
        this.setState(Object.assign({}, this.state, {
            style: __spreadProps(__spreadValues({}, this.state.style), {
                willChange: "transform"
            })
        })),
        this.setTransition(),
        s(e)
    }
    reset() {
        window.requestAnimationFrame( () => {
            this.setState(Object.assign({}, this.state, {
                style: __spreadProps(__spreadValues({}, this.state.style), {
                    transform: `perspective(${this.settings.perspective}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`
                })
            }))
        }
        )
    }
    onMouseMove(s= () => {}
    , e) {
        return e.persist(),
        this.updateCall !== null && window.cancelAnimationFrame(this.updateCall),
        this.event = e,
        this.updateCall = requestAnimationFrame(this.update.bind(this, e)),
        s(e)
    }
    setTransition() {
        clearTimeout(this.transitionTimeout),
        this.setState(Object.assign({}, this.state, {
            style: __spreadProps(__spreadValues({}, this.state.style), {
                transition: `${this.settings.speed}ms ${this.settings.easing}`
            })
        })),
        this.transitionTimeout = setTimeout( () => {
            this.setState(Object.assign({}, this.state, {
                style: __spreadProps(__spreadValues({}, this.state.style), {
                    transition: ""
                })
            }))
        }
        , this.settings.speed)
    }
    onMouseLeave(s= () => {}
    , e) {
        return this.setTransition(),
        this.settings.reset && this.reset(),
        s(e)
    }
    getValues(s) {
        const e = (s.nativeEvent.clientX - this.left) / this.width
          , a = (s.nativeEvent.clientY - this.top) / this.height
          , o = Math.min(Math.max(e, 0), 1)
          , c = Math.min(Math.max(a, 0), 1)
          , d = (this.reverse * (this.settings.max / 2 - o * this.settings.max)).toFixed(2)
          , g = (this.reverse * (c * this.settings.max - this.settings.max / 2)).toFixed(2)
          , _ = o * 100
          , b = c * 100;
        return {
            tiltX: d,
            tiltY: g,
            percentageX: _,
            percentageY: b
        }
    }
    updateElementPosition() {
        const s = this.element.getBoundingClientRect();
        this.width = this.element.offsetWidth,
        this.height = this.element.offsetHeight,
        this.left = s.left,
        this.top = s.top
    }
    update(s) {
        const e = this.getValues(s);
        this.setState(Object.assign({}, this.state, {
            style: __spreadProps(__spreadValues({}, this.state.style), {
                transform: `perspective(${this.settings.perspective}px) rotateX(${this.settings.axis === "x" ? 0 : e.tiltY}deg) rotateY(${this.settings.axis === "y" ? 0 : e.tiltX}deg) scale3d(${this.settings.scale}, ${this.settings.scale}, ${this.settings.scale})`
            })
        })),
        this.updateCall = null
    }
    render() {
        const s = Object.assign({}, this.props.style, this.state.style);
        return jsxRuntimeExports.jsx("div", {
            style: s,
            ref: this.ref,
            className: this.props.className,
            onMouseEnter: this.onMouseEnter,
            onMouseMove: this.onMouseMove,
            onMouseLeave: this.onMouseLeave,
            children: this.props.children
        })
    }
}
;
const Project = s => {
    const e = window.innerWidth > 768;
    return jsxRuntimeExports.jsx(motion.div, {
        className: "px-12 py-8 transition-colors duration-300 transform ",
        whileInView: {
            y: [-30, 0],
            opacity: [0, 1]
        },
        transition: {
            duration: .75
        },
        children: e ? jsxRuntimeExports.jsxs(Tilt, {
            options: {
                max: 45,
                scale: 1,
                speed: 450
            },
            className: "bg-tertiary project_card p-5 border dark:border-gray-600 rounded-2xl",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "flex flex-col sm:flex-row",
                children: [jsxRuntimeExports.jsx("img", {
                    className: "flex-shrink-0 object-cover w-24 h-24 rounded-full sm:mx-4 ring-4 ring-gray-300",
                    src: s.image,
                    alt: ""
                }), jsxRuntimeExports.jsxs("div", {
                    className: "mt-4 sm:mx-4 sm:mt-0",
                    children: [jsxRuntimeExports.jsx("h1", {
                        className: "text-xl font-semibold font-poppins text-gray-700 capitalize md:text-2xl group-hover:text-white text-gradient",
                        children: s.title
                    }), jsxRuntimeExports.jsx("p", {
                        className: "font-poppins font-normal text-dimWhite mt-3",
                        children: "Tech Stack"
                    }), jsxRuntimeExports.jsx("p", {
                        className: "mt-2 text-gray-500 capitalize dark:text-gray-300 group-hover:text-gray-300",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "flex sm:flex-row",
                            children: s.stack.map( (a, o) => jsxRuntimeExports.jsxs("div", {
                                className: "text-dimWhite mr-5 text-[20px] hover:text-teal-200 tooltip",
                                children: [React.createElement(a.icon, {
                                    size: "20px"
                                }), jsxRuntimeExports.jsx("span", {
                                    className: "tooltiptext",
                                    children: a.name
                                })]
                            }, o))
                        })
                    })]
                })]
            }), jsxRuntimeExports.jsx("p", {
                className: "mt-8 text-gray-500 dark:text-gray-300 group-hover:text-gray-300 font-poppins",
                children: s.content
            }), jsxRuntimeExports.jsxs("div", {
                className: "flex mt-4 -mx-2",
                children: [s.github ? jsxRuntimeExports.jsx("a", {
                    href: s.github,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: jsxRuntimeExports.jsx(AiFillGithub, {
                        size: "2rem",
                        className: "text-white mr-1 hover:text-teal-200"
                    })
                }) : "", s.link ? jsxRuntimeExports.jsx("a", {
                    href: s.link,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: jsxRuntimeExports.jsx(BsLink45Deg$1, {
                        size: "2rem",
                        className: "text-white hover:text-teal-200"
                    })
                }) : ""]
            })]
        }) : jsxRuntimeExports.jsxs("div", {
            className: "bg-tertiary project_card p-5 border dark:border-gray-600 rounded-2xl",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "flex flex-col sm:flex-row",
                children: [jsxRuntimeExports.jsx("img", {
                    className: "flex-shrink-0 object-cover w-24 h-24 rounded-full sm:mx-4 ring-4 ring-gray-300",
                    src: s.image,
                    alt: ""
                }), jsxRuntimeExports.jsxs("div", {
                    className: "mt-4 sm:mx-4 sm:mt-0",
                    children: [jsxRuntimeExports.jsx("h1", {
                        className: "text-xl font-semibold font-poppins text-gray-700 capitalize md:text-2xl group-hover:text-white text-gradient",
                        children: s.title
                    }), jsxRuntimeExports.jsx("p", {
                        className: "font-poppins font-normal text-dimWhite mt-3",
                        children: "Tech Stack"
                    }), jsxRuntimeExports.jsx("p", {
                        className: "mt-2 text-gray-500 capitalize dark:text-gray-300 group-hover:text-gray-300",
                        children: jsxRuntimeExports.jsx("div", {
                            className: "flex sm:flex-row",
                            children: s.stack.map( (a, o) => jsxRuntimeExports.jsxs("div", {
                                className: "text-dimWhite mr-5 text-[20px] hover:text-teal-200 tooltip",
                                children: [React.createElement(a.icon, {
                                    size: "20px"
                                }), jsxRuntimeExports.jsx("span", {
                                    className: "tooltiptext",
                                    children: a.name
                                })]
                            }, o))
                        })
                    })]
                })]
            }), jsxRuntimeExports.jsx("p", {
                className: "mt-8 text-gray-500 dark:text-gray-300 group-hover:text-gray-300 font-poppins",
                children: s.content
            }), jsxRuntimeExports.jsxs("div", {
                className: "flex mt-4 -mx-2",
                children: [s.github ? jsxRuntimeExports.jsx("a", {
                    href: s.github,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: jsxRuntimeExports.jsx(AiFillGithub, {
                        size: "2rem",
                        className: "text-white mr-1 hover:text-teal-200"
                    })
                }) : "", s.link ? jsxRuntimeExports.jsx("a", {
                    href: s.link,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: jsxRuntimeExports.jsx(BsLink45Deg$1, {
                        size: "2rem",
                        className: "text-white hover:text-teal-200"
                    })
                }) : ""]
            })]
        })
    })
}
  , Projects = () => jsxRuntimeExports.jsxs("section", {
    id: "projects",
    children: [jsxRuntimeExports.jsx("h1", {
        className: "flex-1 name-gradient font-poppins font-semibold ss:text-[55px] text-[45px] text-white ss:leading-[80px] leading-[80px]",
        children: "Projects"
    }), jsxRuntimeExports.jsx("div", {
        className: "container px-2 py-5 mx-auto mb-8",
        children: jsxRuntimeExports.jsx("div", {
            className: "grid grid-cols-1 gap-8 mt-8 md:mt-16 md:grid-cols-2",
            children: projects.map( (s, e) => jsxRuntimeExports.jsx(Project, {
                image: s.image,
                title: s.title,
                stack: s.stack,
                content: s.content,
                github: s.github,
                link: s.link
            }, e))
        })
    })]
})
  , Button = ({styles: s, text: e, icon: a}) => {
    const o = `py-3 px-10 rounded bg-blue-gradient font-poppins font-medium text-[20px] text-primary outline-none ${s ?? ""}`;
    return a ? jsxRuntimeExports.jsxs("button", {
        type: "button",
        className: o,
        children: [React.createElement(a), "", e]
    }) : jsxRuntimeExports.jsx("button", {
        type: "button",
        className: o,
        children: e
    })
}
  , Footer = () => jsxRuntimeExports.jsx("footer", {
    id: "contactMe",
    className: "footer-bg sm:px-16 px-6",
    children: jsxRuntimeExports.jsxs("div", {
        className: `${layout.sectionReverse} xl:max-w-[1280px] w-full mx-auto gap-y-4 `,
        children: [jsxRuntimeExports.jsxs("div", {
            className: ` ${layout.sectionInfo}`,
            children: [jsxRuntimeExports.jsx("h1", {
                className: "text-xxl font-bold text-gray-800 font-poppins dark:text-white hover:text-gray-700 dark:hover:text-gray-300 text-[30px]",
                children: aboutMe.name
            }), jsxRuntimeExports.jsx("p", {
                className: "font-poppins font-normal text-dimWhite text-[16px] leading-[30.8px] max-w-[470px] mt-5",
                children: aboutMe.tagLine
            }), jsxRuntimeExports.jsx("div", {
                className: "flex flex-row mt-4 ",
                children: socialMedia.map( (s, e) => jsxRuntimeExports.jsx("a", {
                    href: s.link,
                    target: "_blank",
                    index: e,
                    className: "text-white mr-5 text-[25px] hover:text-teal-200",
                    children: React.createElement(s.icon)
                }, s.id))
            }), jsxRuntimeExports.jsxs("div", {
                className: "flex flex-col sm:flex-row items-start md:items-center",
                children: [jsxRuntimeExports.jsx("a", {
                    href: resumeLink,
                    target: "_blank",
                    children: jsxRuntimeExports.jsx(Button, {
                        styles: "mt-10 btn mr-0 sm:mr-10 z-1",
                        text: "Resume",
                        icon: "LuFileSpreadsheet"
                    })
                }), jsxRuntimeExports.jsx("a", {
                    href: repoLink,
                    target: "_blank",
                    rel: "noopener noreferrer"
                })]
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: "md:ml-auto mt-10 md:mt-0",
            children: jsxRuntimeExports.jsx("img", {
                src: profilePic,
                alt: "Terukula Sai",
                className: "w-[250px] h-[250px] border-2 border-teal-200 relative z-[5] rounded-full"
            })
        })]
    })
})
  , Loading = ({isLoading: s}) => jsxRuntimeExports.jsx(motion.div, {
    id: "loading",
    className: `w-[100vw] h-[100vh] flex "${styles.flexCenter}`,
    initial: {
        scale: 1,
        opacity: .1
    },
    animate: {
        scale: 2.5,
        opacity: 1.75
    },
    transition: {
        yoyo: 1 / 0,
        duration: 1.5,
        ease: "easeIn"
    },
    children: jsxRuntimeExports.jsx("img", {
        src: loading1,
        alt: "Terukula Sai",
        className: "w-[200px] h-[200px]"
    })
})
  , StarBackground = s => {
    const e = reactExports.useRef()
      , [a] = reactExports.useState( () => inSphere(new Float32Array(5e3), {
        radius: 1.2
    }));
    return useFrame( (o, c) => {
        e.current.rotation.x -= c / 10,
        e.current.rotation.y -= c / 15
    }
    ),
    jsxRuntimeExports.jsx("group", {
        rotation: [0, 0, Math.PI / 4],
        children: jsxRuntimeExports.jsx(Points, {
            ref: e,
            positions: a,
            stride: 3,
            frustumCulled: !0,
            ...s,
            children: jsxRuntimeExports.jsx(PointMaterial, {
                transparent: !0,
                color: "#12bcad",
                size: .004,
                sizeAttenuation: !0,
                depthWrite: !1
            })
        })
    })
}
  , StarsCanvas = () => jsxRuntimeExports.jsx("div", {
    className: "w-full h-auto fixed inset-0 z-[0]",
    children: jsxRuntimeExports.jsx(Canvas, {
        camera: {
            position: [0, 0, 1]
        },
        children: jsxRuntimeExports.jsx(reactExports.Suspense, {
            fallback: null,
            children: jsxRuntimeExports.jsx(StarBackground, {})
        })
    })
});
function App() {
    const [s,e] = React.useState(!0);
    return React.useEffect( () => {
        setTimeout( () => {
            e(!1)
        }
        , 1600)
    }
    , []),
    s ? jsxRuntimeExports.jsx("div", {
        className: "bg-black w-full overflow-hidden",
        children: jsxRuntimeExports.jsx(Loading, {})
    }) : jsxRuntimeExports.jsxs("div", {
        className: "gradient-bg-welcome",
        children: [jsxRuntimeExports.jsx(StarsCanvas, {}), jsxRuntimeExports.jsx(CustomCursor, {}), jsxRuntimeExports.jsx("div", {
            className: "bg-primary w-full overflow-hidden z-1 relative",
            children: jsxRuntimeExports.jsxs(motion.section, {
                initial: {
                    x: -100,
                    opacity: .25
                },
                animate: {
                    x: 0,
                    opacity: 1
                },
                transition: {
                    duration: 1
                },
                children: [jsxRuntimeExports.jsx("div", {
                    className: `${styles.paddingX} ${styles.flexCenter}`,
                    children: jsxRuntimeExports.jsx("div", {
                        className: `${styles.boxWidth}`,
                        children: jsxRuntimeExports.jsx(Navbar, {})
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: `bg-primary ${styles.flexStart}`,
                    children: jsxRuntimeExports.jsx("div", {
                        className: `${styles.boxWidth}`,
                        children: jsxRuntimeExports.jsx(Hero, {})
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: `bg-primary ${styles.flexCenter} ${styles.paddingX} `,
                    children: jsxRuntimeExports.jsxs("div", {
                        className: `${styles.boxWidth}`,
                        children: [jsxRuntimeExports.jsx(SkillsAndExperience, {}), jsxRuntimeExports.jsx(Education, {}), jsxRuntimeExports.jsx(Projects, {})]
                    })
                }), jsxRuntimeExports.jsx(Footer, {})]
            })
        })]
    })
}
client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode, {
    children: jsxRuntimeExports.jsx(App, {})
}));
